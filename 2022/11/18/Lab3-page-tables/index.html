
<!DOCTYPE html>
<html lang="zh ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starlit Rover || Lab3: page tables</title>
    <meta name="author" content="Jammy Zeta">
    <meta name="description" content="Just stroll in the starlit firmament~ ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/star.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/Pikachu.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Starlit Rover</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Starlit Rover</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Lab3: page tables </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/11/18
        </span>

        
        <span class="category">
            <a href="/categories/操作系统">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                操作系统
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/走码观花" style=color:#6484be>
                    走码观花
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/xv6" style=color:#016a99>
                    xv6
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>兄弟们，我XV6又回来啦，这个栏目的灰都能把人埋了，鸽子王实锤（当然不是因为懒(⁎⁍̴̛ᴗ⁍̴̛⁎)）。不过虽迟但到！主要有时候看完文档和课程后又去搞其他飞机了，回来时，发现一切回到原点。这周发现再不搞真搞不完了，Lab3是关于页表的，文档<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html">戳这</a>。 </p>
<img src="/images/操作系统/5.png" title alt data-align="center">

<span id="more"></span>

<br>

<h2><span id="coding">❖ Coding</span></h2><hr>
<h4><span id="︎-speed-up-system-calls-easy">☑︎ Speed up system calls (easy)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>由于用户在使用系统调用时需要从用户空间跳转到内核空间，存在一定的时间开销。我们可以通过建立一段用户（只读）和内核共享的内存空间来避免空间跳转的时间，从而加速系统调用。这是一些操作系统的常见优化方法，本实验就是希望你以此来优化getpid系统调用。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>我们知道每个用户进程都拥有自己的虚拟空间，通过页表查找到物理地址后再进行相应的操作。因此这段共享空间的起始地址也需要记录在进程的页表上。实验文档指出，每个进程在创建时都需要新建一个只读页（shared memory），并将其物理地址映射到虚拟地址USYSCALL（一个已经存在的宏定义），然后在这一页的开头存储一个<code>struct usyscall</code>（memlayout.h），并把进程pid存入这个结构体中：</p>
<pre><code class="c">   76 struct usyscall {                       
   77   int pid;  // Process ID
   78 };     
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>接着我们再来瞅瞅user/ulib.c中ugetpid的具体实现：</p>
<pre><code class="c"> 144   │ #ifdef LAB_PGTBL
 145   │ int
 146   │ ugetpid(void)
 147   │ {
 148   │   struct usyscall *u = (struct usyscall *)USYSCALL;
 149   │   return u-&gt;pid;
 150   │ }
 151   │ #endif
</code></pre>
<p>这个函数直接访问USYSCALL地址，通过我们设置好的页表就可以直接到相应的usyscall结构体取得pid，从而可以替代原先需要进入内核空间的getpid函数。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>页表相关操作基本都在kernel/proc.c文件中，我们先找到实现主要地址映射的proc_pagetable函数，可以看到这个函数通过mappages函数完成了<strong>Trampoline</strong>（系统调用返回地址，也是用户虚拟空间中的最高地址）和<strong>Trapframe</strong>（当中断来临时存储当前寄存器值的地址，就位于Trampoline的下方）的映射。显然，我们也需要用mappages来实现USYSCALL虚拟地址的映射，但问题是我们需要知道相应的物理地址。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>由于这个只读页是在进程创建时产生的，那么我们来到创建进程的allocproc函数：</p>
<pre><code class="c"> 100   │ // Look in the process table for an UNUSED proc.
 101   │ // If found, initialize state required to run in the kernel,
 102   │ // and return with p-&gt;lock held.
 103   │ // If there are no free procs, or a memory allocation fails, return 0.
 104   │ static struct proc*
 105   │ allocproc(void)
 106   │ {
 107   │   struct proc *p;
 108   │ 
 109   │   for(p = proc; p &lt; &amp;proc[NPROC]; p++) {
 110   │     acquire(&amp;p-&gt;lock);
 111   │     if(p-&gt;state == UNUSED) {
 112   │       goto found;
 113   │     } else {
 114   │       release(&amp;p-&gt;lock);
 115   │     }
 116   │   }
 117   │   return 0;
 118   │ 
 119   │ found:
 120   │     ......
</code></pre>
<p>allocproc函数从进程表中找到一个未使用的进程块然后为它分配相应的页表空间（kalloc：分配一块页大小512B的空间），那么我们就在此仿照trapframe的做法新建只读页，并存入pid：</p>
<pre><code class="c"> 130 + │  // ADD
 131 + │  if((p-&gt;usys = (struct usyscall *)kalloc())==0)
 132 + │  {
 133 + │     // kfree((void*)p-&gt;trapframe);
 134 + │     freeproc(p);
 135 + │     release(&amp;p-&gt;lock);
 136 + │     return 0;
 137 + │  }
 138 + │   p-&gt;usys-&gt;pid=p-&gt;pid;
 139 + │ 
 140   │   // An empty user page table.
 141   │   p-&gt;pagetable = proc_pagetable(p);
 142   │   ......
</code></pre>
<p>由于只读页的物理地址还要在proc_pagetable中使用，因此我们需要在proc结构体（kernel/proc.h）中加入<code>struct usyscall *usys</code>。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>⚠️ 新建只读页必须在调用proc_pagetable（141）之前，因为需要用物理地址做映射。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>然后我们就可以在proc_pagetable里建立映射了：</p>
<pre><code class="c">210 + │   // ADD
211 + │   if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usys), PTE_R | PTE_U) &lt; 0)
212 + │   {
213 + │     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
214 + │     uvmunmap(pagetable, TRAPFRAME, 1, 0);
215 + │     uvmfree(pagetable, 0);
216 + │     return 0;
217 + │   }
218 + │
219   │   return pagetable;
220   │ }
</code></pre>
<p>⚠️权限是只读（PTE_R），同时在用户空间内运行（PTE_U）。如果map失败就需要解除前面TRAMPOLINE和TRAPFRAME的映射。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>最后不要忘记在freeproc中释放分配来的物理空间：</p>
<pre><code class="c"> 168 + │   if(p-&gt;usys)
 169 + │     kfree((void*)p-&gt;usys);
 170 + │   p-&gt;usys = 0;
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>还有很重要的一点是解除映射，否则会panic——“freewalk: leaf”：</p>
<pre><code class="c"> 224   │ void proc_freepagetable(pagetable_t pagetable, uint64 sz) {
 225   │   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
 226   │   uvmunmap(pagetable, TRAPFRAME, 1, 0);
 227 + │   uvmunmap(pagetable, USYSCALL, 1, 0);
 228   │   uvmfree(pagetable, sz);
 229   │ }
</code></pre>
<p>在释放页表空间后会调用freewalk函数来检查该页表中的所有<strong>叶子pte</strong>（三级映射最后的物理地址）是否有效（PTE_V是否为1），如果存在物理地址有效就会panic。</p>
<br>

<h4><span id="︎-print-a-page-tableeasy">☑︎ Print a page table（easy）</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>实现函数vmprint打印出页表树。页表是三级查找结构，把所有PTE条目看作一个节点，物理地址所对应的PTE条目为其子节点，那么从宏观上来看每个L2 page directory的物理地址都对应一个深度不超过3的树。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>只要知道了如何判断PTE（page table entry）和PT就能写出递归函数了。我们可以参考freewalk函数（kernel/vm.c），对就是上面刚刚出现的那位老哥，它就是通过递归遍历整棵树来检查物理地址是否还有效的：</p>
<pre><code class="c"> 266   │ void
 267   │ freewalk(pagetable_t pagetable)
 268   │ {
 269   │   // there are 2^9 = 512 PTEs in a page table.
 270   │   for(int i = 0; i &lt; 512; i++){
 271   │     pte_t pte = pagetable[i];
 272   │     if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){
 273   │       // this PTE points to a lower-level page table.
 274   │       uint64 child = PTE2PA(pte);
 275   │       freewalk((pagetable_t)child);
 276   │       pagetable[i] = 0;
 277   │     } else if(pte &amp; PTE_V){
 278   │       panic("freewalk: leaf");
 279   │     }
 280   │   }
 281   │   kfree((void*)pagetable);
 282   │ }
</code></pre>
<p>可见如果PTE_V是有效的，没有任何权限则说明这是一个PTE，需要继续递归，反之则说明是叶子节点，即虚拟地址对应的真实物理地址。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>由于我们需要用【 ..】的个数来表示深度，因此在vmprint中设置一个<code>static int depth</code>，递归进入子函数前+1，退出时-1。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>首先在kernel/exec.c的exec函数中加入</p>
<pre><code class="c"> 143 + │     if(p-&gt;pid==1)
 144 + │     vmprint(p-&gt;pagetable);
 145 + │ 
 146   │     return argc; // this ends up in a0, the first argument to main(argc, argv)
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>对于vmprint的实现，我是直接在exec函数前插入的，实验文档推荐在kernel/vm.c里实现，那就别忘了在kernel/defs.h里声明。</p>
<pre><code class="c"> 12 + │ void vmprint(pagetable_t pg)
 13 + │ {
 14 + │     static int depth = 1;
 15 + │     if (depth == 1)
 16 + │         printf("page table %p\n", *pg);
 17 + │     for (int i = 0; i &lt; 512; ++i)
 18 + │     {
 19 + │         pte_t pte = pg[i];
 20 + │         if (pte &amp; PTE_V)
 21 + │         {
 22 + │             uint64 child = PTE2PA(pte);
 23 + │             for (int j = 0; j &lt; depth; ++j)
 24 + │                 printf(" ..");
 25 + │             printf("%d: pte %p pa %p\n", i, pte, child);
 26 + │             if ((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0)
 27 + │             {
 28 + │                 depth += 1;
 29 + │                 vmprint((pagetable_t) child);
 30 + │             }
 31 + │         }
 32 + │     }
 33 + │     depth -= 1;
 34 + │ }
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>然后启动qemu后就会输出</p>
<pre><code class="output">hart 2 starting
hart 1 starting
page table 0x0000000021fda801
 ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
 .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
 .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
 .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
 .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
 ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
 .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
 .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000
 .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000
 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
</code></pre>
<br>

<h4><span id="︎-detecting-which-pages-have-been-accessed-hard">☑︎ Detecting which pages have been accessed (hard)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>这里我们需要实现一个系统调用pgaccess，来检查给定物理页们是否被访问过（accessed：read or write），用one bit来表示一个物理页的结果，并将结果拷贝至用户空间。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>pgaccess会接受三个参数——第一个是起始页的虚拟地址，第二个是需要往后检查的页数，最后一个是需要将结果拷贝到用户空间的物理地址。文档中说最后用户空间会用一个bitmask的数据结构存储结果，其中a bit代表1页且第一页位于最低有效位，另外可以自行设置一个页数上限。在内核中运行时，我们可以用一个uint64来存储结果，那么页数上限即为64。另外我们需要自己在kernel/risv.h中定义PTE_A，至于这一位在物理地址中的哪一位则需要查询<a target="_blank" rel="noopener" href="https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf">riscv手册</a>（P70）：</p>
<img title src="/images/操作系统/6.png" alt data-align="center" width="582">

<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>你可能会问PTE_A不是我们自行定义的吗。事实上，pgaccess只是实现一个检查的功能，真正置位的是riscv硬件。文档中指出“The RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB miss”，当CPU需要那一物理页时，发现Translation Look-aside Buffer未命中（cache中没有），就会去access这一页，然后将其PTE_A置1，因此PTE_A的位置是由硬件规定的。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>根据上图可知PTE_A位于倒数第6位，那么就在kernel/riscv.h中加入</p>
<pre><code class="c"> 346 + │ #define PTE_A (1L &lt;&lt; 6) // access bit
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>准确地来讲，页表中存储的并不是物理地址，而是0(10 bits)+PPN(44 bits)+flags(10 bits)=PTE(64 bits)，因此我们可以看到kernel/riscv.h中很多转换宏定义：</p>
<pre><code class="c"> 348   │ // shift a physical address to the right place for a PTE.
 349   │ #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)
 350   │ 
 351   │ #define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)
 352   │ 
 353   │ #define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>想要获取PTE_A只需要<code>(PTE&amp;PTE_A)&gt;&gt;6</code>  即可。另外由于参数是从用户空间传入，因此我们需要将这些参数通过argaddr（64 bits）和argint（32 bits）拷贝过来。由于传入的是虚拟地址，因此我们需要用walk函数找到实际的物理地址。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>kernel/sysproc.c中已经指明了函数的实现位置，直接撸就完事：</p>
<pre><code class="c">  79   │#ifdef LAB_PGTBL
  80   │int
  81   │sys_pgaccess(void)
  82   │{
  83   │    // lab pgtbl: your code here.
  84 + │    uint64 sa, ua, buf = 0;
  85 + │    int n;
  86 + │    if (argaddr(0, &amp;sa) &lt; 0 || argint(1, &amp;n) &lt; 0 || argaddr(2, &amp;ua) &lt; 0)
  87 + │        return -1;
  88 + │
  89 + │    if (n &gt; 64) return -1;
  90 + │
  91 + │    struct proc *p = myproc();
  92 + │    uint64 pg = sa;
  93 + │    for (int i = 0; i &lt; n; ++i)
  94 + │    {
  95 + │        pte_t *pte = walk(p-&gt;pagetable, pg, 0);
  96 + │        buf += ((*pte &amp; PTE_A) &gt; 0) &lt;&lt; i;
  97 + │        (*pte) &amp;= (~PTE_A);
  98 + │        pg += PGSIZE;
  99 + │    }
 100 + │
 101 + │    return copyout(p-&gt;pagetable, ua, (char *) &amp;buf, sizeof(buf));
 102   │}
 103   │#endif
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>文档中指出我们检查完后还需要将PTE_A置0，因为硬件只顾着在访问时置1，如果不复位那么PTE_A就永远是1了。因此别忘记<code>(*pte) &amp;= (~PTE_A)</code>，另外别写出<code>(*pte &amp; PTE_A &gt; 0)</code>，【&amp;】的优先级比【&gt;】低。</p>
<br>

<h2><span id="references">❖ References</span></h2><hr>
<ul>
<li><p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/429304672">MIT 6.S081 2021: Lab page tables</a></p>
</li>
<li><p>[2] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/duile/p/16087757.html">MIT6.S081-Lab3 Pgtbl [2021Fall]</a></p>
</li>
</ul>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Starlit Rover
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Jammy Zeta
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'f1d02ea5b1fd5309c4b9',
        clientSecret: 'fea96546fcd9dc7495659e8c9d6c20cd75fa7dbe',
        repo: 'Blog-Comments',      // The repository of store comments,
        owner: 'StarlitRover',
        admin: ['StarlitRover'],
        language: 'zh-CN',
        id: md5(location.pathname),     // (Ensure uniqueness and length less than 50)
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>