
<!DOCTYPE html>
<html lang="zh ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starlit Rover || Bison^Flex=语法分析生成中</title>
    <meta name="author" content="Jammy Zeta">
    <meta name="description" content="Just stroll in the starlit firmament~ ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="//images/rover.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/Pikachu.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Starlit Rover</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Starlit Rover</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Bison^Flex=语法分析生成中 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/5/5
        </span>

        
        <span class="category">
            <a href="/categories/编译原理">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                编译原理
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/走码观花" style=color:#6484be>
                    走码观花
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>上古时代的时候（前一段时间参加了些些小竞赛，状态有点迷糊，五一又浪里个浪，所以…虽迟但到！），我们有讲解过<a href="/2022/03/22/%E5%80%9F%E5%8A%A9flex%E5%AE%9E%E7%8E%B0SysY%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" title="借助Flex实现SysY词法分析">借助Flex实现SysY词法分析</a>。词法分析是编译的第一阶段，仅仅只是将代码进行切块归类，得到的只是些零散的tokens。现在我们进入第二阶段，对这些token进行整理排序，以便后面可以方便地解读每句code的含义，即语义分析——构建<strong>抽象语法树AST</strong>。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>本文将阐述如何使用Bison联合Flex来生成语法分析器，并输出抽象语法树。</p>
<span id="more"></span>

<hr>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>抽象语法树用树的数据结构将token们进行关联，非常抽象地展现了整体与部分的关系，就好似为一句话断句，使其结构一览无余。既然要为代码块进行“断句”，那么我们势必需要先清楚代码块拥有哪些结构层次。但结构层次并不是死板的，例如英语中正常的句子结构都是主谓宾，但并不是所有句子只有这种模式，句子中还可以有状语、补语等。代码也是如此，那么如何来描述一种编程语言所有可能的结构层次呢，就是所谓的文法。</p>
<img src="/images/编译原理/2.png" style="zoom:40%;">

<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>栗子胜千言，例如下面这个简单的文法<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1987 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"/></g><g data-mml-node="mo" transform="translate(786,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(1064,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(1709,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container></p>
<pre><code class="Grammar">S → aSb | aAb
A → bAa | ba
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewbox="0 -705 645 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></svg></mjx-container>是<strong>开始符号</strong>，即文法推导中的第一个非终结符，也就是说这个文法描述的所有句子都可以由<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewbox="0 -705 645 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></svg></mjx-container>推导而来。一般大写字母表示的都是非终结符，即还可以继续推导的符号，小写字母就相对应的代表终结符。那么很显然，这个文法描述的所有句子可以用集合<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="22.888ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 10116.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"/></g><g data-mml-node="msup" transform="translate(500,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,363) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="msup" transform="translate(1732.8,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(462,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="msup" transform="translate(2669.1,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="msup" transform="translate(3705.4,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(462,363) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(4838.2,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mi" transform="translate(5116.2,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5994.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(6438.9,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7316.7,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"/></g><g data-mml-node="msub" transform="translate(8261.4,0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="2115" d="M20 664Q20 666 31 683H142Q256 683 258 681Q259 680 279 653T342 572T422 468L582 259V425Q582 451 582 490T583 541Q583 611 573 628T522 648Q500 648 493 654Q484 665 493 679L500 683H691Q702 676 702 666Q702 657 698 652Q688 648 680 648Q633 648 627 612Q624 601 624 294V-8Q616 -20 607 -20Q601 -20 596 -15Q593 -13 371 270L156 548L153 319Q153 284 153 234T152 167Q152 103 156 78T172 44T213 34Q236 34 242 28Q253 17 242 3L236 -1H36Q24 6 24 16Q24 34 56 34Q58 35 69 36T86 40T100 50T109 72Q111 83 111 345V603L96 619Q72 643 44 648Q20 648 20 664ZM413 419L240 648H120L136 628Q137 626 361 341T587 54L589 68Q589 78 589 121V192L413 419Z"/></g></g><g data-mml-node="mo" transform="translate(755,-150) scale(0.707)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g></g><g data-mml-node="mo" transform="translate(9616.6,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"/></g></g></g></svg></mjx-container>来表示。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>可以看到有限的推导式足以描述无穷的句子，但这些句子是具有一定语法规则的。而一种编程语言本身就是一些具有特定语法规则的句子，因此也可以用一个文法来表示，只不过推导式的数量稍微多了亿些。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>在不借助任何工具的情况下，要实现一个语法分析器就会有两种思路，其一是自底向上，就是将读入的token不断<strong>归约</strong>（推导的逆过程）为非终结符，直到剩下开始符号<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewbox="0 -705 645 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></svg></mjx-container>；另一种则是自顶向下，即从开始符号<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewbox="0 -705 645 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></svg></mjx-container>找到生成当前代码的推导过程，这里其实就是选择哪一条产生式的问题。两种思路本质上就是选择树的根还是叶子结点作为分析的起点来考虑的，但这并不是本文的重点，你只需知道Bison生成的语法分析器代码采用的是自底向上的思路，而我们只要提供给Bison相应的文法即可得到该文法对应语言的语法分析器。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>不过，带着一点语法分析原理的了解来阅读本文体验会更好哦</p>
<hr>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>GNU Bison是一款用于自动生成语法分析器的程序，基于并兼容yacc，可用于所有常见的操作系统。Bison把LALR形式的上下文无关文法描述转换为可做语法分析的C或C++程序。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>Bison的输入文件<code>*.y</code>的基本格式如下，使用者需要将文法的一些基本信息写入该文件</p>
<pre><code class="Bison">%start CompUnit
%expect 1

%{
    #include "parser.h"
    ...
%}

%union
{
    int     num;
    char*   str;
}

/*声明Flex产生的token有三种格式，其中&lt;type&gt;不是必须的*/
%token &lt;type1&gt; tokens1 /*类型为type1的token们*/
%right &lt;type2&gt; tokens2 /*类型为type2的右结合token们*/
%left &lt;type3&gt; tokens3  /*类型为type3的左结合token们*/

/*声明非终结符的类型*/
%type&lt;num&gt; Number CompUnit Decl ...

%%
/*Grammar Productions and Corresponding Actions*/
CompUnit:       CompUnit Decl                     {$$=$1+$2;}
                | CompUnit FuncDef                {$$=$1-$2;}
Decl:           ConstDecl    %prec    token3      {$$=$1*10;}
                | /*ε*/                                {}
...
%%

int main()
{
    yyparse();
    ...
}
</code></pre>
<ol>
<li><p>第一句<code>%start ...</code>是声明文法的开始符号，后面紧跟一个非终结符</p>
</li>
<li><p>其次<code>%expect n</code>表示你知道这个文法中存在n个<strong>移入/归约冲突</strong>（在某一个时刻既可以选择归约为非终结符也可以选择读入下一个token），并且认同Bison默认的处理方式，那么在生成语法分析器时若Bison确实发现了n个冲突就不会提醒你，否则会有提示</p>
<pre><code class="Bison">*.y: conflicts: n shift/reduce
</code></pre>
</li>
<li><p><code>%{...}%</code>中间则和Flex类似，可以放一些头文件，这一部分会被直接添入生成代码的靠前部分</p>
</li>
<li><p><code>%union{...}</code>则是对之后需要用到的类型声明，即后面<strong>token</strong>和<strong>非终结符</strong>的类型都只能取自union中声明的符号，在上面的文件中只能用<code>num</code>、<code>str</code>来声明类型</p>
</li>
<li><p>对Flex生成的token进行声明，使Bison知道有哪些token存在，另外可以通过<code>&lt;type&gt;</code>对token的类型进行声明（默认为<code>int</code>），这样当Flex返回token时我们可以认为返回的是一个type类型的变量，而对于token的赋值则是在Flex中完成的，如此可以使Bison和Flex之间存在信息交互</p>
</li>
<li><p><code>%right</code>和<code>%left</code>也是token的一种声明方式，分别表示右结合和左结合，多用于运算符token的声明上</p>
</li>
<li><p>token的声明顺序决定了语法优先级，从上至下优先级逐渐升高，同一行的token优先级相同，多用于运算符token的声明，优先级高的token先进行归约</p>
</li>
<li><p><code>%type&lt;&gt; ...</code>则是声明非终结符的类型，类型依然只能取自<code>%union{...}</code>中，token的值是在Flex与Bison之间传递，而非终结符的值则是在产生式之间传递，即当一个非终结符A被归约出来后，我们可以对其进行相应类型的赋值，随后在A被归约时则会带着之前的赋值从产生式左部转移到另一个产生式的右部，那么我们就可以用A的值来定义新归约出来的非终结符的值</p>
</li>
<li><p><code>%%...%%</code>之间则是最重要的语法规则以及相应的动作，只不过产生式中的【→】变成了【:】</p>
</li>
<li><p>每一个产生式的右部可能有好几种推导结果（由【｜】进行分隔），我们认为不同的右部代表着不同的产生式，而每一个产生式后面都可以跟相应的一系列操作【{…}】，表示发生这一个产生式的归约时会执行的相应动作</p>
</li>
<li><p>操作中我们可以用【<span>$</span>】来引用产生式中的每一个token以及终结符，其中【<span>$</span><span>$</span>】表示产生式左部的非终结符（冒号左边的非终结符），【$n】表示产生式右部第n个<strong>非终结符/token/字符串</strong>的值</p>
<p>⚠️当【<span>$</span>n】是一个字符串时，Bison会提示这个【<span>$</span>n】没有声明类型，但不会影响程序的运行，当然你觉得难受的话可以直接将其替换成字符串的字面值</p>
</li>
<li><p>产生式的右部是可以为空的，这就相当于文法中的空串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.919ex" height="1ex" role="img" focusable="false" viewbox="0 -431 406 442"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D716" d="M227 -11Q149 -11 95 41T40 174Q40 262 87 322Q121 367 173 396T287 430Q289 431 329 431H367Q382 426 382 411Q382 385 341 385H325H312Q191 385 154 277L150 265H327Q340 256 340 246Q340 228 320 219H138V217Q128 187 128 143Q128 77 160 52T231 26Q258 26 284 36T326 57T343 68Q350 68 354 58T358 39Q358 36 357 35Q354 31 337 21T289 0T227 -11Z"/></g></g></g></svg></mjx-container></p>
</li>
<li><p>产生式中<code>%prec token_name</code>可以使<code>%prec</code>左边的产生式具有和<code>token_name</code>相同的优先级</p>
</li>
<li><p>最下面的部分也跟Flex类似，会被直接复制到生成代码的底部，函数<code>yyparse()</code>会执行语法分析过程，接下来你可以增加一些输出分析结果的代码</p>
</li>
<li><p>以上只是Bison最基础的规则，希望更加全面系统地学习可以参阅<a target="_blank" rel="noopener" href="http://home.ustc.edu.cn/~guoxing/ebooks/flex%E4%B8%8Ebison%E4%B8%AD%E6%96%87%E7%89%88.pdf">《flex与bison》</a>.</p>
</li>
</ol>
<hr>
<h2><span id="parserh">∫ “parser.h”</span></h2><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;

extern int yylineno;
extern char* yytext;
extern int yylex();

typedef enum {NUM,TEXT} TYPE;

void yyerror(const char* msg)
{
    printf("\033[1;31m%s at line %d\033[0m: %s\n",msg,yylineno,yytext);
}

int OCT2DEC(char* text)
{
    int sum=0;
    for(int i=1;i&lt;strlen(text);++i)
        sum=sum*8+(text[i]-'0');
    return sum;
}

int HEX2DEC(char* text)
{
    int sum=0;
    for(int i=2;i&lt;strlen(text);++i)
    {
        if(text[i]&gt;='0'&amp;&amp;text[i]&lt;='9')
            sum=sum*16+(text[i]-'0');
        else if(text[i]&gt;='a'&amp;&amp;text[i]&lt;='f')
            sum=sum*16+(text[i]-'a'+10);
        else
            sum=sum*16+(text[i]-'A'+10);
    }
    return sum;
}

typedef struct ASTnode
{
    TYPE type;
    char* text;
    int num;
    struct ASTnode* next;
    struct ASTnode* child;
}ASTnode;

ASTnode* ASThead=NULL;

//generate new node
ASTnode* newASTnode(TYPE type, char* text, int num, ASTnode* nxt, ASTnode* child)
{
    ASTnode* node=(ASTnode*)malloc(sizeof(ASTnode)); //不是sizeof(ASTnode*)!!!
    node-&gt;type=type;
    if(type==TEXT)
        node-&gt;text=strdup(text);
    else
        node-&gt;num=num;
    node-&gt;next=nxt;
    node-&gt;child=child;
    return node;
}

//connect sibling nodes
void connectASTnode(int num,...)
{
    va_list valist;
    va_start(valist,num);
    ASTnode* node=va_arg(valist,ASTnode*);
    for(int i=1;i&lt;num;++i)
    {
        ASTnode* next=va_arg(valist,ASTnode*);
        node-&gt;next=next;
        node=next;
    }
    node-&gt;next=NULL;
    va_end(valist);
}

void outputAST(ASTnode* head,int tab)
{
    switch (head-&gt;type)
    {
        case NUM:
            printf("\033[1;35m%d\033[0m\n",head-&gt;num);
            break;
        case TEXT:
            if(head-&gt;child!=NULL)
                printf("\033[1;32m%s\033[0m\n",head-&gt;text);
            else
                printf("\033[1;34m%s\033[0m\n",head-&gt;text);
            break;
    }
    ASTnode* node=head-&gt;child;
    while(node!=NULL)
    {
        for(int i=0;i&lt;tab;++i)
            printf("\t");
        printf("└───────");
        outputAST(node,tab+1);
        node=node-&gt;next;
    }
}

void freeAST(ASTnode *head)
{
    ASTnode *node=head-&gt;child;
    while (node!=NULL)
    {
        freeAST(node);
        node=node-&gt;next;
    }
    if(head-&gt;type==TEXT)
        free(head-&gt;text);
    free(head);
}
</code></pre>
<ol>
<li><p>这个头文件中主要包括了AST的构建、输出、释放等函数，还有8进制、16进制转十进制数的函数</p>
</li>
<li><p>节点<code>ASTnode</code>中既可以存字符串也可以存整型，<code>TYPE type</code>指明了这个节点存储的数据类型，其中<code>TYPE</code>是一个枚举类型</p>
</li>
<li><p>前面3个<code>extern</code>声明了Flex（lex.yy.c）中自带的三个变量，从而可以在Bison中使用</p>
</li>
<li><p><code>yyerror</code>是Bison无法归约时会调用的报错函数，这里它会输出出错信息、出错行数以及出错字符串</p>
</li>
<li><p><code>connectASTnode</code>函数使用了C语言中多参数函数的机制，可以连接任意个数的兄弟节点，每天一个<code>make bug</code>小魔法</p>
<pre><code class="C">#include &lt;stdarg.h&gt;
// num is number of parameters in ...
type func_name(int num,...)
{
  // 声明参数列表
    va_list valist;
    va_start(valist,num);
  // 以TYPE类型取出参数
    TYPE val=va_arg(valist,TYPE);
    for(int i=1;i&lt;num;++i)
    {
        TYPE next=va_arg(valist,TYPE);
        ...
    }
    va_end(valist);
}
</code></pre>
</li>
<li><p>C语言不知道怎么输出树，所以采用了文件树的形式，以tab数表示该节点所处的深度，每个节点的父节点都是其上方最近的tab-1节点</p>
</li>
<li><p>用全局变量<code>ASThead</code>来存储AST的头节点，我们只需要在每次执行<strong>归约到开始符号</strong>（即左部是开始符号）的产生式时将开始符号的节点赋值给<code>ASThead</code>，那么最后一次赋值（即最后一次归约）的必然是AST的头节点</p>
</li>
</ol>
<hr>
<h2><span id="sysyl">∬ SysY.l</span></h2><pre><code class="Flex">%option yylineno

%{
    #include "SysY.tab.h"
    #define UNEXPECTED 0
%}

INT                 int
VOID                void
CONST               const
IF                  if
ELSE                else
WHILE               while
BREAK               break
CONTINUE            continue
RETURN              return
MULDIVSUR           "*"|"/"|"%"
ADDSUB              "+"|"-"
CMP                 "&lt;"|"&gt;"|"&lt;="|"&gt;="
EQNEQ               "=="|"!="
ASSIGN              "="
NONZERO             [1-9]
DIGIT               [0-9]
LETTER              [A-Za-z]
OCTAL_DIGIT         [0-7]
OCTAL_CONST         0{OCTAL_DIGIT}*
ILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z]({LETTER}|{DIGIT})*
HEX_PREFIX          0x|0X
HEX_DIGIT           [0-9a-fA-F]
HEX_CONST           {HEX_PREFIX}{HEX_DIGIT}+
ILLEGAL_HEX_CONST   {HEX_PREFIX}({LETTER}|{DIGIT})*
NONDIGIT            {LETTER}|"_"
ID                  {NONDIGIT}({DIGIT}|{NONDIGIT})*
DEC_CONST           {NONZERO}{DIGIT}*  
COMMENT1            "/*"[^*]*"*"+([^*/][^*]*"*"+)*"/"
COMMENT2            "//".*                                                                                

%%

{INT}                   { yylval.str=strdup(yytext); return INT; }
{VOID}                  { yylval.str=strdup(yytext); return VOID; }
{OCTAL_CONST}           { yylval.str=strdup(yytext); return OCTAL_CONST; }
{ILLEGAL_OCTAL_CONST}   { yylval.str=strdup(yytext); return HEX_CONST; }
{HEX_CONST}             { yylval.str=strdup(yytext); return HEX_CONST; }
{ILLEGAL_HEX_CONST}     { yylval.str=strdup(yytext); return DEC_CONST; }
{DEC_CONST}             { yylval.str=strdup(yytext); return DEC_CONST; }
{CONST}                 { yylval.str=strdup(yytext); return CONST; }
{IF}                    { yylval.str=strdup(yytext); return IF; }
{ELSE}                  { yylval.str=strdup(yytext); return ELSE; }
{WHILE}                 { yylval.str=strdup(yytext); return WHILE; }
{BREAK}                 { yylval.str=strdup(yytext); return BREAK; }
{CONTINUE}              { yylval.str=strdup(yytext); return CONTINUE; }
{RETURN}                { yylval.str=strdup(yytext); return RETURN; }
{MULDIVSUR}             { yylval.str=strdup(yytext); return MULDIVSUR; } 
{ADDSUB}                { yylval.str=strdup(yytext); return ADDSUB; } 
{CMP}                   { yylval.str=strdup(yytext); return CMP; } 
{EQNEQ}                 { yylval.str=strdup(yytext); return EQNEQ; } 
{ASSIGN}                { yylval.str=strdup(yytext); return ASSIGN; }
{ID}                    { yylval.str=strdup(yytext); return ID; }
"("                     { yylval.str=strdup(yytext); return yytext[0]; }
")"                     { yylval.str=strdup(yytext); return yytext[0]; }
"["                     { yylval.str=strdup(yytext); return yytext[0]; }
"]"                     { yylval.str=strdup(yytext); return yytext[0]; }
"{"                     { yylval.str=strdup(yytext); return yytext[0]; }
"}"                     { yylval.str=strdup(yytext); return yytext[0]; }
";"                     { yylval.str=strdup(yytext); return yytext[0]; }
","                     { yylval.str=strdup(yytext); return yytext[0]; }
"&amp;&amp;"                    { yylval.str=strdup(yytext); return AND; }
"||"                    { yylval.str=strdup(yytext); return OR; }
{COMMENT1}|{COMMENT2}   { }
[ \t\n]                 { }
.                       { yylval.str=strdup(yytext); return UNEXPECTED; }
%%

int yywrap(void) 
{ 
    return 1;
}
</code></pre>
<ol>
<li>“SysY.tab.h”是<code>bison -d SysY.y</code>产生的，Bison会将你声明的token进行enum放在生成的头文件”SysY.tab.h”中，所以你无需自己再写一个”translator.h”</li>
<li>注意在Flex中需要完成对token的赋值，如果token的类型为TYPE（取自<code>%union</code>），那么你需要以<code>yylval.TYPE=...</code>的形式进行赋值，然后<code>return token_name;</code></li>
<li><code>char* strdup(char *s)</code>函数会开辟一段新的空间并复制字符串s的值，然后返回新空间的指针（需要<code>free</code>）</li>
</ol>
<hr>
<h2><span id="sysyy">∭ SysY.y</span></h2><pre><code class="Bison">%start CompUnit
%expect 1

%{
    #include "parser.h"
%}

%union
{
    int     num;
    char*   str;
    struct ASTnode* node; /*"struct" is indispensable*/
}

%token &lt;str&gt; INT VOID CONST IF ELSE WHILE BREAK CONTINUE RETURN ID OCTAL_CONST HEX_CONST DEC_CONST
%right &lt;str&gt; ASSIGN
%left &lt;str&gt; OR
%left &lt;str&gt; AND
%left &lt;str&gt; EQNEQ
%left &lt;str&gt; CMP
%left &lt;str&gt; ADDSUB
%left &lt;str&gt; MULDIVSUR

%type&lt;node&gt; Number CompUnit Decl FuncDef ConstDecl VarDecl ConstDef ConstDefBlock ConstExpBlock ConstInitVal ConstExp ConstInitFlag ConstValBlock VarDef
    VarDefFlag InitVal Exp InitValFlag InitValBlock FuncFParams Block FuncFParam FuncFParamBlock ExpBlockFlag ExpBlock BlockItemBlock BlockItem 
    Stmt LVal ExpFlag StmtFlag Cond AddExp LOrExp PrimaryExp UnaryExp FuncFParamsFlag FuncRParams UNARYOP CommaExpBlock MulExp RelExp EqExp LAndExp

%%
CompUnit:       CompUnit Decl                           {
                                                            connectASTnode(2,$1,$2);
                                                            ASThead=$$=newASTnode(TEXT,"CompUnit",0,NULL,$1);
                                                        }
                | CompUnit FuncDef                      {
                                                            connectASTnode(2,$1,$2);
                                                            ASThead=$$=newASTnode(TEXT,"CompUnit",0,NULL,$1);
                                                        }
                | Decl                                  {ASThead=$$=newASTnode(TEXT,"CompUnit",0,NULL,$1);}
                | FuncDef                               {ASThead=$$=newASTnode(TEXT,"CompUnit",0,NULL,$1);}
Decl:           ConstDecl                               {$$=newASTnode(TEXT,"Decl",0,NULL,$1);}
                | VarDecl                               {$$=newASTnode(TEXT,"Decl",0,NULL,$1);}
ConstDecl:      CONST INT ConstDef ConstDefBlock ';'    {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),
                                                                    *n5=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(5,n1,n2,$3,$4,n5);
                                                            $$=newASTnode(TEXT,"ConstDecl",0,NULL,n1);
                                                        }
ConstDefBlock:  ConstDefBlock ',' ConstDef              {
                                                            ASTnode *n=newASTnode(TEXT,",",0,$3,NULL);
                                                            connectASTnode(3,$1,n,$3);
                                                            $$=newASTnode(TEXT,"ConstDefBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"ConstDefBlock",0,NULL,n);
                                                        }
ConstDef:       ID ConstExpBlock ASSIGN ConstInitVal    {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,$3,0,NULL,NULL);
                                                            connectASTnode(4,n1,$2,n3,$4);
                                                            $$=newASTnode(TEXT,"ConstDef",0,NULL,n1);
                                                        }
ConstExpBlock:  ConstExpBlock '[' ConstExp ']'          {
                                                            ASTnode *n2=newASTnode(TEXT,"[",0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,"]",0,NULL,NULL);
                                                            connectASTnode(4,$1,n2,$3,n4);
                                                            $$=newASTnode(TEXT,"ConstExpBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"ConstExpBlock",0,NULL,n);
                                                        }
ConstInitVal:   ConstExp                                {$$=newASTnode(TEXT,"ConstInitVal",0,NULL,$1);}
                |'{'ConstInitFlag'}'                    {
                                                            ASTnode *n1=newASTnode(TEXT,"{",0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,"}",0,NULL,NULL);
                                                            connectASTnode(3,n1,$2,n3);
                                                            $$=newASTnode(TEXT,"ConstInitVal",0,NULL,n1);
                                                        }
ConstInitFlag:  ConstInitVal ConstValBlock              {
                                                            connectASTnode(2,$1,$2);
                                                            $$=newASTnode(TEXT,"ConstInitFlag",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"ConstInitFlag",0,NULL,n);
                                                        }
ConstValBlock:  ConstValBlock ',' ConstInitVal          {
                                                            ASTnode *n2=newASTnode(TEXT,",",0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"ConstValBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"ConstValBlock",0,NULL,n);
                                                        }
VarDecl:        INT VarDef VarDefFlag ';'               {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(4,n1,$2,$3,n4);
                                                            $$=newASTnode(TEXT,"VarDecl",0,NULL,n1);
                                                        }
VarDefFlag:    ',' VarDef VarDefFlag                    {
                                                            ASTnode *n1=newASTnode(TEXT,",",0,NULL,NULL);
                                                            connectASTnode(3,n1,$2,$3);
                                                            $$=newASTnode(TEXT,"VarDefFlag",0,NULL,n1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"VarDefFlag",0,NULL,n);
                                                        }
VarDef:         ID ConstExpBlock                        {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);
                                                            connectASTnode(2,n1,$2);
                                                            $$=newASTnode(TEXT,"VarDef",0,NULL,n1);
                                                        }
                | ID ConstExpBlock ASSIGN InitVal       {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,$3,0,NULL,NULL);
                                                            connectASTnode(4,n1,$2,n3,$4);
                                                            $$=newASTnode(TEXT,"VarDef",0,NULL,n1);
                                                        }
InitVal:          Exp                                   {$$=newASTnode(TEXT,"InitVal",0,NULL,$1);}
                | '{'InitValFlag'}'                     {
                                                            ASTnode *n1=newASTnode(TEXT,"{",0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,"}",0,NULL,NULL);
                                                            connectASTnode(3,n1,$2,n3);
                                                            $$=newASTnode(TEXT,"InitVal",0,NULL,n1);
                                                        }
InitValFlag:    InitVal InitValBlock                    {
                                                            connectASTnode(2,$1,$2);
                                                            $$=newASTnode(TEXT,"InitValFlag",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"InitValFlag",0,NULL,n);
                                                        }
InitValBlock:   InitValBlock ',' InitVal                {
                                                            ASTnode *n2=newASTnode(TEXT,",",0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"InitValBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"InitValFlag",0,NULL,n);
                                                        }
FuncDef:        INT ID '(' FuncFParams')' Block         {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,"(",0,NULL,NULL),
                                                                    *n5=newASTnode(TEXT,")",0,NULL,NULL);
                                                            connectASTnode(6,n1,n2,n3,$4,n5,$6);
                                                            $$=newASTnode(TEXT,"FuncDef",0,NULL,n1);
                                                        }
                | VOID ID '(' FuncFParams')' Block      {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,"(",0,NULL,NULL),
                                                                    *n5=newASTnode(TEXT,")",0,NULL,NULL);
                                                            connectASTnode(6,n1,n2,n3,$4,n5,$6);
                                                            $$=newASTnode(TEXT,"FuncDef",0,NULL,n1);
                                                        }
FuncFParams:    FuncFParam FuncFParamBlock              {
                                                            connectASTnode(2,$1,$2);
                                                            $$=newASTnode(TEXT,"FuncFParams",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"FuncFParams",0,NULL,n);
                                                        }
FuncFParamBlock:FuncFParamBlock ',' FuncFParam          {
                                                            ASTnode *n2=newASTnode(TEXT,",",0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"FuncFParamBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"FuncFParamBlock",0,NULL,n);
                                                        }
FuncFParam:     INT ID ExpBlockFlag                     {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,n1,n2,$3);
                                                            $$=newASTnode(TEXT,"FuncFParam",0,NULL,n1);
                                                        }
ExpBlockFlag:   '['']' ExpBlock                         {
                                                            ASTnode *n1=newASTnode(TEXT,"[",0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,"]",0,NULL,NULL);
                                                            connectASTnode(3,n1,n2,$3);
                                                            $$=newASTnode(TEXT,"ExpBlockFlag",0,NULL,n1);
                                                        }
ExpBlock:       ExpBlock '['Exp']'                      {
                                                            ASTnode *n2=newASTnode(TEXT,"[",0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,"]",0,NULL,NULL);
                                                            connectASTnode(4,$1,n2,$3,n4);
                                                            $$=newASTnode(TEXT,"FuncDef",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"ExpBlock",0,NULL,n);
                                                        }
Block:          '{' BlockItemBlock '}'                  {
                                                            ASTnode *n1=newASTnode(TEXT,"{",0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,"}",0,NULL,NULL);
                                                            connectASTnode(3,n1,$2,n3);
                                                            $$=newASTnode(TEXT,"Block",0,NULL,n1);
                                                        }
BlockItemBlock: BlockItemBlock BlockItem                {
                                                            connectASTnode(2,$1,$2);
                                                            $$=newASTnode(TEXT,"BlockItemBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"BlockItemBlock",0,NULL,n);
                                                        }
BlockItem:        Decl                                  {$$=newASTnode(TEXT,"BlockItem",0,NULL,$1);}
                | Stmt                                  {$$=newASTnode(TEXT,"BlockItem",0,NULL,$1);}
Stmt:           LVal ASSIGN Exp ';' %prec ASSIGN        {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(4,$1,n2,$3,n4);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,$1);
                                                        }
                | ExpFlag';'                            {
                                                            ASTnode *n2=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(2,$1,n2);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,$1);
                                                        }
                | Block                                 {$$=newASTnode(TEXT,"Stmt",0,NULL,$1);}
                | IF'('Cond')' Stmt StmtFlag            {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,"(",0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,")",0,NULL,NULL);
                                                            connectASTnode(6,n1,n2,$3,n4,$5,$6);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,n1);
                                                        }
                | WHILE'('Cond')' Stmt                  {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,"(",0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,")",0,NULL,NULL);
                                                            connectASTnode(5,n1,n2,$3,n4,$5);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,n1);
                                                        }
                | BREAK';'                              {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(2,n1,n2);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,n1);
                                                        }
                | CONTINUE';'                           {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(2,n1,n2);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,n1);
                                                        }
                | RETURN ExpFlag';'                     {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,";",0,NULL,NULL);
                                                            connectASTnode(3,n1,$2,n3);
                                                            $$=newASTnode(TEXT,"Stmt",0,NULL,n1);
                                                        }
ExpFlag:          Exp                                   {$$=newASTnode(TEXT,"ExpFlag",0,NULL,$1);}
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"ExpFlag",0,NULL,n);
                                                        }
StmtFlag:       ELSE Stmt                               {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);
                                                            connectASTnode(2,n1,$2);
                                                            $$=newASTnode(TEXT,"StmtFlag",0,NULL,n1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"StmtFlag",0,NULL,n);
                                                        }
Exp:            AddExp                                  {$$=newASTnode(TEXT,"Exp",0,NULL,$1);}
Cond:           LOrExp                                  {$$=newASTnode(TEXT,"Cond",0,NULL,$1);}
LVal:           ID ExpBlock                             {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);
                                                            connectASTnode(2,n1,$2);
                                                            $$=newASTnode(TEXT,"LVal",0,NULL,n1);
                                                        }
PrimaryExp:     '('Exp')'                               {
                                                            ASTnode *n1=newASTnode(TEXT,"(",0,NULL,NULL),
                                                                    *n3=newASTnode(TEXT,")",0,NULL,NULL);
                                                            connectASTnode(3,n1,$2,n3);
                                                            $$=newASTnode(TEXT,"PrimaryExp",0,NULL,n1);
                                                        }
                | LVal                                  {$$=newASTnode(TEXT,"PrimaryExp",0,NULL,$1);}
                | Number                                {$$=newASTnode(TEXT,"PrimaryExp",0,NULL,$1);}
Number:         OCTAL_CONST                             {
                                                            ASTnode *n=newASTnode(NUM,NULL,OCT2DEC($1),NULL,NULL);
                                                            $$=newASTnode(TEXT,"Number",0,NULL,n);
                                                        }
                | HEX_CONST                             {
                                                            ASTnode *n=newASTnode(NUM,NULL,HEX2DEC($1),NULL,NULL);
                                                            $$=newASTnode(TEXT,"Number",0,NULL,n);
                                                        }
                | DEC_CONST                             {
                                                            ASTnode *n=newASTnode(NUM,NULL,atoi($1),NULL,NULL);
                                                            $$=newASTnode(TEXT,"Number",0,NULL,n);
                                                        }
UnaryExp:       PrimaryExp                              {$$=newASTnode(TEXT,"UnaryExp",0,NULL,$1);}
                | ID '(' FuncFParamsFlag ')'            {
                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),
                                                                    *n2=newASTnode(TEXT,"(",0,NULL,NULL),
                                                                    *n4=newASTnode(TEXT,")",0,NULL,NULL);
                                                            connectASTnode(4,n1,n2,$3,n4);
                                                            $$=newASTnode(TEXT,"PrimaryExp",0,NULL,n1);
                                                        }
                | UNARYOP UnaryExp                      {
                                                            connectASTnode(2,$1,$2);
                                                            $$=newASTnode(TEXT,"UnaryExp",0,NULL,$1);
                                                        }
FuncFParamsFlag:FuncRParams                             {$$=newASTnode(TEXT,"FuncFParamsFlag",0,NULL,$1);}
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"FuncFParamsFlag",0,NULL,n);
                                                        }
FuncRParams:    Exp CommaExpBlock                       {
                                                            connectASTnode(2,$1,$2);
                                                            $$=newASTnode(TEXT,"FuncRParams",0,NULL,$1);
                                                        }
CommaExpBlock:  CommaExpBlock ',' Exp                   {
                                                            ASTnode *n2=newASTnode(TEXT,",",0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"CommaExpBlock",0,NULL,$1);
                                                        }
                | /*ε*/                                 {
                                                            ASTnode *n=newASTnode(TEXT,"ε",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"CommaExpBlock",0,NULL,n);
                                                        }
UNARYOP:        ADDSUB                                  {
                                                            ASTnode *n=newASTnode(TEXT,$1,0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"UNARYOP",0,NULL,n);
                                                        }
                | '!'                                   {
                                                            ASTnode *n=newASTnode(TEXT,"!",0,NULL,NULL);
                                                            $$=newASTnode(TEXT,"UNARYOP",0,NULL,n);
                                                        }
MulExp:         UnaryExp                                {$$=newASTnode(TEXT,"MulExp",0,NULL,$1);}
                | MulExp MULDIVSUR UnaryExp             {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"MulExp",0,NULL,$1);
                                                        }
AddExp:         MulExp                                  {$$=newASTnode(TEXT,"AddExp",0,NULL,$1);}
                | AddExp ADDSUB MulExp                  {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"MulExp",0,NULL,$1);
                                                        }
RelExp:         AddExp                                  {$$=newASTnode(TEXT,"RelExp",0,NULL,$1);}
                | RelExp CMP AddExp                     {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"RelExp",0,NULL,$1);
                                                        }
EqExp:          RelExp                                  {$$=newASTnode(TEXT,"EqExp",0,NULL,$1);}
                | EqExp EQNEQ RelExp                    {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"EqExp",0,NULL,$1);
                                                        }
LAndExp:        EqExp                                   {$$=newASTnode(TEXT,"LAndExp",0,NULL,$1);}
                | LAndExp AND EqExp                     {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"LAndExp",0,NULL,$1);
                                                        }
LOrExp:         LAndExp                                 {$$=newASTnode(TEXT,"LOrExp",0,NULL,$1);}
                | LOrExp OR LAndExp                     {
                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);
                                                            connectASTnode(3,$1,n2,$3);
                                                            $$=newASTnode(TEXT,"LOrExp",0,NULL,$1);
                                                        }
ConstExp:       AddExp                                  {$$=newASTnode(TEXT,"ConstExp",0,NULL,$1);}
%%

int main()
{
    yyparse();
    outputAST(ASThead,0);
    freeAST(ASThead);
    return 0;
}
</code></pre>
<hr>
<h3><span id="testc">Test.c</span></h3><pre><code class="C">int main()
{
    int bb = 0x12d23;
    if (abc &gt;= bb) // hello
            return 8;
    /*This is a test
    */
}
</code></pre>
<h3><span id="cast-magic">Cast Magic 🪄</span></h3><pre><code class="zsh">flex SysY.l
bison -d SysY.y
clang SysY.tab.c lex.yy.c
cat test.c|./a.out
</code></pre>
<h3><span id="output">Output</span></h3><p><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/3.png"></p>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Starlit Rover
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Jammy Zeta
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'f1d02ea5b1fd5309c4b9',
        clientSecret: 'fea96546fcd9dc7495659e8c9d6c20cd75fa7dbe',
        repo: 'Blog-Comments',      // The repository of store comments,
        owner: 'StarlitRover',
        admin: ['StarlitRover'],
        language: 'zh-CN',
        id: md5(location.pathname),     // (Ensure uniqueness and length less than 50)
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>