
<!DOCTYPE html>
<html lang="zh ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starlit Rover || Lab1: Xv6 and Unix utilities</title>
    <meta name="author" content="Jammy Zeta">
    <meta name="description" content="Just stroll in the starlit firmament~ ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/images/star.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/night-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/Pikachu.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Starlit Rover</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Starlit Rover</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>Lab1: Xv6 and Unix utilities </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2022/9/13
        </span>

        
        <span class="category">
            <a href="/categories/操作系统">
                <span class="icon">
                    <a-icon type="book" theme="filled" />
                </span>
                操作系统
            </a>
        </span>
        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/走码观花" style=color:#016a99>
                    走码观花
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/xv6" style=color:#6484be>
                    xv6
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>这学期开始学操作系统啦，一周五节课，是一位老教师，除了讲话慢了点还经常请同学们回答一些神奇问题外感觉还好，和上学期的寄网还是有差距的。暑假想预习来着的，不过经历了一些事情有点颓，现在回忆起来像是上个世纪的假期了。众所周知，大学=大不了自学，所以打开了<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">MIT·S081</a>。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>课程配套实验基于教授们自己写的一个类UNIX教学操作系统——<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6</a>，通过xv6上的实验你能够对操作系统中的一些概念以及操作理解更深，精品良心，废话不多说，希望这学期能好好做实验（\认真脸）。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>第一个实验主要以熟悉xv6以及系统调用函数为主，实验文档<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">戳这</a>。</p>
<span id="more"></span>

<br>

<h2><span id="安装xv6">❖ 安装xv6</span></h2><hr>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>众所周知，环境两小时，实验5分钟。不过安装xv6似乎十分顺利并没有遭遇太多的不测，当然很大一部分原因是站在别人的血泪史上。如果你也是M1用户，可以参考<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1939023">MIT 6.S081/Fall 2020 搭建risc-v与xv6开发调试环境</a>这篇博客。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>前置环境主要是：</p>
<ol>
<li><p>gcc / clang ：用来编译<a target="_blank" rel="noopener" href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-gnu-toolchain</a> 工具链</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/riscv-collab/riscv-gnu-toolchain">riscv-gnu-toolchain</a> 工具链：用来编译调试xv6，需要下载源码进行编译</p>
</li>
<li><p>qemu：可以运行不同架构下操作系统的虚拟机，用C语言来模拟硬件的执行，由于xv6是运行在RISC-V架构上的，因此需要qemu来运行.</p>
</li>
</ol>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>上述环境配置完成后，即可</p>
<pre><code class="terminal">&gt; git clone git://g.csail.mit.edu/xv6-labs-2021
&gt; cd xv6-labs-2021
&gt; git checkout util
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>最后通过<code>make qemu</code>来编译xv6并运行，接下来就可以在xv6的命令行中输入命令了。</p>
<br>

<h2><span id="coding">❖ Coding</span></h2><hr>
<h4><span id="︎-sleep-easy">☑︎ sleep (easy)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>第一个实验非常简单，实现用户指定时间的停顿，而xv6系统内置sleep函数，主要是熟悉码命令时的一些基本格式。首先每个命令都会传入两个参数：<code>int argc</code>&amp;<code>char *argv[]</code>，argc是传入参数的个数，而argv是所有传入参数的字符串形式数组。那么这个问题就非常的清晰明了了，只需要把用户传入的时间转为数字，然后调用sleep()即可。</p>
<pre><code class="c">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int arg, char *argv[])
{
    if (arg &lt;= 1)
    {
        fprintf(2, "usage: sleep n\n");
        exit(1);
    }
    else if (arg &gt; 2)
    {
        fprintf(2, "ERROR: too much arguments!\nusage: sleep n\n");
        exit(1);
    }

    char *s = argv[1];
    int n = 0;
    while (*s &gt;= '0' &amp;&amp; *s &lt;= '9')
        n = 10 * n + *s++ - '0';
    if (*s != 0)
    {
        fprintf(2, "ERROR: the second parameter must be a number!\n");
        exit(0);
    }
    sleep(n);
    exit(0);
}
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>⚠️argv[0]是命令名称，真正的参数从argv[1]开始。另外不要忘记错误处理与错误提示。</p>
<br>

<h4><span id="︎-pingpong-easy">☑︎ pingpong (easy)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>先用fork函数创建子进程，然后使用pipe函数进行进程间通讯，最后通过getpid函数获取进程id并输出“PID：received …”。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>首先通过fork返回值是否为0判断是子进程or父进程（父进程返回子进程id），fork完之后两者的资源都是一样的而且都从fork函数继续运行。那么我们先用pipe创建一个管道，用一个<code>int p[2]</code>来记录管道两端的文件描述符，<code>p[1]</code>写<code>p[2]</code>读。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>那么先在父进程中write，然后子进程read完输出并write，父进程通过wait函数（等待第一个子进程结束，如果没有子进程直接继续）等待子进程结束再继续read并输出。</p>
<pre><code class="c">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int arg, char *argv[])
{
    int p[2];
    pipe(p);
    char buff[5];
    if (fork() == 0)
    {
        if (read(p[0], buff, 5) != 5)
        {
            printf("Read Parent ERROR!\n");
            exit(1);
        }
        close(p[0]);
        printf("%d: received %s\n", getpid(), buff);
        write(p[1], "pong", 5);
        close(p[1]);
    }
    else
    {
        write(p[1], "ping", 5);
        close(p[1]);
        wait(0);
        if (read(p[0], buff, 5) != 5)
        {
            printf("Read Child ERROR!\n");
            exit(1);
        }
        printf("%d: received %s\n", getpid(), buff);
        close(p[0]);
    }
    exit(0);
}
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>read函数返回读取的字节数，达到文件末尾返回0，出错返回-1，write类似。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>⚠️读写完及时close，不要忘记字符串末尾的’\0’。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>至于为什么父进程写的比子进程读的快，我想是因为子进程因为需要复制资源还需要耗费额外的时间，因此开始执行的时间会晚于父进程。</p>
<pre><code class="xv6">    $ pingpong
    4: received ping
    3: received pong
    $
</code></pre>
<br>

<h4><span id="︎-primes-moderatehard">☑︎ primes (moderate/hard)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>不是一个命令，但有助于你理解pipe的工作流程。输入primes命令后输出2-35之间的素数。虽然个数有限而且很少可以直接枚举，但希望你利用pipe制作一个埃氏素数筛。大致的流程如下图所示：</p>
<img src="/images/操作系统/0.gif" title alt data-align="center">

<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>它的思想很简单，首先用最小素数2筛去为其倍数的数字，然后再筛去为第二小素数3的倍数，依次类推。不难发现，如果该数组是以2开始的一串连续数字的话，那么每次筛完后的最小数字一定是素数，否则必然还存在比其小的素数未被筛选，这是矛盾的。因此我们只要每次输出最小数字然后筛去该数字的倍数即可。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>很显然这里需要pipe实现传递的功能，那么我们可以每次先从上一个pipe中读出剩下的数组，然后创建一个新的pipe，将该轮筛选后剩余的数字写入新pipe中，接着fork一个新进程，有点类似函数递归调用，我下面用循环代替了递归。</p>
<pre><code class="c">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main()
{
    int buff[34], p[2], size = 34;
    for (int i = 0; i &lt; 34; ++i)
        buff[i] = i + 2;
    pipe(p);
    write(p[1], buff, size * sizeof(int));
    close(p[1]);

    while(size)
    {
        if (fork() == 0)
        {
            read(p[0], buff, size * sizeof(int));
            close(p[0]);
            pipe(p);
            printf("prime %d\n", buff[0]);
            int cnt = 0, prime = buff[0];
            for (int i = 0; i &lt; size; ++i)
                if (buff[i] % prime != 0)
                    buff[cnt++] = buff[i];
            size = cnt;
            write(p[1], buff, cnt * sizeof(int));
            close(p[1]);
        }
        else
        {
            wait(0);
            exit(0);
        }
    }
    exit(0);
}
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>之所以父进程需要wait是因为如果不wait第一个进程在执行完后就直接exit(0)了，这样就会导致系统以为你执行完了事实上并没有的局面：</p>
<pre><code class="xv6">$ primes
p$r ime 2
prime 3
prime 5
prime 7
prime 11
prime 13
prime 17
prime 19
prime 23
prime 29
prime 31
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>你会发现在输出第一条信息的过程中系统以为进程结束，于是输出【$ 】，其实只是第一个进程结束了，但它需要对创建的所有进程负责。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>⚠️创建新管道前记得把老管道的端口close，否则就丢失了。</p>
<h4><span id="︎-fnd-moderate">☑︎ fnd (moderate)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>实现一个简单的查找文件命令find，命令格式为【find rootfile filename】，共计两个参数，那么这里我们需要学会如何访问文件。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>通过阅读user/ls.c，不难得知每个路径都是一个文件，文件内记录该路径下的子文件信息，首先通过<code>open(char *path, int flag)</code>函数打开对应路径path的文件，返回相应的文件描述符，flag是读写标志。然后用<code>stat(int fd, struct stat *st)</code>将fd对应的文件夹/文件的信息写入结构体st，其中<code>st.type</code>表示其（文件夹T_DIR/文件T_FILE）类型。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>这是一方面，但更重要的是获取路径下子文件的信息，例如文件名。fd对应的文件内部记录了所有子文件的信息，可以通过<code>read(fd, &amp;de, sizeof(de))</code>    来获取一个子文件信息，其中de是子文件信息结构体类型的一个实体。de包含inum和name，inum给不同文件夹和文件编号，name为文件名或文件夹名。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>那么通过<code>stat(path+'/'+de.name, &amp;st)</code>就能获取子文件的相关信息，再由<code>st。tyoe</code>判断是否为文件夹进行递归搜索。</p>
<pre><code class="c">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

void search(char *path, char *name)
{
    struct dirent de;
    struct stat st;
    char buf[512], *p;
    int fd;

    if ((fd = open(path, 0)) &lt; 0)
    {
        fprintf(2, "find: cannot open %s\n", path);
        return;
    }

    if (fstat(fd, &amp;st) &lt; 0)
    {
        fprintf(2, "find: cannot stat %s\n", path);
        close(fd);
        return;
    }

    switch (st.type)
    {
    case T_FILE:
        printf("find: %s is a file instead of a path.\n", path);
        break;
    case T_DIR:
        if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof(buf))
        {
            printf("find: path too long!\n");
            break;
        }
        strcpy(buf, path);
        p = buf + strlen(path);
        *p++ = '/';

        while (read(fd, &amp;de, sizeof(de)) == sizeof(de))
        {
            // dno't forget inum==0!
            if (!strcmp(de.name, ".") || !strcmp(de.name, "..") || de.inum == 0)
                continue;
            memmove(p, de.name, DIRSIZ);
            p[DIRSIZ] = 0;
            if (stat(buf, &amp;st) &lt; 0)
            {
                printf("find: cannot stat %s", buf);
                continue;
            }
            switch (st.type)
            {
            case T_DIR:
                search(buf, name);
                break;
            case T_FILE:
                if (!strcmp(de.name, name))
                    printf("%s\n", buf, path);
                break;
            // default:
            //    break;
            }
        }
        break;
    }
    close(fd);
}

int main(int argc, char *argv[])
{
    if (argc &lt; 3)
    {
        fprintf(2, "usage: find rootpath filename.\n");
        exit(1);
    }

    search(argv[1], argv[2]);
    exit(0);
}
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>简单地说，de是子文件信息结构体，st是本身信息结构体。DIRSIZ是文件名固定长度，方便处理。<code>memmove( void* dest, const void* src, size_t count )</code>从src拷贝count个字节到dest，如果是字符串记得补0。buf来存储路径以及子目录的路径字符串。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>⚠️子文件信息里面会包含当前目录【.】、上级目录【..】还有一个<code>inum==0 &amp;&amp; de.name==""</code>的节点（大概查阅了一下，de.inum==0表示这是一块已经初始化并且可以用来创建文件或者文件夹的位置），注意绕道避免无限递归，无限递归将导致栈溢出，运行时会出现<code>usertrap()</code>。</p>
<pre><code class="xv6">    $ echo &gt; b
    $ mkdir a
    $ echo &gt; a/b
    $ find . b
    ./b
    ./a/b
    $ 
</code></pre>
<br>

<h4><span id="︎-xargs-moderate">☑︎ xargs (moderate)</span></h4><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>xargs命令是一个可以扩展输入参数的命令，通过<code>cmd1 ｜ xargs cmd2</code>可以将cmd1命令的输出添加到cmd2的输入参数中，如果cmd1输出有多行则分别添加执行，效果与UNIX中的<code>xargs -n 1</code>等同：</p>
<pre><code class="UNIX">    $ echo "1\n2" | xargs -n 1 echo line
    line 1
    line 2
</code></pre>
<pre><code class="xv6">    $ echo hello too | xargs echo bye
    bye hello too
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>首先我们需要把xargs后面命令原本就跟着的参数拷贝过去，我这里是直接把字符串指针拷贝过去（相当于浅拷贝），并没有malloc一块新空间。</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>对于追加的参数，我们从标准输入（fd为0）读入。然后就一个一个字符地读，读到’\n’或’ ‘就malloc一块新的空间将这个参数复制过来并将头指针存入<code>char *para[MAXARG]</code>，如果读到了’\n’或者文件结尾就执行一次exec函数（⚠️exec函数不会返回调用函数，如果返回就说明执行失败<code>exit(1)</code>）。</p>
<pre><code class="c">#include "kernel/types.h"
#include "kernel/stat.h"
#include "kernel/param.h"
#include "user/user.h"
#define MAXLEN 512

int main(int argc, char *argv[])
{
    if (argc &lt; 2)
    {
        fprintf(2, "usage: xargs command.\n");
        exit(1);
    }

    char buf[MAXLEN], *para[MAXARG];
    int flag = 1;

    // shallow copy xisting parameters
    for (int i = 1; i &lt; argc; ++i)
        para[i - 1] = argv[i];

    // flag==0 means EOF
    while (flag)
    {
        int cnt = argc - 1, len = 0;
        // read a line from standard input
        while ((flag = read(0, buf + len, 1)))
        {
            if (buf[len] == '\n' || buf[len] == ' ')
            {
                if (len)
                {
                    para[cnt] = (char *)malloc(len + 1);
                    memmove(para[cnt], buf, len);
                    para[cnt][len] = 0;
                    len = 0;
                    if (++cnt &gt; MAXARG)
                    {
                        printf("xargs: too many arguments!\n");
                        exit(1);
                    }
                }

                if (buf[len] == '\n')
                    break;
            }
            else if (len + 1 &gt; MAXLEN)
            {
                printf("xargs: argument too long!\n");
                exit(1);
            }
            else
                ++len;
        }
        if (!fork())
        {
            exec(para[0], para);
            exit(1);
        }
        else
            wait(0);
    }
    exit(0);
}
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>⚠️命令参数个数有限制（MAXARG），另外需要关注一个参数长度不能超过自己定义的buf（MAXLEN）。</p>
<br>

<h2><span id="grading-amp-debug">❖ Grading &amp; Debug</span></h2><hr>
<pre><code class="zsh">cd xv6-labs-2021
./grade-lab-util command_name

e.g.
&gt; ./grade-lab-util sleep   
make: `kernel/kernel' is up to date.
== Test sleep, no arguments == sleep, no arguments: OK (1.3s) 
== Test sleep, returns == sleep, returns: OK (0.9s) 
== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) 
</code></pre>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>所有Test都显示OK即可。</p>
<br>

<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="4.525ex" height="0.036ex" role="img" focusable="false" viewbox="0 0 2000 16"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mspace"/></g></g></g></svg></mjx-container>Debug需要用gdb进行远程调试，首先在一个命令框中（在xv6-labs-2021目录下）<code>make qemu-gdb</code>，然后新建一个命令框窗口（还是在xv6-labs-2021目录下）<code>riscv64-unknown-elf-gdb user/_xargs</code>（【_】+命令名称 ）。如果连接失败在gdb界面输入<code>target remote localhost:25501</code>（端口号见qemu界面最后一行tcp::xxxxx）。不希望每次输入可以写入~/.gdbinit。b设置断点，c运行至断点，n单步执行，p arg查看arg值。</p>
<img title src="/images/操作系统/1.png" alt data-align="center" width="631">

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 Starlit Rover
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Jammy Zeta
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'f1d02ea5b1fd5309c4b9',
        clientSecret: 'fea96546fcd9dc7495659e8c9d6c20cd75fa7dbe',
        repo: 'Blog-Comments',      // The repository of store comments,
        owner: 'StarlitRover',
        admin: ['StarlitRover'],
        language: 'zh-CN',
        id: md5(location.pathname),     // (Ensure uniqueness and length less than 50)
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>