[{"id":"9cc2213cd21176f4b7bef7f9e55191e3","title":"「Chapter 1」初识MySQL","content":"关于数据库这门课着实没学太明白，老师是一位刚从哈工大毕业的美女教师，不过讲课确实不敢恭维，生硬的PPT，书面化的讲述，大概率是教学经验的缺失。最后考前自己把书本啃了一遍，相信老师不会太刁难我们，所以考前也就看了看书，结果考试直接难出天际，列文虎克式出题，覆盖了很多知识点，于是就不出意料地考炸了，可以看得出老师出题的用心良苦。\n当然已经过去许久，至今我对数据库确实还没有一个清晰的体系框架，所以买了一本《MySQL是怎样运行的》，豆瓣上评价挺高，很早就想买了。看了作者前言，内心一阵酸溜，作者本是程序员，中途辞职写书，出版时却发现自己没有名气难以出版，最后幸有好心人相助才得以出版。希望这本封面看起来像幼儿启蒙读本的书能成为我数据库原理的启蒙读本。\n这个系列是关于这本书的笔记，不定期更新，我不会记得太详细，尽量多写自己的理解和感悟，有兴趣可以购书支持一下，作者也是程序员中的一股清流。\n\nMySQL是Oracle旗下的一个关系型数据库管理系统，整体分为服务器和客户端两部分，服务器负责处理响应客户端发来的命令，并将命令结果发回客户端。\n在个人电脑上下载MySQL后，服务器程序和客户端程序都安装在了电脑上。\n","slug":"「Chapter-1」初识MySQL","date":"2023-01-27T12:09:36.000Z","categories_index":"数据库原理","tags_index":"notes,MySQL是怎样运行的","author_index":"Starlit Rover"},{"id":"fec11be8fe74efb46e38390fb6e3547a","title":"『1167」Cartesian Tree","content":"A Cartesian tree is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.\n\nYour job is to output the level-order traversal sequence of the min-heap Cartesian tree.\n\n\nInput Specification:Each input file contains one test case. Each case starts from giving a positive integer N (≤30), and then N distinct numbers in the next line, separated by a space. All the numbers are in the range of int.\nOutput Specification:For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.\nSample Input:10\n8 15 3 4 1 5 12 10 18 6\n\nSample Output:1 3 5 8 4 6 15 10 12 18\n\n\nΩ笛卡尔树是通过一串序列进行构造的，它满足最小堆的特征（父节点&lt;子节点），同时它的中序遍历结果就是构造序列。\n由于构造序列与中序遍历是一致的，那么在逐一插入节点的过程中，我们只能将新节点插入到现有节点的右边（原有节点是新节点的左子树/新节点是原有节点的右子树），才能保证中序遍历中新节点在现有节点的后面。然后最小堆的特征约束了小节点必须在大节点的上方，可以认为一个约束了左右，另一个约束了上下，那么就可以制定如下插入方案：\n\n新节点&gt;当前节点：向右子树插入\n\n新节点&lt;当前节点：将当前节点作为新节点的左子树\n\n\n每次都从根节点开始插入，递归插入函数返回插入后子树的根节点。另外由于节点键值是整型范围，因此还需要一个bool数组标记各个节点的子节点是否存在。\n完结撒花，祝我明天考试顺利～\n\n\n\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nmap&lt;int, pair&lt;bool, bool&gt;&gt; has;\n\nint insert(int r, int k)\n{\n    if (r &lt; k &amp;&amp; has[r].second)\n        sons[r].second = insert(sons[r].second, k);\n    else if (r &lt; k)\n        sons[r].second = k, has[r].second = true;\n    else if (r &gt; k)\n    {\n        sons[k].first = r, has[k].first = true;\n        return k;\n    }\n    return r;\n}\n\nint main()\n{\n    int n, r, k;\n    cin &gt;&gt; n &gt;&gt; r;\n    for (int i = 1; i &lt; n; ++i)\n        cin &gt;&gt; k, r = insert(r, k);\n    vector&lt;int&gt; crt{r}, nxt;\n    bool space = false;\n    while (!crt.empty())\n    {\n        for (auto &amp;t: crt)\n        {\n            printf(\"%s%d\", space ? \" \" : (space = true, \"\"), t);\n            if (has[t].first) nxt.push_back(sons[t].first);\n            if (has[t].second) nxt.push_back(sons[t].second);\n        }\n        crt = std::move(nxt), nxt = vector&lt;int&gt;();\n    }\n}\n","slug":"『1167」Cartesian-Tree","date":"2022-12-02T06:37:46.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Tree","author_index":"Starlit Rover"},{"id":"198f2c49e9910efe18930d8f84735116","title":"「1166』Summit","content":"A summit (峰会) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone.\nNow given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N.\nThen there is another positive integer K (≤ 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L (≤ N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space.\nOutput Specification:For each of the K areas, print in a line your advice in the following format:\n\nif in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), print Area X is OK..\n\nif in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, print Area X may invite more people, such as H. where H is the smallest index of the head who may be invited.\n\nif in this area the arrangement is not an ideal one, then print Area X needs help. so the host can provide some special service to help the heads get to know each other.\n\n\nHere X is the index of an area, starting from 1 to K.\nSample Input:8 10\n5 6\n7 8\n6 4\n3 6\n4 5\n2 3\n8 2\n2 7\n5 3\n3 4\n6\n4 5 4 3 6\n3 2 8 7\n2 2 3\n1 1\n2 4 6\n3 3 2 1\n\nSample Output:Area 1 is OK.\nArea 2 is OK.\nArea 3 is OK.\nArea 4 is OK.\nArea 5 may invite more people, such as 3.\nArea 6 needs help.\n\n\nΩ一群人参加峰会，给出所有的朋友对和若干个小群体，分别判断每个小团体是否为最大的朋友圈，这里的朋友圈指的是内部任意两个人都是朋友。如果是朋友圈，但不是最大的，则还需输出可以加入的最小编号。\n用bitset&lt;201&gt;标记每个人的朋友，在读入一个团体的过程中，单独用一个bitset&lt;201&gt; flag标记已经读入的人，每读入一个人就用他的bitset和flag进行交运算，如果得到的结果不等于flag说明有人和他不是朋友，最后在flag里标记这个人。读完后如果这个团体是朋友圈就再判断是否最大，按编号顺序遍历不在这个团体中的人，用他们的bitset与最终的flag（标记了所有团队中的人）进行交运算，如果存在最终结果等于flag的人就说明不是最大的朋友圈。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b, k, x = -1;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;bitset&lt;201&gt;&gt; edge(n + 1);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a][b] = edge[b][a] = true;\n    }\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i, x = -1)\n    {\n        cin &gt;&gt; m;\n        bitset&lt;201&gt; flag;\n        bool ans = true;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; a;\n            if (!ans) continue;\n            if ((flag &amp; edge[a]) != flag) ans = false;\n            flag[a] = true;\n        }\n        for (int j = 1; j &lt;= n; ++j)\n            if (!flag[j] &amp;&amp; ((edge[j] &amp; flag) == flag))\n            {\n                x = j;\n                break;\n            }\n        if (ans &amp;&amp; x == -1) printf(\"Area %d is OK.\\n\", i + 1);\n        else if (ans) printf(\"Area %d may invite more people, such as %d.\\n\", i + 1, x);\n        else printf(\"Area %d needs help.\\n\", i + 1);\n    }\n}\n","slug":"「1166』Summit","date":"2022-12-02T06:16:17.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,bitset","author_index":"Starlit Rover"},{"id":"9e4aa382d8b2ad0e7867e42c221eb9e6","title":"「1165」Block Reversing","content":"Given a singly linked list L. Let us consider every K nodes as a block (if there are less than K nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks in L. For example, given L as 1→2→3→4→5→6→7→8 and K as 3, your output must be 7→8→4→5→6→1→2→3.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive  which is the total number of nodes, and a positive  which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\n\nwhere Address is the position of the node, Data is an integer, and Next is the position of the next node.\nOutput Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 8 3\n71120 7 88666\n00000 4 99999\n00100 1 12309\n68237 6 71120\n33218 3 00000\n99999 5 68237\n88666 8 -1\n12309 2 33218\n\nSample Output:71120 7 88666\n88666 8 00000\n00000 4 99999\n99999 5 68237\n68237 6 00100\n00100 1 12309\n12309 2 33218\n33218 3 -1\n\n\nΩ常规链表放松题。给出头节点与链表地址、值、下一个节点地址。需要将这个链表每个节点分为一块（最后不足个节点也算一块），然后将这些块逆序连接（块内部无需逆序）输出。\n先将链表中所有节点的地址、值存储到一个vector中，我们只需要确定最后一个块的起始索引，然后每次往后输出个节点，最后把起始索引重复循环即可。\n那么最后块的起始索引应该是，注意当可以整除时就需要减去，因此我们可以-1平移之后再取余得到最后那块的起始索引为\n\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int h, n, k, a;\n    cin &gt;&gt; h &gt;&gt; n &gt;&gt; k;\n    map&lt;int, pair&lt;int, int&gt;&gt; node;\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; a &gt;&gt; node[a].first &gt;&gt; node[a].second;\n    vector&lt;pair&lt;int, int&gt;&gt; list;\n    while (h != -1) list.emplace_back(h, node[h].first), h = node[h].second;\n    bool first = true;\n    for (int i = list.size() - (list.size() - 1) % k - 1; i &gt;= 0; i -= k)\n        for (int j = i; j &lt; min(i + k, int(list.size())); ++j)\n        {\n            if (!first) printf(\" %05d\\n\", list[j].first);\n            else first = false;\n            printf(\"%05d %d\", list[j].first, list[j].second);\n        }\n    printf(\" -1\");\n}\n","slug":"「1165」Block-Reversing","date":"2022-12-02T06:03:29.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,list","author_index":"Starlit Rover"},{"id":"e7fe1381af6f1b05a70d02f02d73c22d","title":"「1164」Good in C","content":"When your interviewer asks you to write “Hello World” using C, can you do as the following figure shows?\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in a 7×5 matrix of C‘s and .‘s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.\nIt is guaranteed that there is at least one word given.\nOutput Specification:For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.\nBetween two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.\nSample Input:..C..\n.C.C.\nC...C\nCCCCC\nC...C\nC...C\nC...C\nCCCC.\nC...C\nC...C\nCCCC.\nC...C\nC...C\nCCCC.\n.CCC.\nC...C\nC....\nC....\nC....\nC...C\n.CCC.\nCCCC.\nC...C\nC...C\nC...C\nC...C\nC...C\nCCCC.\nCCCCC\nC....\nC....\nCCCC.\nC....\nC....\nCCCCC\nCCCCC\nC....\nC....\nCCCC.\nC....\nC....\nC....\nCCCC.\nC...C\nC....\nC.CCC\nC...C\nC...C\nCCCC.\nC...C\nC...C\nC...C\nCCCCC\nC...C\nC...C\nC...C\nCCCCC\n..C..\n..C..\n..C..\n..C..\n..C..\nCCCCC\nCCCCC\n....C\n....C\n....C\n....C\nC...C\n.CCC.\nC...C\nC..C.\nC.C..\nCC...\nC.C..\nC..C.\nC...C\nC....\nC....\nC....\nC....\nC....\nC....\nCCCCC\nC...C\nC...C\nCC.CC\nC.C.C\nC...C\nC...C\nC...C\nC...C\nC...C\nCC..C\nC.C.C\nC..CC\nC...C\nC...C\n.CCC.\nC...C\nC...C\nC...C\nC...C\nC...C\n.CCC.\nCCCC.\nC...C\nC...C\nCCCC.\nC....\nC....\nC....\n.CCC.\nC...C\nC...C\nC...C\nC.C.C\nC..CC\n.CCC.\nCCCC.\nC...C\nCCCC.\nCC...\nC.C..\nC..C.\nC...C\n.CCC.\nC...C\nC....\n.CCC.\n....C\nC...C\n.CCC.\nCCCCC\n..C..\n..C..\n..C..\n..C..\n..C..\n..C..\nC...C\nC...C\nC...C\nC...C\nC...C\nC...C\n.CCC.\nC...C\nC...C\nC...C\nC...C\nC...C\n.C.C.\n..C..\nC...C\nC...C\nC...C\nC.C.C\nCC.CC\nC...C\nC...C\nC...C\nC...C\n.C.C.\n..C..\n.C.C.\nC...C\nC...C\nC...C\nC...C\n.C.C.\n..C..\n..C..\n..C..\n..C..\nCCCCC\n....C\n...C.\n..C..\n.C...\nC....\nCCCCC\nHELLO~WORLD!\n\nSample Output:C...C CCCCC C.... C.... .CCC.\nC...C C.... C.... C.... C...C\nC...C C.... C.... C.... C...C\nCCCCC CCCC. C.... C.... C...C\nC...C C.... C.... C.... C...C\nC...C C.... C.... C.... C...C\nC...C CCCCC CCCCC CCCCC .CCC.\n\nC...C .CCC. CCCC. C.... CCCC.\nC...C C...C C...C C.... C...C\nC...C C...C CCCC. C.... C...C\nC.C.C C...C CC... C.... C...C\nCC.CC C...C C.C.. C.... C...C\nC...C C...C C..C. C.... C...C\nC...C .CCC. C...C CCCCC CCCC.\n\n\nΩ给出所有大写字母的点阵表示，最后一行是需要用点阵输出的语句，单词之间用非大写字母的字符（串）隔开，保证至少有一个单词。单词中字母之间需要空一列，单词与单词之间需要空一行。\n由于只能横向输出，因此用一个二维数组存储每个字母点阵的每一行表示。然后读入需要输出的字符串，如果是大写字母就先存入待输出字符串，如果是非大写字母字符，就检查待输出字符串是否为空，不空就分七行输出。由于字符串结尾不一定会有非大写字母字符，因此在读入后直接结尾加一个空格。另外单词之间的空行只要判断一下是不是第一个输出的单词即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;vector&lt;string&gt;&gt; matrix(26, vector(7, string()));\n    for (int i = 0; i &lt; 26; ++i)\n        for (int j = 0; j &lt; 7; ++j)\n            getline(cin, matrix[i][j]);\n    string s, w;\n    getline(cin, s);\n    s += \" \";\n    bool line = false;\n    for (auto &amp;c: s)\n    {\n        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')\n            w += c;\n        else if (!w.empty())\n        {\n            if (line) printf(\"\\n\");\n            else line = true;\n            for (int i = 0; i &lt; 7; ++i)\n                for (int j = 0; j &lt; w.size(); ++j)\n                    printf(\"%s%s\", matrix[w[j] - 'A'][i].c_str(), j == w.size() - 1 ? \"\\n\" : \" \");\n            w.clear();\n        }\n    }\n}\n","slug":"「1164」Good-in-C","date":"2022-12-02T05:51:06.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"ed0b23be5de3068df8822b7f089d6673","title":"『1163」Dijkstra Sequence","content":"Dijkstra’s algorithm is one of the very famous greedy algorithms.It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.\nIn this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it Dijkstra sequence, is generated by Dijkstra’s algorithm.\nOn the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive integers  and , which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to ​.\nThen Ne​ lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.\nFinally the number of queries, K, is given as a positive integer no larger than 100, followed by K lines of sequences, each contains a permutationof the Nv​ vertices. It is assumed that the first vertex is the source for each sequence.\nAll the inputs in a line are separated by a space.\nOutput Specification:For each of the K sequences, print in a line Yes if it is a Dijkstra sequence, or No if not.\nSample Input:5 7\n1 2 2\n1 5 1\n2 3 1\n2 4 1\n2 5 2\n3 5 1\n3 4 1\n4\n5 1 3 4 2\n5 3 1 2 4\n2 3 4 5 1\n3 2 1 5 4\n\nSample Output:Yes\nYes\nYes\nNo\n\n\nΩ考察对Dijkstra算法的本质理解，不难。我们知道，给定起点，Dijkstra算法会逐一把距离起点由近到远的顶点加入到一个集合中，也就是已经确定到起点最短距离的顶点们，那么将顶点的加入顺序称为Dijkstra Sequence。现在给定一个无向图和若干序列，判断它们是否为这张图的Dijkstra Sequence。注意到，由于部分顶点到起点的最短距离相同，因此一张图存在多个Dijkstra Sequence。\n很显然，直接上Dijkstra算法，由于是检查，因此我们不用完全按流程走。按照顺序遍历给出的序列，我们只要保证当前未加入集合中没有比距离起点更近的顶点即可，如果有更近的顶点说明不是Dijkstra Sequence退出循环，否则更新与关联顶点到起点的距离，并将到起点的距离改为INT32_MAX（后面就无需考虑是否已在集合中）然后重复循环。\n⚠️ 不要更新那些已经在集合中的顶点到起点的距离，因此还是需要标记位于集合中的顶点。 \n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int v, e, a, b, d, k;\n    cin &gt;&gt; v &gt;&gt; e;\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; edge(v + 1);\n    for (int i = 0; i &lt; e; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;\n        edge[a].emplace_back(b, d);\n        edge[b].emplace_back(a, d);\n    }\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        vector&lt;int&gt; dj(v), dist(v + 1, INT32_MAX);\n        vector&lt;bool&gt; visited(v + 1, false);\n        bool ans = true;\n        for (auto &amp;t: dj) cin &gt;&gt; t;\n        for (auto &amp;t: edge[dj[0]])\n            dist[t.first] = t.second;\n        visited[dj[0]] = true;\n        for (int j = 1; j &lt; v; dist[dj[j]] = INT32_MAX, visited[dj[j]] = true, ++j)\n        {\n            if (!(ans = *min_element(dist.begin(), dist.end()) == dist[dj[j]]))\n                break;\n            for (auto &amp;t: edge[dj[j]])\n            {\n                if (visited[t.first]) continue;\n                dist[t.first] = min(dist[dj[j]] + t.second, dist[t.first]);\n            }\n        }\n        printf(ans ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n","slug":"『1163」Dijkstra-Sequence","date":"2022-12-01T16:57:57.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Dijkstra","author_index":"Starlit Rover"},{"id":"7d33432dbf79dd8f70b2b1b9bfcc3dbc","title":"「1162』Postfix Expression","content":"Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i-th line corresponds to the i-th node) in the format:\ndata left_child right_child\n\nwhere data is a string of no more than 10 characters, left_child and right_child are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\n\n\nOutput Specification:For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.\nSample Input 1:8\n* 8 7\na -1 -1\n* 4 1\n+ 2 5\nb -1 -1\nd -1 -1\n- -1 6\nc -1 -1\n\nSample Output 1:(((a)(b)+)((c)(-(d))*)*)\n\nSample Input 2:8\n2.35 -1 -1\n* 6 1\n- -1 4\n% 7 8\n+ 2 3\na -1 -1\nstr -1 -1\n871 -1 -1\n\nSample Output 2:(((a)(2.35)*)(-((str)(871)%))+)\n\n\nΩ给出一个运算式的语法树，输出它的后缀表达式。本质上就是考察树的后序遍历，唯一不同的地方在于，需要注意单目运算符【-】，如果说存在右子树但不存在左子树就说明是单目运算符，需要先输出节点的值，然后再输出右子树的后缀表达式。\n⚠️根节点需要自己计算，初始化根节点序号为1-N之和，然后减去所有节点的子节点序号，最后剩下的就是根节点编号。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;string&gt; value;\nvector&lt;pair&lt;int, int&gt;&gt; sons;\n\nstring postfix(int i)\n{\n    if (i == -1) return \"\";\n    else if (sons[i].first == -1) return \"(\" + value[i] + postfix(sons[i].second) + \")\";\n    else return \"(\" + postfix(sons[i].first) + postfix(sons[i].second) + value[i] + \")\";\n}\n\nint main()\n{\n    int n, h;\n    cin &gt;&gt; n;\n    h = n * (n + 1) / 2;\n    value.resize(n + 1), sons.resize(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        cin &gt;&gt; value[i] &gt;&gt; sons[i].first &gt;&gt; sons[i].second;\n        h -= max(0, sons[i].first) + max(0, sons[i].second);\n    }\n    cout &lt;&lt; postfix(h);\n}\n","slug":"「1162』Postfix-Expression","date":"2022-12-01T16:02:39.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"37353806131bb7be8e2475ba5c533abf","title":"「1161」Merging Linked Lists","content":"Given two singly linked lists ​ and ​. If , you are supposed to reverse and merge the shorter one into the longer one to obtain a list like ​⋯. For example, given one list being 6→7 and the other one 1→2→3→4→5, you must output 1→2→7→3→4→6→5.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes of L1​ and L2​, plus a positive  which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\n\nwhere Address is the position of the node, Data is a positive integer no more than , and Next is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.\nOutput Specification:For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 01000 7\n02233 2 34891\n00100 6 00001\n34891 3 10086\n01000 1 02233\n00033 5 -1\n10086 4 00033\n00001 7 -1\n\nSample Output:01000 1 02233\n02233 2 00001\n00001 7 34891\n34891 3 10086\n10086 4 00100\n00100 6 00033\n00033 5 -1\n\n\nΩ链表水题放松。给出两个链表，长度分别为，需要你将短链表反向隔2插入到长链表中。\n首先读入所有节点，用map建立地址到节点值以及下一个节点地址的映射。然后通过头节点遍历链表，将每个节点的地址及值存储到vector&lt;pair&lt;int,int&gt;&gt;中。最后每输出两个长链表节点，就反向输出一个短链表节点。短链表输完后需要把长链表剩余节点一次性输出。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\ninline void output(pair&lt;int, int&gt; &amp;p)\n{\n    static bool flag = false;\n    if (flag) printf(\" %05d\\n\", p.first);\n    printf(\"%05d %d\", p.first, p.second);\n    flag = true;\n}\n\nint main()\n{\n    int sa, sb, n, a, v, nxt, j;\n    cin &gt;&gt; sa &gt;&gt; sb &gt;&gt; n;\n    map&lt;int, pair&lt;int, int&gt;&gt; node;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; v &gt;&gt; nxt;\n        node[a] = make_pair(v, nxt);\n    }\n    vector&lt;pair&lt;int, int&gt;&gt; l1, l2;\n    while (sa != -1)\n        l1.emplace_back(sa, node[sa].first), sa = node[sa].second;\n    while (sb != -1)\n        l2.emplace_back(sb, node[sb].first), sb = node[sb].second;\n    if (l1.size() &lt; l2.size()) swap(l1, l2);\n    for (j = 0; j &lt; 2 * l2.size(); j += 2)\n        output(l1[j]), output(l1[j + 1]), output(l2[l2.size() - j / 2 - 1]);\n    for (; j &lt; l1.size(); ++j) output(l1[j]);\n    printf(\" -1\");\n}\n","slug":"「1161」Merging-Linked-Lists","date":"2022-12-01T15:33:32.000Z","categories_index":"","tags_index":"","author_index":"Starlit Rover"},{"id":"75be25fcd9a5cd2b923517296b55a3e7","title":"「1160」Forever","content":"“Forever number” is a positive integer A with K digits, satisfying the following constrains:\n\nthe sum of all the digits of A is m;\nthe sum of all the digits of A+1 is n; and\nthe greatest common divisor of m and n is a prime number which is greater than 2.\n\nNow you are supposed to find these forever numbers.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains a positive integer N (≤5). Then N lines follow, each gives a pair of K (3&lt;K&lt;10) and m (1&lt;m&lt;90), of which the meanings are given in the problem description.\nOutput Specification:For each pair of K and m, first print in a line Case X, where X is the case index (starts from 1). Then print n and A in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order of n. If still not unique, output in the ascending order of A. If there is no solution, output No Solution.\nSample Input:2\n6 45\n7 80\n\nSample Output:Case 1\n10 189999\n10 279999\n10 369999\n10 459999\n10 549999\n10 639999\n10 729999\n10 819999\n10 909999\nCase 2\nNo Solution\n\n\nΩ长久数A，满足为大于2的质数，其中指的是的各位之和，指的是的各位之和，gcd是最大公因数。\n一开始看是二十分的题，而且限时3000ms，就想着直接枚举，结果前两个测试点都没超1000ms，后面两个测试点炸了。不过每加1时间确实会翻十倍。我很绝望地要开始尝试DFS搜索了，不过注意到Sample中的结果都是以99结尾的，寻思着会不会有什么规律，没想到还真有。\n从最低位开始，如果的最低位不是9的话，那么就不会产生进位，从而，而显然，必然不是质数。Amazing，接着看如果的倒数第二位不是9，这时我们已经确定的最后一位一定是9，那么意味着只会在十位产生一次进位，从而，注意到一定是8的因子，整除8的素数只有2，而题目要求是&gt;2的素数，因此也一定不符合题意。到第三位的时候，，，那么最大公因子只可能是1或者17，是有可能符合题意的。综上可以确定长久数的最后两位一定是99。\n在确定最后两位后，枚举的工作量直接降两个量级，枚他丫的。\n当然要是我没注意到这个特性，就必须想办法降低枚举量。首先可以直接构造所有各位数之和为的位数，从最高位开始枚举构造，如果后面所有位都取9都达不到的话，说明前面数字取小了，可以直接跳过，这样能节省大量开销。\n\n🐎#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nbool isPrime(int r)\n{\n    if (r &lt; 4) return r &gt; 2;\n    for (int i = 2; i &lt;= sqrt(r); i += (i == 2) + 1)\n        if (r % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int n, k, m, u = 1, v = 1, vv = 0;\n    bool flag = true;\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i, u = 1, v = 19, vv = 0, flag = true)\n    {\n        vector&lt;pair&lt;int, int&gt;&gt; ans;\n        printf(\"Case %d\\n\", i + 1);\n        scanf(\"%d %d\", &amp;k, &amp;m);\n        for (int j = 1; j &lt; k - 2; ++j) u *= 10;\n        for (int j = u; j &lt; 10 * u; ++j, v = vv + 18, vv = 0)\n        {\n            string s = to_string(j + 1);\n            for (auto &amp;c: s)\n                vv += c - '0';\n            if (v == m &amp;&amp; isPrime(gcd(v, vv)))\n                ans.emplace_back(vv, j * 100 + 99), flag = false;\n        }\n        if (flag) printf(\"No Solution\\n\");\n        else\n        {\n            sort(ans.begin(), ans.end());\n            for (auto &amp;t: ans) printf(\"%d %d\\n\", t.first, t.second);\n        }\n    }\n}\n","slug":"「1160」Forever","date":"2022-12-01T12:15:21.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,prime","author_index":"Starlit Rover"},{"id":"23a26d9dbfb7f35f39b098e97db54754","title":"『1159』Structure of a Binary Tree","content":"Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.\nNow given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:\n\nA is the root\nA and B are siblings\nA is the parent of B\nA is the left child of B\nA is the right child of B\nA and B are on the same level\nIt is a full tree\n\nNote:\n\nTwo nodes are on the same level, means that they have the same depth.\nA full binary tree is a tree in which every node other than the leaves has two children.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more than  and are separated by a space.\nThen another positive integer M (≤30) is given, followed by M lines of statements. It is guaranteed that both A and B in the statements are in the tree.\nOutput Specification:For each statement, print in a line Yes if it is correct, or No if not.\nSample Input:9\n16 7 11 32 28 2 23 8 15\n16 23 7 32 11 2 28 15 8\n7\n15 is the root\n8 and 2 are siblings\n32 is the parent of 11\n23 is the left child of 16\n28 is the right child of 2\n7 and 11 are on the same level\nIt is a full tree\n\nSample Output:Yes\nNo\nYes\nNo\nYes\nYes\nYes\n\n\nΩ给出一棵二叉树的后序、中序遍历，然后判断七种陈述模式的对错。\n树的节点不超过30个，因此直接搞个结构体存储所有信息——父节点、子节点、深度。而且节点编号不会超过1000，因此直接开个数组存储所有节点的结构体。在递归建树的过程中，记录每个节点的信息，同时如果当前节点只有一个孩子则标记notFull为true。\n另一个难点是判断陈述模式，我们可以先将整行读入（⚠️不要忘记读完后getchar()），然后按照空格将单词压入数组中，根据语句中的关键词进行判断。⚠️判断顺序尽量按照单词数少的模式到单词数多的模式，如果先判断单词数多模式偏后的关键词可能会导致单词数少模式的越界访问。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; post, in;\nbool notFull = false, ans;\n\nstruct node\n{\n    int parent = -1, depth = 0;\n    pair&lt;int, int&gt; sons{-1, -1};\n};\n\nvector&lt;node&gt; tree(1001);\n\nvoid build(int ps, int pe, int is, int ie)\n{\n    int bias = find(in.begin() + is, in.begin() + ie, post[pe]) - in.begin() - is;\n    if (bias &gt; 0)\n    {\n        tree[post[pe]].sons.first = post[ps + bias - 1];\n        tree[post[ps + bias - 1]].parent = post[pe];\n        tree[post[ps + bias - 1]].depth = tree[post[pe]].depth + 1;\n        build(ps, ps + bias - 1, is, is + bias);\n    }\n    if (is + bias &lt; ie - 1)\n    {\n        tree[post[pe]].sons.second = post[pe - 1];\n        tree[post[pe - 1]].parent = post[pe];\n        tree[post[pe - 1]].depth = tree[post[pe]].depth + 1;\n        build(ps + bias, pe - 1, is + bias + 1, ie);\n    }\n    notFull |= (bias &lt; ie - is - 1) ^ (bias &gt; 0);\n}\n\nint main()\n{\n    int n, m, p = 0;\n    cin &gt;&gt; n;\n    post.resize(n), in.resize(n);\n    for (auto &amp;k: post) cin &gt;&gt; k;\n    for (auto &amp;k: in) cin &gt;&gt; k;\n    build(0, n - 1, 0, n);\n    cin &gt;&gt; m;\n    getchar();\n    string st;\n    for (int i = 0; i &lt; m; ++i, p = 0)\n    {\n        vector&lt;string&gt; jdg;\n        getline(cin, st);\n        st.push_back(' ');\n        for (int j = 0; j &lt; st.size(); ++j)\n            if (st[j] == ' ')\n            {\n                jdg.push_back(st.substr(p, j - p));\n                p = j + 1;\n            }\n        if (jdg[3] == \"root\") ans = stoi(jdg[0]) == post.back();\n        else if (jdg[0] == \"It\") ans = !notFull;\n        else if (jdg[1] == \"and\")\n        {\n            auto &amp;a = tree[stoi(jdg[0])], &amp;b = tree[stoi(jdg[2])];\n            ans = (jdg[4] == \"on\" ? a.depth == b.depth : a.parent == b.parent);\n        }\n        else if (jdg[3] == \"parent\") ans = stoi(jdg[0]) == tree[stoi(jdg[5])].parent;\n        else\n            ans = (jdg[3] == \"left\" ? tree[stoi(jdg.back())].sons.first == stoi(jdg[0]) :\n                   tree[stoi(jdg.back())].sons.second == stoi(jdg[0]));\n        printf(\"%s\\n\", ans ? \"Yes\" : \"No\");\n    }\n}\n","slug":"『1159』Structure-of-a-Binary-Tree","date":"2022-12-01T09:44:36.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"7369aa2af707a2b4122dd8865d50ba11","title":"「1158」Telefraud Detection","content":"Telefraud（电信诈骗） remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.\nA person must be detected as a suspect if he/she makes more than K short phone calls to different people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang. A makes a short phone call to B means that the total duration of the calls from A to B is no more than 5 minutes.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives 3 positive integers , the threshold（阈值） of the amount of short phone calls), , the number of different phone numbers), and , the number of phone call records). Then M lines of one day’s records are given, each in the format:\ncaller receiver duration\n\nwhere caller and receiver are numbered from 1 to N, and duration is no more than 1440 minutes in a day.\nOutput Specification:Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.\nIf no one is detected, output None instead.\nSample Input 1:5 15 31\n1 4 2\n1 5 2\n1 5 4\n1 7 5\n1 8 3\n1 9 1\n1 6 5\n1 15 2\n1 15 5\n3 2 2\n3 5 15\n3 13 1\n3 12 1\n3 14 1\n3 10 2\n3 11 5\n5 2 1\n5 3 10\n5 1 1\n5 7 2\n5 6 1\n5 13 4\n5 15 1\n11 10 5\n12 14 1\n6 1 1\n6 9 2\n6 10 5\n6 11 2\n6 12 1\n6 13 1\n\nSample Output 1:3 5\n6\n\nNote: In sample 1, although 1 had 9 records, but there were 7 distinct receivers, among which 5 and 15 both had conversations lasted more than 5 minutes in total. Hence 1 had made 5 short phone calls and didn’t exceed the threshold 5, and therefore is not a suspect.\nSample Input 2:5 7 8\n1 2 1\n1 3 1\n1 4 1\n1 5 1\n1 6 1\n1 7 1\n2 1 1\n3 1 1\n\nSample Output 2:None\n\n\nΩ题目比较复杂，揉杂了很多考点，但只要把题目读懂，理清条件就还好。给出若干通电话记录，包括拨打者、接听者和通话时长，如果一个人给个【不同】的人打了【短】通话（作为【拨打者】通话【总】时长≤ 5 min）电话，而且【这些人】中只有≤ 20%的人回拨，就认定这是一个电信诈骗嫌疑犯。另外如果两个嫌疑人之间【互通】电话，那么我们认为他们可能属于同一个团伙。最后输出所有嫌疑犯，一行一个团伙，按照升序输出。\n需要注意的点都用【】标注出来了，可以看到只要有一个地方没理解透彻就翻车。注意到人数不会超过1000，所以我打算用bitset来分别标记打出记录和接听记录：bitset&lt;1000&gt; call(n),rec(n)。由于需要记录短通话的次数，因此用一个二维数组存储单向拨打通话总时长。注意到call和rec的信息其实是等价的，因此我们用call来标记短通话。当两个人之间存在通话记录就在拨打者的call里进行标记，如果单向通话时长超过5min，就取消标记。rec只要有通话记录都标记。\n那么拨打短通话的不同人数就是call[i]中1的数量call[i].count()，而回拨的人数我们只考虑那些有接听的短通话的人群，即call[i][j]&amp;&amp;rec[i][j]。最终我们将这部分人数（需要保证整型不会溢出）再和call[i].count()进行比较，将嫌疑人存入vector&lt;int&gt; sus。最后再对sus进行DFS或BFS或并查集来求取连通分图，我这里用了DFS。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; edge;\nvector&lt;bool&gt; flag;\n\nvoid dfs(int n, vector&lt;int&gt; &amp;gang)\n{\n    flag[n] = true, gang.push_back(n);\n    for (auto &amp;k: edge[n])\n    {\n        if (flag[k]) continue;\n        dfs(k, gang);\n    }\n}\n\nint main()\n{\n    int k, n, m, c, r, d, cnt = 0;\n    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;\n    vector&lt;bitset&lt;1000&gt;&gt; call(n), rec(n);\n    vector&lt;vector&lt;int&gt;&gt; dur(n, vector(n, 0));\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; c &gt;&gt; r &gt;&gt; d;\n        call[c - 1][r - 1] = (dur[c - 1][r - 1] += d) &lt;= 5;\n        rec[r - 1][c - 1] = true;\n    }\n    vector&lt;int&gt; sus, gang;\n    for (int i = 0; i &lt; n; ++i, cnt = 0)\n    {\n        for (int j = 0; j &lt; n; ++j) cnt += (call[i][j] &amp;&amp; rec[i][j]);\n        if (call[i].count() &gt; k &amp;&amp; 5 * cnt &lt;= call[i].count())\n            sus.push_back(i);\n    }\n    if (sus.empty()) printf(\"None\");\n    else\n    {\n        edge.resize(sus.size()), flag.resize(sus.size(), false);\n        for (int i = 0; i &lt; sus.size(); ++i)\n            for (int j = i + 1; j &lt; sus.size(); ++j)\n                if (rec[sus[i]][sus[j]] &amp;&amp; rec[sus[j]][sus[i]])\n                    edge[i].push_back(j), edge[j].push_back(i);\n        for (int i = 0; i &lt; sus.size(); ++i, gang.clear())\n        {\n            if (flag[i]) continue;\n            dfs(i, gang);\n            sort(gang.begin(), gang.end(), [&amp;sus](int a, int b) { return sus[a] &lt; sus[b]; });\n            for (int j = 0; j &lt; gang.size(); ++j)\n                printf(\"%d%s\", sus[gang[j]] + 1, j == gang.size() - 1 ? \"\\n\" : \" \");\n        }\n    }\n}\n","slug":"「1158」Telefraud-Detection","date":"2022-12-01T06:53:52.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,DFS,bitset","author_index":"Starlit Rover"},{"id":"11dc3c2912f3e8bbbeebc80b6943eb66","title":"『1157』Anniversary","content":"Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association （校友会） has gathered the ID’s of all her alumni. Now your job is to write a program to count the number of alumni among all the people who come to the celebration.\n\n\nInput Specification:Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integer . Then N lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letter X. It is guaranteed that all the ID’s are distinct.\nThe next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integer . Then M lines follow, each contains an ID number of a guest. It is guaranteed that all the ID’s are distinct.\nOutput Specification:First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus – notice that the 7th - 14th digits of the ID gives one’s birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.\nSample Input:5\n372928196906118710\n610481197806202213\n440684198612150417\n13072819571002001X\n150702193604190912\n6\n530125197901260019\n150702193604190912\n220221196701020034\n610481197806202213\n440684198612150417\n370205198709275042\n\nSample Output:3\n150702193604190912\n\n\nΩ给出校友身份ID，然后统计参加校庆人群中的校友个数，并输出最年长的校友ID。如果没有校友参加，则输出所有宾客中最年长的ID。\n最年长ID具有明显的优先级，与pair比较的思想类似，我们可以用pair对的比较来判断是否需要替换最年长ID。比如说一个校友{false,\"19991229\"}和一个非校友{true,\"18900101\"}，由于前者的pair较小（），选择前者为最年长ID。\n\n🐎#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    set&lt;string&gt; alu;\n    int n, m, cnt = 0;\n    cin &gt;&gt; n;\n    string id, oldest;\n    pair&lt;bool, string&gt; cmp{true, string(8, '9')};\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; id, alu.insert(id);\n    cin &gt;&gt; m;\n    bool notAlu;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id;\n        (notAlu = alu.find(id) == alu.end()) ?: ++cnt;\n        if (make_pair(notAlu, id.substr(6, 8)) &lt; cmp)\n            cmp = make_pair(notAlu, id.substr(6, 8)), oldest = id;\n    }\n    printf(\"%d\\n%s\", cnt, oldest.c_str());\n}\n","slug":"『1157』Anniversary","date":"2022-11-29T14:27:33.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"8ed7bca38adabdf721bda6f764633180","title":"『1156」Sexy Primes","content":"Sexy primes are pairs of primes of the form , so-named since “sex” is the Latin word for “six”. (Quoted from http://mathworld.wolfram.com/SexyPrimes.html)\nNow given an integer, you are supposed to tell if it is a sexy prime.\n\n\nInput Specification:Each input file contains one test case. Each case gives a positive integer .\nOutput Specification:For each case, print in a line Yes if N is a sexy prime, then print in the next line the other sexy prime paired with N (if the answer is not unique, output the smaller number). Or if N is not a sexy prime, print No instead, then print in the next line the smallest sexy prime which is larger than N.\nSample Input 1:47\n\nSample Output 1:Yes\n41\n\nSample Input 2:21\n\nSample Output 2:No\n23\n\n\nΩ性感（sexy，与six发音相近）素数指同为素数的素数。现在给出一个数，判断是否为性感素数，如果是就输出另一个最小的素数伙伴，否则输出最小且的性感素数。\n直接从开始判断是否为性感素数，不是就+1，最后找到的第一个性感素数如果和相等就输出“Yes”和它的素数伙伴，否则输出“No”和最小的性感素数。\n\n🐎#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    if (n &lt; 4) return n &gt; 1;\n    for (int i = 2; i &lt;= sqrt(n); i += (i != 2) + 1)\n        if (n % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n, m = n - 1;\n    while (!isPrime(++m) || (!isPrime(k = m - 6) &amp;&amp; !isPrime(k = m + 6)));\n    printf(\"%s\\n%d\", m == n ? \"Yes\" : \"No\", m == n ? k : m);\n}\n","slug":"『1156」Sexy-Primes","date":"2022-11-29T12:59:44.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,prime","author_index":"Starlit Rover"},{"id":"af9a9a9068aea13525f268c88dd33420","title":"『1155』Heap Paths","content":"In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))\nOne thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.\nYour job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (1&lt;N≤1,000), the number of keys in the tree. Then the next line contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.\nOutput Specification:For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.\nFinally print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all.\nSample Input 1:8\n98 72 86 60 65 12 23 50\n\nSample Output 1:98 86 23\n98 86 12\n98 72 65\n98 72 60 50\nMax Heap\n\nSample Input 2:8\n8 38 25 58 52 82 70 60\n\nSample Output 2:8 25 70\n8 25 82\n8 38 52\n8 38 58 60\nMin Heap\n\nSample Input 3:8\n10 28 15 12 34 9 8 56\n\nSample Output 3:10 15 8\n10 15 9\n10 28 34\n10 28 12 56\nNot Heap\n\n\nΩ按照叶子节点从右至左的顺序输出所有根节点到叶子节点的路径，并判断是小顶堆还是大顶堆。输入堆的层次遍历，由于堆是完全二叉树，因此可以根据节点索引判断是否存在。\n本质上就是树的DFS，优先遍历右子树，再遍历左子树。用一个vector存储从根节点到当前函数所在节点的路径（进入函数时压入当前节点编号，退出时把最后一个元素推出），如果当前节点是叶子节点，就将路径输出。递归过程中顺便记录每个节点与父节点之间的大小关系，如果有不同的大小关系说明不是堆。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define sign(x, y) (x==y?0:(x&gt;y)+1)\n\nusing namespace std;\nint n, jdg = 0;\nvector&lt;int&gt; level, path;\n\nvoid traverse(int r)\n{\n    if (r &gt; n) return;\n    path.push_back(level[r]);\n    jdg |= sign(level[r], level[r / 2]);\n    if (2 * r &gt; n &amp;&amp; 2 * r + 1 &gt; n)\n        for (int i = 0; i &lt; path.size(); ++i)\n            printf(\"%d%s\", path[i], i &lt; path.size() - 1 ? \" \" : \"\\n\");\n    traverse(2 * r + 1);\n    traverse(2 * r);\n    path.pop_back();\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    level.resize(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        cin &gt;&gt; level[i];\n    level[0] = level[1];\n    traverse(1);\n    printf(\"%s\", jdg == 3 ? \"Not Heap\" : jdg == 2 ? \"Min Heap\" : \"Max Heap\");\n}\n","slug":"『1155』Heap-Paths","date":"2022-11-29T12:12:08.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,heap","author_index":"Starlit Rover"},{"id":"09fcb22b7551ea744c57f07b69e5a972","title":"「1154」Vertex Coloring","content":"A proper vertex coloring is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k colors is called a (proper) k-coloring.\nNow you are supposed to tell if a given coloring is a proper k-coloring.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than ), being the total numbers of vertices and edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge.\nAfter the graph, a positive integer  is given, which is the number of colorings you are supposed to check. Then K lines follow, each contains N colors which are represented by non-negative integers in the range of int. The i-th color is the color of the i-th vertex.\nOutput Specification:For each coloring, print in a line k-coloring if it is a proper k-coloring for some positive k, or No if not.\nSample Input:10 11\n8 7\n6 8\n4 5\n8 4\n8 1\n1 2\n1 4\n9 8\n9 1\n1 0\n2 4\n4\n0 1 0 1 4 1 0 1 3 0\n0 1 0 1 4 1 0 1 0 0\n8 1 0 1 4 1 0 5 3 0\n1 2 3 4 5 6 7 8 8 9\n\nSample Output:4-coloring\nNo\n6-coloring\nNo\n\n\nΩ给定一个无向图，判断顶点染色方案是否满足任意边的两个端点不同色，若满足则同时输出颜色数量。\n在读取染色方案时，用set存储各个点不能染的颜色编号。读入顶点的颜色之后，先在的set中find(c) ，如果找到了说明不满足要求，满足的话再将所有与关联的顶点set中插入颜色，表明它不能染成颜色。同时单独用一个set存储所有出现过的颜色来记录不同颜色数量。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b, k;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;vector&lt;int&gt;&gt; edge(n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        edge[a].push_back(b), edge[b].push_back(a);\n    }\n    scanf(\"%d\", &amp;k);\n    for (int i = 0; i &lt; k; ++i)\n    {\n        vector&lt;set&lt;int&gt;&gt; no(n);\n        set&lt;int&gt; color;\n        bool ans = true;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            scanf(\"%d\", &amp;a);\n            if (!ans) continue;\n            ans = (no[j].find(a) == no[j].end());\n            for (auto &amp;t: edge[j])\n                no[t].insert(a);\n            color.insert(a);\n        }\n        if (ans) printf(\"%zu-coloring\\n\", color.size());\n        else printf(\"No\\n\");\n    }\n}\n","slug":"「1154」Vertex-Coloring","date":"2022-11-29T10:43:33.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph","author_index":"Starlit Rover"},{"id":"1dc52340625e6d898b967d568951e86c","title":"「1153」Decode Registration Card of PAT","content":"A registration card number of PAT consists of 4 parts:\n\nthe 1st letter represents the test level, namely, T for the top level, A for advance and B for basic;\nthe 2nd - 4th digits are the test site number, ranged from 101 to 999;\nthe 5th - 10th digits give the test date, in the form of yymmdd;\nfinally the 11th - 13th digits are the testee’s number, ranged from 000 to 999.\n\nNow given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤104) and M (≤100), the numbers of cards and the queries, respectively.\nThen N lines follow, each gives a card number and the owner’s score (integer in [0,100]), separated by a space.\nAfter the info of testees, there are M lines, each gives a query in the format Type Term, where\n\nType being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level;\nType being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number;\nType being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card.\n\nOutput Specification:For each query, first print in a line Case #: input, where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested:\n\nfor a type 1 query, the output format is the same as in input, that is, CardNumber Score. If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed);\nfor a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score;\nfor a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site. The output must be in non-increasing order of Nt‘s, or in increasing order of site numbers if there is a tie of Nt.\n\nIf the result of a query is empty, simply print NA.\nSample Input:8 4\nB123180908127 99\nB102180908003 86\nA112180318002 98\nT107150310127 62\nA107180908108 100\nT123180908010 78\nB112160918035 88\nA107180908021 98\n1 A\n2 107\n3 180908\n2 999\n\nSample Output:Case 1: 1 A\nA107180908108 100\nA107180908021 98\nA112180318002 98\nCase 2: 2 107\n3 260\nCase 3: 3 180908\n107 2\n123 2\n102 1\nCase 4: 2 999\nNA\n\n\nΩ做这种题目的时候总是心惊胆战，生怕哪个地方优化没做好，数据结构没搞好就TLE。\n给出若干个PAT考试登记码：，接下来会有多个查询，有三种查询模式：\n\nType 1：输入level（B、A、T），按照成绩降序输出所有参加这个等级考的学生登记码和成绩，成绩一样按登记码升序排列\n\nType 2：输入考场号，输出在该考场参加考试的总人数以及总成绩\n\nType 3：输入日期，按照当日考试人数降序输出所有有人考试的考场号，以及相应的考试人数，如果考试人数一致则按考场号升序排列\n\n\n查询结果为空就输出NA。\n前两种查询方式都挺好处理。读取完所有登记码和成绩，对三个level的信息分别进行排序；注意到考场号只有三位数，那么直接开一个vector&lt;pair&lt;int,int&gt;&gt; site(1000)，考场号即为索引，来存储人数和总成绩。第三个查询模式就比较棘手了，我的思路是直接开一个map&lt;int,map&lt;int,int&gt;&gt;来存储单个日期下单个考场的人数，在查询时把子map拷贝到一个vector中，然后再进行排序输出。\n第一次提交，后三个测试点全是TLE，把我看傻了，心态直接崩。不知道还有什么优化手段，于是去网上看了些题解，发现暴力循环遍历都能过，百思不得其解。我试着把三个level的排序部分给注释掉，竟然发现时间骤减。仔细研究一番，发现问题出在lambda表达式中的传参。由于我把登记码和成绩单独存储在一个vector&lt;pair&lt;int,int&gt;&gt; info中，而三个level都只存info的索引，因此在sort的lambda函数中需要将info传入：\n[info](int a, int b) {return info[a].second == info[b].second ? info[a].first &lt; info[b].first : info[a].second &gt; info[b].second;}\n\n那么就意味着每次调用lambda函数时都会拷贝一遍info，从而造成了大量的时间开销。其实lambda函数是可以传入引用的，只要在变量名前加上&amp;即可：\n[&amp;info](int a, int b)\n\n传入所有参数是[=]，⚠️这也是拷贝传参。如果需要传入多个参数就用【,】分隔。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\n\n#define idx(x) (x=='B'?0:x=='A'?1:2)\n\nusing namespace std;\ntypedef const pair&lt;int, int&gt; cpii;\n\nint main()\n{\n    int n, m, tp, s, d;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;pair&lt;string, int&gt;&gt; info(n, {string(13, 0), 0});\n    vector&lt;pair&lt;int, int&gt;&gt; site(1000);\n    vector&lt;int&gt; level[3];\n    unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; date;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;info[i].first[0], &amp;info[i].second);\n        s = stoi(info[i].first.substr(1, 3)), d = stoi(info[i].first.substr(4, 6));\n        level[idx(info[i].first[0])].push_back(i);\n        ++site[s].first; site[s].second += info[i].second;\n        ++date[d][s];\n    }\n    for (auto &amp;k: level)\n        sort(k.begin(), k.end(), [&amp;info](int a, int b) \n        {return info[a].second == info[b].second ? info[a].first &lt; info[b].first : info[a].second &gt; info[b].second;});\n    string st;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; tp &gt;&gt; st;\n        printf(\"Case %d: %d %s\\n\", i + 1, tp, st.c_str());\n        switch (tp)\n        {\n            case 1:\n                if (level[idx(st[0])].empty()) printf(\"NA\\n\");\n                else\n                    for (auto &amp;k: level[idx(st[0])])\n                        printf(\"%s %d\\n\", info[k].first.c_str(), info[k].second);\n                break;\n            case 2:\n                if (!site[stoi(st)].first) printf(\"NA\\n\");\n                else printf(\"%d %d\\n\", site[stoi(st)].first, site[stoi(st)].second);\n                break;\n            case 3:\n                if (date[stoi(st)].empty()) printf(\"NA\\n\");\n                else\n                {\n                    vector&lt;pair&lt;int, int&gt;&gt; tmp(date[stoi(st)].begin(), date[stoi(st)].end());\n                    sort(tmp.begin(), tmp.end(), [](cpii &amp;a, cpii &amp;b) \n                    {return a.second == b.second ? a.first &lt; b.first : a.second &gt; b.second;});\n                    for (auto &amp;k: tmp)\n                        printf(\"%03d %d\\n\", k.first, k.second);\n                }\n                break;\n        }\n    }\n}\n","slug":"「1153」Decode-Registration-Card-of-PAT","date":"2022-11-29T08:35:11.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"1c996a2205f7f5bbcbe287507d181067","title":"「1152」Google Recruitment","content":"In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constant e. The person who could find this prime number could go to the next step in Google’s hiring process by visiting this website.\n\nThe natural constant e is a well known transcendental number（超越数）. The first several digits are: e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… where the 10 digits in bold are the answer to Google’s question.\nNow you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number.\n\n\nInput Specification:Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line.\nOutput Specification:For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number.\nSample Input 1:20 5\n23654987725541023819\n\nSample Output 1:49877\n\nSample Input 2:10 3\n2468024680\n\nSample Output 2:404\n\n\nΩ好老的梗啊，几百年前就看到过了。给定一个长度为L的字符串，从中找出最前面长度为K的连续素子串。直接从～依次遍历，找到第一个素数后停止。\n⚠️时直接输出404。\n\n🐎#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    if (n &lt; 3) return n == 2;\n    for (int i = 2; i &lt;= sqrt(n); i += i == 2 ? 1 : 2)\n        if (n % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int l, k;\n    string s;\n    cin &gt;&gt; l &gt;&gt; k &gt;&gt; s;\n    if (l &lt; k)\n    {\n        printf(\"404\");\n        return 0;\n    }\n    for (int i = 0; i &lt; l - k + 1; ++i)\n        if (isPrime(stoi(s.substr(i, k))))\n        {\n            printf(\"%s\", s.substr(i, k).c_str());\n            return 0;\n        }\n    printf(\"404\");\n}\n","slug":"「1152」Google-Recruitment","date":"2022-11-28T15:31:17.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,prime,string","author_index":"Starlit Rover"},{"id":"1e6798c1367bb43a43c504bc91548d12","title":"「1151』LCA in a Binary Tree","content":"The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.\nGiven any two nodes in a binary tree, you are supposed to find their LCA.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int.\nOutput Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the binary tree, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found..\nSample Input:6 8\n7 2 3 4 6 5 1 8\n5 3 7 2 6 4 8 1\n2 6\n8 1\n7 9\n12 -3\n0 8\n99 99\n\nSample Output:LCA of 2 and 6 is 3.\n8 is an ancestor of 1.\nERROR: 9 is not found.\nERROR: 12 and -3 are not found.\nERROR: 0 is not found.\nERROR: 99 and 99 are not found.\n\n\nΩ好眼熟的题目啊，感觉连测试样例甚至都是一样的——『1143』Lowest Common Ancestor。同样是输出两个节点共同的最低祖宗节点，上一问中是二叉搜索树，而这一问只是二叉树，但给出了中序遍历和先序遍历。\n真是换汤不换药啊，我寻思着上一问之所以可以把中序遍历省去是因为所有节点的升序排列就是二叉搜索树的中序遍历。所以两者本质上是一样的，我们只要给每一个节点重新编号使得它们的中序遍历结果即为升序排列，通过map建立起老编号和新编号之间的映射。那么很显然，我们只需要把每个节点的新编号设置为中序遍历中的索引即可。接下来就在先序遍历中找到第一个新编号介于两个节点新编号之间的节点即可，证明过程见1143。\n其实根据推导过程，可以看出一般的树（非二叉树）也适用这种做法。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k, a, b, u, v, ans;\n    scanf(\"%d %d\", &amp;m, &amp;n);\n    vector&lt;int&gt; pre(n);\n    map&lt;int, int&gt; in;\n    for (int i = 0; i &lt; n; ++i)\n        scanf(\"%d\", &amp;k), in[k] = i;\n    for (auto &amp;p: pre) cin &gt;&gt; p;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        bool fa = in.find(a) == in.end(), fb = in.find(b) == in.end();\n        switch (fa + (fb &lt;&lt; 1))\n        {\n            case 1:\n                printf(\"ERROR: %d is not found.\\n\", a); continue;\n            case 2:\n                printf(\"ERROR: %d is not found.\\n\", b); continue;\n            case 3:\n                printf(\"ERROR: %d and %d are not found.\\n\", a, b); continue;\n        }\n        u = min(in[a], in[b]), v = max(in[a], in[b]);\n        for (auto &amp;p: pre)\n            if (in[p] &gt;= u &amp;&amp; in[p] &lt;= v)\n            {\n                ans = p;\n                break;\n            }\n        if (in[ans] == v || in[ans] == u)\n            printf(\"%d is an ancestor of %d.\\n\", in[ans] == in[a] ? a : b, in[ans] == in[a] ? b : a);\n        else\n            printf(\"LCA of %d and %d is %d.\\n\", a, b, ans);\n    }\n}\n\n\n","slug":"「1151』LCA-in-a-Binary-Tree","date":"2022-11-28T14:12:07.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"a4815f6ae46beab8c783f42705d05394","title":"『1150」Travelling Salesman Problem","content":"The “travelling salesman problem” asks the following question: “Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?” It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science. (Quoted from “https://en.wikipedia.org/wiki/Travelling_salesman_problem“.)\nIn this problem, you are supposed to find, from a given list of cycles, the one that is the closest to the solution of a travelling salesman problem.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers N (2&lt;N≤200), the number of cities, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format City1 City2 Dist, where the cities are numbered from 1 to N and the distance Dist is positive and is no more than 100. The next line gives a positive integer K which is the number of paths, followed by K lines of paths, each in the format:\nn C1​ C2​ … Cn​\nwhere n is the number of cities in the list, and Ci​’s are the cities on a path.\nOutput Specification:For each path, print in a line Path X: TotalDist (Description) where X is the index (starting from 1) of that path, TotalDist its total distance (if this distance does not exist, output NA instead), and Description is one of the following:\n\nTS simple cycle if it is a simple cycle that visits every city;\nTS cycle if it is a cycle that visits every city, but not a simple cycle;\nNot a TS cycle if it is NOT a cycle that visits every city.\n\nFinally print in a line Shortest Dist(X) = TotalDist where X is the index of the cycle that is the closest to the solution of a travelling salesman problem, and TotalDist is its total distance. It is guaranteed that such a solution is unique.\nSample Input:6 10\n6 2 1\n3 4 1\n1 5 1\n2 5 1\n3 1 8\n4 1 6\n1 6 1\n6 3 1\n1 2 1\n4 5 1\n7\n7 5 1 4 3 6 2 5\n7 6 1 3 4 5 2 6\n6 5 1 4 3 6 2\n9 6 2 1 6 3 4 5 2 6\n4 1 2 5 1\n7 6 1 2 5 4 3 1\n7 6 3 2 5 4 1 6\n\nSample Output:Path 1: 11 (TS simple cycle)\nPath 2: 13 (TS simple cycle)\nPath 3: 10 (Not a TS cycle)\nPath 4: 8 (TS cycle)\nPath 5: 3 (Not a TS cycle)\nPath 6: 13 (Not a TS cycle)\nPath 7: NA (Not a TS cycle)\nShortest Dist(4) = 8\n\n\nΩTSP是一个NP难问题，这一题需要你判断给定无向图中的一些路径是以下三种中的哪种：\n\nTS 简单环：每座城市访问过且仅访问过一次\n\nTS 环：每座城市都访问过，但部分城市多次访问\n\n非TS环：部分城市没有访问，或根本不是环，或路线不存在\n\n\n注意如果不是路线不存在，所有的路线都需要输出总长度，而最优路线只能从TS simple cycle和TS cycle中选。用一个bitset&lt;201&gt;来标记城市是否访问过，用整型变量jdg的低两位分别来表示具备TS cycle（重复访问城市）和Not a TS cycle的特征（有城市没访问、不是环路、路线不存在），显然当时说明是前者的情况，而都是后者。读入路线的过程中，判断是否重复访问，同时检查路线是否存在。读完之后判断起点和终点是否相同，是否所有城市都已访问。最后根据jdg的值输出相应的信息。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, a, b, p, d = 0, jdg = 0, opt = -1, min_d = INT32_MAX;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector(n + 1, 0));\n    for (int i = 0; i &lt; m; ++i)\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; dist[b][a], dist[a][b] = dist[b][a];\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i, d = 0, jdg = 0)\n    {\n        bitset&lt;201&gt; flag(string(n, '1'));\n        cin &gt;&gt; k &gt;&gt; a, p = a;\n        for (int j = 1; j &lt; k; ++j, p = b)\n        {\n            cin &gt;&gt; b;\n            // if revisit city and visit non-existent road\n            jdg |= !flag[b - 1] + (dist[p][b] ? 0 : (d = -1, 2));\n            d += (d &gt; -1) * dist[p][b], flag[b - 1] = false;\n        }\n        // if starting city is same as ending city and all the cities have been visited\n        jdg |= (a == b &amp;&amp; flag == 0 ? 0 : 2);\n        switch (jdg)\n        {\n            case 0:\n                printf(\"Path %d: %d (TS simple cycle)\\n\", i + 1, d);\n                if (d &lt; min_d) min_d = d, opt = i + 1;\n                break;\n            case 1:\n                printf(\"Path %d: %d (TS cycle)\\n\", i + 1, d);\n                if (d &lt; min_d) min_d = d, opt = i + 1;\n                break;\n            default:\n                if (d &gt; 0) printf(\"Path %d: %d (Not a TS cycle)\\n\", i + 1, d);\n                else printf(\"Path %d: NA (Not a TS cycle)\\n\", i + 1);\n                break;\n        }\n    }\n    printf(\"Shortest Dist(%d) = %d\", opt, min_d);\n}\n","slug":"『1150」Travelling-Salesman-Problem","date":"2022-11-28T12:44:21.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,TSP","author_index":"Starlit Rover"},{"id":"ff3134335de30a822a5e1c46f95fdfc6","title":"『1149』Dangerous Goods Packaging","content":"When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent （氧化剂） must not be packed with flammable liquid （易燃液体）, or it can cause explosion.\nNow you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: , the number of pairs of incompatible goods, and , the number of lists of goods to be shipped.\nThen two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format:\nK G[1] G[2] ... G[K]\n\nwhere K (≤1,000) is the number of goods and G[i]‘s are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces.\nOutput Specification:For each shipping list, print in a line Yes if there are no incompatible goods in the list, or No if not.\nSample Input:6 3\n20001 20002\n20003 20004\n20005 20006\n20003 20001\n20005 20004\n20004 20006\n4 00001 20004 00002 20003\n5 98823 20002 20003 20006 10010\n3 12345 67890 23333\n\nSample Output:No\nYes\nYes\n\n\nΩ今天真的是水逆，一会TLE，一会MLE，总之每次第一个思路总是错的，可恶。\n给出对不能一起运输的物品ID，随后输入个运输清单，输出能否运输。就连这种题目都不能一边过，服了。\n一开始我打算用一个set&lt;long long&gt;存储不能一起运输的物品ID，假设是一对不能一起运输的物品，那么就将查询索引存入set。在读入一个运输清单时，将每一个读入物品与之前读入物品组成查询索引在set中查找，如果找到了就说明不能一起运输。结果后面两个测试点TLE了。后来我想直接给每个物品开一个bitset&lt;100000&gt;来记录不能一起存储的物品，结果ME（Memory Limit Exceeded）。\n最后采取常规做法，用map&lt;int,vector&lt;int&gt;&gt;建立ID到不能一起运输物品集的映射，然后每读入一个物品就将不能和其一起运输的物品ID进行标记，如果后面出现了标记过的物品，则说明这单不能运输。事实证明，中庸才是王道，我之前的两个做法分别在时间和空间上过于极端（当然题目限的太狠也是一个因素\n反思了一下，最开始建立的那个查询索引会让索引量增长到，set和map内部的数据结构都是红黑树，查找效率在，那么会让时间增长一倍，这确实是一笔不小的开销。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    map&lt;int, vector&lt;int&gt;&gt; incap;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        incap[a].push_back(b), incap[b].push_back(a);\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d\", &amp;n);\n        bitset&lt;size_t(1e5)&gt; tmp;\n        bool ans = true;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            scanf(\"%d\", &amp;a);\n            if (!ans) continue;\n            if (tmp[a]) ans = false;\n            for (auto &amp;k: incap[a]) tmp[k] = true;\n        }\n        printf(ans ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n","slug":"『1149』Dangerous-Goods-Packaging","date":"2022-11-28T10:26:29.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,bitset","author_index":"Starlit Rover"},{"id":"00adf0accb1aad7e13f310feb201ca0a","title":"「1148」Werewolf - Simple Version","content":"Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game,\n\nplayer #1 said: “Player #2 is a werewolf.”;\nplayer #2 said: “Player #3 is a human.”;\nplayer #3 said: “Player #4 is a werewolf.”;\nplayer #4 said: “Player #5 is a human.”; and\nplayer #5 said: “Player #4 is a human.”.\n\nGiven that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves?\nNow you are asked to solve a harder version of this problem: given that there were N players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer . Then N lines follow and the i-th line gives the statement of the i-th player , which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf.\nOutput Specification:If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence – that is, for two sequences  and , if there exists 0≤k&lt;M such that  and , then A is said to be smaller than B. In case there is no solution, simply print No Solution.\nSample Input 1:5\n-2\n+3\n-4\n+5\n+4\n\nSample Output 1:1 4\n\nSample Input 2:6\n+6\n+3\n+1\n-5\n-2\n+4\n\nSample Output 2 (the solution is not unique):1 5\n\nSample Input 3:5\n-2\n-3\n-4\n-5\n-1\n\nSample Output 3:No Solution\n\n\nΩ做了好久，最近脑子非常混乱，感觉状态越做越差，可能睡眠质量不佳。\n狼人杀模拟，个玩家分别作出谁是狼人/平民的陈述，已知其中有两个狼人，且有一个狼人和一个平民说谎，请判断谁是狼人。\n20分一看就是枚举题，结果我一开始竟然在枚举谁说谎，枚了半天差点疯了。因为就算确定了哪两个人说谎也不一定能推断出狼人是谁，有些人的陈述可能会针对同一个人，也就是说一部分人会没有任何身份信息。事实证明，不要把20分的问题想的太复杂，求啥枚啥，直接枚举两个狼人，然后计数有几个错的陈述，接着判断是否两人撒谎，是不是一个狼人一个平民。\n对于是否撒谎我们可以通过【是否为狼人】与【推测是狼人】的异或运算得出，一狼一平民的判断也可以通过异或进行判断。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define isWolf(x) (abs(x)==i||abs(x)==j)\n\nusing namespace std;\n\nint main()\n{\n    int n, r = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; st(n), liar;\n    for (auto &amp;s: st) cin &gt;&gt; s;\n    for (int i = 1; i &lt; n; ++i)\n        for (int j = i + 1; j &lt;= n; ++j, r = 0, liar.clear())\n        {\n            for (int k = 0; k &lt; n; ++k)\n                if (isWolf(st[k]) ^ (st[k] &lt; 0))\n                    liar.push_back(k + 1);\n            if (liar.size() == 2 &amp;&amp; (isWolf(liar[0]) ^ isWolf(liar[1])))\n            {\n                printf(\"%d %d\\n\", i, j);\n                return 0;\n            }\n        }\n    printf(\"No Solution\\n\");\n}\n","slug":"「1148」Werewolf-Simple-Version","date":"2022-11-28T08:38:29.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"26c8e58b47c0447a364ca71b586839ff","title":"「1147」Heaps","content":"In computer science, a heap is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))\nYour job is to tell if a given complete binary tree is a heap.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 100), the number of trees to be tested; and N (1 &lt; N ≤ 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range of int), which gives the level order traversal sequence of a complete binary tree.\nOutput Specification:For each given tree, print in a line Max Heap if it is a max heap, or Min Heap for a min heap, or Not Heap if it is not a heap at all. Then in the next line print the tree’s postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line.\nSample Input:3 8\n98 72 86 60 65 12 23 50\n8 38 25 58 52 82 70 60\n10 28 15 12 34 9 8 56\n\nSample Output:Max Heap\n50 60 65 72 12 23 86 98\nMin Heap\n60 58 52 38 82 70 25 8\nNot Heap\n56 12 34 28 9 8 15 10\n\n\nΩ根据一棵完全二叉树的层次遍历判断是最大堆还是最小堆，最后输出该树的后序遍历。\n那么就将每个节点与其根节点进行大小比较，用一个int的低两位（bit）标记和，最后如果低两位都被标记了就说明不是堆，最低位被标记就是最小堆，次低位被标记就是最大堆，最后递归输出后序遍历即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define sign(x, y) (x==y?0:x&gt;y?2:1)\n\nusing namespace std;\nvector&lt;int&gt; level;\n\nvoid printPost(int n)\n{\n    if (n &gt;= level.size()) return;\n    printPost(2 * n + 1);\n    printPost(2 * n + 2);\n    printf(\"%d%s\", level[n], n == 0 ? \"\\n\" : \" \");\n}\n\nint main()\n{\n    int m, n, jdg = 0;\n    cin &gt;&gt; m &gt;&gt; n;\n    level.resize(n);\n    bool flag = false;\n    for (int i = 0; i &lt; m; ++i, flag = false, jdg = 0)\n    {\n        cin &gt;&gt; level[0];\n        for (int j = 1; j &lt; n; ++j, flag = !flag)\n        {\n            cin &gt;&gt; level[j];\n            jdg |= sign(level[j / 2 - flag], level[j]);\n        }\n        printf(jdg == 3 ? \"Not Heap\\n\" : jdg == 2 ? \"Max Heap\\n\" : \"Min Heap\\n\");\n        printPost(0);\n    }\n}\n","slug":"「1147」Heaps","date":"2022-11-28T03:50:32.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,heap","author_index":"Starlit Rover"},{"id":"58b13f5d3514e42a82f269de71ed64e3","title":"『1146」Topological Order","content":"This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤ 1,000), the number of vertices in the graph, and M (≤ 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (≤ 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space.\nOutput Specification:Print in a line all the indices of queries which correspond to “NOT a topological order”. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer.\nSample Input:6 8\n1 2\n1 3\n5 2\n5 4\n2 3\n2 6\n3 4\n6 4\n6\n5 2 3 6 4 1\n1 5 2 3 6 4\n5 1 2 6 3 4\n5 1 2 3 6 4\n5 2 1 6 3 4\n1 2 3 4 5 6\n\nSample Output:0 4 5\n\n\nΩ给定有向图，判断几个顶点全排列是否满足拓扑排序，输出不是拓扑排序的序列编号。\n如果把每个顶点看作任务，每条有向边表示开始任务B之前需要先完成A任务，那么如果一组顶点的全排列满足所有任务可以按照顺序做完，就称其为该图的拓扑排序。那么我们只要按顺序检查每个顶点的入边起点是否都已经完成即可。\n这种检查题都没啥难度，对每个全排列，标记已经出现的节点，然后判断当前节点所有入边的起点是否被标记，若存在入边起点未被标记说明不满足拓扑排序。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt; edge(n + 1);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[b].push_back(a);\n    }\n    cin &gt;&gt; m;\n    vector&lt;int&gt; ans;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        bool isTPG = true;\n        vector&lt;bool&gt; flag(n + 1, false);\n        for (int j = 0; j &lt; n; ++j)\n        {\n            cin &gt;&gt; a, flag[a] = true;\n            if (!isTPG) continue;\n            for (auto &amp;k: edge[a])\n                if (!flag[k])\n                {\n                    isTPG = false;\n                    break;\n                }\n        }\n        if (!isTPG) ans.push_back(i);\n    }\n    cout &lt;&lt; ans[0];\n    for (int i = 1; i &lt; ans.size(); ++i)\n        cout &lt;&lt; \" \" &lt;&lt; ans[i];\n}\n","slug":"『1146」Topological-Order","date":"2022-11-27T15:31:10.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,拓扑排序","author_index":"Starlit Rover"},{"id":"83b3a4468e6241cb8f0d55c9d71c268b","title":"『1145』Hashing - Average Search Time","content":"The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to be  where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.\nNote that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more than . Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more than .\nOutput Specification:For each test case, in case it is impossible to insert some number, print in a line X cannot be inserted. where X is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place.\nSample Input:4 5 4\n10 6 4 15 11\n11 4 15 2\n\nSample Output:15 cannot be inserted.\n2.8\n\n\nΩ救命，哈希题好难啊。给出表大小（如果不为素数需要找到的最小素数），个待插入的数，个需要查询的数。对不能插入的数进行输出，最后输出平均搜索时间。\n如果插入时存在冲突采取二次探测法，详见上一道hash题「1078」Hashing。对于无法插入的键值最多只需次，关键是平均搜索时间的计算。\n每一次键值的比较都算是一个单位的搜索时间，但问题是不存在键值的搜索时间是否是一个固定时间，答案是否定的。因为不存在的键值有两种情况：1. 未曾尝试插入过，2. 尝试插入过但失败了。对于case 2，你需要次搜索（最后一次发现回到起点也算，虽然我觉的没什么必要）；而对于case 1，在你采取二次探测法查找键值时如果发现某个位置为空，就说明它之前没有插入过，应该直接停止搜索。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    if (n == 1) return false;\n    if (n == 2) return true;\n    for (int i = 2; i &lt;= sqrt(n); i += (i == 2 ? 1 : 2))\n        if (n % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int t, n, m, k, bias = -1, cnt = 0;\n    cin &gt;&gt; t &gt;&gt; n &gt;&gt; m;\n    while (!isPrime(t)) ++t;\n    vector&lt;int&gt; hash(t, 0);\n    for (int i = 0; i &lt; n; ++i, bias = -1)\n    {\n        cin &gt;&gt; k;\n        while (++bias &lt; t &amp;&amp; hash[(k + bias * bias) % t]);\n        if (bias == t) printf(\"%d cannot be inserted.\\n\", k);\n        else hash[(k + bias * bias) % t] = k;\n    }\n    for (int i = 0; i &lt; m; ++i, bias = -1)\n    {\n        cin &gt;&gt; k;\n        while (++cnt, ++bias &lt; t &amp;&amp; hash[(k + bias * bias) % t] != k &amp;&amp; hash[(k + bias * bias) % t] != 0);\n    }\n    printf(\"%.1f\", 1.0 * cnt / m);\n}\n","slug":"『1145』Hashing-Average-Search-Time","date":"2022-11-27T14:35:53.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,hash","author_index":"Starlit Rover"},{"id":"16253d2f98c7585dcb9c2bd2f1f7d451","title":"「1144」The Missing Number","content":"Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer . Then N integers are given in the next line, separated by spaces. All the numbers are in the range of int.\nOutput Specification:Print in a line the smallest positive integer that is missing from the input list.\nSample Input:10\n5 -25 9 6 1 3 4 2 5 17\n\nSample Output:7\n\n\nΩ给出一个整数序列，输出序列中不存在的最小正整数。\n注意到最大也才，因此答案一定在～中。我们开一个大小（最后一个索引是）的bool数组，并初始化索引指针为1。每次读入一个数，如果是一个的【正】整数，那么将其索引的bool值置true，同时往后移动（也可能不移动）索引指针到第一个值为false的索引。最后直接输出索引指针。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, ans = 1;\n    scanf(\"%d\", &amp;n);\n    vector&lt;bool&gt; pos(1e5 + 2, false);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        if (k &lt;= 1e5 &amp;&amp; k &gt; 0) pos[k] = true;\n        while (pos[ans]) ++ans;\n    }\n    printf(\"%d\", ans);\n}\n","slug":"「1144」The-Missing-Number","date":"2022-11-27T12:33:03.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"f27d92d50d5edef0b562aa3325cde9aa","title":"『1143』Lowest Common Ancestor","content":"The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.\nA binary search tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nGiven any two nodes in a BST, you are supposed to find their LCA.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (≤ 1,000), the number of pairs of nodes to be tested; and N (≤ 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range of int.\nOutput Specification:For each given pair of U and V, print in a line LCA of U and V is A. if the LCA is found and A is the key. But if A is one of U and V, print X is an ancestor of Y. where X is A and Y is the other node. If U or V is not found in the BST, print in a line ERROR: U is not found. or ERROR: V is not found. or ERROR: U and V are not found..\nSample Input:6 8\n6 3 1 2 5 4 8 7\n2 5\n8 7\n1 9\n12 -3\n0 8\n99 99\n\nSample Output:LCA of 2 and 5 is 3.\n8 is an ancestor of 7.\nERROR: 9 is not found.\nERROR: 12 and -3 are not found.\nERROR: 0 is not found.\nERROR: 99 and 99 are not found.\n\n\nΩ给出一个二叉搜索树的先序遍历，输出两个节点的最低祖宗节点，如果树中不存在节点，就输出相应的报错信息。\n被自己蠢哭了，最近题目刷多反而刷傻了。一看到先序遍历和二叉搜索树，就急着要构建出整棵树来，而且在构建过程中记录了每个节点的深度。读入需要查找的两个节点，如果树中存在这两个节点，就先让深度更大的节点往上回溯父节点直到与另一个节点深度相同，如果其父节点就是另一个节点则输出“X is an ancestor of Y.”，否则一起往上回溯直到两者父节点相同。\n其实提交前自我感觉良好，觉得能一遍过，结果最后两个测试点超时了。我就轻车熟路地把所有cin、cout换成scanf、printf，这次竟然没用，于是我又把map换成了unordered_map，i.e. 哈希表，结果最后一个测试点还是超时。我深感不妙，到这一步就已经说明是我的算法出了问题。我寻思着，难到还有什么奇技淫巧吗。。。\n这时候就需要回归本质了，最低祖宗节点其实是两个节点分流的地方，那么为什么会分流呢？因为两个节点与最低祖宗节点的大小关系不同。bingo，注意到先序遍历的特征是根节点在所有子节点前，那么我们只要顺序遍历先序遍历序列，找到第一个使得，其中是需要查找的两个节点。这里之所以两边都要加上【=】是因为有可能就是。那为什么第一个满足条件的就是答案呢？因为当你把为根节点的子树去掉后就会发现剩余节点与的大小关系都是一致的，而先序遍历中前面的节点一定来自于这些剩余节点。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, a, b, u, v, ans;\n    cin &gt;&gt; m &gt;&gt; n;\n    vector&lt;int&gt; pre(n);\n    map&lt;int, bool&gt; flag;\n    for (auto &amp;k: pre)\n        cin &gt;&gt; k, flag[k] = true;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        bool skip = true;\n        switch ((flag[a] &lt;&lt; 1) + flag[b])\n        {\n            case 2: printf(\"ERROR: %d is not found.\\n\", b); break;\n            case 1: printf(\"ERROR: %d is not found.\\n\", a); break;\n            case 0: printf(\"ERROR: %d and %d are not found.\\n\", a, b); break;\n            default: skip = false;\n        }\n        if (skip) continue;\n        u = min(a, b), v = max(a, b);\n        for (auto &amp;k: pre)\n            if (k &gt;= u &amp;&amp; k &lt;= v)\n            {\n                ans = k;\n                break;\n            }\n        (ans == v || ans == u) ? printf(\"%d is an ancestor of %d.\\n\", ans == v ? v : u, ans == v ? u : v)\n                               : printf(\"LCA of %d and %d is %d.\\n\", a, b, ans);\n    }\n}\n\n🐎🐎（case 5: Time Limit Exceeded）#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre;\nunordered_map&lt;int, pair&lt;int, int&gt;&gt; dad;\n\nvoid build(int s, int e)\n{\n    int r = upper_bound(pre.begin() + s, pre.begin() + e, pre[s]) - pre.begin();\n    if (r &gt; s + 1)\n    {\n        dad[pre[s + 1]] = make_pair(pre[s], dad[pre[s]].second + 1);\n        build(s + 1, e);\n    }\n    if (r &lt; e)\n    {\n        dad[pre[r]] = make_pair(pre[s], dad[pre[s]].second + 1);\n        build(r, e);\n    }\n}\n\nint main()\n{\n    int m, n, a, b, u, v;\n    scanf(\"%d %d\", &amp;m, &amp;n);\n    pre.resize(n);\n    for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;pre[i]);\n    dad[pre[0]] = make_pair(pre[0], 0);\n    build(0, n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        bool fa = dad.find(a) == dad.end(), fb = dad.find(b) == dad.end(), flag = true;\n        switch ((fa &lt;&lt; 1) + fb)\n        {\n            case 1: printf(\"ERROR: %d is not found.\\n\", b); break;\n            case 2: printf(\"ERROR: %d is not found.\\n\", a); break;\n            case 3: printf(\"ERROR: %d and %d are not found.\\n\", a, b); break;\n            default: flag = false;\n        }\n        if (flag) continue;\n        u = (dad[a].second &gt; dad[b].second) ? a : b, v = (dad[a].second &gt; dad[b].second) ? b : a;\n        while (dad[u].second &gt; dad[v].second) u = dad[u].first;\n        if (u == v) printf(\"%d is an ancestor of %d.\\n\", v, v == a ? b : a);\n        else\n        {\n            while (u != v)\n                u = dad[u].first, v = dad[v].first;\n            printf(\"LCA of %d and %d is %d.\\n\", a, b, u);\n        }\n    }\n}\n","slug":"『1143』Lowest-Common-Ancestor","date":"2022-11-27T11:26:11.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search,traversal order,Tree","author_index":"Starlit Rover"},{"id":"fd7ce911047e09d73f8229b416cde491","title":"「1142」Maximal Clique","content":"A clique is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. A maximal clique is a clique that cannot be extended by including one more adjacent vertex. (Quoted from https://en.wikipedia.org/wiki/Clique_(graph_theory))\nNow it is your job to judge if a given subset of vertices can form a maximal clique.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers Nv (≤ 200), the number of vertices in the graph, and Ne, the number of undirected edges. Then Ne lines follow, each gives a pair of vertices of an edge. The vertices are numbered from 1 to Nv.\nAfter the graph, there is another positive integer M (≤ 100). Then M lines of query follow, each first gives a positive number K (≤ Nv), then followed by a sequence of K distinct vertices. All the numbers in a line are separated by a space.\nOutput Specification:For each of the M queries, print in a line Yes if the given subset of vertices can form a maximal clique; or if it is a clique but not a maximal clique, print Not Maximal; or if it is not a clique at all, print Not a Clique.\nSample Input:8 10\n5 6\n7 8\n6 4\n3 6\n4 5\n2 3\n8 2\n2 7\n5 3\n3 4\n6\n4 5 4 3 6\n3 2 8 7\n2 2 3\n1 1\n3 4 3 6\n3 3 2 1\n\nSample Output:Yes\nYes\nYes\nYes\nNot Maximal\nNot a Clique\n\n\nΩ给出一个无向图，判断其中的顶点子集是否为最大完全图，完全图指内部任意两个顶点之间均有边相连，而最大则指图中其余任意点的加入都不能再构成一个更大的完全图。\n完全图只要遍历所有顶点对检查是否有边即可，而最大则检查剩余图中是否存在与子集中所有顶点均有边的顶点，若存在说明不是最大。\n这种题用bitset就很爽，注意到顶点数不超过200个，因此我们给每一个顶点都开一个bitset&lt;201&gt;，第位为1代表与第个顶点之间有边相连，那么201位就能代表一个顶点的连边情况。在读入一个顶点子集的过程中，每读入一个顶点，就将其连边情况与之前读入的顶点（也用bitset&lt;201&gt;表示）进行并运算，如果结果与之前读入的顶点一致就代表该顶点与前面所有顶点之间均有边相连，否则说明不是完全图。最后将剩余顶点的连边情况与该顶点集的顶点进行并运算，如果结果等于顶点集中的顶点就说明不是最大的clique。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int v, e, a, b;\n    cin &gt;&gt; v &gt;&gt; e;\n    bitset&lt;201&gt; edge[v + 1];\n    for (int i = 0; i &lt; e; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a][b] = edge[b][a] = true;\n    }\n    int n, m;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        bool ans = true;\n        vector&lt;bool&gt; flag(v + 1, false);\n        bitset&lt;201&gt; r(0);\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; a;\n            if (!ans) continue;\n            if ((edge[a] &amp; r) != r) ans = false;\n            r[a] = true, flag[a] = true;\n        }\n        if (!ans) printf(\"Not a Clique\\n\");\n        else\n        {\n            for (int j = 1; j &lt;= v; ++j)\n            {\n                if (flag[j]) continue;\n                if ((edge[j] &amp; r) == r)\n                {\n                    ans = false;\n                    break;\n                }\n            }\n            printf(ans ? \"Yes\\n\" : \"Not Maximal\\n\");\n        }\n    }\n}\n","slug":"「1142」Maximal-Clique","date":"2022-11-27T07:38:11.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph","author_index":"Starlit Rover"},{"id":"324ab5351ee7cff7d5b7ed1cb7ec626b","title":"『1141』PAT Ranking of Institutions","content":"After each PAT, the PAT Center will announce the ranking of institutions based on their students’ performances. Now you are asked to generate the ranklist.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤105), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format:\nID Score School\n\nwhere ID is a string of 6 characters with the first one representing the test level: B stands for the basic level, A the advanced level and T the top level; Score is an integer in [0, 100]; and School is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that ID is unique for each testee.\nOutput Specification:For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format:\nRank School TWS Ns\n\nwhere Rank is the rank (start from 1) of the institution; School is the institution code (all in lower case); ; TWS is the total weighted score which is defined to be the integer part of ScoreB/1.5 + ScoreA + ScoreT*1.5, where ScoreX is the total score of the testees belong to this institution on level X; and Ns is the total number of testees who belong to this institution.\nThe institutions are ranked according to their TWS. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns. If there is still a tie, they shall be printed in alphabetical order of their codes.\nSample Input:10\nA57908 85 Au\nB57908 54 LanX\nA37487 60 au\nT28374 67 CMU\nT32486 24 hypu\nA66734 92 cmu\nB76378 71 AU\nA47780 45 lanx\nA72809 100 pku\nA03274 45 hypu\n\nSample Output:5\n1 cmu 192 2\n1 au 192 3\n3 pku 100 1\n4 hypu 81 2\n4 lanx 81 2\n\n\nΩ为PAT的团体成绩进行排序，给出每个考生的准考证号、成绩、学校代号，最终学校团体成绩按照，ABT代表三个不同的考试等级，表示这个学校参加X等级考试的考生成绩总和。最终结果按团体成绩降序排列，并给出相应名次，如果总成绩相同就按照参与人数的升序排列，如果人数也一致就按照学校代码升序排列。\n先用一个map&lt;string, tuple&lt;int, int, int, int&gt;&gt;建立学校代码到BAT考试成绩总和以及考生人数的映射。然后计算每个学校的团体成绩，并将学校代码、考生人数一并存入vector&lt;tuple&lt;string, int, int&gt;&gt;，然后根据排序要求给定cmp函数进行sort。最后依次输出相关信息。如果团体成绩与上一个学校一样，那么名次不变，否则=下标+1。\n\nΩ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;string, int, int&gt; tsii;\n\nint main()\n{\n    string id, school;\n    int n, s, r = 0, p = -1;\n    cin &gt;&gt; n;\n    map&lt;string, tuple&lt;int, int, int, int&gt;&gt; score;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s &gt;&gt; school;\n        transform(school.begin(), school.end(), school.begin(), ::tolower);\n        switch (id[0])\n        {\n            case 'B':\n                get&lt;0&gt;(score[school]) += s;\n                break;\n            case 'A':\n                get&lt;1&gt;(score[school]) += s;\n                break;\n            case 'T':\n                get&lt;2&gt;(score[school]) += s;\n                break;\n        }\n        ++get&lt;3&gt;(score[school]);\n    }\n    vector&lt;tsii&gt; tws;\n    for (auto &amp;t: score)\n        tws.emplace_back(t.first, get&lt;0&gt;(t.second) / 1.5 + get&lt;1&gt;(t.second) + get&lt;2&gt;(t.second) * 1.5, get&lt;3&gt;(t.second));\n    sort(tws.begin(), tws.end(), [](tsii &amp;a, tsii &amp;b) {return get&lt;1&gt;(a) == get&lt;1&gt;(b) ?\n          make_pair(get&lt;2&gt;(a), get&lt;0&gt;(a)) &lt; make_pair(get&lt;2&gt;(b), get&lt;0&gt;(b)) : get&lt;1&gt;(a) &gt; get&lt;1&gt;(b);});\n    printf(\"%zu\\n\", tws.size());\n    for (int i = 0; i &lt; tws.size(); ++i)\n    {\n        r = (get&lt;1&gt;(tws[i]) == p) ? r : (p = get&lt;1&gt;(tws[i]), i + 1);\n        printf(\"%d %s %d %d\\n\", r, get&lt;0&gt;(tws[i]).c_str(), get&lt;1&gt;(tws[i]), get&lt;2&gt;(tws[i]));\n    }\n}\n","slug":"『1141』PAT-Ranking-of-Institutions","date":"2022-11-26T07:20:45.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,sort,tuple","author_index":"Starlit Rover"},{"id":"7df29c755cdde6fc07511e582be256da","title":"「1140」Look-and-say Sequence","content":"Look-and-say sequence is a sequence of integers as the following:\nD, D1, D111, D113, D11231, D112213111, ...\n\nwhere D is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2nd number means that there is one D in the 1st number, and hence it is D1; the 2nd number consists of one D (corresponding to D1) and one 1 (corresponding to 11), therefore the 3rd number is D111; or since the 4th number is D113, it consists of one D, two 1’s, and one 3, so the next number must be D11231. This definition works for D = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digit D.\n\n\n\n\nInput Specification:Each input file contains one test case, which gives D (in [0, 9]) and a positive integer N (≤ 40), separated by a space.\nOutput Specification:Print in a line the Nth number in a look-and-say sequence of D.\nSample Input:1 8\n\nSample Output:1123123111\n\n\nΩ字符串迭代，每次迭代的规则，是将原字符串中的连续子串“xx…x”替换为“xn”，n表示最长连续子串中x的个数。那么只需遍历字符串，若当前字符与前一个字符不同，就把前一个字符与cnt加到结果字符串中，同时将计数器cnt归1，若相同则++cnt。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string ans, nxt;\n    int n, cnt = 1;\n    cin &gt;&gt; ans &gt;&gt; n;\n    for (int i = 1; i &lt; n; ++i, cnt = 1)\n    {\n        for (int j = 1; j &lt; ans.size(); ++j)\n        {\n            if (ans[j] != ans[j - 1])\n                nxt += string(1, ans[j - 1]) + to_string(cnt), cnt = 1;\n            else ++cnt;\n        }\n        nxt += string(1, ans.back()) + to_string(cnt);\n        ans = std::move(nxt), nxt = \"\";\n    }\n    cout &lt;&lt; ans;\n}\n","slug":"「1140」Look-and-say-Sequence","date":"2022-11-26T05:03:10.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"8e874153b53000d75be72bb73b703255","title":"「1139」First Contact","content":"Unlike in nowadays, the way that boys and girls expressing their feelings of love was quite subtle in the early years. When a boy A had a crush on a girl B, he would usually not contact her directly in the first place. Instead, he might ask another boy C, one of his close friends, to ask another girl D, who was a friend of both B and C, to send a message to B – quite a long shot, isn’t it? Girls would do analogously.\nHere given a network of friendship relations, you are supposed to help a boy or a girl to list all their friends who can possibly help them making the first contact.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (1 &lt; N ≤ 300) and M, being the total number of people and the number of friendship relations, respectively. Then M lines follow, each gives a pair of friends. Here a person is represented by a 4-digit ID. To tell their genders, we use a negative sign to represent girls.\nAfter the relations, a positive integer K (≤ 100) is given, which is the number of queries. Then K lines of queries follow, each gives a pair of lovers, separated by a space. It is assumed that the first one is having a crush on the second one.\nOutput Specification:For each query, first print in a line the number of different pairs of friends they can find to help them, then in each line print the IDs of a pair of friends.\nIf the lovers A and B are of opposite genders, you must first print the friend of A who is of the same gender of A, then the friend of B, who is of the same gender of B. If they are of the same gender, then both friends must be in the same gender as theirs. It is guaranteed that each person has only one gender.\nThe friends must be printed in non-decreasing order of the first IDs, and for the same first ones, in increasing order of the seconds ones.\nSample Input:10 18\n-2001 1001\n-2002 -2001\n1004 1001\n-2004 -2001\n-2003 1005\n1005 -2001\n1001 -2003\n1002 1001\n1002 -2004\n-2004 1001\n1003 -2002\n-2003 1003\n1004 -2002\n-2001 -2003\n1001 1003\n1003 -2001\n1002 -2001\n-2002 -2003\n5\n1001 -2001\n-2003 1001\n1005 -2001\n-2002 -2004\n1111 -2003\n\nSample Output:4\n1002 2004\n1003 2002\n1003 2003\n1004 2002\n4\n2001 1002\n2001 1003\n2002 1003\n2002 1004\n0\n1\n2003 2001\n0\n\n\nΩ又是单身狗无法理解的一道题目，我由衷地希望，大家能够直球地面对自己的心上人，真诚才是必杀技，谢谢。\n累了，简单的外表下，藏着一颗月球的心，不要问我在哪，有坑的地方就有我……. 什么叫做一步一个脚印，就是每当你提交前觉得要ac的时候，结果只多红了一个测试点，甚至毫无变化。\nA喜欢B，怂的1b，希望通过好基友C找到B的好闺蜜D去试探B（你这种人能脱单才怪哦）⚠️AC，BD必须同性别。想法非常简单，用set存储每个人的同性朋友，然后用一个map&lt;int,bool&gt; r 所有朋友对，来表示之间是否为朋友。那么我们就直接枚举A和B的所有同性朋友，然后用r来判断是否为朋友。由于set会自动按照编号升序排序，因此按依次遍历得到的结果顺序即为题意要求。\n思路就是这么简单，接下来是环形坑枚举阶段：\n\n四位编号输入可能存在“0000”和“-0000”，如果是用int读取就无法区分性别，因此需要用字符串读取后判断长度得出性别\n\nA和B可能本身就是同性朋友（为这道题的格局点赞），因此枚举A的同性朋友时需要跳过B\n\n同样的，枚举B的同性朋友时跳过A（很重要，有时候想到2也不见得会记得3）\n\nC和D不能是同一个人，但你只要有判断C和D是否是朋友就不需要关注这点\n\n如果是以int存储编号的，最后输出别忘记格式化%04d\n\n\n这还不是最开心的，最让人激动的是唯一的测试样例没有出现上面的任何一个坑: ) 可谓埋的一手好雷。外加这种题目不好自己构造测试样例，有时只能站在出题人的角度去找洞攻击自己代码。道高一尺，魔高一丈，只是未曾想过路途如此险恶。\n\n🐎#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    map&lt;int, set&lt;int&gt;&gt; f;\n    map&lt;int, bool&gt; r;\n    string sa, sb;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; sa &gt;&gt; sb;\n        a = stoi(sa), b = stoi(sb);\n        if (sa.size() == sb.size())\n            f[abs(a)].insert(abs(b)), f[abs(b)].insert(abs(a));\n        r[abs(a) * 10000 + abs(b)] = r[abs(b) * 10000 + abs(a)] = true;\n    }\n    scanf(\"%d\", &amp;m);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        vector&lt;int&gt; ans;\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        a = abs(a), b = abs(b);\n        for (auto &amp;u: f[a])\n        {\n            if (u == b) continue;\n            for (auto &amp;v: f[b])\n            {\n                if (v == a) continue;\n                if (r[u * 10000 + v])\n                    ans.push_back(u * 10000 + v);\n            }\n        }\n        printf(\"%zu\\n\", ans.size());\n        for (auto &amp;t: ans)\n            printf(\"%04d %04d\\n\", t / 10000, t % 10000);\n    }\n}\n","slug":"「1139」First-Contact","date":"2022-11-25T17:09:15.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph","author_index":"Starlit Rover"},{"id":"568e7e4ef7b87e91d83cab23742c4094","title":"「1138」Postorder Traversal","content":"Suppose that all the keys in a binary tree are distinct positive integers. Given the preorder and inorder traversal sequences, you are supposed to output the first number of the postorder traversal sequence of the corresponding binary tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the first number of the postorder traversal sequence of the corresponding binary tree.\nSample Input:7\n1 2 3 4 5 6 7\n2 3 1 5 4 7 6\n\nSample Output:3\n\n\nΩ给出前序、中序遍历，输出后序遍历第一个元素。根据后序遍历的定义，第一个元素是整棵树最左边那个没有子节点的节点。那么递归顺序就很显然了，如果存在左子树就递归左子树，没有就递归右子树，直到没有子树的节点为止。子树的划分就不多说了，详情看traversal order的tag。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre, in;\n\nint first_post(int ps, int pe, int is, int ie)\n{\n    if (ps == pe) return pre[ps];\n    int bias = find(in.begin() + is, in.begin() + ie, pre[ps]) - in.begin() - is;\n    if (bias &gt; 0) return first_post(ps + 1, ps + bias, is, is + bias - 1);\n    else return first_post(ps + bias + 1, pe, is + bias + 1, ie);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    pre.resize(n), in.resize(n);\n    for (auto &amp;k: pre) cin &gt;&gt; k;\n    for (auto &amp;k: in) cin &gt;&gt; k;\n    cout &lt;&lt; first_post(0, n - 1, 0, n - 1);\n}\n","slug":"「1138」Postorder-Traversal","date":"2022-11-25T14:28:08.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"b068c193355ec83faa12b088a84c2501","title":"『1137』Final Grading","content":"For a student taking the online course “Data Structures” on China University MOOC (http://www.icourse163.org/), to be qualified for a certificate, he/she must first obtain no less than 200 points from the online programming assignments, and then receive a final grade no less than 60 out of 100. The final grade is calculated by  if ​, or ​ will be taken as the final grade G. Here ​ and ​ are the student’s scores of the mid-term and the final exams, respectively.\nThe problem is that different exams have different grading sheets. Your job is to write a program to merge all the grading sheets into one.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives three positive integers: P , the number of students having done the online programming assignments; M, the number of students on the mid-term list; and N, the number of students on the final exam list. All the numbers are no more than 10,000.\nThen three blocks follow. The first block contains P online programming scores ​’s; the second one contains M mid-term scores ’s; and the last one contains N final exam scores ​’s. Each score occupies a line with the format: StudentID Score, where StudentID is a string of no more than 20 English letters and digits, and Score is a nonnegative integer (the maximum score of the online programming is 900, and that of the mid-term and final exams is 100).\nOutput Specification:For each case, print the list of students who are qualified for certificates. Each student occupies a line with the format:\nStudentID \n$$If some score does not exist, output “−1” instead. The output must be sorted in descending order of their final grades (G must be rounded up to an integer). If there is a tie, output in ascending order of their StudentID‘s. It is guaranteed that the StudentID‘s are all distinct, and there is at least one qullified student.\nSample Input:6 6 7\n01234 880\na1903 199\nydjh2 200\nwehu8 300\ndx86w 220\nmissing 400\nydhfu77 99\nwehu8 55\nydjh2 98\ndx86w 88\na1903 86\n01234 39\nydhfu77 88\na1903 66\n01234 58\nwehu8 84\nydjh2 82\nmissing 99\ndx86w 81\n\nSample Output:missing 400 -1 99 99\nydjh2 200 98 82 88\ndx86w 220 88 81 84\nwehu8 300 55 84 84\n\n\nΩ  分三块给出 上机、期中和期末 成绩名单，一个学生的最终成绩计算方式如下：\n\n期末成绩≥期中成绩：取期末成绩为总成绩\n\n期末成绩&lt;期中成绩：\n\n如果上机分数没有到200分（包括没参加），或者总成绩G没到60分，则认定该学生成绩无效\n\n\n那么最终需要输出所有成绩有效学生的各门分数+总成绩，按照总成绩降序排列，总成绩相同则按照ID升序排列。\n我们先用一个map&lt;string,tuple&lt;int,int,int&gt;&gt;建立ID到三门成绩的映射，第一轮读入上机分数，如果成绩没到200就不存入。接着读入期中和期末成绩，这里我们只将上机分数有效的同学成绩录入（就是map中能找到ID的）。然后按照上述规则计算这些同学的总成绩，将总成绩也有效（G≥60）的学生ID和G存入一个vector&lt;pair&lt;int,string&gt;&gt;，以便后续的sort。指定cmp函数后直接sort，然后按照顺序输出即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;int, string&gt; pis;\n\nint main()\n{\n    int p, m, n, s, f;\n    cin &gt;&gt; p &gt;&gt; m &gt;&gt; n;\n    string id;\n    map&lt;string, tuple&lt;int, int, int&gt;&gt; score;\n    vector&lt;pair&lt;int, string&gt;&gt; final;\n    for (int i = 0; i &lt; p; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s;\n        if (s &gt;= 200) score[id] = make_tuple(s, -1, -1);\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s;\n        auto it = score.end();\n        if ((it = score.find(id)) != score.end())\n            get&lt;1&gt;(it-&gt;second) = s;\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s;\n        auto it = score.end();\n        if ((it = score.find(id)) != score.end())\n            get&lt;2&gt;(it-&gt;second) = s;\n    }\n    for (auto &amp;t: score)\n    {\n        f = get&lt;1&gt;(t.second) &gt; get&lt;2&gt;(t.second) ? round(0.4 * get&lt;1&gt;(t.second) + 0.6 * get&lt;2&gt;(t.second))\n                                                : get&lt;2&gt;(t.second);\n        if (f &gt;= 60) final.emplace_back(f, t.first);\n    }\n    sort(final.begin(), final.end(),\n         [](pis &amp;a, pis &amp;b) { return a.first != b.first ? a.first &gt; b.first : a.second &lt; b.second; });\n    for (auto &amp;t: final)\n        printf(\"%s %d %d %d %d\\n\", t.second.c_str(), get&lt;0&gt;(score[t.second]), get&lt;1&gt;(score[t.second]),\n               get&lt;2&gt;(score[t.second]), t.first);\n}\n\n这里我对期中、期末成绩的初始化是-1，主要为了最后输出的方便，至于在计算总成绩的时候，如果期末成绩为-1（没参加考试）根本不可能让总成绩达到60；如果期中没考，那么就会选择期末成绩为总成绩，因此-1对总成绩计算没有影响。\n","slug":"『1137』Final-Grading","date":"2022-11-25T09:13:34.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"53c2472eec1fb780c12dac8c28c45b29","title":"『1136」A Delayed Palindrome","content":"Consider a positive integer N written in standard notation with k+1 digits ai​ as  with  for all  and . Then N is palindromic if and only if  for all . Zero is written 0 and is also palindromic by definition.\nNon-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. Such number is called a delayed palindrome. (Quoted from https://en.wikipedia.org/wiki/Palindromic_number )\nGiven any positive integer, you are supposed to find its paired palindromic number.\n\n\nInput Specification:Each input file contains one test case which gives a positive integer no more than 1000 digits.\nOutput Specification:For each test case, print line by line the process of finding the palindromic number. The format of each line is the following:\nA + B = C\n\nwhere A is the original number, B is the reversed A, and C is their sum. A starts being the input number, and this process ends until C becomes a palindromic number – in this case we print in the last line C is a palindromic number.; or if a palindromic number cannot be found in 10 iterations, print Not found in 10 iterations. instead.\nSample Input 1:97152\n\nSample Output 1:97152 + 25179 = 122331\n122331 + 133221 = 255552\n255552 is a palindromic number.\n\nSample Input 2:196\n\nSample Output 2:196 + 691 = 887\n887 + 788 = 1675\n1675 + 5761 = 7436\n7436 + 6347 = 13783\n13783 + 38731 = 52514\n52514 + 41525 = 94039\n94039 + 93049 = 187088\n187088 + 880781 = 1067869\n1067869 + 9687601 = 10755470\n10755470 + 07455701 = 18211171\nNot found in 10 iterations.\n\n\nΩ给定一个不超过1000位的数字，判断其是否为回文数，如果不是则将其与自身的逆序数相加，如果依旧不是回文数则重复迭代，迭代十次后依旧不是则输出“Not found in 10 iterations.”。\n又是reverse函数大显身手的时候了。1000位的数显然不能用int，而且需要自己实现大数的加法运算，老样子，设置个进位，每位单独运算，然后将结果和其逆序比较，如果相等说明是回文数终止迭代，否则继续。\n\n🐎#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s, t, r;\n    cin &gt;&gt; s, t = s;\n    reverse(t.begin(), t.end());\n    int c = 0, d, i;\n    // ATTENTION: c=0 !!!\n    for (i = 0; i &lt; 10 &amp;&amp; s != t; ++i, c = 0, r.clear())\n    {\n        for (int j = s.size() - 1; j &gt;= 0; --j)\n        {\n            d = s[j] + t[j] - 2 * '0' + c;\n            r.push_back(d % 10 + '0'), c = d / 10;\n        }\n        if (c) r.push_back('1');\n        reverse(r.begin(), r.end());\n        printf(\"%s + %s = %s\\n\", s.c_str(), t.c_str(), r.c_str());\n        s = t = r;\n        reverse(t.begin(), t.end());\n    }\n    if (i == 10) printf(\"Not found in 10 iterations.\\n\");\n    else printf(\"%s is a palindromic number.\\n\", s.c_str());\n}\n","slug":"『1136」A-Delayed-Palindrome","date":"2022-11-25T09:05:29.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,reverse,string","author_index":"Starlit Rover"},{"id":"23124d9c52676e982f8ad5a9c32feebd","title":"『1135』Is It A Red-Black Tree","content":"There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties:\n\n(1) Every node is either red or black.\n(2) The root is black.\n(3) Every leaf (NULL) is black.\n(4) If a node is red, then both its children are black.\n(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\n\nFor example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.\n\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\nFigure 3\n\n\nFor each given binary search tree, you are supposed to tell if it is a legal red-black tree.\n\n\nInput Specification:Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.\nOutput Specification:For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not.\nSample Input:3\n9\n7 -2 1 5 -4 -11 8 14 -15\n9\n11 -2 1 -7 5 -4 8 14 -15\n8\n10 -7 5 -6 8 15 -11 17\n\nSample Output:Yes\nNo\nNo\n\n\nΩ给出二叉搜索树的先序遍历，判断它是否为红黑树。红黑树是一种高效的二叉搜索树，查找效率可以达到，主要具有以下特征：\n\n根节点和所有叶子节点（这里将NULL看作叶节点，因此这个特征不具有什么约束）都是黑色\n\n如果一个节点是红色，那么它的两个子节点必须均为黑色\n\n每个节点到它所有子代叶子节点的路径上有相同个数的黑色节点\n\n\n由于是二叉搜素树，因此通过和根节点之间的比较，可以将先序遍历划分为【根节点｜左子树节点｜右子树节点】，然后递归划分找出所有父子关系。然后通过DFS递归验证2、3特征，2比较简单只要检查红节点的子节点即可；验证3的话就让dfs函数返回从当前节点到叶子节点路径中的黑节点个数，如果发现左右子节点返回个数不同或者其一返回-1，则说明不符合特征3直接返回-1。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nvector&lt;int&gt; pre;\n\nvoid build(int s, int e)\n{\n    int idx = upper_bound(pre.begin() + s, pre.begin() + e, abs(pre[s]),\n                          [](const int &amp;a, const int &amp;b) { return abs(a) &lt; abs(b); }) - pre.begin();\n    if (idx &gt; s + 1)\n    {\n        sons[pre[s]].first = pre[s + 1];\n        build(s + 1, idx);\n    }\n    if (idx &lt; e)\n    {\n        sons[pre[s]].second = pre[idx];\n        build(idx, e);\n    }\n}\n\nint check(int n)\n{\n    if (n == 0) return 0;\n    // feature 2\n    if (n &lt; 0 &amp;&amp; (sons[n].first &lt; 0 || sons[n].second &lt; 0))\n        return -1;\n    int l, r;\n    // feature 3\n    if ((l = check(sons[n].first)) &lt; 0) return -1;\n    else if ((r = check(sons[n].second)) &lt; 0) return -1;\n    else if (l != r) return -1;\n    else return l + (n &gt; 0);\n}\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        pre.resize(m);\n        for (int j = 0; j &lt; m; ++j)\n            cin &gt;&gt; pre[j];\n        if (pre[0] &lt; 0)\n        {\n            printf(\"No\\n\");\n            continue;\n        }\n        build(0, m);\n        printf(check(pre[0]) &gt; 0 ? \"Yes\\n\" : \"No\\n\");\n        sons.clear(), pre.clear();\n    }\n}\n\n这里用了upper_bound函数找到右子树的根节点位置，该函数返回第一个&gt;给定值的元素迭代器，它的兄弟函数lower_bound则返回第一个≥给定值的元素迭代器。\n","slug":"『1135』Is-It-A-Red-Black-Tree","date":"2022-11-25T06:06:31.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree,DFS,RBT","author_index":"Starlit Rover"},{"id":"1e867ab5e03f286a58fad122534ef050","title":"「1134」Vertex Cover","content":"A vertex cover of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. Now given a graph with several vertex sets, you are supposed to tell if each of them is a vertex cover or not.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than ), being the total numbers of vertices and the edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge.\nAfter the graph, a positive integer K (≤ 100) is given, which is the number of queries. Then K lines of queries follow, each in the format:\n\nwhere Nv​ is the number of vertices in the set, and ’s are the indices of the vertices.\nOutput Specification:For each query, print in a line Yes if the set is a vertex cover, or No if not.\nSample Input:10 11\n8 7\n6 8\n4 5\n8 4\n8 1\n1 2\n1 4\n9 8\n9 1\n1 0\n2 4\n5\n4 0 3 8 4\n6 6 1 7 5 4 9\n3 1 8 4\n2 2 8\n7 9 8 7 6 5 4 2\n\nSample Output:No\nYes\nYes\nNo\nNo\n\n\nΩ顶点覆盖是一个顶点的集合，其定义是，如果图中任何一条边至少一个端点位于顶点集内则称该顶点集为一个顶点覆盖。给定图和几个顶点集，判断它们是否为顶点覆盖。\n本质上是看顶点集中所有顶点关联边集的并集是否包含图中所有边。可以用一个vector&lt;bool&gt;进行标记，但这里我萌生了bitset的想法，用二进制位表示每个顶点关联的边集，然后对顶点集中所有顶点的边集二进制数取或运算，看最终二进制树中是否所有边位都为1，这也是求并集的一种方法。bitset是1位1bit，和bool不同的是可以直接进行位运算，不过bitset必须在编译期间就确定位数大小，因此不能用变量初始化位数。由于，因此直接开bitset&lt;10000&gt;，或运算结束后我们将其转换为字符串，取最后的m位检查是否全为1。\n\n🐎#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, v, k, t, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;bitset&lt;10000&gt;&gt; flag(n, 0);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        flag[a][i] = flag[b][i] = 1;\n    }\n    cin &gt;&gt; v;\n    for (int i = 0; i &lt; v; ++i)\n    {\n        cin &gt;&gt; k;\n        bitset&lt;10000&gt; otc(0);\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; t;\n            otc |= flag[t];\n        }\n        printf(otc.to_string().substr(10000 - m) == string(m, '1') ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n","slug":"「1134」Vertex-Cover","date":"2022-11-25T02:50:33.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,bitset","author_index":"Starlit Rover"},{"id":"25908c90d75c97f6d5f5af144716999a","title":"『1133」Splitting A Linked List","content":"Given a singly linked list, you are supposed to rearrange its elements so that all the negative values appear before all of the non-negatives, and all the values in [0, K] appear before all those greater than K. The order of the elements inside each class must not be changed. For example, given the list being 18→7→-4→0→5→-6→10→11→-2 and K being 10, you must output -4→-6→-2→7→0→5→10→18→11.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive  which is the total number of nodes, and a positive . The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\n\nwhere Address is the position of the node, Data is an integer in , and Next is the position of the next node. It is guaranteed that the list is not empty.\nOutput Specification:For each case, output in order (from beginning to the end of the list) the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 9 10\n23333 10 27777\n00000 0 99999\n00100 18 12309\n68237 -6 23333\n33218 -4 00000\n48652 -2 -1\n99999 5 68237\n27777 11 48652\n12309 7 33218\n\nSample Output:33218 -4 68237\n68237 -6 48652\n48652 -2 12309\n12309 7 00000\n00000 0 99999\n99999 5 23333\n23333 10 00100\n00100 18 27777\n27777 11 -1\n\n\nΩ链表题，给出一个链表，将所有节点按值分为三部分，同时每一部分内的节点顺序必须按照原先链表内的顺序。\n最直接的做法，就是用三个vector分别存储，最后按顺序输出，不过我想试试stable_sort，即稳定排序函数，保证值相等的元素按照原先顺序排列。用法与sort函数类似，⚠️不过在用lambda函数时注意传入参数类型需要const保证！\n注意题目给出的节点不一定全部用上，先根据头节点地址找出链表，然后根据节点的值在哪个区间范围内分别赋值-1，0，1，最后调用stable_sort即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef const pair&lt;string, int&gt; psi;\n\nint main()\n{\n    map&lt;string, pair&lt;int, string&gt;&gt; info;\n    string start, addr;\n    int n, k;\n    cin &gt;&gt; start &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; addr &gt;&gt; info[addr].first &gt;&gt; info[addr].second;\n    vector&lt;pair&lt;string, int&gt;&gt; node;\n    while (start != \"-1\")\n    {\n        node.emplace_back(start, info[start].first &gt; k ? 1 : info[start].first &lt; 0 ? -1 : 0);\n        start = info[start].second;\n    }\n    stable_sort(node.begin(), node.end(), [](psi &amp;a, psi &amp;b) { return a.second &lt; b.second; });\n    for (int i = 0; i &lt; node.size(); ++i)\n    {\n        if (i) printf(\" %s\\n\", node[i].first.c_str());\n        printf(\"%s %d\", node[i].first.c_str(), info[node[i].first].first);\n    }\n    printf(\" -1\\n\");\n}\n\n还发现一件比较神奇的事情：\n    cin &gt;&gt; addr &gt;&gt; info[addr].first &gt;&gt; info[addr].second;\n\n强迫症重度患者表示不用分两行写很赞👍🏼\n","slug":"『1133」Splitting-A-Linked-List","date":"2022-11-24T17:28:48.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,list","author_index":"Starlit Rover"},{"id":"358e1bd298e98daf2cbd6662a57fb65a","title":"『1132』Cut Integer","content":"Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167 × 334) = 3. Given an integer Z, you are supposed to test if it is such an integer.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20). Then N lines follow, each gives an integer . It is guaranteed that the number of digits of Z is an even number.\nOutput Specification:For each case, print a single line Yes if it is such a number, or No if not.\nSample Input:3\n167334\n2333\n12345678\n\nSample Output:Yes\nNo\nNo\n\n\nΩ给出一个具有偶数位数的整数P，将P拆成位数相同的前后两半A、B，如果P能够被A、B的乘积整除就输出Yes，反之输出No。\n用字符串存储P，再用substr计算出AB。⚠️A or B为0时直接输出No，取余会发生“Float Point Exception“。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    string k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        if (!stoi(k.substr(0, k.size() / 2)) || !stoi(k.substr(k.size() / 2)))\n            printf(\"No\\n\");\n        else\n            printf(stoi(k) % (stoi(k.substr(0, k.size() / 2)) * stoi(k.substr(k.size() / 2))) ? \"No\\n\" : \"Yes\\n\");\n    }\n}\n","slug":"『1132』Cut-Integer","date":"2022-11-24T16:28:21.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"841d996290522367bb59c54f717d9310","title":"「1131」Subway Map","content":"In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 100), the number of subway lines. Then N lines follow, with the i-th (i=1,⋯,N) line describes the i-th subway line in the format:\nM S[1] S[2] … S[M]\nwhere M (≤ 100) is the number of stops, and S[i]’s (i=1,⋯,M) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order – that is, the train travels between S[i] and S[i+1] (i=1,⋯,M−1) without any stop.\nNote: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called “transfer stations”), no station can be the conjunction of more than 5 lines.\nAfter the description of the subway, another positive integer K (≤ 10) is given. Then K lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively.\nThe following figure shows the sample map.\n\nNote: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.\nOutput Specification:For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:\nTake Line#X1 from S1 to S2.\nTake Line#X2 from S2 to S3.\n......\n\nwhere Xi’s are the line numbers and Si’s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.\nIf the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.\nSample Input:4\n7 1001 3212 1003 1204 1005 1306 7797\n9 9988 2333 1204 2006 2005 2004 2003 2302 2001\n13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011\n4 6666 8432 4011 1306\n3\n3011 3013\n6666 2001\n2004 3001\n\nSample Output:2\nTake Line#3 from 3011 to 3013.\n10\nTake Line#4 from 6666 to 1306.\nTake Line#3 from 1306 to 2302.\nTake Line#2 from 2302 to 2001.\n6\nTake Line#2 from 2004 to 1204.\nTake Line#1 from 1204 to 1306.\nTake Line#3 from 1306 to 3001.\n\n\nΩ勾八题目，死给你看哦。其实不是很难，但我一直陷在BFS，百思不得其解。\n给出地铁站图中所有线路的站台编号，要求你输出给定起点和终点站台的路线。如需换乘则还需输出换乘站台。优先输出过站最少的路线，如果有多条路线则输出换乘数最少的路线。\n一开始，我还尝试了Dijkstra，不禁超时而且只ac了两个测试点。于是乎，我改用BFS结果还是只ac了两个。如果PAT考试里遇到这题，我怕不是已经千疮百孔了。经过几百次抓狂之后，仔细分析了一波，我在BFS中用pre数组存储最优路线的前置节点，但事实上你不往后走是无法确定到某个节点的路线是最优的，因为你还不知道终点在哪个方向，所以你不知道在这个节点上是否需要换乘，不同路线到达这个站台的换乘次数就会不同。当然你可以找到所有起点到终点站台数最少的路线，然后再逐一计算换乘数，取最小者。\n最后发现所有的方法都会回到DFS，只有DFS能直接计算出到终点站共换乘了多少次。设置一个全局最优pair对opt，如果到终点的路线比opt优则记录路线并更新opt，同时用pos表示这条路原本在几号线上，如果接下去将要dfs的站台线号与当前路线线号不同则给trans+1。o对，注意到每个站台可能属于多个线路，而邻站之间的路线则属于唯一线路，因此用map&lt;pair&lt;int,int&gt;,int&gt;表示相邻站台之间的路线属于哪一线路。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\nmap&lt;pair&lt;int, int&gt;, int&gt; line;\nvector&lt;vector&lt;int&gt;&gt; edge(10000);\nvector&lt;bool&gt; flag(10000, false);\nvector&lt;int&gt; path, ans;\npair&lt;int, int&gt; opt{INT32_MAX, INT32_MAX};\n\nvoid dfs(int s, int e, int trans, int pos)\n{\n    static int depth = 0;\n    flag[s] = true, path.push_back(s);\n    if (s == e)\n    {\n        if (make_pair(depth, trans) &lt; opt)\n        {\n            opt = make_pair(depth, trans);\n            ans = path;\n        }\n    }\n    else\n    {\n        for (auto &amp;k: edge[s])\n        {\n            if (flag[k]) continue;\n            depth += 1;\n            dfs(k, e, trans + (pos != line[{k, s}] &amp;&amp; depth &gt; 1), line[{k, s}]);\n            depth -= 1;\n        }\n    }\n    flag[s] = false, path.pop_back();\n}\n\nint main()\n{\n    int n, m, k, a, b, p;\n    scanf(\"%d\", &amp;n);\n    edge.resize(10000);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d %d\", &amp;m, &amp;p);\n        for (int j = 1; j &lt; m; ++j)\n        {\n            scanf(\"%d\", &amp;k);\n            line[make_pair(k, p)] = line[make_pair(p, k)] = i + 1;\n            edge[k].push_back(p), edge[p].push_back(k);\n            p = k;\n        }\n    }\n    scanf(\"%d\", &amp;m);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        dfs(a, b, 0, 0);\n        printf(\"%d\\n\", opt.first);\n        int l = line[{ans[0], ans[1]}], p = a;\n        for (int j = 1; j &lt; ans.size(); ++j)\n        {\n            if (line[{ans[j - 1], ans[j]}] != l)\n            {\n                printf(\"Take Line#%d from %04d to %04d.\\n\", l, p, ans[j - 1]);\n                l = line[{ans[j - 1], ans[j]}], p = ans[j - 1];\n            }\n        }\n        printf(\"Take Line#%d from %04d to %04d.\\n\", l, p, ans.back());\n        path.clear(), ans.clear();\n        opt = {INT32_MAX, INT32_MAX};\n    }\n}\n","slug":"「1131」Subway-Map","date":"2022-11-24T14:20:00.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,DFS","author_index":"Starlit Rover"},{"id":"0def5409a91f0fbcec7f6cf9896df886","title":"『1130」Infix Expression","content":"Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (the i-th line corresponds to the i-th node) in the format:\ndata left_child right_child\n\nwhere data is a string of no more than 10 characters, left_child and right_child are the indices of this node’s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented by −1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\n\n\nOutput Specification:For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols.\nSample Input 1:8\n* 8 7\na -1 -1\n* 4 1\n+ 2 5\nb -1 -1\nd -1 -1\n- -1 6\nc -1 -1\n\nSample Output 1:(a+b)*(c*(-d))\n\nSample Input 2:8\n2.35 -1 -1\n* 6 1\n- -1 4\n% 7 8\n+ 2 3\na -1 -1\nstr -1 -1\n871 -1 -1\n\nSample Output 2:(a*2.35)+(-(str%871))\n\n\nΩ给出一棵表达式语法二叉树中每个节点的值以及左右子节点编号，输出最终的表达式，括号用于表达运算符的优先级，⚠️最终表达式的外面不要加括号。\n本质上就是二叉树的中序遍历，遍历同时运用字符串的加法，但问题在于何时加括号：很显然就是没有子节点的节点表达式不需要括号，因为节点本身是个叶子节点，表示一个单独的值。对于其他情况的节点表达式都需要加上【(】【)】。由于最终输出的结果不需要大括号，于是乎我们就取中间不含子串的部分。\n⚠️有一种情况需要单独考虑，那就是只有根节点的情况，基于上述规则我们不会给根节点表达式添加括号，那么最后直接输出得到的字符串即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; sons;\nvector&lt;string&gt; value;\n\nstring infix(int node)\n{\n    if (node == -1) return \"\";\n    else if (sons[node] == make_pair(-1,-1)) return value[node];\n    return \"(\" + infix(sons[node].first) + value[node] + infix(sons[node].second) + \")\";\n}\n\nint main()\n{\n    int n, root;\n    cin &gt;&gt; n;\n    root = n * (n + 1) / 2;\n    sons.resize(n + 1), value.resize(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        cin &gt;&gt; value[i] &gt;&gt; sons[i].first &gt;&gt; sons[i].second;\n        root -= (sons[i].first == -1 ? 0 : sons[i].first) + (sons[i].second == -1 ? 0 : sons[i].second);\n    }\n    string ans = infix(root);\n    if (n == 1) cout &lt;&lt; ans;\n    else cout &lt;&lt; ans.substr(1, ans.size() - 2);\n}\n","slug":"『1130」Infix-Expression","date":"2022-11-23T17:27:42.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"f1ff96299aac15c031753a8c21bad439","title":"『1129』Recommendation System","content":"Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user’s preference by the number of times that an item has been accessed by this user.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains two positive integers: N (≤ 50,000), the total number of queries, and K (≤ 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing – for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space.\nOutput Specification:For each case, process the queries one by one. Output the recommendations for each query in a line in the format:\nquery: rec[1] rec[2] ... rec[K]\n\nwhere query is the item that the user is accessing, and rec[i] (i=1, … K) is the i-th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order.\nNote: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query.\nSample Input:12 3\n3 5 7 5 5 3 2 1 8 3 8 12\n\nSample Output:5: 3\n7: 3 5\n5: 3 5 7\n5: 5 3 7\n3: 5 3 7\n2: 5 3 7\n1: 5 3 2\n8: 5 3 1\n3: 5 3 1\n8: 3 5 1\n12: 3 5 8\n\n\nΩ写一个推荐系统，假设访问对象的编号从1-N，给出用户按时间顺序访问的对象序列，以及每次最多推荐的对象个数，在每次用户访问对象前（除第一次）给出推荐序列，按照先前访问次数降序排列，如果访问次数一致，按照序号升序排列。\n这勾八题目我读了半天，谁来救救我的英蓝瓜哥。没有想太多，只知道每次都需要选出访问次数最高的个对象，每次排序估计时间开销太大。于是乎我打算用set和vector设计一个桶vector&lt;set&lt;int&gt;&gt; item(n+1)，那么item[i]就表示访问次数为的对象集合，set会自动按照序号升序排列。接着再用一个vector&lt;int&gt; cnt(n+1,0)存储每个物体的访问次数。那么每当一个对象的访问次数增加时，我们都需要将原先桶中（）的对象erase，在新桶中（）插入。然后再用一个most变量记录当前的最高访问次数，那么每次选择推荐对象时都从开始找个即可。\n⚠️如果访问过的对象不足个就不需要推荐这么多，有多少就推荐多少。\n听上去虽然有点麻烦，但实现起来还是很快的。然鹅一开始最后一个测试点一直SF，我一脸茫然，两眼懵逼。最后发现前面的访问对象可能都是同一个，那么预测对象只需要输出一个即可，而不能取决于访问次数！！！\n还有一种做法，感觉相对easy点，就是全部装在一个set中，然后给出set的compare函数，那么每次都直接从前个选择，感觉实操性更强一点。\no还无意中发现，multiset中如果erase函数的参数给的是特定值的话就会把所有特定值都删掉，如果想只删其中一个，就搭配find给出迭代器：multiset.erase(multiset.find(value))。估计内部实现就是set&lt;pair&lt;...,int&gt;&gt;。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, m, most = 1, j, p, distinct = 1;\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;\n    vector&lt;set&lt;int&gt;&gt; item(n + 1);\n    vector&lt;int&gt; cnt(n + 1, 0);\n    item[1].insert(m), cnt[m] = 1;\n    for (int i = 1; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        j = min(distinct, k), p = most;\n        printf(\"%d:\", m);\n        while (j &gt; 0)\n            for (auto &amp;t: item[p--])\n            {\n                printf(\" %d\", t);\n                if (--j &lt;= 0) break;\n            }\n        printf(\"\\n\");\n        if (++cnt[m] &gt; 1) item[cnt[m] - 1].erase(m);\n        else ++distinct;\n        item[cnt[m]].insert(m);\n        most = max(most, cnt[m]);\n    }\n}\n","slug":"『1129』Recommendation-System","date":"2022-11-23T16:22:12.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,set","author_index":"Starlit Rover"},{"id":"988044046878bff1b1dd82dbd324dde7","title":"「1128」N Queens Puzzle","content":"The “eight queens puzzle” is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more general N queens problem of placing N non-attacking queens on an N×N chessboard. (From Wikipedia - “Eight queens puzzle”.)\nHere you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequence , where ​ is the row number of the queen in the i-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queens’ solution.\n\n\n\n\n\n\n\n\n\nFigure 1\n\nFigure 2\n\n\n\n\nInput Specification:Each input file contains several test cases. The first line gives an integer . Then K lines follow, each gives a configuration in the format “​”, where 4≤N≤1000 and it is guaranteed that  for all . The numbers are separated by spaces.\nOutput Specification:For each configuration, if it is a solution to the N queens problem, print YES in a line; or NO if not.\nSample Input:4\n8 4 6 8 2 7 1 3 5\n9 4 6 7 2 8 1 9 5 3\n6 1 5 2 6 4 3\n5 1 3 5 2 4\n\nSample Output:YES\nNO\nNO\nYES\n\n\nΩ给出几个棋盘布局，判断是否满足“八皇后问题”的要求，即行列以及对角线上最多只能有一个皇后。棋盘布局的表示方法是给出每一列皇后所在的（自下而上）行数。\n题目保证了棋盘上的每一列均有一个皇后，因此我们只要检查行与对角线之间是否满足。行检查比较显然，只要所有皇后的行数不同；而对于对角线的条件，则需要满足，其中是列数，表示列皇后所在的行数。每一列的皇后只需和前面几列的皇后比较即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        vector&lt;int&gt; seq(m);\n        bool ans = true;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; seq[j];\n            if (!ans) continue;\n            for (int k = 0; k &lt; j; ++k)\n                ans = ans &amp;&amp; (j - k != abs(seq[j] - seq[k])) &amp;&amp; seq[j] != seq[k];\n        }\n        printf(ans ? \"YES\\n\" : \"NO\\n\");\n    }\n}\n","slug":"「1128」N-Queens-Puzzle","date":"2022-11-23T09:22:37.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"dec46595a39d6d567d60096de34e1f5b","title":"『1127』ZigZagging on a Tree","content":"Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” – that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer , the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:8\n12 11 20 17 1 15 8 5\n12 20 17 11 15 8 5 1\n\nSample Output:1 11 5 8 17 12 20 15\n\n\nΩ给出一棵二叉树的中序遍历和后续遍历，输出其ZigZag遍历结果。花样真多啊，就是S形的层次遍历，先从左到右，再从右到左。\n树的根节点都在后续遍历中的最后一位，然后再通过中序遍历中根节点的位置得知左右子树的节点，在后续遍历中划分完递归划分子树，记录每个节点的左右子节点。最后设置一个flag布尔变量表示顺序，每次都即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nvector&lt;int&gt; post, in;\n\nvoid build(int is, int ie, int ps, int pe)\n{\n    int bias = (find(in.begin(), in.end(), post[pe]) - in.begin()) - is;\n    if (bias &gt; 0)\n    {\n        sons[post[pe]].first = post[ps + bias - 1];\n        build(is, is + bias - 1, ps, ps + bias - 1);\n    }\n    if (bias + is &lt; ie)\n    {\n        sons[post[pe]].second = post[pe - 1];\n        build(is + bias + 1, ie, ps + bias, pe - 1);\n    }\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    post.resize(n), in.resize(n);\n    for (auto &amp;k: in) cin &gt;&gt; k;\n    for (auto &amp;k: post) cin &gt;&gt; k;\n    build(0, n - 1, 0, n - 1);\n    vector&lt;int&gt; crt{post.back()}, nxt;\n    bool flag = false, space = false;\n    while (!crt.empty())\n    {\n        for (auto &amp;k: crt)\n        {\n            if (sons[k].first) nxt.push_back(sons[k].first);\n            if (sons[k].second) nxt.push_back(sons[k].second);\n        }\n        if (flag)\n            for (auto &amp;k: crt) \n                printf(\"%s%d\", space ? \" \" : (space = true, \"\"), k);\n        else\n            for (auto it = crt.rbegin(); it != crt.rend(); ++it)\n                printf(\"%s%d\", space ? \" \" : (space = true, \"\"), *it);\n        crt = std::move(nxt), nxt = vector&lt;int&gt;(), flag = !flag;\n    }\n}\n","slug":"『1127』ZigZagging-on-a-Tree","date":"2022-11-23T08:27:59.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"9c2a27d777225ad7770aaf3f1ce46c04","title":"「1126」Eulerian Path","content":"In graph theory, an Eulerian path is a path in a graph which visits every edge exactly once. Similarly, an Eulerian circuit is an Eulerian path which starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the famous Seven Bridges of Konigsberg problem in 1736. It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are called Eulerian. If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other. A graph that has an Eulerian path but not an Eulerian circuit is called semi-Eulerian. (Cited from https://en.wikipedia.org/wiki/Eulerian_path)\nGiven an undirected graph, you are supposed to tell if it is Eulerian, semi-Eulerian, or non-Eulerian.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 2 numbers N (≤ 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by giving the two ends of the edge (the vertices are numbered from 1 to N).\nOutput Specification:For each test case, first print in a line the degrees of the vertices in ascending order of their indices. Then in the next line print your conclusion about the graph – either Eulerian, Semi-Eulerian, or Non-Eulerian. Note that all the numbers in the first line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.\nSample Input 1:7 12\n5 7\n1 2\n1 3\n2 3\n2 4\n3 4\n5 2\n7 6\n6 3\n4 5\n6 4\n5 6\n\nSample Output 1:2 4 4 4 4 4 2\nEulerian\n\nSample Input 2:6 10\n1 2\n1 3\n2 3\n2 4\n3 4\n5 2\n6 3\n4 5\n6 4\n5 6\n\nSample Output 2:2 4 4 4 3 3\nSemi-Eulerian\n\nSample Input 3:5 8\n1 2\n2 5\n5 4\n4 1\n1 3\n3 2\n3 4\n5 3\n\nSample Output 3:3 3 4 3 3\nNon-Eulerian\n\n\nΩ判断图为欧拉图（所有节点的度为偶数）、半欧拉图（除了两个节点度为奇数，其余点度均为偶数） or 非欧拉图。题目都把判断方式写出来了，剩下的就考察英语阅读理解了。\n当然这一切成立还存在一个前提条件，也是测试点3暗藏的大坑——这个图必须是连通图。这个点其实不难想到，因为计算机中将0也视为偶数，那么如果一条边也没有，所有点度都为偶数，按照上述理论应为欧拉图（礼貌的微笑.jpg）。所以判断前别忘了来个【DFS/BFS/并查集】检查一下连通性。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; edge;\nvector&lt;bool&gt; flag;\n\nint dfs(int n)\n{\n    flag[n] = true;\n    int sum = 0;\n    for (auto &amp;k: edge[n])\n    {\n        if (flag[k]) continue;\n        sum += dfs(k);\n    }\n    return sum + 1;\n}\n\nint main()\n{\n    int n, m, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    edge.resize(n + 1), flag.resize(n + 1, false);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a].push_back(b), edge[b].push_back(a);\n    }\n    int odd = edge[1].size() % 2, even = 1 - edge[1].size() % 2;\n    cout &lt;&lt; edge[1].size();\n    for (int i = 2; i &lt;= n; ++i)\n    {\n        cout &lt;&lt; \" \" &lt;&lt; edge[i].size();\n        edge[i].size() % 2 ? ++odd : ++even;\n    }\n    cout &lt;&lt; endl;\n    if (dfs(1) &lt; n) printf(\"Non-Eulerian\");\n    else printf(even == n ? \"Eulerian\" : (odd == 2 ? \"Semi-Eulerian\" : \"Non-Eulerian\"));\n}\n","slug":"「1126」Eulerian-Path","date":"2022-11-23T07:17:49.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,DFS","author_index":"Starlit Rover"},{"id":"e21aa88525fef8dbccd8e7f69148bf51","title":"「1125」Chain the Ropes","content":"Given some segments of rope, you are supposed to chain them into one rope. Each time you may only fold two segments into loops and chain them into one piece, as shown by the figure. The resulting chain will be treated as another segment of rope and can be folded again. After each chaining, the lengths of the original two segments will be halved.\n\nYour job is to make the longest possible rope out of N given segments.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer . Then N positive integer lengths of the segments are given in the next line, separated by spaces. All the integers are no more than .\nOutput Specification:For each case, print in a line the length of the longest possible rope that can be made by the given segments. The result must be rounded to the nearest integer that is no greater than the maximum length.\nSample Input:8\n10 15 12 3 4 13 1 15\n\nSample Output:14\n\n\nΩ给出几段绳子的长度，当我们把两段绳子打结后就会成为一段新的绳子，且长度为两者之和的一半，输出这些绳子最后打成一段的最大长度。\n乍看一脸茫然，仔细想想就会发现每次打结后绳子的长度就会损失一半，而且长绳子的一半与短绳子的一半显然不同。基于损失最小原则，我们应该尽力让长绳子折半次数最少，短绳子折半次数尽可能多。于是我们就可以对绳子长度进行一个排序，每次都取最短的两段绳子打结，由于打结后的绳子长度必然介于原绳长度的两者之间，因此接下来只要拿打结的绳子和剩余最短的绳子继续打结即可。这本质上是一种贪心策略。\n\n🐎#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    int a[n];\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; a[i];\n    sort(a, a + n);\n    int ans = a[0];\n    for (int i = 1; i &lt; n; ++i)\n        ans = (ans + a[i]) / 2;\n    cout &lt;&lt; ans;\n}\n","slug":"「1125」Chain-the-Ropes","date":"2022-11-22T16:47:47.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,贪心","author_index":"Starlit Rover"},{"id":"0e44f9fb7cc06322096d65164057b9ec","title":"「1124」Raffle for Weibo Followers","content":"John got a full mark on PAT. He was so happy that he decided to hold a raffle（抽奖） for his followers on Weibo – that is, he would select winners from every N followers who forwarded his post, and give away gifts. Now you are supposed to help him generate the list of winners.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives three positive integers M (≤ 1000), N and S, being the total number of forwards, the skip number of winners, and the index of the first winner (the indices start from 1). Then M lines follow, each gives the nickname (a nonempty string of no more than 20 characters, with no white space or return) of a follower who has forwarded John’s post.\nNote: it is possible that someone would forward more than once, but no one can win more than once. Hence if the current candidate of a winner has won before, we must skip him/her and consider the next one.\nOutput Specification:For each case, print the list of winners in the same order as in the input, each nickname occupies a line. If there is no winner yet, print Keep going... instead.\nSample Input 1:9 3 2\nImgonnawin!\nPickMe\nPickMeMeMeee\nLookHere\nImgonnawin!\nTryAgainAgain\nTryAgainAgain\nImgonnawin!\nTryAgainAgain\n\nSample Output 1:PickMe\nImgonnawin!\nTryAgainAgain\n\nSample Input 2:2 3 5\nImgonnawin!\nPickMe\n\nSample Output 2:Keep going...\n\n\nΩ从转发者中确定获奖名单。给定转发名单，起始序号，以及确定一个获奖者之后的跳过人数。由于转发不限次数，但只能获一次奖，因此遇到已经获奖的人就查看下一个。抽奖系统要真这么写，我就转他个千百来次…..\n先用一个vector存储转发名单，然后从起始序号开始，找到第一个非获奖者，加入获奖者set集，将该获奖者序号+N重复上述步骤。\n没有获奖者（m&lt;s）时就“Keep going…”\n\n🐎#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, s;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;\n    vector&lt;string&gt; nick(m);\n    for (auto &amp;t: nick)\n        cin &gt;&gt; t;\n    set&lt;string&gt; winner;\n    for (int i = s - 1; i &lt; m; i += n)\n    {\n        while (i &lt; m &amp;&amp; winner.find(nick[i]) != winner.end()) ++i;\n        if (i != m)\n        {\n            winner.insert(nick[i]);\n            cout &lt;&lt; nick[i] &lt;&lt; endl;\n        }\n    }\n    if (m &lt; s) cout &lt;&lt; \"Keep going...\";\n}\n","slug":"「1124」Raffle-for-Weibo-Followers","date":"2022-11-22T16:27:16.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"84f574e4cfc0fc23647f1cff6dfd2d15","title":"「1123」Is It a Complete AVL Tree","content":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.\n\n\n\n\n\n\n\n\n\n\n\n\nNow given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print YES if the tree is complete, or NO if not.\nSample Input 1:5\n88 70 61 63 65\n\nSample Output 1:70 63 88 61 65\nYES\n\nSample Input 2:8\n88 70 61 96 120 90 65 68\n\nSample Output 2:88 65 96 61 70 90 120 68\nNO\n\n\nΩ又见AVL！第二次看它比第一次亲切多了，但还是花了不少时间，而且是看着之前的博客码的。关于AVL旋转的详细介绍请见「1066」Root of AVL Tree。\n这次需要我们输出AVL的层次遍历，同时判断是否为完全二叉树（编号与满二叉树相同）。As before，用pair对存储左右子节点，同时存储每个节点作为根节点的子树高度，都通过map进行索引。\n对每一个新节点的插入，先通过递归找到插入位置，然后在递归回退的过程中找到第一个左右子树高度差&gt;1的节点，进行AVL旋转调整同时更新相应的高度。最后BFS出层次遍历，顺便记录每个节点编号（=父节点编号*2【左子节点】/父节点编号*2+1【右子节点】），看最后一个节点编号是否=N，不等于说明不是完全二叉树。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\n#define diff(root) (depth[sons[root].first]-depth[sons[root].second])\n#define depth(root) (max(depth[sons[root].first],depth[sons[root].second])+1)\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nmap&lt;int, int&gt; depth;\n\nvoid insert(int &amp;root, int num)\n{\n    if (root == 0)\n    {\n        root = num, depth[num] = 1;\n        return;\n    }\n    if (root &gt; num) insert(sons[root].first, num);\n    else insert(sons[root].second, num);\n    depth[root] = depth(root);\n    if (abs(diff(root)) &lt; 2) return;\n    bool isLeft = diff(root) &gt; 0;\n    int &amp;so = isLeft ? sons[root].first : sons[root].second,\n        &amp;si = isLeft ? sons[root].second : sons[root].first,\n        &amp;sso = isLeft ? sons[so].first : sons[so].second,\n        &amp;ssi = isLeft ? sons[so].second : sons[so].first,\n        tmp = so;\n    // 判断插入节点是否位于子树的同侧\n    if ((diff(root) ^ diff(so)) &gt; 0)\n    {\n        so = ssi, ssi = root, root = tmp;\n        depth[ssi] = depth(ssi);\n        depth[root] = depth(root);\n    }\n    else\n    {\n        int &amp;ssso = isLeft ? sons[ssi].first : sons[ssi].second,\n            &amp;sssi = isLeft ? sons[ssi].second : sons[ssi].first,\n            t1 = ssso, t2 = sssi;\n        ssso = so, sssi = root, so = t2, root = ssi, ssi = t1;\n        // 注意高度更新顺序自下往上\n        depth[ssso] = depth(ssso);\n        depth[sssi] = depth(sssi);\n        depth[root] = depth(root);\n    }\n}\n\nint main()\n{\n    int n, m, r;\n    cin &gt;&gt; n &gt;&gt; r;\n    for (int i = 1; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        insert(r, m);\n    }\n    bool flag = false;\n    vector&lt;pair&lt;int, int&gt;&gt; crt{{r, 1}}, nxt;\n    int end = -1;\n    while (!crt.empty())\n    {\n        for (auto &amp;k: crt)\n        {\n            printf(\"%s%d\", flag ? \" \" : (flag = true, \"\"), k.first);\n            if (sons[k.first].first)\n                nxt.emplace_back(sons[k.first].first, 2 * k.second);\n            if (sons[k.first].second)\n                nxt.emplace_back(sons[k.first].second, 2 * k.second + 1);\n            end = k.second;\n        }\n        crt = std::move(nxt);\n        nxt = vector&lt;pair&lt;int, int&gt;&gt;();\n    }\n    printf(end == n ? \"\\nYES\" : \"\\nNO\");\n}\n\n","slug":"「1123」Is-It-a-Complete-AVL-Tree","date":"2022-11-22T15:46:11.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,BFS,Tree,AVL","author_index":"Starlit Rover"},{"id":"033ed2c7a1bcdb67e313290ff8557d56","title":"「1122」Hamiltonian Cycle","content":"The “Hamilton cycle problem” is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a “Hamiltonian cycle”.\nIn this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers , the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format Vertex1 Vertex2, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format:\n\nwhere n is the number of vertices in the list, and ​’s are the vertices on a path.\nOutput Specification:For each query, print in a line YES if the path does form a Hamiltonian cycle, or NO if not.\nSample Input:6 10\n6 2\n3 4\n1 5\n2 5\n3 1\n4 1\n1 6\n6 3\n1 2\n4 5\n6\n7 5 1 4 3 6 2 5\n6 5 1 4 3 6 2\n9 6 2 1 6 3 4 5 2 6\n4 1 2 5 1\n7 6 1 3 4 5 2 6\n7 6 1 2 5 4 3 1\n\nSample Output:YES\nNO\nNO\nNO\nYES\nNO\n\n\nΩ给出一个无向图，再给出几个顶点序列，判断是否构成哈密尔顿回路。\n哈密尔顿回路指，每个顶点都出现且仅出现一次，那么这个顶点序列需要满足：\n\n起点和终点相同\n\n除了终点，其他节点必须互不相同\n\n顶点总数应为N+1（结合2⇒每个顶点出现且仅出现一次）\n\n任意相邻节点之间必须存在边\n\n\n根据以上判据设置一个bool向量，如果有重复出现的顶点就将flag置false，如果尚未出现就将其标记为true，同时++cnt。最后根据 flag&amp;&amp;起点==终点&amp;&amp;cnt==n 来断定是否为哈密尔顿回路。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, s, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;bool&gt;&gt; edge(n + 1, vector&lt;bool&gt;(n + 1, false));\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a][b] = edge[b][a] = true;\n    }\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        bool flag = true;\n        int cnt = 0, pre;\n        vector&lt;bool&gt; show(n + 1, false);\n        cin &gt;&gt; a &gt;&gt; s, pre = s;\n        for (int j = 1; j &lt; a; ++j)\n        {\n            cin &gt;&gt; k;\n            if (show[k] || !edge[pre][k]) flag = false;\n            else show[k] = true, ++cnt;\n            pre = k;\n        }\n        if (flag &amp;&amp; s == k &amp;&amp; cnt == n) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n}\n","slug":"「1122」Hamiltonian-Cycle","date":"2022-11-22T07:14:15.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph","author_index":"Starlit Rover"},{"id":"682e37dc1f7927fd1308b08627948fb9","title":"「1121」Damn Single","content":"“Damn Single (单身狗)” is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of ID’s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (≤ 10,000) followed by M ID’s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (重婚) or dangling with more than one companion.\nOutput Specification:First print in a line the total number of lonely guests. Then in the next line, print their ID’s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line.\nSample Input:3\n11111 22222\n33333 44444\n55555 66666\n7\n55555 44444 10000 88888 22222 11111 23333\n\nSample Output:5\n10000 23333 44444 55555 88888\n\n\nΩDamn Single!\n根据给出的couple信息，列举出所有参加party的单身人士，包括没有和伴侣一起来的，以便给他们提供特殊关照：)\n像这种编号不太大的题目，直接开满数组，用桶的思想去解决。首先用一个数组存储所有的couple信息，如果没有则为-1；然后用一个布尔向量标记需要特殊关照的对象，如果发现伴侣已在care对象中，则将其伴侣置false。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;int&gt; mate(int(1e5), -1);\n    vector&lt;bool&gt; care(int(1e5), false);\n    int n, u, v, cnt = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; u &gt;&gt; v;\n        mate[u] = v;\n        mate[v] = u;\n    }\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; u;\n        if (mate[u] == -1 || !care[mate[u]])\n            care[u] = true, ++cnt;\n        else care[mate[u]] = false, --cnt;\n    }\n    printf(\"%d\\n\", cnt);\n    bool flag = false;\n    for (int i = 0; i &lt; int(1e5); ++i)\n        if (care[i])\n        {\n            if (flag) printf(\" \");\n            else flag = true;\n            printf(\"%05d\", i);\n        }\n}\n","slug":"「1121」Damn-Single","date":"2022-11-22T05:57:31.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"8e095d3dd038417b28cb9cd069dbad37","title":"『1120』Friend Numbers","content":"Two integers are called “friend numbers” if they share the same sum of their digits, and the sum is their “friend ID”. For example, 123 and 51 are friend numbers since 1+2+3 = 5+1 = 6, and 6 is their friend ID. Given some numbers, you are supposed to count the number of different friend ID’s among them.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N. Then N positive integers are given in the next line, separated by spaces. All the numbers are less than .\nOutput Specification:For each case, print in the first line the number of different friend ID’s among the given integers. Then in the second line, output the friend ID’s in increasing order. The numbers must be separated by exactly one space and there must be no extra space at the end of the line.\nSample Input:8\n123 899 51 998 27 33 36 12\n\nSample Output:4\n3 6 9 26\n\n\nΩ夜深人静之时，配合一道水题放松心情是何等的享受～🕑打卡\n一个数所有位上的数字之和即为其friend id，给出一组数，按照升序输出所有的friend ids。搞一个set，逐一插入再逐一输出即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    set&lt;int&gt; id;\n    int n;\n    cin &gt;&gt; n;\n    string s;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; s;\n        int sum = 0;\n        for (auto &amp;c: s)\n            sum += c - '0';\n        id.insert(sum);\n    }\n    cout &lt;&lt; id.size() &lt;&lt; endl &lt;&lt; *id.begin();\n    for (auto it = ++id.begin(); it != id.end(); ++it)\n        cout &lt;&lt; \" \" &lt;&lt; *it;\n}\n","slug":"『1120』Friend-Numbers","date":"2022-11-21T17:53:46.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,set","author_index":"Starlit Rover"},{"id":"b5bfa4c818f558091af57c67af0a1746","title":"「1119」Pre- and Post-order Traversals","content":"Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.\nNow given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤ 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, first printf in a line Yes if the tree is unique, or No if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input 1:7\n1 2 3 4 6 7 5\n2 6 7 4 5 3 1\n\nSample Output 1:Yes\n2 1 6 4 7 3 5\n\nSample Input 2:4\n1 2 3 4\n2 4 3 1\n\nSample Output 2:No\n2 1 3 4\n\n\nΩ给出一棵二叉树的前序和后续遍历，且每个节点编号唯一，请判断这棵二叉树是否唯一，随后输出这棵二叉树的中序遍历。如果不唯一则输出任意一种情况。\n为什么单靠前序和后续遍历结果不能确定唯一二叉树呢？对于树的遍历问题，我曾经说过最重要的莫过于对左右子树区间的划分。前序遍历可以得知P后面的节点可能是P的子节点，后续遍历告诉我们P前面的节点可能是P的子节点，两者的交集即为P的所有子节点。在得到所有子节点的遍历序列后，我们需要划分左右子树，而不确定性的问题就在这，如果这个节点只有一边的子树，那么你就无法确定它是左子树还是右子树：ABC，BCA，但你无法得知AD，DA中的D到底是B还是C。\n由于最终的中序遍历可以输出任意情况，于是我们都假设一个节点如果存在子节点那么必有左子树。从而在我们获得子节点区间后，我们可以肯定第一个子节点必然是左子树的根节点，然后在后续遍历结果中找到该节点的位置，两者一夹就是左子树的根节点区间，同时其余部分就是右子树。由此递归下去，在分析树结构的同时，直接将生成中序遍历。\n遍历过程中只要有一棵子树的开始索引&gt;末端索引就说明其父节点只有左子树（开始索引=末端索引 表明无子节点），从而可以得出不唯一的结论。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre, post, in;\n\nbool inOrder(int pre_b, int pre_e, int post_b, int post_e)\n{\n    if (pre_b == pre_e)\n    {\n        in.push_back(pre[pre_b]);\n        return true;\n    }\n    else if (pre_b &gt; pre_e) return false;\n    int bias = (find(post.begin(), post.end(), pre[pre_b + 1]) - post.begin()) - post_b;\n    bool left = inOrder(pre_b + 1, pre_b + 1 + bias, post_b, post_b + bias);\n    in.push_back(pre[pre_b]);\n    bool right = inOrder(pre_b + bias + 2, pre_e, post_b + bias + 1, post_e - 1);\n    return left &amp;&amp; right;\n}\n\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    pre.resize(n), post.resize(n);\n    for (auto &amp;k: pre)\n        cin &gt;&gt; k;\n    for (auto &amp;k: post)\n        cin &gt;&gt; k;\n    if (inOrder(0, n - 1, 0, n - 1))\n        cout &lt;&lt; \"Yes\\n\";\n    else cout &lt;&lt; \"No\\n\";\n    printf(\"%d\", in[0]);\n    for (int i = 1; i &lt; in.size(); ++i)\n        printf(\" %d\", in[i]);\n    printf(\"\\n\");\n}\n","slug":"「1119」Pre-and-Post-order-Traversals","date":"2022-11-21T17:20:53.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"d6253ae8573741ec535150562a0d9517","title":"『1118』Birds in Forest","content":"Some scientists took pictures of thousands of birds in a forest. Assume that all the birds appear in the same picture belong to the same tree. You are supposed to help the scientists to count the maximum number of trees in the forest, and for any pair of birds, tell if they are on the same tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive number  which is the number of pictures. Then N lines follow, each describes a picture in the format:\n\n\nwhere K is the number of birds in this picture, and Bi​’s are the indices of birds. It is guaranteed that the birds in all the pictures are numbered continuously from 1 to some number that is no more than .\nAfter the pictures there is a positive number  which is the number of queries. Then Q lines follow, each contains the indices of two birds.\nOutput Specification:For each test case, first output in a line the maximum possible number of trees and the number of birds. Then for each query, print in a line Yes if the two birds belong to the same tree, or No if not.\nSample Input:4\n3 10 1 2\n2 3 4\n4 1 5 7 8\n3 9 6 4\n2\n10 5\n3 7\n\nSample Output:2 10\nYes\nNo\n\n\nΩ给出N张图以及每张图中鸟的编号，每张图中只有一棵树，输出这些照片中可能有几棵树，有几只鸟，同时判断给出的几对鸟是否在同一棵树上。\n本质上就是求连通分图数，由于不知道鸟的个数，直接开一个的数组，标记出现过的鸟编号，每次都将同一张照片中的鸟所在组织的头头指向第一只鸟的头头，最后看总共有几个头头即可。\nisRoot变量标记已经找到的头头鸟，避免重复计数。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nint main()\n\n{\n    int n, m, k, r, t = 0, b;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; belong(1e4 + 1);\n    vector&lt;bool&gt; flag(1e4 + 1, false), isRoot(1e4 + 1, false);\n    iota(belong.begin(), belong.end(), 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m &gt;&gt; r, flag[r] = true;\n        while (belong[r] != r) r = belong[r];\n        for (int j = 1; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k, flag[k] = true;\n            while (k != belong[k]) k = belong[k];\n            belong[k] = r;\n        }\n    }\n    for (int i = 0; i &lt; 1e4 + 1; ++i)\n    {\n        if (!flag[i]) continue;\n        k = belong[i], b = i;\n        while (k != belong[k]) k = belong[k];\n        if (!isRoot[k])\n            isRoot[k] = true, ++t;\n        belong[i] = k;\n    }\n    printf(\"%d %d\\n\", t, b);\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m &gt;&gt; k;\n        printf(belong[m] == belong[k] ? \"Yes\\n\" : \"No\\n\");\n    }\n    system(\"pause\");\n}\n","slug":"『1118』Birds-in-Forest","date":"2022-11-21T08:30:10.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,并查集","author_index":"Starlit Rover"},{"id":"10c9109a3fadc3f6ba7135ecb14ceb9c","title":"「1117」Eddington Number","content":"British astronomer Eddington liked to ride a bike. It is said that in order to show off his skill, he has even defined an “Eddington number”, E – that is, the maximum integer E such that it is for E days that one rides more than E miles. Eddington’s own E was 87.\nNow given everyday’s distances that one rides for N days, you are supposed to find the corresponding E (≤N).\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer , the days of continuous riding. Then N non-negative integers are given in the next line, being the riding distances of everyday.\nOutput Specification:For each case, print in a line the Eddington number for these N days.\nSample Input:10\n6 7 6 9 3 10 8 2 7 8\n\nSample Output:6\n\n\nΩ摘要：the maximum integer E such that it is for E days that one rides more than E miles. \n给出每天的骑车里程，我们需要找到最大的E使得有E天（不必连续）的里程超过E。\n这里有两个大小关系容易混淆：（里程&gt;E的天数）≥ E。\n由此我们可以得到状态转移方程：\n\n其中代表里程&gt;的天数，代表里程数为的天数。从而我们只要先统计出里程&gt;N的天数和即可，然后从N～0找到第一个的天数就是答案。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n;\n    map&lt;int, int&gt; cnt;\n    vector&lt;int&gt; edt(n + 1, 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        cnt[m] += 1;\n        edt[n] += m &gt; n;\n    }\n    for (k = n; k &gt; 0 &amp;&amp; edt[k] &lt; k; --k)\n        edt[k - 1] = edt[k] + cnt[k];\n    cout &lt;&lt; k;\n}\n","slug":"「1117」Eddington-Number","date":"2022-11-21T03:24:30.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"动态规划,C＋＋","author_index":"Starlit Rover"},{"id":"1b3a87c044266e0bb63bda9873a9376f","title":"「1116」Come on! Let's C","content":"“Let’s C” is a popular and fun programming contest hosted by the College of Computer Science and Technology, Zhejiang University. Since the idea of the contest is for fun, the award rules are funny as the following:\n\n\nThe Champion will receive a “Mystery Award” (such as a BIG collection of students’ research papers…).\n\n\n\nThose who ranked as a prime number will receive the best award – the Minions (小黄人)!\n\n\n\nEveryone else will receive chocolates.\n\n\n\nGiven the final ranklist and a sequence of contestant ID’s, you are supposed to tell the corresponding awards.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer , the total number of contestants. Then N lines of the ranklist follow, each in order gives a contestant’s ID (a 4-digit number). After the ranklist, there is a positive integer K followed by K query ID’s.\nOutput Specification:For each query, print in a line ID: award where the award is Mystery Award, or Minion, or Chocolate. If the ID is not in the ranklist, print Are you kidding? instead. If the ID has been checked before, print ID: Checked.\nSample Input:6\n1111\n6666\n8888\n1234\n5555\n0001\n6\n8888\n0001\n1111\n2222\n8888\n2222\n\nSample Output:8888: Minion\n0001: Chocolate\n1111: Mystery Award\n2222: Are you kidding?\n8888: Checked\n2222: Are you kidding?\n\n\nΩ为一个比赛的用户提供获奖查询服务，规则如下：\n\n第一名获得”Mystery Award”\n\n排名为素数的用户获得小黄人一只\n\n其他人获得巧克力\n\n没参与的用户让他gun\n\n\n注意到n不超过10000，因此直接打素数表，建立一个vector&lt;bool&gt;(n+1,true)，用大筛法将非素数置false。然后用map建立id和rank之间的映射，同时附一个bool变量记录是否已经查询过。按照 用户是否参赛→是否已经检查→是否第一→是否是素数排名依次检查即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, t = 2;\n    scanf(\"%d\", &amp;n);\n    vector&lt;bool&gt; isPrime(n + 1, true);\n    for (int i = 2; i &lt; sqrt(n) + 1; t = ++i)\n    {\n        if (!isPrime[i]) continue;\n        while ((t += i) &lt;= n) isPrime[t] = false;\n    }\n    map&lt;string, pair&lt;int, bool&gt;&gt; rank;\n    string id(4, 0);\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        scanf(\"%s\", &amp;id[0]);\n        rank[id] = {i, false};\n    }\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s\", &amp;id[0]);\n        printf(\"%s: \", id.c_str());\n        if (rank.find(id) == rank.end())\n        {\n            printf(\"Are you kidding?\\n\");\n            continue;\n        }\n        else if (rank[id].second) printf(\"Checked\\n\");\n        else if (rank[id].first == 1) printf(\"Mystery Award\\n\");\n        else if (isPrime[rank[id].first]) printf(\"Minion\\n\");\n        else printf(\"Chocolate\\n\");\n        rank[id].second = true;\n    }\n}\n","slug":"「1116」Come-on-Let-s-C","date":"2022-11-20T12:14:14.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,prime","author_index":"Starlit Rover"},{"id":"4fd53e230858db5e382512fd3cfbd1a2","title":"「1115」Counting Nodes in a Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node’s key.\nThe right subtree of a node contains only nodes with keys greater than the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nInsert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤1000) which is the size of the input sequence. Then given in the next line are the N integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree.\nOutput Specification:For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:\nn1 + n2 = n\n\nwhere n1 is the number of nodes in the lowest level, n2 is that of the level above, and n is the sum.\nSample Input:10\n25 30 42 16 20 20 35 -5 28 22\n\nSample Output:3 + 4 = 7\n\n\nΩ按照给定数组构建二叉搜索树，然后输出最低两层节点个数，以及两者之和。\n不是很难，由于数组中的值并不是两两不同的，因此不能直接用值当索引去查找子节点。直接在构建BST的过程中，一边插入一边计数深度，最后将相应深度的节点个数+1，最后输出最大两个深度的节点个数即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, root = 0;\n    cin &gt;&gt; n;\n    map&lt;int, int, greater&lt;&gt;&gt; cnt{{1, 1}};\n    vector&lt;pair&lt;int, int&gt;&gt; sons(n, {-1, -1});\n    vector&lt;int&gt; value(n);\n    cin &gt;&gt; value[0];\n    for (int i = 1; i &lt; n; ++i)\n    {\n        int depth = 0, *tmp = &amp;root;\n        cin &gt;&gt; value[i];\n        while (++depth, *tmp != -1)\n            tmp = value[i] &gt; value[*tmp] ? &amp;(sons[*tmp].second) : &amp;(sons[*tmp].first);\n        *tmp = i, cnt[depth] += 1;\n    }\n    int a = cnt.begin()-&gt;second, b = ++cnt.begin() == cnt.end() ? 0 : (++cnt.begin())-&gt;second;\n    printf(\"%d + %d = %d\", a, b, a + b);\n}\n","slug":"「1115」Counting-Nodes-in-a-Binary-Search-Tree","date":"2022-11-20T11:34:27.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search,Tree","author_index":"Starlit Rover"},{"id":"65d0a1b9a75654efd6950a77e52b0ae4","title":"Lab3: page tables","content":"兄弟们，我XV6又回来啦，这个栏目的灰都能把人埋了，鸽子王实锤（当然不是因为懒(⁎⁍̴̛ᴗ⁍̴̛⁎)）。不过虽迟但到！主要有时候看完文档和课程后又去搞其他飞机了，回来时，发现一切回到原点。这周发现再不搞真搞不完了，Lab3是关于页表的，文档戳这。 \n\n\n\n\n\n\n❖ Coding\n☑︎ Speed up system calls (easy)由于用户在使用系统调用时需要从用户空间跳转到内核空间，存在一定的时间开销。我们可以通过建立一段用户（只读）和内核共享的内存空间来避免空间跳转的时间，从而加速系统调用。这是一些操作系统的常见优化方法，本实验就是希望你以此来优化getpid系统调用。\n我们知道每个用户进程都拥有自己的虚拟空间，通过页表查找到物理地址后再进行相应的操作。因此这段共享空间的起始地址也需要记录在进程的页表上。实验文档指出，每个进程在创建时都需要新建一个只读页（shared memory），并将其物理地址映射到虚拟地址USYSCALL（一个已经存在的宏定义），然后在这一页的开头存储一个struct usyscall（memlayout.h），并把进程pid存入这个结构体中：\n76 struct usyscall {                       \n77   int pid;  // Process ID\n78 };     \n\n接着我们再来瞅瞅user/ulib.c中ugetpid的具体实现：\n144   │ #ifdef LAB_PGTBL\n145   │ int\n146   │ ugetpid(void)\n147   │ {\n148   │   struct usyscall *u = (struct usyscall *)USYSCALL;\n149   │   return u-&gt;pid;\n150   │ }\n151   │ #endif\n\n这个函数直接访问USYSCALL地址，通过我们设置好的页表就可以直接到相应的usyscall结构体取得pid，从而可以替代原先需要进入内核空间的getpid函数。\n页表相关操作基本都在kernel/proc.c文件中，我们先找到实现主要地址映射的proc_pagetable函数，可以看到这个函数通过mappages函数完成了Trampoline（系统调用返回地址，也是用户虚拟空间中的最高地址）和Trapframe（当中断来临时存储当前寄存器值的地址，就位于Trampoline的下方）的映射。显然，我们也需要用mappages来实现USYSCALL虚拟地址的映射，但问题是我们需要知道相应的物理地址。\n由于这个只读页是在进程创建时产生的，那么我们来到创建进程的allocproc函数：\n100   │ // Look in the process table for an UNUSED proc.\n101   │ // If found, initialize state required to run in the kernel,\n102   │ // and return with p-&gt;lock held.\n103   │ // If there are no free procs, or a memory allocation fails, return 0.\n104   │ static struct proc*\n105   │ allocproc(void)\n106   │ {\n107   │   struct proc *p;\n108   │ \n109   │   for(p = proc; p &lt; &amp;proc[NPROC]; p++) {\n110   │     acquire(&amp;p-&gt;lock);\n111   │     if(p-&gt;state == UNUSED) {\n112   │       goto found;\n113   │     } else {\n114   │       release(&amp;p-&gt;lock);\n115   │     }\n116   │   }\n117   │   return 0;\n118   │ \n119   │ found:\n120   │     ......\n\nallocproc函数从进程表中找到一个未使用的进程块然后为它分配相应的页表空间（kalloc：分配一块页大小512B的空间），那么我们就在此仿照trapframe的做法新建只读页，并存入pid：\n130 + │  // ADD\n131 + │  if((p-&gt;usys = (struct usyscall *)kalloc())==0)\n132 + │  {\n133 + │     // kfree((void*)p-&gt;trapframe);\n134 + │     freeproc(p);\n135 + │     release(&amp;p-&gt;lock);\n136 + │     return 0;\n137 + │  }\n138 + │   p-&gt;usys-&gt;pid=p-&gt;pid;\n139 + │ \n140   │   // An empty user page table.\n141   │   p-&gt;pagetable = proc_pagetable(p);\n142   │   ......\n\n由于只读页的物理地址还要在proc_pagetable中使用，因此我们需要在proc结构体（kernel/proc.h）中加入struct usyscall *usys。\n⚠️ 新建只读页必须在调用proc_pagetable（141）之前，因为需要用物理地址做映射。\n然后我们就可以在proc_pagetable里建立映射了：\n210 + │   // ADD\n211 + │   if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usys), PTE_R | PTE_U) &lt; 0)\n212 + │   {\n213 + │     uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n214 + │     uvmunmap(pagetable, TRAPFRAME, 1, 0);\n215 + │     uvmfree(pagetable, 0);\n216 + │     return 0;\n217 + │   }\n218 + │\n219   │   return pagetable;\n220   │ }\n\n⚠️权限是只读（PTE_R），同时在用户空间内运行（PTE_U）。如果map失败就需要解除前面TRAMPOLINE和TRAPFRAME的映射。\n最后不要忘记在freeproc中释放分配来的物理空间：\n168 + │   if(p-&gt;usys)\n169 + │     kfree((void*)p-&gt;usys);\n170 + │   p-&gt;usys = 0;\n\n还有很重要的一点是解除映射，否则会panic——“freewalk: leaf”：\n224   │ void proc_freepagetable(pagetable_t pagetable, uint64 sz) {\n225   │   uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n226   │   uvmunmap(pagetable, TRAPFRAME, 1, 0);\n227 + │   uvmunmap(pagetable, USYSCALL, 1, 0);\n228   │   uvmfree(pagetable, sz);\n229   │ }\n\n在释放页表空间后会调用freewalk函数来检查该页表中的所有叶子pte（三级映射最后的物理地址）是否有效（PTE_V是否为1），如果存在物理地址有效就会panic。\n\n\n☑︎ Print a page table（easy）实现函数vmprint打印出页表树。页表是三级查找结构，把所有PTE条目看作一个节点，物理地址所对应的PTE条目为其子节点，那么从宏观上来看每个L2 page directory的物理地址都对应一个深度不超过3的树。\n只要知道了如何判断PTE（page table entry）和PT就能写出递归函数了。我们可以参考freewalk函数（kernel/vm.c），对就是上面刚刚出现的那位老哥，它就是通过递归遍历整棵树来检查物理地址是否还有效的：\n266   │ void\n267   │ freewalk(pagetable_t pagetable)\n268   │ {\n269   │   // there are 2^9 = 512 PTEs in a page table.\n270   │   for(int i = 0; i &lt; 512; i++){\n271   │     pte_t pte = pagetable[i];\n272   │     if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){\n273   │       // this PTE points to a lower-level page table.\n274   │       uint64 child = PTE2PA(pte);\n275   │       freewalk((pagetable_t)child);\n276   │       pagetable[i] = 0;\n277   │     } else if(pte &amp; PTE_V){\n278   │       panic(\"freewalk: leaf\");\n279   │     }\n280   │   }\n281   │   kfree((void*)pagetable);\n282   │ }\n\n可见如果PTE_V是有效的，没有任何权限则说明这是一个PTE，需要继续递归，反之则说明是叶子节点，即虚拟地址对应的真实物理地址。\n由于我们需要用【 ..】的个数来表示深度，因此在vmprint中设置一个static int depth，递归进入子函数前+1，退出时-1。\n首先在kernel/exec.c的exec函数中加入\n143 + │     if(p-&gt;pid==1)\n144 + │     vmprint(p-&gt;pagetable);\n145 + │ \n146   │     return argc; // this ends up in a0, the first argument to main(argc, argv)\n\n对于vmprint的实现，我是直接在exec函数前插入的，实验文档推荐在kernel/vm.c里实现，那就别忘了在kernel/defs.h里声明。\n12 + │ void vmprint(pagetable_t pg)\n13 + │ {\n14 + │     static int depth = 1;\n15 + │     if (depth == 1)\n16 + │         printf(\"page table %p\\n\", *pg);\n17 + │     for (int i = 0; i &lt; 512; ++i)\n18 + │     {\n19 + │         pte_t pte = pg[i];\n20 + │         if (pte &amp; PTE_V)\n21 + │         {\n22 + │             uint64 child = PTE2PA(pte);\n23 + │             for (int j = 0; j &lt; depth; ++j)\n24 + │                 printf(\" ..\");\n25 + │             printf(\"%d: pte %p pa %p\\n\", i, pte, child);\n26 + │             if ((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0)\n27 + │             {\n28 + │                 depth += 1;\n29 + │                 vmprint((pagetable_t) child);\n30 + │             }\n31 + │         }\n32 + │     }\n33 + │     depth -= 1;\n34 + │ }\n\n然后启动qemu后就会输出\nhart 2 starting\nhart 1 starting\npage table 0x0000000021fda801\n ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000\n .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000\n .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000\n .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000\n .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000\n ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000\n .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000\n .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000\n .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000\n .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000\n\n\n\n☑︎ Detecting which pages have been accessed (hard)这里我们需要实现一个系统调用pgaccess，来检查给定物理页们是否被访问过（accessed：read or write），用one bit来表示一个物理页的结果，并将结果拷贝至用户空间。\npgaccess会接受三个参数——第一个是起始页的虚拟地址，第二个是需要往后检查的页数，最后一个是需要将结果拷贝到用户空间的物理地址。文档中说最后用户空间会用一个bitmask的数据结构存储结果，其中a bit代表1页且第一页位于最低有效位，另外可以自行设置一个页数上限。在内核中运行时，我们可以用一个uint64来存储结果，那么页数上限即为64。另外我们需要自己在kernel/risv.h中定义PTE_A，至于这一位在物理地址中的哪一位则需要查询riscv手册（P70）：\n\n\n你可能会问PTE_A不是我们自行定义的吗。事实上，pgaccess只是实现一个检查的功能，真正置位的是riscv硬件。文档中指出“The RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB miss”，当CPU需要那一物理页时，发现Translation Look-aside Buffer未命中（cache中没有），就会去access这一页，然后将其PTE_A置1，因此PTE_A的位置是由硬件规定的。\n根据上图可知PTE_A位于倒数第6位，那么就在kernel/riscv.h中加入\n346 + │ #define PTE_A (1L &lt;&lt; 6) // access bit\n\n准确地来讲，页表中存储的并不是物理地址，而是0(10 bits)+PPN(44 bits)+flags(10 bits)=PTE(64 bits)，因此我们可以看到kernel/riscv.h中很多转换宏定义：\n348   │ // shift a physical address to the right place for a PTE.\n349   │ #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)\n350   │ \n351   │ #define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)\n352   │ \n353   │ #define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)\n\n想要获取PTE_A只需要(PTE&amp;PTE_A)&gt;&gt;6  即可。另外由于参数是从用户空间传入，因此我们需要将这些参数通过argaddr（64 bits）和argint（32 bits）拷贝过来。由于传入的是虚拟地址，因此我们需要用walk函数找到实际的物理地址。\nkernel/sysproc.c中已经指明了函数的实现位置，直接撸就完事：\n 79   │#ifdef LAB_PGTBL\n 80   │int\n 81   │sys_pgaccess(void)\n 82   │{\n 83   │    // lab pgtbl: your code here.\n 84 + │    uint64 sa, ua, buf = 0;\n 85 + │    int n;\n 86 + │    if (argaddr(0, &amp;sa) &lt; 0 || argint(1, &amp;n) &lt; 0 || argaddr(2, &amp;ua) &lt; 0)\n 87 + │        return -1;\n 88 + │\n 89 + │    if (n &gt; 64) return -1;\n 90 + │\n 91 + │    struct proc *p = myproc();\n 92 + │    uint64 pg = sa;\n 93 + │    for (int i = 0; i &lt; n; ++i)\n 94 + │    {\n 95 + │        pte_t *pte = walk(p-&gt;pagetable, pg, 0);\n 96 + │        buf += ((*pte &amp; PTE_A) &gt; 0) &lt;&lt; i;\n 97 + │        (*pte) &amp;= (~PTE_A);\n 98 + │        pg += PGSIZE;\n 99 + │    }\n100 + │\n101 + │    return copyout(p-&gt;pagetable, ua, (char *) &amp;buf, sizeof(buf));\n102   │}\n103   │#endif\n\n文档中指出我们检查完后还需要将PTE_A置0，因为硬件只顾着在访问时置1，如果不复位那么PTE_A就永远是1了。因此别忘记(*pte) &amp;= (~PTE_A)，另外别写出(*pte &amp; PTE_A &gt; 0)，【&amp;】的优先级比【&gt;】低。\n\n\n❖ References\n\n[1] MIT 6.S081 2021: Lab page tables\n\n[2] MIT6.S081-Lab3 Pgtbl [2021Fall]\n\n\n","slug":"Lab3-page-tables","date":"2022-11-17T16:34:38.000Z","categories_index":"操作系统","tags_index":"走码观花,xv6","author_index":"Starlit Rover"},{"id":"7239e6ffaff5533d5d38121f0a34ad8b","title":"「1114」Family Property","content":"This time, you are supposed to help us collect the data for family-owned property. Given each person’s family members, and the estate（房产）info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤1000). Then N lines follow, each gives the infomation of a person who owns estate in the format:\nID Father Mother k Child1​⋯Childk​ Mestate​ Area\nwhere ID is a unique 4-digit identification number for each person; Father and Mother are the ID‘s of this person’s parents (if a parent has passed away, -1 will be given instead); k (0≤k≤5) is the number of children of this person; Childi​’s are the ID‘s of his/her children; Mestate​ is the total number of sets of the real estate under his/her name; and Area is the total area of his/her estate.\nOutput Specification:For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format:\nID M AVGsets​ AVGarea​\nwhere ID is the smallest ID in the family; M is the total number of family members; AVGsets​ is the average number of sets of their real estate; and AVGarea​ is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the ID’s if there is a tie.\nSample Input:10\n6666 5551 5552 1 7777 1 100\n1234 5678 9012 1 0002 2 300\n8888 -1 -1 0 1 1000\n2468 0001 0004 1 2222 1 500\n7777 6666 -1 0 2 300\n3721 -1 -1 1 2333 2 150\n9012 -1 -1 3 1236 1235 1234 1 100\n1235 5678 9012 0 1 50\n2222 1236 2468 2 6661 6662 1 300\n2333 -1 3721 3 6661 6662 6663 1 100\n\nSample Output:3\n8888 1 1.000 1000.000\n0001 15 0.600 100.000\n5551 4 0.750 100.000\n\n\nΩ打地主，分田地（bushi\n给出一群人拥有的房产数和总房产面积，以及他的父母、子女信息，输出家族个数，以及每个家族的人数、平均房产数和平均面积。\n本质上就是给出一个图求出连通分图的个数。我们认为在一代内有血缘关系的人之间存在一条边，即亲子关系，然后用一个邻接表存储所有边。接着对所有人进行BFS，同时flag标记是否已被访问。\n\n🐎#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;int, int, double, double&gt; tiidd;\n\nstruct info\n{\n    set&lt;int&gt; edge;\n    int est = 0, area = 0;\n    bool flag = false;\n};\n\nint main()\n{\n    int n, id, f, m, k, c;\n    scanf(\"%d\", &amp;n);\n    map&lt;int, info&gt; p;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d %d %d %d\", &amp;id, &amp;f, &amp;m, &amp;k);\n        if (f != -1)\n            p[id].edge.insert(f), p[f].edge.insert(id);\n        if (m != -1)\n            p[id].edge.insert(m), p[m].edge.insert(id);\n        for (int j = 0; j &lt; k; ++j)\n        {\n            scanf(\"%d\", &amp;c);\n            p[id].edge.insert(c);\n            p[c].edge.insert(id);\n        }\n        scanf(\"%d %d\", &amp;p[id].est, &amp;p[id].area);\n    }\n\n    vector&lt;tiidd&gt; ans;\n    for (auto &amp;r: p)\n    {\n        if (r.second.flag) continue;\n        r.second.flag = true;\n        set&lt;int&gt; crt{r.first}, nxt;\n        int sum_est = r.second.est, sum_area = r.second.area, num = 1, min_id = r.first;\n        while (!crt.empty())\n        {\n            for (auto &amp;t: crt)\n                for (auto &amp;z: p[t].edge)\n                {\n                    if (p[z].flag) continue;\n                    min_id = min(min_id, z);\n                    p[z].flag = true;\n                    ++num, sum_est += p[z].est, sum_area += p[z].area;\n                    nxt.insert(z);\n                }\n            crt = std::move(nxt);\n            nxt = set&lt;int&gt;();\n        }\n        ans.emplace_back(min_id, num, 1.0 * sum_est / num, 1.0 * sum_area / num);\n    }\n    sort(ans.begin(), ans.end(),\n         [](tiidd &amp;a, tiidd &amp;b) { return get&lt;3&gt;(a) == get&lt;3&gt;(b) ? get&lt;0&gt;(a) &lt; get&lt;0&gt;(b) : get&lt;3&gt;(a) &gt; get&lt;3&gt;(b); });\n    printf(\"%zu\\n\", ans.size());\n    for (auto &amp;t: ans)\n        printf(\"%04d %d %.3f %.3f\\n\", get&lt;0&gt;(t), get&lt;1&gt;(t), get&lt;2&gt;(t), get&lt;3&gt;(t));\n}\n","slug":"「1114」Family-Property","date":"2022-11-16T02:09:36.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set,BFS,tuple","author_index":"Starlit Rover"},{"id":"e36208e2f8f3b544d6aecbeda1298b6f","title":"「1113」Integer Set Partition","content":"Given a set of N (&gt;1) positive integers, you are supposed to partition them into two disjoint sets A1​ and A2​ of n1​ and n2​ numbers, respectively. Let S1​ and S2​ denote the sums of all the numbers in A1​ and A2​, respectively. You are supposed to make the partition so that ∣n1​−n2​∣ is minimized first, and then ∣S1​−S2​∣ is maximized.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives an integer , and then N positive integers follow in the next line, separated by spaces. It is guaranteed that all the integers and their sum are less than .\nOutput Specification:For each case, print in a line two numbers: ∣n1​−n2​∣ and ∣S1​−S2​∣, separated by exactly one space.\nSample Input 1:10\n23 8 10 99 46 2333 46 1 666 555\n\nSample Output 1:0 3611\n\nSample Input 2:13\n110 79 218 69 3721 100 29 135 2 6 13 5188 85\n\nSample Output 2:1 9359\n\n\nΩ小学生题，把一个数组分为两组，先使得两组大小相差最小，然后再使两组和之差最大。很显然排个序从中间切开就好了。\n然后发现求和也有库函数——accumulate：\n#include &lt;numeric&gt;\ntemplate&lt;class InputIt, class T&gt;\nconstexpr // since C++20\nT accumulate(InputIt first, InputIt last, T init)\n{\n    for (; first != last; ++first)\n        init = std::move(init) + *first; // std::move since C++20\n    return init;\n}\n\n指定求和数组结尾的迭代器和初始值init，最后就会得到相应区间之和+init。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (auto &amp;k: a)\n        cin &gt;&gt; k;\n    sort(a.begin(), a.end());\n    cout &lt;&lt; n % 2 &lt;&lt; \" \" &lt;&lt; accumulate(a.begin() + n / 2, a.end(), 0) - accumulate(a.begin(), a.begin() + n / 2, 0);\n}\n","slug":"「1113」Integer-Set-Partition","date":"2022-11-15T10:47:35.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"618b8ef040c33dc554fa44d01d787f4c","title":"「1112」Stucked Keyboard","content":"On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for k times.\nNow given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string.\nNotice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed k times whenever it is pressed. For example, when k=3, from the string thiiis iiisss a teeeeeest we know that the keys i and e might be stucked, but s is not even though it appears repeatedly sometimes. The original string could be this isss a teest.\n\n\nInput Specification:Each input file contains one test case. For each case, the 1st line gives a positive integer  which is the output repeating times of a stucked key. The 2nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and _. It is guaranteed that the string is non-empty.\nOutput Specification:For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key.\nSample Input:3\ncaseee1__thiiis_iiisss_a_teeeeeest\n\nSample Output:ei\ncase1__this_isss_a_teest\n\n\nΩ寻找所有卡住的按键。首先我们知道每个卡住的按键会重复次，那么给出一个输入后显示的字符串，请判断哪些字符可能是卡住的（按照出现顺序输出），同时给出正常键盘的输出。\n显然，只要一个字符连续出现的次数有一次不是的倍数，那么它就必然不是卡住的按钮。我们设置一个map&lt;char,short&gt; flag，在遍历字符串的过程中分别代表以下含义：\n\n表示在之前的字符串中c连续出现的个数都是的倍数，即是可能卡住的按钮\n\n表示在之前的字符串中c未出现过（map的初始化值即为0）\n\n表示c不可能是卡住的按钮（之前的字符串中出现过非倍数长度的连续c串）\n\n\n那么局势就明朗多啦，用一个vector&lt;char&gt; stuck来存储怀疑对象，由于不读到最后一个字符就无法肯定stuck中的按钮确实有可能卡住，因此最后在输出stuck时需要检查flag是否为1，-1的不能输出。\n遍历整个字符串，如果当前字符与下一个字符不相等（⚠️或是在字符串末尾的字符），就将计数器对取余，一旦不为0直接-1封杀，如果是的倍数且那么就先压入stuck作为考察对象，之前就不要重复存入stuck了，同时将计数器归0。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int k, cnt = 0;\n    cin &gt;&gt; k;\n    vector&lt;char&gt; stuck;\n    map&lt;char, short&gt; flag;\n    string s;\n    cin &gt;&gt; s;\n    for (int i = 0; i &lt; s.size(); ++i)\n    {\n        cnt += 1;\n        if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == s[i]) continue;\n        if (cnt % k == 0 &amp;&amp; flag[s[i]] == 0)\n            stuck.push_back(s[i]), flag[s[i]] = 1;\n        else if (cnt % k != 0)\n            flag[s[i]] = -1;\n        cnt = 0;\n    }\n    for (auto &amp;c: stuck)\n        if (flag[c] == 1) cout &lt;&lt; c;\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; s.size(); ++i)\n    {\n        cout &lt;&lt; s[i];\n        i += (flag[s[i]] == 1) * (k - 1);\n    }\n}\n","slug":"「1112」Stucked-Keyboard","date":"2022-11-14T17:01:35.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,string","author_index":"Starlit Rover"},{"id":"d918ffea37eef621e5dbc24cef76eeef","title":"「1111」Online Map","content":"Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (2≤N≤500), and M, being the total number of streets intersections on a map, and the number of streets, respectively. Then M lines follow, each describes a street in the format:\nV1 V2 one-way length time\n\nwhere V1 and V2 are the indices (from 0 to N−1) of the two ends of the street; one-way is 1 if the street is one-way from V1 to V2, or 0 if not; length is the length of the street; and time is the time taken to pass the street.\nFinally a pair of source and destination is given.\nOutput Specification:For each case, first print the shortest path from the source to the destination with distance D in the format:\nDistance = D: source -&gt; v1 -&gt; ... -&gt; destination\n\nThen in the next line print the fastest path with total time T:\nTime = T: source -&gt; w1 -&gt; ... -&gt; destination\n\nIn case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.\nIn case the shortest and the fastest paths are identical, print them in one line in the format:\nDistance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination\n\nSample Input 1:10 15\n0 1 0 1 1\n8 0 0 1 1\n4 8 1 1 1\n3 4 0 3 2\n3 9 1 4 1\n0 6 0 1 1\n7 5 1 2 1\n8 5 1 2 1\n2 3 0 2 2\n2 1 1 1 1\n1 3 0 3 1\n1 4 0 1 1\n9 7 1 3 1\n5 1 0 5 2\n6 5 1 1 2\n3 5\n\nSample Output 1:Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5\nTime = 3: 3 -&gt; 1 -&gt; 5\n\nSample Input 2:7 9\n0 4 1 1 1\n1 6 1 1 3\n2 6 1 1 1\n2 5 1 2 2\n3 0 0 1 1\n3 1 1 1 3\n3 2 1 1 2\n4 5 0 2 2\n6 5 1 1 2\n3 5\n\nSample Output 2:Distance = 3; Time = 4: 3 -&gt; 2 -&gt; 5\n\n\nΩ疯狂Dijkstra，给出一个图，有些边双向通行其余边单向通行，本质上就是一个有向图，每条边给出相应的距离和时间，然后给出起点与终点分别求出路径最短（多条路径最短时取时间最短）和时间最短（多条时间最短时取途经节点数最少）的路径，如果两条路径相同则一起输出。\n就是Dijkstra算法，求路径最短时取边权为pair&lt;distance,time&gt;，利用pair对比较运算符的重载就可以直接套用Dijkstra算法；第二次则是pair&lt;time,intersection num&gt;，重复一遍最短路径的流程。另外对于路径的记录则采取记录每个节点前置节点的方法，在每次更新节点的最小边权时顺便更新它的前置节点。那么最后从终点回溯至起点即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, v1, v2, ow, len, t, s, d;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;vector&lt;tuple&lt;int, int, int&gt;&gt;&gt; info(n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d %d %d %d\", &amp;v1, &amp;v2, &amp;ow, &amp;len, &amp;t);\n        info[v1].emplace_back(v2, len, t);\n        if (!ow) info[v2].emplace_back(v1, len, t);\n    }\n    scanf(\"%d %d\", &amp;s, &amp;d);\n    vector&lt;bool&gt; isDtm(n, false);\n    vector&lt;int&gt; dpre(n, -1);\n    vector&lt;pair&lt;int, int&gt;&gt; dist(n, {INT32_MAX, INT32_MAX});\n    pair&lt;int, int&gt; dopt{0, 0}, topt{0, 0};\n    isDtm[s] = true, dist[s] = {0, 0};\n    for (auto &amp;k: info[s])\n        dpre[get&lt;0&gt;(k)] = s, dist[get&lt;0&gt;(k)] = {get&lt;1&gt;(k), get&lt;2&gt;(k)};\n    while (!isDtm[d])\n    {\n        int idx = -1;\n        dopt = {INT32_MAX, INT32_MAX};\n        for (int i = 0; i &lt; n; ++i)\n            if (!isDtm[i] &amp;&amp; dist[i] &lt; dopt)\n                dopt = dist[i], idx = i;\n        isDtm[idx] = true;\n        for (auto &amp;k: info[idx])\n            if (make_pair(get&lt;1&gt;(k) + dopt.first, get&lt;2&gt;(k) + dopt.second) &lt; dist[get&lt;0&gt;(k)])\n            {\n                dist[get&lt;0&gt;(k)] = make_pair(get&lt;1&gt;(k) + dopt.first, get&lt;2&gt;(k) + dopt.second);\n                dpre[get&lt;0&gt;(k)] = idx;\n            }\n    }\n\n    fill(isDtm.begin(), isDtm.end(), false);\n    vector&lt;int&gt; tpre(n, -1);\n    vector&lt;pair&lt;int, int&gt;&gt; time(n, {INT32_MAX, INT32_MAX});\n    isDtm[s] = true, time[s] = {0, 0};\n    for (auto &amp;k: info[s])\n        tpre[get&lt;0&gt;(k)] = s, time[get&lt;0&gt;(k)] = {get&lt;2&gt;(k), 1};\n    while (!isDtm[d])\n    {\n        int idx = -1;\n        topt = {INT32_MAX, INT32_MAX};\n        for (int i = 0; i &lt; n; ++i)\n            if (!isDtm[i] &amp;&amp; time[i] &lt; topt)\n                topt = time[i], idx = i;\n        isDtm[idx] = true;\n        for (auto &amp;k: info[idx])\n            if (make_pair(get&lt;2&gt;(k) + topt.first, topt.second + 1) &lt; time[get&lt;0&gt;(k)])\n            {\n                time[get&lt;0&gt;(k)] = make_pair(get&lt;2&gt;(k) + topt.first, topt.second + 1);\n                tpre[get&lt;0&gt;(k)] = idx;\n            }\n    }\n\n    vector&lt;int&gt; pathd, patht;\n    t = d;\n    while (t != -1) pathd.push_back(t), t = dpre[t];\n    t = d;\n    while (t != -1) patht.push_back(t), t = tpre[t];\n    if (pathd == patht)\n    {\n        printf(\"Distance = %d; Time = %d: %d\", dopt.first, dopt.second, s);\n        for (int i = pathd.size() - 2; i &gt;= 0; --i)\n            printf(\" -&gt; %d\", pathd[i]);\n    }\n    else\n    {\n        printf(\"Distance = %d: %d\", dopt.first, s);\n        for (int i = pathd.size() - 2; i &gt;= 0; --i)\n            printf(\" -&gt; %d\", pathd[i]);\n        printf(\"\\nTime = %d: %d\", topt.first, s);\n        for (int i = patht.size() - 2; i &gt;= 0; --i)\n            printf(\" -&gt; %d\", patht[i]);\n    }\n}\n\n⚠️ Dijkstra算法中每一轮都需要找到距起点边权和最小的节点P，那么一般和起点之间还没路的节点距离默认为，编程时一般直接取INT32_MAX。但如果你是用邻接矩阵来存储节点之间的边权而且没有边的权重也直接记为INT32_MAX的话，那么你要注意在更新节点到起点的距离时，你必须跳过这些与P没有边的节点，否则相加时会导致溢出。我在这里采用的是邻接表的形式，意味着没有边的节点根本没有存，因此不用担心这个问题。\n","slug":"「1111」Online-Map","date":"2022-11-14T15:22:03.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Dijkstra,tuple","author_index":"Starlit Rover"},{"id":"1c866b059d574be929326143e875b3a0","title":"「1110」Complete Binary Tree","content":"Given a tree, you are supposed to tell if it is a complete binary tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤20) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space.\nOutput Specification:For each case, print in one line YES and the index of the last node if the tree is a complete binary tree, or NO and the index of the root if not. There must be exactly one space separating the word and the number.\nSample Input 1:9\n7 8\n- -\n- -\n- -\n0 1\n2 3\n4 5\n- -\n- -\n\nSample Output 1:YES 8\n\nSample Input 2:8\n- -\n4 5\n0 6\n- -\n2 3\n- 7\n- -\n- -\n\nSample Output 2:NO 1\n\n\nΩ给出一棵二叉树的节点关系，请判断其是否为完全二叉树（所有节点索引与满二叉树一致），若是则输出最后一个节点的编号，否则输出根节点编号。\n首先我们将根节点编号变量赋值，i.e.，所有编号之和，然后把有父亲节点的编号都减掉，剩下的必然是根节点编号（⚠️但要保证所有节点之和不能超出int范围）。然后DFS递归遍历整棵树，把相应的节点编号赋值到层次遍历的向量中。索引为节点的左右子节点索引分别为、，一旦发现某个节点的编号超出了N就说明不是完全二叉树，直接返回false。\n最后如果YES就输出层次遍历的最后一个节点编号，反之则输出root。\n\nΩ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, top;\nvector&lt;int&gt; level;\nvector&lt;pair&lt;int, int&gt;&gt; sons;\n\nbool isCBT(int node, int idx)\n{\n    level[idx] = node;\n    int l = sons[node].first, r = sons[node].second;\n    return ((l != -1 &amp;&amp; 2 * idx + 1 &lt; n) ? isCBT(l, 2 * idx + 1) : (l == -1))\n        &amp;&amp; ((r != -1 &amp;&amp; 2 * idx + 2 &lt; n) ? isCBT(r, 2 * idx + 2) : (r == -1));\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    top = n * (n - 1) / 2;\n    sons.resize(n);\n    string a, b;\n    for (auto &amp;k: sons)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        k.first = a == \"-\" ? -1 : (top -= stoi(a), stoi(a));\n        k.second = b == \"-\" ? -1 : (top -= stoi(b), stoi(b));\n    }\n    level.resize(n);\n    if (isCBT(top, 0))\n        cout &lt;&lt; \"YES \" &lt;&lt; level.back();\n    else cout &lt;&lt; \"NO \" &lt;&lt; top;\n}\n","slug":"「1110」Complete-Binary-Tree","date":"2022-11-13T15:44:16.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Tree,DFS","author_index":"Starlit Rover"},{"id":"e5acc25f52a3eda31fca71a61f248459","title":"「1109」Group Photo","content":"Formation is very important when taking a group photo. Given the rules of forming K rows with N people as the following:\n\nThe number of people in each row must be N/K (round down to the nearest integer), with all the extra people (if any) standing in the last row;\n\nAll the people in the rear row must be no shorter than anyone standing in the front rows;\n\nIn each row, the tallest one stands at the central position (which is defined to be the position , where m is the total number of people in that row, and the division result must be rounded down to the nearest integer);\n\nIn each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.);\n\nWhen there are many people having the same height, they must be ordered in alphabetical (increasing) order of their names, and it is guaranteed that there is no duplication of names.\n\n\nNow given the information of a group of people, you are supposed to write a program to output their formation.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains two positive integers , the total number of people, and K (≤10), the total number of rows. Then N lines follow, each gives the name of a person (no more than 8 English letters without space) and his/her height (an integer in [30, 300]).\nOutput Specification:For each case, print the formation – that is, print the names of people in K lines. The names must be separated by exactly one space, but there must be no extra space at the end of each line. Note: since you are facing the group, people in the rear rows must be printed above the people in the front rows.\nSample Input:10 3\nTom 188\nMike 170\nEva 168\nTim 160\nJoe 190\nAnn 168\nBob 175\nNick 186\nAmy 160\nJohn 159\n\nSample Output:Bob Tom Joe Nick\nAnn Mike Eva\nTim Amy John\n\n\nΩ首先我想问，这测试样例怎么每行个数与行数相同啊。当我春光满面地submit时结果三个WA，我人傻了直呼impossible，结果后来发现k是行数，原地爆炸。\n题不难，就是排一个拍照队列，规则是：\n\n行间规则：高的人站后排，矮的在前\n\n行内规则：一排内最高的站C位，即（）个位置，然后按照身高降序排列分别在最高者的右左轮流排列。\n\n身高一样者按照名字字母序升序排列\n\n\n读入姓名和身高后按照规则降序排序，然后从最后一排开始，从最高者开始，设置一个bias=0变量，bias = i % 2 ? -bias : -bias - 1，从而实现最高者左右的轮流分配。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;int, string&gt; pis;\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;pis&gt; info(n);\n    for (auto &amp;t: info)\n        cin &gt;&gt; t.second &gt;&gt; t.first;\n    sort(info.begin(), info.end(),\n         [](pis &amp;a, pis &amp;b) { return a.first == b.first ? a.second &lt; b.second : a.first &gt; b.first; });\n    vector&lt;string&gt; row;\n    int r = n / k, u = r + n % r, head = 0, bias = 0;\n    while (head &lt; n)\n    {\n        row.resize(u);\n        for (int i = 0; i &lt; u; ++i)\n        {\n            row[u / 2 + bias] = info[head + i].second;\n            bias = i % 2 ? -bias : -bias - 1;\n        }\n        cout &lt;&lt; row[0];\n        for (int j = 1; j &lt; u; ++j)\n            cout &lt;&lt; \" \" &lt;&lt; row[j];\n        cout &lt;&lt; endl;\n        head += u, u = r, bias = 0, row.clear();\n    }\n}\n","slug":"「1109」Group-Photo","date":"2022-11-13T11:56:09.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"80283fa8bfdc49e4840f7226c64452a7","title":"「1108」Finding Average","content":"The basic task is simple: given N real numbers, you are supposed to calculate their average. But what makes it complicated is that some of the input numbers might not be legal. A legal input is a real number in [−1000,1000] and is accurate up to no more than 2 decimal places. When you calculate the average, those illegal numbers must not be counted in.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then N numbers are given in the next line, separated by one space.\nOutput Specification:For each illegal input number, print in a line ERROR: X is not a legal number where X is the input. Then finally print in a line the result: The average of K numbers is Y where K is the number of legal inputs and Y is their average, accurate to 2 decimal places. In case the average cannot be calculated, output Undefined instead of Y. In case K is only 1, output The average of 1 number is Y instead.\nSample Input 1:7\n5 -3.2 aaa 9999 2.3.4 7.123 2.35\n\nSample Output 1:ERROR: aaa is not a legal number\nERROR: 9999 is not a legal number\nERROR: 2.3.4 is not a legal number\nERROR: 7.123 is not a legal number\nThe average of 3 numbers is 1.38\n\nSample Input 2:2\naaa -9999\n\nSample Output 2:ERROR: aaa is not a legal number\nERROR: -9999 is not a legal number\nThe average of 0 numbers is Undefined\n\n\nΩ输入一个数组，对不合法的数字进行报错输出，然后对所有合法的数字求取平均值。\n总体来说并不是很难，主要是题目没看全就要了老命。首先，没有合法数字的话最后的平均值应为Undefined，如果只有一个合法数字的话必须number而非numbers。其他就是对数字合法性的检验了，大概有以下几点：\n\n小数点个数\n\n夹杂非数字字符\n\n小数点后的位数不超过两位\n\n整体数值的绝对值不&gt;1000\n\n\n我对于小数点最多精确到两位的理解就是小数点后只能有两位，而整数部分可以有前置0。那么先以字符串的形式读入，然后遍历所有字符，逐一判断是否为小数点（之前是否出现过）、非数字字符、小数点前有效数字位数是否&lt;5、小数点后位数是否&lt;3。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, cnt = 0;\n    cin &gt;&gt; n;\n    string t;\n    double sum = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; t;\n        int before = 0, after = 0;\n        bool flag = true, point = false, sign = t[0] == '-' &amp;&amp; (t.erase(0, 1), true);\n        for (auto &amp;c: t)\n        {\n            if (c == '.' &amp;&amp; !point)\n            {\n                point = true;\n                continue;\n            }\n            else if (!isdigit(c))\n                flag = false;\n            else if (!point)\n                flag = (before += (before != 0 || c != '0')) &lt; 5;\n            else\n                flag = ++after &lt; 3;\n            if (!flag) break;\n        }\n        if (flag &amp;&amp; stod(t) &lt;= 1000)\n        {\n            sum += (sign ? -1 : 1) * stod(t);\n            cnt += 1;\n        }\n        else\n        {\n            t = (sign ? \"-\" : \"\") + t;\n            printf(\"ERROR: %s is not a legal number\\n\", t.c_str());\n        }\n    }\n    if (!cnt) printf(\"The average of 0 numbers is Undefined\");\n    else printf(\"The average of %d number%s is %.2f\", cnt, cnt == 1 ? \"\" : \"s\", sum / cnt);\n}\n","slug":"「1108」Finding-Average","date":"2022-11-12T13:58:13.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"c00bb795d937e8dc21c5c90e4285b807","title":"「1107」Social Clusters","content":"When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A social cluster is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains a positive integer , the total number of people in a social network. Hence the people are numbered from 1 to N. Then N lines follow, each gives the hobby list of a person in the format:\n\nwhere  is the number of hobbies, and  is the index of the j-th hobby, which is an integer in [1, 1000].\nOutput Specification:For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:8\n3: 2 7 10\n1: 4\n2: 5 3\n1: 4\n1: 3\n1: 4\n4: 6 8 1 5\n1: 4\n\nSample Output:3\n4 3 1\n\n\nΩ请你将一群人划分为几个没有爱好交集的群体，爱好用编号给出。\n一开始没有用并查集，直接的想法是对爱好进行分组，即让每个爱好指向一个分组编号，如果一个人有着不同分组内的爱好，那么就把不同分组的统计量全部加到一个组上，然后将所有出现的爱好指向这个组。乍一看没啥问题，但在将一个爱好的分组指向重定向时，本来同属于一个组的爱好还是指向原来的组，事实上这个组已经被合并到新的组去了，我们不应再用这个组去统计人数了，结果后面有这些爱好的人还是会被统计到原来的组去。\n并查集就是给每个爱好都设置一个父节点，父节点就是自己的节点R可以认为是一个组织的头头，所有祖宗节点（不断溯源父节点的结果）为R的节点被认为是属于R组织。基于这样一个想法，我们首先读入一个人的所有爱好，然后选取第一个爱好所在组织的头头（没有组织的话就是自己）为合并组织的头头，然后将其余爱好所在其他组织的头头都合并到这个头头上来，同时将先前统计的人数也进行合并，被合并头头的统计数量归0。\n这样可以保证最后统计量非零的一定都是头头，而且所有统计量一定都汇总到了头头那。因为每次统计量都必然会被转移到当前头头处，如果说以后这个头头被合并了那么这个统计量会一起转移。简单点说，就是每次统计量都是位于该时刻的头头们处，那么最后也是一样。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; dad(1001), num(1001, 0);\n    iota(dad.begin(), dad.end(), 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d: \", &amp;m);\n        cin &gt;&gt; k;\n        int r = dad[k], s;\n        while (r != dad[r]) r = dad[r];\n        for (int j = 1; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k;\n            s = dad[k];\n            while (s != dad[s]) s = dad[s];\n            num[r] += num[s], num[s] = 0;\n            dad[s] = dad[k] = r;\n        }\n        num[r] += 1;\n    }\n    sort(num.begin(), num.end(), greater&lt;&gt;());\n    auto tail = find(num.begin(), num.end(), 0);\n    cout &lt;&lt; (tail - num.begin()) &lt;&lt; endl;\n    cout &lt;&lt; *num.begin();\n    for (auto it = num.begin() + 1; it != tail; ++it)\n        cout &lt;&lt; \" \" &lt;&lt; *it;\n}\n","slug":"「1107」Social-Clusters","date":"2022-11-10T10:09:22.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,并查集","author_index":"Starlit Rover"},{"id":"9241d85f7d3a9c013c622065a01dc5ab","title":"「1106」Lowest Price in Supply Chain","content":"A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.\nStarting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.\nNow given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers.\n\n\nInput Specification:Each input file contains one test case. For each case, The first line contains three positive numbers: , the total number of the members in the supply chain (and hence their ID’s are numbered from 0 to N−1, and the root supplier’s ID is 0); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then N lines follow, each describes a distributor or retailer in the following format:\n\nwhere in the i-th line,  is the total number of distributors or retailers who receive products from supplier i, and is then followed by the ID’s of these distributors or retailers.  being 0 means that the j-th member is a retailer. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceed .\nSample Input:10 1.80 1.00\n3 2 3 5\n1 9\n1 4\n1 7\n0\n2 6 1\n1 8\n0\n0\n0\n\nSample Output:1.8362 2\n\n\nΩ第三次见这题目了，感觉没什么新意，秒了。\n输出售价最便宜的销售价格以及销售此价格的零售商个数。\n直接BFS到第一个零售商出现停止，⚠️可能出现根供应商即为零售商的情况，在遍历过程中记录价格的变化。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, cnt = 0;\n    double p, r, t = 1.0;\n    scanf(\"%d %lf %lf\", &amp;n, &amp;p, &amp;r);\n    r = 1 + 0.01 * r;\n    vector&lt;vector&lt;int&gt;&gt; sup(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;m);;\n        sup[i].resize(m);\n        for (auto &amp;k: sup[i])\n            scanf(\"%d\", &amp;k);\n    }\n    vector&lt;int&gt; crt(sup[0]), nxt;\n    cnt = (crt.empty());\n    while (!cnt)\n    {\n        t *= r;\n        for (auto &amp;k: crt)\n        {\n            cnt += (sup[k].empty());\n            nxt.insert(nxt.end(), sup[k].begin(), sup[k].end());\n        }\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    }\n    printf(\"%.4f %d\", p * t, cnt);\n}\n","slug":"「1106」Lowest-Price-in-Supply-Chain","date":"2022-11-10T06:44:17.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,BFS,Tree","author_index":"Starlit Rover"},{"id":"9fd6e61746966814315473dc06fd52de","title":"「1105」Spiral Matrix","content":"This time your job is to fill a sequence of N positive integers into a spiral matrix in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix has m rows and n columns, where m and n satisfy the following: m×n must be equal to N; m≥n; and m−n is the minimum of all the possible values.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N. Then the next line contains N positive integers to be filled into the spiral matrix. All the numbers are no more than . The numbers in a line are separated by spaces.\nOutput Specification:For each test case, output the resulting matrix in m lines, each contains n numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.\nSample Input:12\n37 76 20 98 76 42 53 95 60 81 58 93\n\nSample Output:98 95 93\n42 37 81\n53 20 76\n58 60 76\n\n\nΩ输出一个数组的降序（顺时针）旋转矩阵，要求。\n首先确定，从开始往下枚举，找到的第一个N的因子即为。然后每次顺时针遍历一圈给旋转矩阵赋值，由外向内深入，但需要注意的是有时一圈会退化成一条边，不要重复赋值，否则会越界访问原始数组。当然简单一点可以每次都检查一下idx是否越界。\n\n🐎#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int r, n, m;\n    cin &gt;&gt; r;\n    int seq[r];\n    for (auto &amp;k: seq)\n        cin &gt;&gt; k;\n    sort(seq, seq + r, greater());\n    for (n = int(sqrt(r)); n &gt; 1; --n)\n        if (r % n == 0) break;\n    m = r / n;\n    int mtx[m][n], l = -1, idx = -1;\n    while (++l &lt; (n + 1) / 2)\n    {\n        for (int i = l; i &lt; n - l; ++i)\n            mtx[l][i] = seq[++idx];\n        for (int i = l + 1; i &lt; m - l; ++i)\n            mtx[i][n - l - 1] = seq[++idx];\n        for (int i = n - l - 2; i &gt;= l; --i)\n            mtx[m - l - 1][i] = seq[++idx];\n        if (l != n / 2)\n            for (int i = m - l - 2; i &gt; l; --i)\n                mtx[i][l] = seq[++idx];\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        printf(\"%d\", mtx[i][0]);\n        for (int j = 1; j &lt; n; ++j)\n            printf(\" %d\", mtx[i][j]);\n        printf(\"\\n\");\n    }\n}\n\n之所以只对竖边检查即可（if (l != n / 2)）是因为，因此只可能退化为一个点（）或是一条竖边（），而不会出现退化横边。而退化成一个点时，后两者for循环都不会进入，因此仅考虑竖边即可。嫌麻烦就每次都检查idx是否越界。\n","slug":"「1105」Spiral-Matrix","date":"2022-11-02T15:21:40.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"032852f306632572219a0e57a789cd37","title":"「1104」Sum of Number Segments","content":"Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4).\nNow given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than . The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space.\nOutput Specification:For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places.\nSample Input:4\n0.1 0.2 0.3 0.4\n\nSample Output:5.00\n\n\nΩ输出一个数组所有连续子串之和之和，可以认为是把所有连续子串中出现的数字加起来。\n很显然，我们只需要统计每个数字出现了几次，考虑第个数（从0开始数），首先以该数字开头的子串共有个，而以第个数开头并包含第个数的连续子串个数都是，因此第个数共计出现次。最终答案即为\n\n本以为又是水题一道，没想到case 2绿的晃眼。看了半天找不出什么错误，冥冥之中估计又是四舍五入或者是精度的问题。参阅了一些博客之后，发现确实是double的问题。C语言浮点数存储是参照IEEE 754的，简单地说就是由一位符号位(S)和固定位数的阶码(E)、尾数(f)组成。由于尾数位数有限，因此在阶码较大时低位的数字根本无法存储从而造成了精度的损失，而且数字越大损失越大。有兴趣可以看看纠正测试数据这位同学的博客由一道 OJ 引发的关于 double 类型的一些思考。\n想在本题内解决这个问题并不难，只要将double左移3位转存long long，最后再/1000.0即可，不过这只能算缓兵之计。如果想要做到0误差可能就需要实现一个大数类，这不经让我想起了大一做的个大作业：高精度实数运算，是用链表实现了一个大数类，算是用空间换精度，闲来无事可以瞅瞅。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    double k;\n    long long ans = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        ans += (long long)(k * 1000) * (n - i) * (i + 1)  ;\n    }\n    printf(\"%.2lf\", ans/1000.0);\n}\n","slug":"「1104」Sum-of-Number-Segments","date":"2022-11-02T08:58:20.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"4ef3e4e200e4b84799be544dd9cdda17","title":"「1103」Integer Factorization","content":"The K−P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K−P factorization of N for any positive integers N, K and P.\n\n\nInput Specification:Each input file contains one test case which gives in a line the three positive integers N (≤400), K (≤N) and P (1&lt;P≤7). The numbers in a line are separated by a space.\nOutput Specification:For each case, if the solution exists, output in the format:\nN = n[1]^P + ... n[K]^P\n\nwhere n[i] (i = 1, …, K) is the i-th factor. All the factors must be printed in non-increasing order.\nNote: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122+42+22+22+12, or 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen – sequence  is said to be larger than  if there exists  such that  for  and ​.\nIf there is no solution, simple output Impossible.\nSample Input 1:169 5 2\n\nSample Output 1:169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2\n\nSample Input 2:169 167 3\n\n\nΩ给定，将分解为，满足。\n一开始没什么头绪，就想着枚举呗，但从哪开始枚举呢。\n首先题目要求如果有多个解则优先选择更大的解，如果也相等则选择第一个不同factor更大的解，我们也认为这个解&gt;另一个解。为了可以少判断一个选择条件，我们直接从最大解开始遍历，这样先遇到的可行解就肯定是更大的。首先可以肯定，因此我们可以将作为最大的初始（不一定可行）解向量，然后向下遍历。\n我们规定表示解向量中最后一个非零元素的引用，表示解向量中的非零元素的个数， ，，表示目前最大的s，表示将v的第一个0元素改为t，表示将下一个可行解赋给，然后制定如下遍历规则：\n\n\n\n\n\n：更新最优解，，\n\n：\n\n\n\n：\n\n\n\n\n\n：\n\n：\n\n\n\n\n简单地说，如果没到K个factor就继续加入最大可能的factor，到了K个就看factor的P方和是否为N，若m=0那么就看这个解是否更优，s更大的话就更新最优解。\n主体部分已经确定了，那么应该如何实现呢。直接的想法就是对最后一个非零元素减1，⚠️如果减到0了就必须对再前一个factor减1，否则将会重新遍历这段过程，陷入死循环。但我们还可以做出一些优化。首先，注意到在的时候肯定会执行，此时最后一个元素不管减多少肯定，不可能产生可行解，因此可以直接把删除，对倒数第二个factor减1。而时就不能直接把删除，就执行正常减1。同时别忘更新。\n至此就差不多了，接下来做一些优化。注意到这种题目中会用到很多pow函数，但pow函数效率令人堪忧，一种常见的办法是自己实现一下简单的myPow函数，但是这一题我们注意到，因此我们只会求以内整数的P次方，那么就可以直接打表，用一个vector存储1-的P次方即可。另外当时就说明接下来所遍历的解不可能产生可行解，直接跳过，而我们可以用之前的P次方vector外加二分查找快速找到。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, k, p, s, s_max = 0, m;\nvector&lt;int&gt; power{0, 1};\n\ninline int nth_root(int a)\n{\n    int left = 1, right = power.size(), mid;\n    while (left &lt; right - 1)\n    {\n        mid = (left + right) / 2;\n        if (power[mid] &gt; a) right = mid;\n        else left = mid;\n    }\n    return left;\n}\n\n// eliminate the last factor and minus 1\ninline void next(vector&lt;int&gt; &amp;sol)\n{\n    s -= sol.back(), m += power[sol.back()];\n    sol.pop_back();\n    while (!sol.empty() &amp;&amp; sol.back() == 1)\n    {\n        m += 1, s -= 1;\n        sol.pop_back();\n    }\n    while (!sol.empty())\n    {\n        sol.back() -= 1, s -= 1;\n        m += power[sol.back() + 1] - power[sol.back()];\n        if (power[sol.back()] * (k - sol.size()) &lt; m)\n        {\n            m += power[sol.back()];\n            s -= sol.back();\n            sol.pop_back();\n        }\n        else break;\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &amp;n, &amp;k, &amp;p);\n    for (int i = 2; power.back() &lt; n; ++i)\n    {\n        int otc = i;\n        for (int j = 1; j &lt; p; ++j) otc *= i;\n        power.push_back(otc);\n    }\n    vector&lt;int&gt; opt, tmp{nth_root(n)};\n    m = n - power[tmp.back()];\n    s = tmp.back();\n    while (!tmp.empty())\n    {\n        if (tmp.size() == k)\n        {\n            if (m == 0 &amp;&amp; s &gt; s_max)\n            {\n                s_max = s;\n                opt = tmp;\n            }\n            next(tmp);\n        }\n        else if (m &gt; 0)\n        {\n            tmp.push_back(min(tmp.back(), nth_root(m)));\n            m -= power[tmp.back()];\n            s += tmp.back();\n        }\n        else\n        {\n            tmp.push_back(0);\n            next(tmp);\n        }\n    }\n    if (s_max == 0) printf(\"Impossible\");\n    else\n    {\n        printf(\"%d = %d^%d\", n, opt[0], p);\n        for (int i = 1; i &lt; opt.size(); ++i)\n            printf(\" + %d^%d\", opt[i], p);\n    }\n}\n","slug":"「1103」Integer-Factorization","date":"2022-11-02T02:26:51.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"11aaeea099b9cb0ef7fb12c65a5510db","title":"「1102」Invert a Binary Tree","content":"The following is from Max Howell @twitter:\nGoogle: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off.\n\nNow it’s your turn to prove that YOU CAN invert a binary tree!\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node from 0 to N−1, and gives the indices of the left and right children of the node. If the child does not exist, a - will be put at the position. Any pair of children are separated by a space.\nOutput Specification:For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.\nSample Input:8\n1 -\n- -\n0 -\n2 7\n- -\n- -\n5 -\n4 6\n\nSample Output:3 7 2 6 4 0 5 1\n6 5 7 4 3 2 0 1\n\n\nΩ输出反转二叉树的层次和中序遍历。\n没什么难度，就是把二叉树的左右节点都互换一下。\n根节点的确定只要看哪个节点没父节点即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; son;\nvector&lt;int&gt; in;\n\nvoid in_order(int root)\n{\n    if (root == -1) return;\n    in_order(son[root].second);\n    in.push_back(root);\n    in_order(son[root].first);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    son.resize(n);\n    string l, r;\n    int root = (n - 1) * n / 2;\n    for (auto &amp;k: son)\n    {\n        cin &gt;&gt; l &gt;&gt; r;\n        k.first = (l == \"-\" ? -1 : (root -= stoi(l), stoi(l)));\n        k.second = (r == \"-\" ? -1 : (root -= stoi(r), stoi(r)));\n    }\n    cout &lt;&lt; root;\n    vector&lt;int&gt; crt{3}, nxt;\n    do\n    {\n        for (auto k: crt)\n        {\n            if (son[k].first != -1) nxt.push_back(son[k].first);\n            if (son[k].second != -1) nxt.push_back(son[k].second);\n        }\n        for (int i = int(nxt.size() - 1); i &gt;= 0; --i)\n            cout &lt;&lt; \" \" &lt;&lt; nxt[i];\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    } while (!crt.empty());\n    cout &lt;&lt; endl;\n    in_order(root);\n    cout &lt;&lt; in[0];\n    for (int i = 1; i &lt; n; ++i)\n        cout &lt;&lt; \" \" &lt;&lt; in[i];\n}\n","slug":"「1102」Invert-a-Binary-Tree","date":"2022-10-29T12:36:57.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,BFS,traversal order,Tree","author_index":"Starlit Rover"},{"id":"4d3cc8d027fb9a0d2261e74e193155cc","title":"「1101」Quick Sort","content":"There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?\nFor example, given N=5 and the numbers 1, 3, 2, 4, and 5. We have:\n\n1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;\n3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;\n2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;\nand for the similar reason, 4 and 5 could also be the pivot.\n\nHence in total there are 3 pivot candidates.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer . Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces.\nOutput Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.\nSample Input:5\n1 3 2 4 5\n\nSample Output:3\n1 4 5\n\n\nΩ在快速排序中经常需要设定一个，我们把放它左边，的放它右边，然后递归分治。那么给出一个快排序列，请输出其中的哪些数可能是。\n比较简单，首先可以肯定的一点是所处的位置一定和排序后的位置相同，因此我们先对原序列sort一下，然后从头开始遍历，如果当前位置元素与排序后元素不同就直接跳过（⚠️跳过时别忘记录当前最大值），否则比较左边最大元素与当前元素的大小，如果小于当前元素就说明比它小的数都在左边，那么就是，然后更新当前（左边）最大元素。\n由于们所处位置就是排序后的位置，因此从头开始遍历一定是按照升序压入的，最后就无需sort了，按顺序输出即可。\no，有个极其离谱的测试点（case 2），就是0的时候需要回车两次，也就是需要把列举pivot的那一列空出来，不知道咋想的，孩子已经很久没有Presentation Error了（−＿−#）。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, left_max = -1;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; seq(n);\n    for (auto &amp;k: seq)\n        cin &gt;&gt; k;\n    vector&lt;int&gt; copy(seq), ans;\n    sort(copy.begin(), copy.end());\n    for (int i = 0; i &lt; n; ++i)\n    {\n        left_max = max(left_max, seq[i]);\n        if (copy[i] != seq[i]) continue;\n        if (left_max &lt;= seq[i]) ans.push_back(seq[i]);\n    }\n    if (ans.empty()) printf(\"0\\n\\n\");\n    else\n    {\n        printf(\"%zu\\n%d\", ans.size(), ans[0]);\n        for (int i = 1; i &lt; ans.size(); ++i)\n            printf(\" %d\", ans[i]);\n    }\n}\n","slug":"「1101」Quick-Sort","date":"2022-10-29T09:44:37.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"f3192472433d930fd2273aca0588815b","title":"「1100」Mars Numbers","content":"People on Mars count their numbers with base 13:\n\nZero on Earth is called “tret” on Mars.\nThe numbers 1 to 12 on Earth is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.\nFor the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.\n\nFor examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.\nOutput Specification:For each number, print in a line the corresponding number in the other language.\nSample Input:4\n29\n5\nelo nov\ntam\n\nSample Output:hel mar\nmay\n115\n13\n\n\nΩ火星上面不用字母，谢谢。\n给地球和火星翻译数字，假设火星上的数字是13进制的，而且最多两位，而且每一位的数字表示都不同，另有以下规则：\n\n0需要单独输出“tret”\n\n某位上的数字为0时不输出\n\n如果两位都输出中间必须有空格\n\n\n真的很讨厌这种分类讨论题，一不小心就把所有坑都踩了一遍。首先根据读入的一行字符串第一个字符是否为数字来判断是火星数字还是地球数字。\n如果是地球数字，分别对13进行除和取余操作，空格需要在两者都不为0时出现，⚠️0需单独输出；如果是火星数字，判断是否含空格，有空格就分别查找对应的数字，无空格时要对两位上的火星数字表示都查找一遍，⚠️“tret”。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;string&gt; high{\"\", \"tam\", \"hel\", \"maa\", \"huh\", \"tou\", \"kes\", \"hei\", \"elo\", \"syy\", \"lok\", \"mer\", \"jou\"},\n                   low{\"\", \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jly\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"};\n    int n;\n    cin &gt;&gt; n;\n    getchar();\n    string s;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        getline(cin, s);\n        if (isdigit(s[0]))\n        {\n            int k = stoi(s);\n            if (k) cout &lt;&lt; high[k / 13] &lt;&lt; (k % 13 &amp;&amp; k / 13 ? \" \" : \"\") &lt;&lt; low[k % 13] &lt;&lt; endl;\n            else cout &lt;&lt; \"tret\\n\";\n        }\n        else\n        {\n            int space = s.find(' ');\n            if (space == string::npos)\n            {\n                if (s == \"tret\") cout &lt;&lt; \"0\\n\";\n                else\n                {\n                    int k = int(find(low.begin(), low.end(), s) - low.begin());\n                    cout &lt;&lt; (k == low.size() ? 13 * (find(high.begin(), high.end(), s) - high.begin()) : k) &lt;&lt; endl;\n                }\n            }\n            else\n            {\n                int a = int(find(high.begin(), high.end(), s.substr(0, space)) - high.begin()),\n                        b = int(find(low.begin(), low.end(), s.substr(space + 1, s.size() - space - 1)) - low.begin());\n                cout &lt;&lt; a * 13 + b &lt;&lt; endl;\n            }\n        }\n    }\n}\n","slug":"「1100」Mars-Numbers","date":"2022-10-28T16:15:14.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"e3cd66a2f1f386d336b0cf25b87033ab","title":"「1099」Build A Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nGiven the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format left_index right_index, provided that the nodes are numbered from 0 to N−1, and 0 is always the root. If one child is missing, then −1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line.\nOutput Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.\nSample Input:9\n1 6\n2 3\n-1 -1\n-1 4\n5 -1\n-1 -1\n7 -1\n-1 8\n-1 -1\n73 45 11 58 82 25 67 38 42\n\nSample Output:58 25 82 11 38 67 45 73 42\n\n\nΩ给出二叉搜索树（BST）的结构与一个无序数组，输出将这个数组放入该结构BST的层次遍历结果。\n很显然，我们只要知道了BST中每个节点在排序结果中的序号即可，比如最左边的节点是最小的，因此排序序号为0，根据BST的性质可知排序序号就是左子树的节点个数。那么我们对BST进行中序遍历就能得到每个节点的排序序号，再对进行排序，根据在排序序列中的序号放入相应的BST节点，最后BFS遍历输出节点即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; idx; // sort index\nvector&lt;pair&lt;int, int&gt;&gt; son;\n\nvoid make_idx(int r) // In-Order Traversal\n{\n    static int i = 0;\n    if (son[r].first != -1)\n        make_idx(son[r].first);\n    idx[r] = i++;\n    if (son[r].second != -1)\n        make_idx(son[r].second);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    son.resize(n);\n    for (auto &amp;s: son)\n        cin &gt;&gt; s.first &gt;&gt; s.second;\n    idx.resize(n);\n    make_idx(0);\n    vector&lt;int&gt; seq(n);\n    for (auto &amp;k: seq)\n        cin &gt;&gt; k;\n    sort(seq.begin(), seq.end());\n    vector&lt;int&gt; crt{0}, nxt;\n    cout &lt;&lt; seq[idx[0]];\n    do\n    {\n        for (auto &amp;k: crt)\n        {\n            if (son[k].first != -1) nxt.push_back(son[k].first);\n            if (son[k].second != -1) nxt.push_back(son[k].second);\n        }\n        for (auto &amp;k: nxt)\n            cout &lt;&lt; \" \" &lt;&lt; seq[idx[k]];\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    } while (!crt.empty());\n}\n","slug":"「1099」Build-A-Binary-Search-Tree","date":"2022-10-27T12:04:57.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search,BFS,Tree","author_index":"Starlit Rover"},{"id":"1055437ed759d1b58da767b6a5e1ca44","title":"「1098」Insertion or Heap Sort","content":"According to Wikipedia:\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nHeap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n\nSample Output 1:Insertion Sort\n1 2 3 5 7 8 9 4 6 0\n\nSample Input 2:10\n3 1 2 8 7 5 9 4 6 0\n6 4 5 1 0 3 2 7 8 9\n\nSample Output 2:Heap Sort\n5 4 3 1 0 2 6 7 8 9\n\n\n🐎好坏啊，知道有sort函数，就专搞部分排序。给出部分排序序列，判断是插入排序还是堆排序，并输出下一步后的排序结果。每次都有插入排序的友情参演，每次都是陪衬其他排序算法，好惨。\n判断方式、插入排序的处理和一个弥天大坑参照「1089」Insert or Merge ，第一次写堆排序，脑子跟盘古开天辟地一样。堆排序的底层数据结构是二叉树，根据根节点和子节点的大小关系可以分为大顶堆（father&gt;sons）和小顶堆（father&lt;sons）。以大顶堆为例，每次都把二叉树分为只有两层（只有父亲和最多两个儿子）的小子堆，然后从最后一个小堆开始，把小堆中最大的节点与根节点进行互换，从后往前做完后整棵二叉树的根节点就是最大的元素。然后把这个最大的元素放到最后一个位置上（与最后一个元素互换），并将二叉树的节点个数-1，即最后的位置不参与接下来的排序。最后二叉树的层次遍历结果就是升序排列。\n⚠️在互换小堆的父子节点时，如果这个子节点是另一个小堆的父节点，那么应该递归向下调整，直到没有子节点或者无需交换为止。\n事实上，我们可以注意到，在第一次调整完毕后，接下来的每次调整都无需从后往前依次调整，因为我们只交换了根节点与最后一个节点，而不满足大/小顶堆的只可能是根节点，因此只需从根节点向下递归调整即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ninline void heap_down(vector&lt;int&gt; &amp;heap, int r, int end)\n{\n    int max_r = (end - 1) / 2, j;\n    while (r &lt;= max_r)\n    {\n        if (2 * r + 2 &lt;= end)\n            j = (heap[2 * r + 2] &gt; heap[2 * r + 1] ? 2 * r + 2 : 2 * r + 1);\n        else if (2 * r + 1 &lt;= end)\n            j = 2 * r + 1;\n        if (heap[j] &gt; heap[r])\n        {\n            swap(heap[j], heap[r]);\n            r = j;\n        }\n        else break;\n    }\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; org(n), crt(n);\n    for (auto &amp;k: org)\n        cin &gt;&gt; k;\n    for (auto &amp;k: crt)\n        cin &gt;&gt; k;\n    int t = n - 1;\n    while (t &gt;= 0 &amp;&amp; crt[t] == org[t]) --t;\n    if (t == -1)\n    {\n        t = 0;\n        while (t &lt; n &amp;&amp; crt[t] &lt;= crt[t + 1]) ++t;\n    }\n    vector&lt;int&gt; copy(org);\n    sort(copy.begin(), copy.begin() + t + 1);\n    bool isHeap = false;\n    for (int i = 0; i &lt; n &amp;&amp; (copy[i] == crt[i] || (isHeap = true, false)); ++i);\n    cout &lt;&lt; (isHeap ? \"Heap\" : \"Insertion\") &lt;&lt; \" Sort\\n\";\n    if (isHeap)\n    {\n        int end = n - 1, max_r = n - 1;\n        for (int i = max_r; i &gt;= 0; --i)\n            heap_down(org, i, end);\n        while (--end, copy != crt)\n        {\n            copy = org;\n            swap(org[0], org[end + 1]);\n            heap_down(org, 0, end);\n        }\n    }\n    else\n        sort(org.begin(), org.begin() + t + 2);\n    for (int i = 0; i &lt; n; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; org[i];\n}\n\nmax_r是拥有儿子的最大节点编号，&gt;max_r的节点就无需调整。\n","slug":"「1098」Insertion-or-Heap-Sort","date":"2022-10-27T05:01:24.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,heap","author_index":"Starlit Rover"},{"id":"ffc78994f12cf87b4b6e2fe952701b6e","title":"「1097」Deduplication on a Linked List","content":"Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive  which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Key Next\n\nwhere Address is the position of the node, Key is an integer of which absolute value is no more than 104, and Next is the position of the next node.\nOutput Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 5\n99999 -7 87654\n23854 -15 00000\n87654 15 -1\n00000 -15 99999\n00100 21 23854\n\nSample Output:00100 21 23854\n23854 -15 99999\n99999 -7 -1\n00000 -15 87654\n87654 15 -1\n\n\nΩ对一个链表进行绝对值去重，即将绝对值与前面节点重复的节点单独取出组成一个新的链表，最后输出两个链表。\n首先读入所有节点，然后用一个map&lt;int,bool&gt;记录出现过的节点key，再用两个vector&lt;string,int&gt;来模拟链表，最后直接按顺序输出即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    string head, crt, nxt;\n    cin &gt;&gt; head &gt;&gt; n;\n    map&lt;string, pair&lt;int, string&gt;&gt; node;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; crt &gt;&gt; m &gt;&gt; nxt;\n        node[crt] = make_pair(m, nxt);\n    }\n    map&lt;int, bool&gt; flag;\n    crt = head;\n    vector&lt;pair&lt;string, int&gt;&gt; stay, rmv;\n    while (crt != \"-1\")\n    {\n        if (flag[abs(node[crt].first)])\n            rmv.emplace_back(crt, node[crt].first);\n        else\n        {\n            stay.emplace_back(crt, node[crt].first);\n            flag[abs(node[crt].first)] = true;\n        }\n        crt = node[crt].second;\n    }\n    stay.emplace_back(\"-1\", 0), rmv.emplace_back(\"-1\", 0);\n    for (int i = 0; i &lt; stay.size() - 1; ++i)\n        printf(\"%s %d %s\\n\", stay[i].first.c_str(), stay[i].second, stay[i + 1].first.c_str());\n    for (int i = 0; i &lt; rmv.size() - 1; ++i)\n        printf(\"%s %d %s\\n\", rmv[i].first.c_str(), rmv[i].second, rmv[i + 1].first.c_str());\n}\n","slug":"「1097」Deduplication-on-a-Linked-List","date":"2022-10-26T15:57:17.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,string,list","author_index":"Starlit Rover"},{"id":"4284065e5cb88855913cdeb3766387e3","title":"「1096」Consecutive Factors","content":"Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors.\n\n\nInput Specification:Each input file contains one test case, which gives the integer .\nOutput Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format factor[1]*factor[2]*...*factor[k], where the factors are listed in increasing order, and 1 is NOT included.\nSample Input:630\n\nSample Output:3\n5*6*7\n\n\nΩ输出一个数最长的连续因子串，因子串的乘积可以整除。\n想不出什么精妙的解法，单纯从2到开始枚举，如果这个数是的因子就往后连续枚举直到不能整除为止，然后看这因子串长度是否超过了目前为止的最大长度。\n起初有个想法，就是如果我找到了一个满足题意的局部最长因子串，那么下一次我是不是就可以直接从开始枚举了，因为（根据局部最长可知）。仔细推敲后就会发现是错的，比如说60，从2开始枚举只能得到，如果跳过3、4直接从5开始枚举就会错过这个最优解。本质原因是因为前面的因子可能会占用后面数的因子才导致无法整除，这里就是2占用了4的一个2因子才导致无法整除。如果题目求的是连续质因子串就没问题了。\n\n🐎#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n;\n    int m, len, max_len = 0, start = n;\n    for (int i = 2; i &lt;= sqrt(n); ++i)\n    {\n        m = n, len = 0, k = i;\n        while (m % k == 0)\n        {\n            m /= k++;\n            ++len;\n        }\n        max_len = (len &gt; max_len) ? (start = i, len) : max_len;\n    }\n    max_len = max_len == 0 ? 1 : max_len;\n    printf(\"%d\\n%d\", max_len, start);\n    for (int i = 1; i &lt; max_len; ++i)\n        printf(\"*%d\", start + i);\n}\n","slug":"「1096」Consecutive-Factors","date":"2022-10-25T07:31:44.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"ba694c9323b17ea3ea3e3b2ebd47bf82","title":"「1095」Cars on Campus","content":"Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.\n\n\nInput Specification:Each input file contains one test case. Each case starts with two positive integers , the number of records, and  the number of queries. Then N lines follow, each gives a record in the format:\nplate_number hh:mm:ss status\n\nwhere plate_number is a string of 7 English capital letters or 1-digit numbers; hh:mm:ss represents the time point in a day by hour:minute:second, with the earliest time being 00:00:00 and the latest 23:59:59; and status is either in or out.\nNote that all times will be within a single day. Each in record is paired with the chronologically next record for the same car provided it is an out record. Any in records that are not paired with an out record are ignored, as are out records not paired with an in record. It is guaranteed that at least one car is well paired in the input, and no car is both in and out at the same moment. Times are recorded using a 24-hour clock.\nThen K lines of queries follow, each gives a time point in the format hh:mm:ss. Note: the queries are given in ascending order of the times.\nOutput Specification:For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.\nSample Input:16 7\nJH007BD 18:00:01 in\nZD00001 11:30:08 out\nDB8888A 13:00:00 out\nZA3Q625 23:59:50 out\nZA133CH 10:23:00 in\nZD00001 04:09:59 in\nJH007BD 05:09:59 in\nZA3Q625 11:42:01 out\nJH007BD 05:10:33 in\nZA3Q625 06:30:50 in\nJH007BD 12:23:42 out\nZA3Q625 23:55:00 in\nJH007BD 12:24:23 out\nZA133CH 17:11:22 out\nJH007BD 18:07:01 out\nDB8888A 06:30:50 in\n05:10:00\n06:30:50\n11:00:00\n12:23:42\n14:00:00\n18:00:00\n23:59:00\n\nSample Output:1\n4\n5\n2\n1\n0\n1\nJH007BD ZD00001 07:20:09\n\n\nΩ给浙大停车场写个计数统计小程序。给出N条汽车进出记录，然后对K个时间点输出当前停车场内的汽车数量，最后输出当天内停车时间最长的所有车牌号，以及相应的停车时间。妈妈再也不用担心我进浙大啦～浙大保安：我用脚趾头都数得出来，抢我饭碗，滚\n首先有以下几个注意点：\n\n一辆车一天内可能有多次进出记录\n\n进出记录只有在时间轴上相邻才可以匹配（即in记录下一个时间点记录为out），忽略无法匹配的记录\n\n记录输入的顺序不是时间顺序，时间点查询则是按照时间顺序\n\n\n首先所有涉及到时间的值全都换算成s。由于记录是无序输入，所以起初不能确定哪些记录需要忽略，因此每辆车的记录都用一个set&lt;pair&lt;int,bool&gt;&gt;来存储进出（true/false）的时间戳，外面再套一个map以便用车牌号查询。\n因为要统计某个时间点校内汽车数量，因此我们需要一个全局时间戳变量vector&lt;pair&lt;int,bool&gt;&gt; stamp存储所有汽车进出记录，只统计数量就无需存储车牌号。\n在所有记录都读取完成后，就对每个车辆能成功匹配（out记录前一个是否为in记录）的记录对的进出时间点存入stamp，顺便用一个map统计停车时长。\n存完后对stamp排个序，接着就可以读入查询时间点t了，对t时刻前的记录进行计数，如果是in就+1，out则-1。注意到查询时间点是按照时间顺序的，因此无序回退，遍历一次stamp足矣。\n最后遍历一遍停车时长map，找到停最久的那几辆车，输出即可。\n一遍过，似乎没什么大坑，测试样例已经涵盖很多注意点了。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, h, m, s, t;\n    cin &gt;&gt; n &gt;&gt; k;\n    map&lt;string, set&lt;pair&lt;int, bool&gt;&gt;&gt; record;\n    string p(7, 0), st(3, 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d:%d:%d %s\", &amp;p[0], &amp;h, &amp;m, &amp;s, &amp;st[0]);\n        t = 3600 * h + 60 * m + s;\n        record[p].emplace(t, st[0] == 'i');\n    }\n    vector&lt;pair&lt;int, bool&gt;&gt; stamp;\n    map&lt;string, int&gt; time;\n    for (auto &amp;r: record)\n    {\n        int pre = -1;\n        for (auto &amp;w: r.second)\n        {\n            if (w.second) pre = w.first;\n            else if (pre &gt; -1)\n            {\n                stamp.emplace_back(pre, true);\n                stamp.emplace_back(w.first, false);\n                time[r.first] += (w.first - pre);\n                pre = -1;\n            }\n        }\n    }\n    sort(stamp.begin(), stamp.end());\n    int idx = 0, cnt = 0;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        scanf(\"%d:%d:%d\", &amp;h, &amp;m, &amp;s);\n        t = 3600 * h + 60 * m + s;\n        while (idx &lt; stamp.size() &amp;&amp; stamp[idx].first &lt;= t)\n        {\n            cnt += stamp[idx].second ? 1 : -1;\n            ++idx;\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    int max_t = 0;\n    set&lt;string&gt; plt;\n    for (auto &amp;w: time)\n    {\n        if (w.second &gt; max_t)\n        {\n            plt.clear();\n            plt.emplace(w.first);\n            max_t = w.second;\n        }\n        else if (w.second == max_t)\n            plt.emplace(w.first);\n    }\n    for (auto &amp;w: plt)\n        printf(\"%s \", w.c_str());\n    printf(\"%02d:%02d:%02d\", max_t / 3600, max_t % 3600 / 60, max_t % 60);\n}\n","slug":"「1095」Cars-on-Campus","date":"2022-10-25T03:42:18.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,sort,set","author_index":"Starlit Rover"},{"id":"aee00b96e421a4a9f4457610d24d4237","title":"「1094」The Largest Generation","content":"A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population.\n\n\nInput Specification:Each input file contains one test case. Each case starts with two positive integers N (&lt;100) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 to N), and M (&lt;N) which is the number of family members who have children. Then M lines follow, each contains the information of a family member in the following format:\nID K ID[1] ID[2] ... ID[K]\n\nwhere ID is a two-digit number representing a family member, K (&gt;0) is the number of his/her children, followed by a sequence of two-digit ID‘s of his/her children. For the sake of simplicity, let us fix the root ID to be 01. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1.\nSample Input:23 13\n21 1 23\n01 4 03 02 04 05\n03 3 06 07 08\n06 2 12 13\n13 1 21\n08 2 15 16\n02 2 09 10\n11 2 19 20\n17 1 22\n05 1 11\n07 1 14\n09 1 17\n10 1 18\n\nSample Output:9 4\n\n\nΩ给出一个家谱树，需要输出同辈的最多人数以及相应的辈分。\n经典无脑的BFS题，每次往下遍历一个level，统计该层人数是否超过最大值，如果超过则进行标记。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, f;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt; child(n + 1);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; f &gt;&gt; k;\n        child[f].resize(k);\n        for (auto &amp;s: child[f])\n            cin &gt;&gt; s;\n    }\n    int max_pop = 1, level = 1, grt = 1;\n    vector&lt;int&gt; crt{1}, nxt;\n    while (++level, !crt.empty())\n    {\n        for (auto &amp;s: crt)\n            std::move(child[s].begin(), child[s].end(), back_inserter(nxt));\n        max_pop = max_pop &gt; nxt.size() ? max_pop : (grt = level, int(nxt.size()));\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    }\n    cout &lt;&lt; max_pop &lt;&lt; \" \" &lt;&lt; grt;\n}\n\n\nTips然后发现move函数还有一个类似insert的隐藏用法：\ntemplate&lt;class InputIt, class OutputIt&gt;\nOutputIt move(InputIt first, InputIt last, OutputIt d_first)\n{\n    while (first != last) \n    {\n        *d_first++ = std::move(*first++);\n    }\n    return d_first;\n}\n\n就是把一连续的数据move到指定位置，所以可以看到我没有用insert函数。\n","slug":"「1094」The-Largest-Generation","date":"2022-10-23T11:10:15.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,BFS,Tree","author_index":"Starlit Rover"},{"id":"fe84dbd5061bf8b532b9409db1710e96","title":"「1093」Count PAT's","content":"The string APPAPT contains two PAT‘s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.\nNow given any string, you are supposed to tell the number of PAT‘s contained in the string.\n\n\nInput Specification:Each input file contains one test case. For each case, there is only one line giving a string of no more than  characters containing only P, A, or T.\nOutput Specification:For each test case, print in one line the number of PAT‘s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.\nSample Input:APPAPT\n\nSample Output:2\n\n\nΩ计数一个字符串中有几个PAT，字符可以重复使用。\n从后往前遍历字符串，设置三个计数变量sum_T,sum_AT,sum_PAT，字如其名，每经过一个T时sum_T+=1，每经过一个A时sum_AT+=sum_T，每经过一个P时sum_PAT+=sum_AT，原理很显然，就是直接统计每个A后面有几个T来计数AT，每个P后有几个AT来计数PAT。\n第一次提交后面两个测试点绿了，因为我只在最后模了一次1000000007，中间过程会发生溢出，所以每加一次就模一次。\n\n🐎#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin &gt;&gt; s;\n    int sum_T = 0, sum_AT = 0, sum_PAT = 0;\n    reverse(s.begin(), s.end());\n    for (auto &amp;c: s)\n    {\n        sum_T += (c == 'T');\n        sum_AT += (c == 'A') * sum_T;\n        sum_PAT = (sum_PAT + (c == 'P') * sum_AT) % 1000000007;\n    }\n    cout &lt;&lt; sum_PAT;\n}\n","slug":"「1093」Count-PAT-s","date":"2022-10-23T10:24:59.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"075a9a10b3dedbd22ddf3f7a1ad6394e","title":"0-1多背包带约束问题（MKAR）","content":"本文其实与智能算法无关，这是最优化课程的一个小作业，之所以放在智能算法一栏，是因为这个问题的大部分解法都是智能算法。下面出场的是背包问题的一个变种——带约束的多背包问题，这个问题的精确算法复杂度极高，所以一般退而求其次寻找拥有固定近似比的近似算法，本文求解采取的则是一种基于DP动态规划的近似算法，巧妙的并不是算法本身，算法也不能保证求出最优解，精华在于近似比的证明部分，这一部分证明我参考了相关文献，分享给大家细细品味。\n\n\n\n\n❖ 问题描述\n有个物品，每个物品的重量为，另有个背包，每个背包的容量为，另外每个物品有放入限制，则表明物品可以放入背包中，则不能，因此是一个的矩阵。\n那么在不违背放入限制规则，同时每个背包内物品不超过相应容量时，如何使背包所装物品的重量最大？上述问题可以用以下数学模型来描述：\n\n\n\n\n\n\n\n\n❖ 算法描述\n\n设置是否放入标记列表isPut，初始化为False\n\n依次遍历每一个背包，记当前背包的编号为\n\n枚举出当前isPut=False且R[i][j]=1的所有物品集item\n\n利用DP动态规划求出从item中取出物品放入背包的最优解，并将取出物品的isPut标记为True（表示前个物品能放入容量为背包的最大重量）\n\n\n回到求解下一背包\n\n\n\n\n❖ 近似比证明\n\n\n上述算法求得的目标函数值. \n\nProve\n我们假设上述算法执行的目标结果为，且背包中的物品重量之和为，而该算法中没有被放置于任何背包的物品集为，接下来证明其余任何可行解从中取出放入背包的物品重量总和。\n【反证法】 假设存在一个可行解，使得，那么总有一个背包内的物品重量之和，即背包里面存在一个物品集有。注意到DP动态规划求得的是最优解，即是当时剩下物品放入背包的最优方案，而中的物品在上述算法中没有被放入任何背包，从而可以将中物品放入背包获得更优解，矛盾！从而得证。\n另外从外放入背包的物品总量最多即为，从而背包总量。\n\n\n❖ 求解结果\n\n\n\n\n\n\n\n背包\n放入物品编号\n背包内物品重量之和\n背包容量\n\n\n\n0\n2, 5, 6, 11, 12, 13\n866\n866\n\n\n1\n3, 14, 16, 19, 20, 22\n908\n908\n\n\n2\n1, 7, 10, 18, 21, 24, 30, 31\n1361\n1361\n\n\n3\n4, 9, 15, 17, 23, 26, 33\n559\n559\n\n\n4\n8, 27, 28, 32, 36, 39, 40, 42, 47, 49\n1216\n1216\n\n\n5\n29, 35, 38, 41, 51, 52\n983\n983\n\n\n6\n25, 34, 37, 53, 54, 55\n1111\n1111\n\n\n7\n71, 72, 80, 83\n300\n300\n\n\n8\n46, 50, 56, 57, 63\n857\n857\n\n\n9\n44, 48, 58, 61, 62, 64, 70\n1462\n1462\n\n\n\n\n问题Sample下载： 多背包问题.\n所有背包均装满，可以确定是最优解。\n\n\n❖ 总结\n事实上根据证明过程可以看出，任意一个能够求出0-1单背包问题最优解的算法都可以替换DP算法达到1/2的下界。同时可以举例证明1/2是最优下界，如背包容量，物品重量为。最优解为，而实际运行结果可能为，两者比值\n\n由此可见，如果将物品重量从高到低排列后再进行DP求解可以优化算法结果。\n\n\n❖ C ☺ D E\nimport numpy as np\nimport pandas as pd\nfrom copy import deepcopy as dp\n\nload = np.array(pd.read_excel(\"/Users/starlitrover/Downloads/最优化/背包问题.xlsx\", header=4, usecols=range(1, 11)))\nvalue = np.array(\npd.read_excel(\"/Users/starlitrover/Downloads/最优化/背包问题.xlsx\", header=4, usecols=[11]).iloc[:,\n    0])\nsize = np.array(\npd.read_excel(\"/Users/starlitrover/Downloads/最优化/背包问题.xlsx\", usecols=range(1, 11), nrows=1).iloc[0, :])\n\nisPut = [False] * len(value)\ntotal = []\nlist = []\nfor i in range(len(size)):\n    item = []\n    for j in range(len(value)):\n        if not isPut[j] and load[j, i] == 1:\n            item.append(j)\n    f = np.zeros([len(item), size[i] + 1])\n    it = [[[] for a in range(size[i] + 1)] for b in range(len(item))]\n    for a in range(1, len(item)):\n        for b in range(value[item[a]], size[i] + 1):\n            if value[item[a]] + f[a - 1, b - value[item[a]]] &gt; f[a - 1, b]:\n                f[a, b] = value[item[a]] + f[a - 1, b - value[item[a]]]\n                it[a][b] = dp(it[a - 1][b - value[item[a]]])\n                it[a][b].append(item[a])\n            else:\n                f[a, b] = f[a - 1, b]\n                it[a][b] = dp(it[a - 1][b])\n    for k in it[len(item) - 1][size[i]]:\n        isPut[k] = True\n    if len(item) &gt; 0:\n        total.append(f[len(item) - 1, size[i]])\n        list.append(it[len(item) - 1][size[i]])\n\nPutIn=pd.DataFrame(columns=range(10),index=range(100))\nPutIn.fillna(0,inplace=True)\nfor i in range(len(list)):\n    for j in list[i]:\n        PutIn[i][j]=1\n\nprint(PutIn)\n\n\n\n❖ References\n\n[1] Approximation Algorithms for the Multiple Knapsack Problem with Assignment Restrictions\n\n[2] Chapter 6: Multiple knapsack problem , Knapsack Problems\n\n\n","slug":"0-1多背包带约束问题（MKAR）","date":"2022-10-22T13:17:44.000Z","categories_index":"智能算法","tags_index":"python,数学煎馍,动态规划","author_index":"Starlit Rover"},{"id":"a08c0b0ed5f594b2852b4c4eda7ad240","title":"「1092」To Buy or Not to Buy","content":"Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is Yes, please tell her the number of extra beads she has to buy; or if the answer is No, please tell her the number of beads missing from the string.\nFor the sake of simplicity, let’s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead.\n\nFigure 1\n\n\n\nInput Specification:Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively.\nOutput Specification:For each test case, print your answer in one line. If the answer is Yes, then also output the number of extra beads Eva has to buy; or if the answer is No, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number.\nSample Input 1:ppRYYGrrYBR2258\nYrR8RrY\n\nSample Output 1:Yes 8\n\nSample Input 2:ppRYYGrrYB225\nYrR8RrY\n\nSample Output 2:No 2\n\n\nΩ又是读题十分钟，做题几秒钟。Eva想要做五颜六色的珠珠串，奈何珠珠店老板是个坏蛋，只肯一串一串卖，现在就请你判断坏老板卖的珠珠串是否能满足Eva想要做的串，如果可以输出多了几颗珠子，反之输出少了几颗珠子。\n遍历Eva的珠珠字符串，对老板的字符串用string自带的find函数，若没找到（==string::npos）给lack+=1，否则就将其erase掉，那么最后如果lack不为0就输出lack，反之就直接输出erase完的老板珠珠串长度。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    int lack = 0;\n    size_t pos;\n    for (auto &amp;c: b)\n    {\n        if ((pos = a.find(c)) == string::npos)\n            lack += 1;\n        else\n            a.erase(pos, 1);\n    }\n    if (lack)\n        cout &lt;&lt; \"No \" &lt;&lt; lack;\n    else\n        cout &lt;&lt; \"Yes \" &lt;&lt; a.size();\n}\n","slug":"「1092」To-Buy-or-Not-to-Buy","date":"2022-10-22T13:07:25.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"2a6d9618f81bcb5d8f3a7de4f306ec7b","title":"「1091」Acute Stroke","content":"One important factor to identify acute stroke (急性脑卒中) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers: M, N, L and T, where M and N are the sizes of each slice (i.e. pixels of a slice are in an M×N matrix, and the maximum resolution is 1286 by 128); L (≤60) is the number of slices of a brain; and T is the integer threshold (i.e. if the volume of a connected core is less than T, then that core must not be counted).\nThen L slices are given. Each slice is represented by an M×N matrix of 0’s and 1’s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1’s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less than T are counted. Two pixels are connected and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.\n\nFigure 1\n\nOutput Specification:For each case, output in a line the total volume of the stroke core.\nSample Input:3 4 5 2\n1 1 1 1\n1 1 1 1\n1 1 1 1\n0 0 1 1\n0 0 1 1\n0 0 1 1\n1 0 1 1\n0 1 0 0\n0 0 0 0\n1 0 1 1\n0 0 0 0\n0 0 0 0\n0 0 0 1\n0 0 0 1\n1 0 0 0\n\nSample Output:26\n\n\nΩ统计CT切片中连续（上下左右前后相邻）部分超过T的stroke core体积总和。本质上就是求三维连通块，直接BFS或DFS。\n也无需设置isVisited标记变量，像素点为0就表示该处没有stroke或者已经访问过。\n然而用DFS递归搜索提交，后面两个测试点双双Segmentation Fault，这意味着递归调用太多了导致栈溢出。于是乎我用stack来模拟递归调用后就AC了。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;tuple&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, l, t;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; t;\n    vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; pixel(l, vector(m, vector(n, 0)));\n\n    for (int i = 0; i &lt; l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; n; ++k)\n                cin &gt;&gt; pixel[i][j][k];\n    int sum = 0;\n    for (int i = 0; i &lt; l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; n; ++k)\n            {\n                if (!pixel[i][j][k]) continue;\n                stack&lt;tuple&lt;int, int, int&gt;&gt; s;\n                s.emplace(i, j, k);\n                int piece = 0;\n                while (!s.empty())\n                {\n                    int a = get&lt;0&gt;(s.top()), b = get&lt;1&gt;(s.top()), c = get&lt;2&gt;(s.top());\n                    s.pop();\n                    if (a &lt; 0 || a &gt;= l || b &lt; 0 || b &gt;= m || c &lt; 0 || c &gt;= n || !pixel[a][b][c]) continue;\n                    pixel[a][b][c] = 0;\n                    ++piece;\n                    if (a &gt; 0) s.emplace(a - 1, b, c);\n                    if (a &lt; l - 1) s.emplace(a + 1, b, c);\n                    if (b &gt; 0) s.emplace(a, b - 1, c);\n                    if (b &lt; m - 1) s.emplace(a, b + 1, c);\n                    if (c &gt; 0) s.emplace(a, b, c - 1);\n                    if (c &lt; n - 1) s.emplace(a, b, c + 1);\n                }\n                sum += piece &gt;= t ? piece : 0;\n            }\n    cout &lt;&lt; sum;\n}\n","slug":"「1091」Acute-Stroke","date":"2022-10-22T06:47:27.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,stack,tuple,DFS","author_index":"Starlit Rover"},{"id":"a826ea08eba83fcbe604bb29b17897fe","title":"「1090」Highest Price in Supply Chain","content":"A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.\nStarting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.\nNow given a supply chain, you are supposed to tell the highest price we can expect from some retailers.\n\n\nInput Specification:Each input file contains one test case. For each case, The first line contains three positive  numbers: , the total number of the members in the supply chain (and hence they are numbered from 0 to N−1); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then the next line contains N numbers, each number  is the index of the supplier for the i-th member. Sroot​ for the root supplier is defined to be −1. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed .\nSample Input:9 1.80 1.00\n1 5 4 4 -1 4 5 3 6\n\nSample Output:1.85 2\n\n\nΩ比「1079」Total Sales of Supply Chain简单，只需要输出最大的商品出售价格和以该价格出售的商贩个数。\nObviously，就是求一棵树的最大深度以及最底层的叶子节点个数，那么BFS和DFS皆可，注意DFS不要从叶子节点往根节点遍历，这样会导致顶层部分节点和边会被多次遍历，造成大量耗时。\n我采取的是递归DFS，用全局变量max_d来表示目前为止遍历到的最大深度，num记录深度=max_d的节点个数，如果有节点深度&gt;max_d就将num置1。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint max_d = 0, num = 0;\nvector&lt;vector&lt;int&gt;&gt; rtl;\n\nvoid dfs(int r, int d)\n{\n    if (d &gt; max_d)\n    {\n        num = 1;\n        max_d = d;\n    }\n    else if (d == max_d)\n        num += 1;\n    for (auto &amp;k: rtl[r])\n        dfs(k, d + 1);\n}\n\nint main()\n{\n    int n, m, root = -1;\n    double p, r;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; r;\n    r = 1 + 0.01 * r;\n    rtl.resize(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        root = m == -1 ? i : (rtl[m].push_back(i), root);\n    }\n    dfs(root, 0);\n    printf(\"%.2f %d\", p * pow(r, max_d), num);\n}\n","slug":"「1090」Highest-Price-in-Supply-Chain","date":"2022-10-21T15:16:17.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Tree,DFS","author_index":"Starlit Rover"},{"id":"c5437ffcf609ae633f4f1165eadcfbba","title":"「1089」Insert or Merge","content":"According to Wikipedia:\nInsertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nMerge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in the first line either “Insertion Sort” or “Merge Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n\nSample Output 1:Insertion Sort\n1 2 3 5 7 8 9 4 6 0\n\nSample Input 2:10\n3 1 2 8 7 5 9 4 0 6\n1 3 2 8 5 7 4 9 0 6\n\nSample Output 2:Merge Sort\n1 2 3 8 4 5 7 9 0 6\n\n\nΩ根据中间的一个排序结果判断采用的是插入排序还是归并排序。\n看来排序题已经弹尽粮绝了。两者的差别其实还是挺大的，插入排序跟打扑克时整理手牌的过程差不多，拿一张牌找到位置插入，因此中间过程必然是前面有序后面原样；而归并排序是相邻的有序组进行合并，因此中间过程必然是局部有序的。\n那么初始想法就很简单，我们对当前序列和原序列一起从后往前读，找到第一个不同元素，对该元素及之前的元素进行排序，如果这是插入排序，那么排序后的结果应该与当前序列完全一致，否则就是归并排序。这个想法是正确的，但我没想到有一个测试样例中两个序列都是完全一致的，一个数没动过。我就纳闷了，这你能说是哪种排序呢。后来仔细想了想，既然说了是部分排序结果，那么一定是排过序的，而当原始序列前个数本来就是有序时，前几步的插入排序就能做到不改变原序列。\n⚠️因此不要忘记加上索引≥0限制，另外当所有元素都一致时，我们就需要正向遍历找到第一个不是ascending的元素。\n如果是插入排序那么我们再往后面sort一位即可，若是归并排序，我们则可以模拟实际的归并过程然后判断是否与当前序列相等（直接确定当前分组的元素个数并不是那么简单，反正元素个数最多也才100），然后再归并一次即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, turn;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; org(n), crt(n);\n    for (auto &amp;k: org)\n        cin &gt;&gt; k;\n    for (auto &amp;k: crt)\n        cin &gt;&gt; k;\n    turn = n;\n    while (--turn &gt;= 0 &amp;&amp; crt[turn] == org[turn]);\n    if (turn == -1)\n    {\n        turn = 0;\n        while (turn &lt; n &amp;&amp; crt[turn] &lt;= crt[turn + 1]) ++turn;\n    }\n    vector&lt;int&gt; copy(org);\n    sort(copy.begin(), copy.begin() + turn + 1);\n    bool isMerge = false;\n    // Short-circuit evaluation\n    for (int i = 0; i &lt; n &amp;&amp; (copy[i] == crt[i] || (isMerge = true , false)); ++i);\n    if (isMerge)\n    {\n        int delta = 1;\n        while (delta *= 2, crt != copy)\n        {\n            copy = org;\n            for (int i = 0; i &lt; n; i += delta)\n                sort(org.begin() + i, org.begin() + (i + delta &gt; n ? n : i + delta));\n        }\n    }\n    else\n        sort(org.begin(), org.begin() + turn + 2);\n    cout &lt;&lt; (isMerge ? \"Merge Sort\" : \"Insertion Sort\") &lt;&lt; endl;\n    for (int i = 0; i &lt; n; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; org[i];\n}\n","slug":"「1089」Insert-or-Merge","date":"2022-10-21T12:50:54.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"358311a56ccea31028176b056f12f8e9","title":"『1088」Rational Arithmetic","content":"For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.\n\n\nInput Specification:Each input file contains one test case, which gives in one line the two rational numbers in the format a1/b1 a2/b2. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.\nOutput Specification:For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is number1 operator number2 = result. Notice that all the rational numbers must be in their simplest form k a/b, where k is the integer part, and a/b is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output Inf as the result. It is guaranteed that all the output integers are in the range of long int.\nSample Input 1:2/3 -4/2\n\nSample Output 1:2/3 + (-2) = (-1 1/3)\n2/3 - (-2) = 2 2/3\n2/3 * (-2) = (-1 1/3)\n2/3 / (-2) = (-1/3)\n\nSample Input 2:5/3 0/6\n\nSample Output 2:1 2/3 + 0 = 1 2/3\n1 2/3 - 0 = 1 2/3\n1 2/3 * 0 = 0\n1 2/3 / 0 = Inf\n\n\nΩ用带分数的形式输出两个分数之和、差、积、商，具体输出规则如下：\n\n整数部分和真分数部分若为0则不输出，⚠️0必须输出【0】\n\n负数需要加上（），负号要么在整数部分，要么在真分数的分子部分（整数部分为0）\n\n当带分数整数和真分数部分皆不为0时，中间需要用space分隔\n\n带分数必须是约分后的最简形式\n\n分母为0直接输出【Inf】\n\n\n整体不难，一个格式化输出函数，一个简化函数即可。注意带分数中间的空格必须在两者都输出的时候才有。计算时可以用一个pair对来存取一个分数的分子和分母，然后分母始终为正。\n另外题目既然说了long int，就不要侥幸int可能和long int等长。\n\n🐎#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\ninline void output(pair&lt;long int, long int&gt; f)\n{\n    if (!f.second)\n        cout &lt;&lt; \"Inf\";\n    else\n    {\n        bool flag = f.first &lt; 0 &amp;&amp; (f.first *= -1), space = false;\n        cout &lt;&lt; (flag ? \"(-\" : \"\");\n        if (f.first / f.second || f.first == 0) cout &lt;&lt; f.first / f.second, space = true;\n        if (f.first % f.second) cout &lt;&lt; (space ? \" \" : \"\") &lt;&lt; f.first % f.second &lt;&lt; \"/\" &lt;&lt; f.second;\n        cout &lt;&lt; (flag ? \")\" : \"\");\n    }\n}\n\ninline void simplify(pair&lt;long int, long int&gt; &amp;f)\n{\n    long int g = gcd(f.first, f.second);\n    f.first /= g, f.second /= g;\n    if (f.second &lt; 0) f.first *= -1, f.second *= -1;\n}\n\nint main()\n{\n    pair&lt;long int, long int&gt; a, b, c;\n    scanf(\"%ld/%ld %ld/%ld\", &amp;a.first, &amp;a.second, &amp;b.first, &amp;b.second);\n    simplify(a), simplify(b);\n    long int lab = lcm(a.second, b.second), na = a.first * lab / a.second, nb = b.first * lab / b.second;\n    c.second = lab, c.first = na + nb, simplify(c);\n    output(a), cout &lt;&lt; \" + \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n    c.second = lab, c.first = na - nb, simplify(c);\n    output(a), cout &lt;&lt; \" - \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n    c.second = a.second * b.second, c.first = a.first * b.first, simplify(c);\n    output(a), cout &lt;&lt; \" * \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n    c.second = a.second * b.first, c.first = a.first * b.second, simplify(c);\n    output(a), cout &lt;&lt; \" / \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n}\n","slug":"『1088」Rational-Arithmetic","date":"2022-10-20T05:15:51.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,pair,numeric","author_index":"Starlit Rover"},{"id":"36db02f696efbf1ae4833c7a9cd82a86","title":"『1087』All Roads Lead to Rome","content":"Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.\nOutput Specification:For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.\nHence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format City1-&gt;City2-&gt;...-&gt;ROM.\nSample Input:6 7 HZH\nROM 100\nPKN 40\nGDN 55\nPRS 95\nBLN 80\nROM GDN 1\nBLN ROM 1\nHZH PKN 1\nPRS ROM 2\nBLN HZH 2\nPKN GDN 1\nHZH PRS 1\n\nSample Output:3 3 195 97\nHZH-&gt;PRS-&gt;ROM\n\n\nΩ好久没Dijkstra了，这道题要输出的东西有亿点多。\n从一个城市去罗马，每条路上有一定的代价，到一座城市能收获相应的快乐值，输出【代价最短的路线数 最小代价 最小代价中的最大快乐值 平均快乐值】和最优路线（评价优先级依次为：代价最小，快乐多多，城市少少）。\n首先用Dijkstra求出所有代价最小的路线，老套路，最短路线上的每个节点存储上一个节点的编号，由于路线不唯一，所以每个节点可能有多个前节点，用vector进行存储。然后从终点DFS回溯，回溯的路上顺便计算一下快乐值和节点个数，然后记录每个节点的最优next节点，即如果回到某个城市得到了一个更优的，那么就更新其next值，回溯到起点0就停止。那么最后最优的快乐值和节点数就存储在起点0的info中。\n第一次提交case 3超时，看到网上也没有人case 3裂开的，于是乎我改进了回溯函数，对于已经回溯过的节点不再重新回溯，直接用之前得出的结果，但绿色依旧，直到我把所有的INT16_MAX换成了INT32_MAX。INT_MAX是用来代替Dijkstra中走不通距离的，有时候替代数太小了会出问题。\n⚠️ 尽量用大数（INT32_MAX）替代。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; happy, nxt, path;\nvector&lt;vector&lt;int&gt;&gt; pre;     // previous nodes in the least cost paths\nvector&lt;pair&lt;int, int&gt;&gt; info; // &lt;happiness sum, nodes num&gt;\n\nint collect(int &amp;node)\n{\n    int sum = 0;\n    for (auto k: pre[node])\n    {\n        auto p = make_pair(info[node].first + happy[k], info[node].second - 1);\n        if (p &gt; info[k])\n        {\n            info[k] = p;\n            nxt[k] = node;\n        }\n        sum += (path[k] == -1 ? collect(k) : path[k]);\n    }\n    return path[node]=sum;\n}\n\nint main()\n{\n    int n, k, dst, c;\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    vector&lt;string&gt; city(n, string(3, 0));\n    happy.resize(n, 0);\n    map&lt;string, int&gt; num;\n    cin &gt;&gt; city[0];\n    num[city[0]] = 0;\n    for (int i = 1; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;city[i][0], &amp;happy[i]);\n        num[city[i]] = i;\n        if (city[i] == \"ROM\")\n            dst = i;\n    }\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; cost(n);\n    string c1(3, 0), c2(3, 0);\n    for (int i = 0; i &lt; k; ++i)\n    {\n        scanf(\"%s %s %d\", &amp;c1[0], &amp;c2[0], &amp;c);\n        cost[num[c1]].emplace_back(num[c2], c);\n        cost[num[c2]].emplace_back(num[c1], c);\n    }\n    vector&lt;int&gt; dist(n, INT32_MAX);\n    vector&lt;bool&gt; done(n, false);\n    dist[0] = 0, done[0] = true;\n    pre.resize(n);\n    for (auto &amp;v: cost[0])\n        pre[v.first].push_back(0), dist[v.first] = v.second;\n    while (!done[dst])\n    {\n        int min_d = INT32_MAX;\n        vector&lt;int&gt; opt;\n        for (int i = 1; i &lt; n; ++i)\n        {\n            if (done[i]) continue;\n            else if (dist[i] &lt; min_d)\n            {\n                opt.clear();\n                opt.push_back(i);\n                min_d = dist[i];\n            }\n            else if (dist[i] == min_d)\n                opt.push_back(i);\n        }\n        for (auto &amp;o: opt)\n        {\n            for (auto &amp;v: cost[o])\n                if (dist[o] + v.second &lt; dist[v.first])\n                {\n                    dist[v.first] = dist[o] + v.second;\n                    pre[v.first].clear();\n                    pre[v.first].push_back(o);\n                }\n                else if (dist[o] + v.second == dist[v.first])\n                    pre[v.first].push_back(o);\n            done[o] = true;\n        }\n    }\n    info.resize(n, {INT32_MIN, INT32_MIN});\n    info[dst] = make_pair(happy[dst], 0);\n    nxt = path = vector&lt;int&gt;(n, -1);\n    path[0] = 1;\n    printf(\"%d %d %d %d\\n\", collect(dst), dist[dst], info[0].first, info[0].first / -info[0].second);\n    int idx = 0;\n    printf(\"%s\", city[0].c_str());\n    while ((idx = nxt[idx]) != -1)\n        printf(\"-&gt;%s\", city[idx].c_str());\n}\n\nTips\n注意到回溯函数中节点数我是-1处理的，因为快乐数要bigger，而节点数要尽量smaller，如果要使用pair的比较运算就需要统一两者，所以对节点数取了个负\n\n对所有城市先进行了编号，map用来获取编号，vector存取编号对应城市名\n\n距离用了邻接表的结构进行存储，Dijkstra用邻接表足矣\n\n\n","slug":"『1087』All-Roads-Lead-to-Rome","date":"2022-10-18T15:38:59.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,Dijkstra","author_index":"Starlit Rover"},{"id":"241889b3806f3abfea3a2386c711c8ff","title":"『1086』Tree Traversals Again","content":"An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.  \n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.\nOutput Specification:For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\n\nSample Output:3 4 2 6 5 1\n\n\nΩ用栈输出一棵二叉树的中序遍历，给出栈的操作，请你输出后续遍历结果。\n遍历问题的核心永远是抓住子树的根节点，然后划分子树的子树。\n那么根据栈的操作我们可以得到一个中序遍历序列，注意到栈操作本质上是先遍历根节点，然后遍历左子树，最后遍历右子树。从而我们可得一棵子树节点中最先Push的就是根节点，只要找到根节点一切都好说了，左边是左子树序列，右边是右子树序列，直接进行后序递归操作即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; post, in;\n\nvoid PostOrder(int begin, int end)\n{\n    if (begin &gt; end) return;\n    int root = min_element(in.begin() + begin, in.begin() + end + 1) - in.begin();\n    PostOrder(begin, root - 1);\n    PostOrder(root + 1, end);\n    post.push_back(in[root]);\n}\n\nint main()\n{\n    stack&lt;int&gt; s;\n    int n, m, idx = 0;\n    cin &gt;&gt; n;\n    string opr;\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; 2 * n; ++i)\n    {\n        cin &gt;&gt; opr;\n        if (opr == \"Push\")\n        {\n            cin &gt;&gt; v[idx];\n            s.push(idx++);\n        }\n        else if (opr == \"Pop\")\n        {\n            in.push_back(s.top());\n            s.pop();\n        }\n    }\n    PostOrder(0, n - 1);\n    for (int i = 0; i &lt; n; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; v[post[i]];\n}\n","slug":"『1086』Tree-Traversals-Again","date":"2022-10-18T11:47:02.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"a488d0c6dd54b287e5f9b6c39b458e0d","title":"『1085』Perfect Sequence","content":"Given a sequence of positive integers and another positive integer p. The sequence is said to be a perfect sequence if M≤m×p where M and m are the maximum and minimum numbers in the sequence, respectively.\nNow given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive integers N and p, where  is the number of integers in the sequence, and  is the parameter. In the second line there are N positive integers, each is no greater than .\nOutput Specification:For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.\nSample Input:10 8\n2 3 20 4 5 1 6 7 8 9\n\nSample Output:8\n\n\nΩ完美序列指的是满足的序列，给出一组序列和，输出最多能够从这个序列中抽出元素构成完美序列的个数。\n很淳朴的思想，设定一个只加不减的偏移量（1个数字必然成立），先sort数组然后顺序遍历，判断是否成立，成立则继续找到上限，否则continue。\n最后case 5挂了，检查后发现可能会溢出，将int换成long int即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    long int n, p;\n    cin &gt;&gt; n &gt;&gt; p;\n    vector&lt;int&gt; arr(n);\n    for (auto &amp;a: arr)\n        cin &gt;&gt; a;\n    sort(arr.begin(), arr.end());\n    int ans = 1;\n    for (int i = 0; i &lt; arr.size() - ans; ++i)\n        while (i + ans &lt; arr.size() &amp;&amp; arr[i + ans] &lt;= arr[i] * p)\n            ++ans;\n    cout &lt;&lt; ans;\n}\n","slug":"『1085』Perfect-Sequence","date":"2022-10-17T17:27:54.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,vector","author_index":"Starlit Rover"},{"id":"1ce59a895ae0c8cfde6ce2080e52dc00","title":"「1084」Broken Keyboard","content":"On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.\nNow given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.\n\n\nInput Specification:Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or _ (representing the space). It is guaranteed that both strings are non-empty.\nOutput Specification:For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.\nSample Input:7_This_is_a_test\n_hs_s_a_es\n\nSample Output:7TI\n\n\nΩ小小键盘检修工，输出坏掉的键盘按键（只能是大写）。\n先将两个字符串转成大写，然后将显示出来的所有字符map成true，接着遍历一遍输入的字符串，如果map中没有（false）就输出同时在map中置true防止重复输出。\n\n🐎#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    string org, scr;\n    cin &gt;&gt; org &gt;&gt; scr;\n    transform(org.begin(), org.end(), org.begin(), ::toupper);\n    transform(scr.begin(), scr.end(), scr.begin(), ::toupper);\n\n    map&lt;char, bool&gt; check;\n    for (auto &amp;c: scr)\n        check[c] = true;\n    for (auto &amp;c: org)\n        if (!check[c])\n        {\n            cout &lt;&lt; c;\n            check[c] = true;\n        }\n}\n","slug":"「1084」Broken-Keyboard","date":"2022-10-17T16:53:22.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,string,transform","author_index":"Starlit Rover"},{"id":"e0ba25d20b6a90a6cc9db32813ef3126","title":"「1083」List Grades","content":"Given a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.\n\n\nInput Specification:Each input file contains one test case. Each case is given in the following format:\nN\nname[1] ID[1] grade[1]\nname[2] ID[2] grade[2]\n... ...\nname[N] ID[N] grade[N]\ngrade1 grade2\n\nwhere name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade’s interval. It is guaranteed that all the grades are distinct.\nOutput Specification:For each test case you should output the student records of which the grades are in the given interval [grade1, grade2] and are in non-increasing order. Each student record occupies a line with the student’s name and ID, separated by one space. If there is no student’s grade in that interval, output NONE instead.\nSample Input 1:4\nTom CS000001 59\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n60 100\n\nSample Output 1:Mike CS991301\nMary EE990830\nJoe Math990112\n\nSample Input 2:2\nJean AA980920 60\nAnn CS01 80\n90 95\n\nSample Output 2:NONE\n\n\nΩ非常经典的桶排序问题，由于每个学生的分数不同，因此直接来个vector&lt;pair&lt;string,string&gt;&gt; info(101)，索引即为分数，然后反序输出之间的信息即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, g1, g2;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;string, string&gt;&gt; info(101);\n    string name, id;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; id &gt;&gt; m;\n        info[m] = make_pair(name, id);\n    }\n    cin &gt;&gt; g1 &gt;&gt; g2;\n    bool flag = true;\n    for (int i = g2; i &gt;= g1; --i)\n        if (!info[i].first.empty())\n        {\n            cout &lt;&lt; info[i].first &lt;&lt; \" \" &lt;&lt; info[i].second &lt;&lt; endl;\n            flag = false;\n        }\n    if (flag) cout &lt;&lt; \"NONE\";\n}\n","slug":"「1083」List-Grades","date":"2022-10-15T13:15:04.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,pair","author_index":"Starlit Rover"},{"id":"4561856231e707471afc65c846bfe2ca","title":"「1082」Read Number in Chinese","content":"Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai.\n\n\nInput Specification:Each input file contains one test case, which gives an integer with no more than 9 digits.\nOutput Specification:For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.\nSample Input 1:-123456789\n\nSample Output 1:Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\n\nSample Input 2:100800\n\nSample Output 2:yi Shi Wan ling ba Bai\n\n\nΩ救命，好难啊，我再一次体会到了中国文化的博大精深。\n\n\n- 你真的会用汉语读数字吗？\n- 会啊会啊\n- 你能教会计算机读吗？\n- 简简单单\n-（to Mr.Computer）每个数字读完后加上它的位名\n-（Mr.Computer）一十万二万三千四百五十六(?)（12，3456）\n-（to Mr.Computer）。。最后一位是没名字的，【亿】和【万】只在位置输出\n-（Mr.Computer）一亿零千零百零十零万零千零百零十一（1，0000，0001）\n-（to Mr.Computer）诶诶诶，连续的0只要输出一个就够了，都是0的话就不用输出位名了\n-（Mr.Computer）一千零一十零（1010）\n-（to Mr.Computer）。。。末尾的零不用输出\n-（Mr.Computer）（null）（0）\n-（to Mr.Computer）啪\n-（Mr.Computer）卒\n\n\n坑点基本都在上面了，两个坑点尤为突出：1. 0的处理；2. 亿万何时输出。对于0的问题，我们可以设置一个zero布尔变量，当有0出现时将其置true，然后到非0数字出现时检查zero，若为true则先加上0的读音，再将zero置false。但会出现yi Bai Wan ling yi Qian（1001000）的情况，因此在输出亿和万后也需要将zero置false。对于亿万的输出也是设置一个flag布尔数组，出现非0数后将的flag置true，等到位置时检查相应flag若为true则输出。另外别忘记特殊情况0。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string n, py[] = {\"ling \", \"yi \", \"er \", \"san \", \"si \", \"wu \", \"liu \", \"qi \", \"ba \", \"jiu \"},\n          ans, sfx[] = {\"\", \"Shi \", \"Bai \", \"Qian \", \"Wan \", \"Shi \", \"Bai \", \"Qian \", \"Yi \"};\n    bool flag[3] = {false, false, false}, zero = false;\n    cin &gt;&gt; n;\n    ans += n[0] == '-' ? (n.erase(0, 1), \"Fu \") : \"\";\n    for (int i = 0; i &lt; n.size(); ++i)\n    {\n        if (n[i] == '0')\n        {\n            zero = true;\n            int r = int(n.size() - i - 1);\n            if (flag[r / 4] &amp;&amp; r % 4 == 0)\n            {\n                ans += sfx[r];\n                zero = false;\n            }\n            continue;\n        }\n        ans += zero ? (zero = false, py[0]) : \"\";\n        ans += py[n[i] - '0'] + sfx[n.size() - i - 1];\n        flag[(n.size() - i - 1) / 4] = true;\n    }\n    if (n == \"0\") ans += py[0];\n    ans.erase(ans.size() - 1);\n    cout &lt;&lt; ans;\n}\n","slug":"「1082」Read-Number-in-Chinese","date":"2022-10-15T12:11:08.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"8c93de95cc54dabff6d1524322e2911a","title":"「1081」Rational Sum","content":"Given N rational numbers in the form numerator/denominator, you are supposed to calculate their sum.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a positive integer N (≤100), followed in the next line N rational numbers a1/b1 a2/b2 ... where all the numerators and denominators are in the range of long int. If there is a negative number, then the sign must appear in front of the numerator.\nOutput Specification:For each test case, output the sum in the simplest form integer numerator/denominator where integer is the integer part of the sum, numerator &lt; denominator, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.\nSample Input 1:5\n2/5 4/15 1/30 -2/60 8/3\n\nSample Output 1:3 1/3\n\nSample Input 2:2\n4/3 2/3\n\nSample Output 2:2\n\nSample Input 3:3\n1/3 -1/6 1/8\n\nSample Output 3:7/24\n\n\nΩ给出几个分数，计算其总和，以带分数的形式输出。\n在以前需要自己手写最小公倍数/最大公因数函数，有了numeric库函数，妈妈再也不用担心我因为码题而吃不上饭啦。在读入所有分数的时候，先对所有分数进行约分，同时计算至此为止所有分母的最小公倍数，根据最新分母计算分子总和，最后再进行一次约分即可。\n⚠️ 分子为0时只能输出一个0。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, g, dmt = 1, nrt = 0, time;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt;&gt; frac(n);\n    for (auto &amp;f: frac)\n    {\n        scanf(\"%d/%d\", &amp;f.first, &amp;f.second);\n        g = gcd(f.first, f.second);\n        f.first /= g, f.second /= g;\n        time = lcm(dmt, f.second) / dmt;\n        nrt = time * nrt + time * dmt / f.second * f.first;\n        dmt *= time;\n    }\n    g = gcd(nrt, dmt);\n    nrt /= g, dmt /= g;\n    if (nrt / dmt == 0 &amp;&amp; nrt != 0)\n        cout &lt;&lt; nrt &lt;&lt; \"/\" &lt;&lt; dmt;\n    else if (nrt % dmt == 0)\n        cout &lt;&lt; nrt / dmt;\n    else\n        cout &lt;&lt; nrt / dmt &lt;&lt; \" \" &lt;&lt; nrt % dmt &lt;&lt; \"/\" &lt;&lt; dmt;\n}\n","slug":"「1081」Rational-Sum","date":"2022-10-14T09:55:41.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,numeric","author_index":"Starlit Rover"},{"id":"d79e1a49ba7f6556c0817ac0afa7d9ae","title":"「1080」Graduate Admission","content":"It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.\nEach applicant will have to provide two grades: the national entrance exam grade GE​, and the interview grade GI​. The final grade of an applicant is (GE​+GI​)/2. The admission rules are:\n\nThe applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.\n\nIf there is a tied final grade, the applicants will be ranked according to their national entrance exam grade GE​. If still tied, their ranks must be the same.\n\nEach applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.\n\nIf there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded.\n\n\n\n\nInput Specification:Each input file contains one test case.\nEach case starts with a line containing three positive integers: N (≤40,000), the total number of applicants; M (≤100), the total number of graduate schools; and K (≤5), the number of choices an applicant may have.\nIn the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively.\nThen N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s GE​ and GI​, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1.\nOutput Specification:For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.\nSample Input:11 6 3\n2 1 2 2 2 3\n100 100 0 1 2\n60 60 2 3 5\n100 90 0 3 4\n90 100 1 2 0\n90 90 5 1 3\n80 90 1 0 2\n80 80 0 1 2\n80 80 0 1 2\n80 70 1 3 2\n70 80 1 2 3\n100 100 0 2 4\n\nSample Output:0 10\n3\n5 6 7\n2 8\n\n1 4\n\n\nΩ读题读的呕心沥血，但不难理解题意，写一个考试录取系统，类似高考中的平行志愿，每个人有三个志愿，分数高的人优先择校，按照志愿顺序依次投递，如果该校还有名额剩余则成功录取。另外，如果某校录取了名次R的同学，那么在面对其余名次也为R的同学时可以忽略人数限制录取，即只要有1个名额剩余名次相同的可以一起录。\n由于有两个分数，我们可以用一个tuple依次存取【总分，，ID】然后直接sort（💡tuple和pair均已重载过比较运算符，按照顺序依次比较）。然后根据排序次序依次择校，根据其志愿依次遍历学校剩余人数，如果有剩余名额则录取并break。对于相同名次可以一起录取的特殊情况，用vector给每个学校一个bool值，每当一位同学录取后就将录取学校赋值为true，表示同名次可以一并录取。到下一个同学时先比较分数确定是否与上一位同学名次相同，若相同则不做任何修改，否则将所有学校的bool值都置false。那么在遍历志愿时除了检查剩余名额，同时检查其bool值。\n每个学校的录取人员用一个set存储，最后直接输出。\n一遍过，中规中矩。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;tuple&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);\n\n    vector&lt;int&gt; quota(m);\n    for (auto &amp;q: quota)\n        scanf(\"%d\", &amp;q);\n\n    vector&lt;tuple&lt;int, int, int&gt;&gt; score(n);\n    vector&lt;vector&lt;int&gt;&gt; pref(n, vector&lt;int&gt;(k));\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d%d\", &amp;get&lt;1&gt;(score[i]), &amp;get&lt;0&gt;(score[i]));\n        get&lt;0&gt;(score[i]) += get&lt;1&gt;(score[i]);\n        get&lt;2&gt;(score[i]) = i;\n        for (auto &amp;p: pref[i])\n            scanf(\"%d\", &amp;p);\n    }\n\n    sort(score.begin(), score.end(), greater&lt;&gt;());\n\n    vector&lt;bool&gt; green(m, false);\n    pair&lt;int, int&gt; pre{-1, -1};\n    vector&lt;set&lt;int&gt;&gt; admit(m);\n    for (auto &amp;s: score)\n    {\n        if (pre.first != get&lt;0&gt;(s) || pre.second != get&lt;1&gt;(s))\n            fill(green.begin(), green.end(), false);\n        for (auto &amp;p: pref[get&lt;2&gt;(s)])\n            if (quota[p] &gt; 0 || green[p])\n            {\n                quota[p] -= 1;\n                green[p] = true;\n                admit[p].insert(get&lt;2&gt;(s));\n                break;\n            }\n        pre = make_pair(get&lt;0&gt;(s), get&lt;1&gt;(s));\n    }\n\n    for (auto &amp;a: admit)\n    {\n        if (!a.empty())\n        {\n            printf(\"%d\", *a.begin());\n            for (auto aa = ++a.begin(); aa != a.end(); ++aa)\n                printf(\" %d\", *aa);\n        }\n        printf(\"\\n\");\n    }\n}\n\n\nTipssort(score.begin(), score.end(), greater&lt;&gt;());\n\n这里的greater事实上是一个重载了()的结构体struct模板，因此加上括号之后就类似函数名，效果类似大于符号。\n","slug":"「1080」Graduate-Admission","date":"2022-10-11T12:44:56.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,set,tuple","author_index":"Starlit Rover"},{"id":"60bfb2bd1454fe93e59a0b3383c25980","title":"「1079」Total Sales of Supply Chain","content":"A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer.\nStarting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.\nNow given a supply chain, you are supposed to tell the total sales from all the retailers.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains three positive numbers: , the total number of the members in the supply chain (and hence their ID’s are numbered from 0 to N−1, and the root supplier’s ID is 0); P, the unit price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then N lines follow, each describes a distributor or retailer in the following format:\n\nwhere in the i-th line, Ki​ is the total number of distributors or retailers who receive products from supplier i, and is then followed by the ID’s of these distributors or retailers. ​ being 0 means that the j-th member is a retailer, then instead the total amount of the product will be given aftter ​. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceed .\nSample Input:10 1.80 1.00\n3 2 3 5\n1 9\n1 4\n1 7\n0 7\n2 6 1\n1 8\n0 9\n0 4\n0 3\n\nSample Output:42.4\n\n\nΩ给出一个经销商树，根节点是最大供应商，叶子节点是零售商，其余供应商都从父供应商进货，然后卖给自己下面的供应商。每个供应商（包括零售商）出售价格都会比自己买入的价格高出，告知所有零售商的进货量，计算所有零售商的预期收入总和。\n不难看出，零售商出售价格只与自身所处的深度有关，因此我们可以用BFS，每次遍历一层节点，将该层中的叶子节点进货量相加，最后即为该层零售商的预期收入。\n遍历完整颗树后再将得到结果乘以最大供应商的出售价格即可。\n无意中还发现其实\"%.nf\"这种浮点数格式化也是四舍五入，重塑世界观。之前还有一篇博客专门分析四舍五入时还以为是浮点数运算中的精度损失，未曾想是直接给四舍五入了，玩完，得补课去了。不过他的四舍五入机制因为浮点数精度的问题会有点差异，详情可见C语言printf函数%.2f输出为什么四舍五入实现机制不同？。\n⚠️+0.5操作是浮点数转int时的操作，上面的格式化默认是四舍五入。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    double p, r;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; r;\n    r = 1 + r / 100;\n    vector&lt;vector&lt;int&gt;&gt; sup(n);\n    vector&lt;int&gt; ret(n, 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        sup[i].resize(m);\n        for (int j = 0; j &lt; m; ++j)\n            cin &gt;&gt; sup[i][j];\n        if (m == 0) cin &gt;&gt; ret[i];\n    }\n\n    vector&lt;int&gt; crt{0}, tmp;\n    double total = 0, rate = 1;\n    while (!crt.empty())\n    {\n        int num = 0;\n        for (auto &amp;k: crt)\n        {\n            if (ret[k])\n                num += ret[k];\n            else\n                tmp.insert(tmp.end(), sup[k].begin(), sup[k].end());\n        }\n        total += rate * num;\n        rate *= r;\n        crt = std::move(tmp);\n        tmp = vector&lt;int&gt;();\n    }\n\n    total *= p;\n    printf(\"%.1f\", total);\n}\n","slug":"「1079」Total-Sales-of-Supply-Chain","date":"2022-10-11T06:10:22.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,BFS,Tree","author_index":"Starlit Rover"},{"id":"c2d476bf277e1b89715673299c98c76c","title":"「1078」Hashing","content":"The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be  where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.\nNote that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive numbers:  and  which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead.\nSample Input:4 4\n10 6 4 15\n\nSample Output:0 1 4 -\n\n\nΩ单纯考哈希散列中的二次探查，对于用户输入的哈希表大小，需要将其改成最小且大于它的素数，然后输出每个数的哈希索引。如有冲突用二次探查法寻找新的索引，找不到则输出-。\n首先，1不是素数需要单独处理，然后问题就在于如何判断一个数找不到哈希索引，这其实涉及到一个单纯朴素的数论小知识：\n\n证明也很显然，展开即得。因此如果时都没有空余索引，后面自然也是找不到的。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k;\n    cin &gt;&gt; m &gt;&gt; n;\n    m = (m == 1 ? 2 : m);\n    for (int i = m + 1 - m % 2; m &gt; 2; i += 2)\n    {\n        bool flag = false;\n        for (int j = 2; j &lt;= i / j; ++j)\n            if (i % j == 0)\n            {\n                flag = true;\n                break;\n            }\n        if (flag) continue;\n        else\n        {\n            m = i;\n            break;\n        }\n    }\n    vector&lt;bool&gt; flag(m, false);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        int r = k % m, cnt = 1;\n        while (cnt &lt; m &amp;&amp; flag[r])\n        {\n            r = (k + cnt * cnt) % m;\n            ++cnt;\n        }\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; (cnt == m ? \"-\" : (flag[r] = true, to_string(r)));\n    }\n\n}\n","slug":"「1078」Hashing","date":"2022-10-08T10:51:59.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,hash","author_index":"Starlit Rover"},{"id":"fd5509f1a9c73776f2474d74cf48b6da","title":"「1077」Kuchiguse","content":"The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality:\n\nItai nyan~ (It hurts, nyan~)\n\nNinjin wa iyada nyan~ (I hate carrots, nyan~)\n\n\nNow given a few lines spoken by the same character, can you find her Kuchiguse?\n\n\nInput Specification:Each input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive.\nOutput Specification:For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write nai.\nSample Input 1:3\nItai nyan~\nNinjin wa iyadanyan~\nuhhh nyan~\n\nSample Output 1:nyan~\n\nSample Input 2:3\nItai!\nNinjinnwaiyada T_T\nT_T\n\nSample Output 2:nai\n\n\nΩ寻找最长公共后缀，无则输出“nai”。\n最简单的想法就是先把所有句子存到一个vector里，然后一起从后往前数。\n事实上不需要这么麻烦，只要每次读入一个新句子后和当前公共后缀从后至前进行比较，然后存取新的公共后缀。当然嫌从后往前麻烦，就把他们都reverse一下。\n⚠️使用getline时注意上一行是否读完，包括’\\n’（需要getchar一下）。\n\n🐎#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n;\n    string ans, tmp;\n    getchar(); //get '\\n'\n    getline(cin, ans);\n    reverse(ans.begin(), ans.end());\n    for (int i = 1; i &lt; n; ++i)\n    {\n        getline(cin, tmp);\n        reverse(tmp.begin(), tmp.end());\n        for (k = 0; k &lt; min(ans.size(), tmp.size()); ++k)\n            if (ans[k] != tmp[k])\n                break;\n        ans = ans.substr(0, k);\n    }\n    reverse(ans.begin(), ans.end());\n    cout &lt;&lt; (ans.empty() ? \"nai\" : ans);\n}\n","slug":"「1077」Kuchiguse","date":"2022-10-08T08:39:36.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,reverse,string","author_index":"Starlit Rover"},{"id":"bdaf6b5d6e486b0211610bff2d92703a","title":"「1076」Forwards on Weibo","content":"Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format:\nM[i] user_list[i]\n\nwhere M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.\nThen finally a positive K is given, followed by K UserID‘s for query.\nOutput Specification:For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.\nSample Input:7 3\n3 2 3 4\n0\n2 5 6\n2 3 1\n2 3 4\n1 4\n1 5\n2 2 6\n\nSample Output:4\n5\n\n\nΩ告知微博的关注网络图，假设一个人发微博，关注他的人都会转发一次，相应转发微博人的关注者也会转发一次，但同一个人只转发一次，问指定人发博会得到几次转发，只计数L层关注链内的人。\n很显然的BFS题，没有难度，明确每个人的followers然后进行L次BFS，对于已经遍历过的人进行标记，如果下一次遍历的集合为空就提前退出循环。没遇到什么坑。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, l, m, k;\n    cin &gt;&gt; n &gt;&gt; l;\n    vector&lt;vector&lt;int&gt;&gt; follow(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k;\n            follow[k - 1].push_back(i);\n        }\n    }\n    cin &gt;&gt; m;\n    vector&lt;int&gt; crt, nxt;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; k;\n        vector&lt;bool&gt; flag(n, true);\n        flag[k - 1] = false;\n        int cnt = 0;\n        crt.push_back(k - 1);\n        for (int j = 0; j &lt; l &amp;&amp; !crt.empty(); ++j)\n        {\n            for (auto &amp;v: crt)\n                for (auto &amp;u: follow[v])\n                    if (flag[u])\n                    {\n                        nxt.push_back(u);\n                        flag[u] = false;\n                        ++cnt;\n                    }\n            crt = std::move(nxt);\n            nxt = vector&lt;int&gt;();\n        }\n        cout &lt;&lt; cnt &lt;&lt; endl;\n    }\n}\n","slug":"「1076」Forwards-on-Weibo","date":"2022-10-06T14:08:39.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,BFS,Graph","author_index":"Starlit Rover"},{"id":"50b7040dd173c7b4aabe65b86d7947f4","title":"「1075」PAT Judge","content":"The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 3 positive integers, , the total number of users, K (≤5), the total number of problems, and , the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format:\nuser_id problem_id partial_score_obtained\n\nwhere partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, you are supposed to output the ranklist in the following format:\nrank user_id total_score s[1] ... s[K]\n\nwhere rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-“ must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.\nThe ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.\nSample Input:7 4 20\n20 25 25 30\n00002 2 12\n00007 4 17\n00005 1 19\n00007 2 25\n00005 1 20\n00002 2 2\n00005 1 15\n00001 1 18\n00004 3 25\n00002 2 25\n00005 3 22\n00006 4 -1\n00001 2 18\n00002 1 20\n00004 1 15\n00002 4 18\n00001 3 4\n00001 4 2\n00005 2 -1\n00004 2 0\n\nSample Output:1 00002 63 20 25 - 18\n2 00005 42 20 0 22 -\n2 00007 42 - 25 - 17\n2 00001 42 18 18 4 2\n5 00004 40 15 0 25 -\n\n\nΩ国庆的尾巴还能遇上这种烦人的题目，悲伤加倍。估计是没什么题目好编了，PAT评测系统都来了，可能是变相招聘。难是不敢说，烦是真的烦。明天又要关进去了，呜呜呜。\n借助微薄的PTA使用经验，稍微整理了一下（潜）规则：\n\n用户连编译阶段都没通过时输入的分数为-1\n\n单个题目多次提交取最高分（Case 4：第一次满分，第二次编译没通过算满分）\n\n没有题目通过编译（包括未提交）的用户不应上榜\n\n对于总分为0用户的名次，需要排除那些不参与排名而总得分同样为0的用户\n\n只有一次都没提交过的题目输出“-”，编译没通过输出0\n\n依次按照总分降序、满分题目个数降序、ID升序的优先级来排名\n\n同一题目多次提交满分不要重复计算\n\n\n对于复杂的比较规则只要码一个cmp函数即可，头疼的是判断哪些用户需要排名，首先可以设置一个全为false的bool向量，只要有题目通过编译（&gt;-1）就改true说明上榜。另外对于编译没通过和从没提交过也得区分开（5），那么初始化用户题目分数都为-1，若是提交编译未通过就改成0。其余情况就取更高分数。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\nvector&lt;int&gt; sum, solve;\nvector&lt;vector&lt;int&gt;&gt; score;\n\nbool cmp(int &amp;a, int &amp;b)\n{\n    if (sum[a] != sum[b])\n        return sum[a] &gt; sum[b];\n    else if (solve[a] != solve[b])\n        return solve[a] &gt; solve[b];\n    else\n        return a &lt; b;\n}\n\nint main()\n{\n    int n, k, m, id, q, s;\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;\n    vector&lt;int&gt; mark(k), ids(n);\n    vector&lt;bool&gt; flag(n, false);\n    iota(ids.begin(), ids.end(), 0);\n    sum = solve = vector&lt;int&gt;(n, 0);\n    for (auto &amp;v: mark)\n        cin &gt;&gt; v;\n    score = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(k, -1));\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; q &gt;&gt; s;\n        if (score[id - 1][q - 1] == -1 &amp;&amp; s == -1)\n            score[id - 1][q - 1] = 0;\n        else\n            score[id - 1][q - 1] = (score[id - 1][q - 1] &lt; s ? (flag[id - 1] = true, s) : score[id - 1][q - 1]);\n    }\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; k; ++j)\n        {\n            sum[i] += (score[i][j] != -1) * score[i][j];\n            solve[i] += score[i][j] == mark[j];\n        }\n    sort(ids.begin(), ids.end(), cmp);\n    int rank = 1, pre = sum[ids[0]], cnt = 1;\n    for (auto &amp;v: ids)\n    {\n        if (!flag[v]) continue;\n        rank = sum[v] == pre ? rank : cnt;\n        printf(\"%d %05d %d\", rank, v + 1, sum[v]);\n        for (int i = 0; i &lt; k; ++i)\n            cout &lt;&lt; \" \" &lt;&lt; (score[v][i] == -1 ? \"-\" : to_string(score[v][i]));\n        cout &lt;&lt; endl;\n        pre = sum[v];\n        ++cnt;\n    }\n}\n","slug":"「1075」PAT-Judge","date":"2022-10-06T12:17:54.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"e845b313b55f4309188a47e3699e705a","title":"「1074」Reversing Linked List","content":"Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive  which is the total number of nodes, and a positive  which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\n\nwhere Address is the position of the node, Data is an integer, and Next is the position of the next node.\nOutput Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\n\nSample Output:00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1\n\n\nΩ将链表每K个元素反转排列，输出最后链表的节点地址、数值以及下一个元素的地址，如果最后的节点个数不足K个则无需反转。\n如果没有最后一句话，直接就用一个栈读K个输出K个。测试Sample时才发现最后不足K个无需反转，那就直接上vector，每K个reverse一下，最后不足就不用动。很显然，下一个元素的地址会连着输出两次（中间换了个行），那就让下一个元素一起负责输出了。\n那么除了首节点外都是平行四边形式的输出，最后再输出个-1即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, pair&lt;int, string&gt;&gt; value;\n    string addr, next, head;\n    int n, k, v;\n    cin &gt;&gt; head &gt;&gt; n &gt;&gt; k;\n    for (int j = 0; j &lt; n; ++j)\n    {\n        cin &gt;&gt; addr &gt;&gt; v &gt;&gt; next;\n        value[addr] = {v, next};\n    }\n    vector&lt;string&gt; list;\n    for (string tmp = head; tmp != \"-1\"; tmp = value[tmp].second)\n        list.push_back(tmp);\n    for (int i = k; i &lt;= list.size(); i += k)\n        reverse(list.begin() + i - k, list.begin() + i);\n    printf(\"%s %d \", list[0].c_str(), value[list[0]].first);\n    list.erase(list.begin());\n    // 平行四边形输出\n    for (auto &amp;s: list)\n        printf(\"%s\\n%s %d \", s.c_str(), s.c_str(), value[s].first);\n    printf(\"-1\\n\");\n}\n","slug":"「1074」Reversing-Linked-List","date":"2022-10-06T08:27:35.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,reverse,list","author_index":"Starlit Rover"},{"id":"489d94365958188264d5e930f4f52aca","title":"「1073」Scientific Notation","content":"Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9].[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent’s signs are always provided even when they are positive.\nNow given a real number A in scientific notation, you are supposed to print A in the conventional notation while keeping all the significant figures.\n\n\nInput Specification:Each input contains one test case. For each case, there is one line containing the real number A in scientific notation. The number is no more than 9999 bytes in length and the exponent’s absolute value is no more than 9999.\nOutput Specification:For each test case, print in one line the input number A in the conventional notation, with all the significant figures kept, including trailing zeros.\nSample Input 1:+1.23400E-03\n\nSample Output 1:0.00123400\n\nSample Input 2:-1.2E+10\n\nSample Output 2:-12000000000\n\n\nΩ科学计数法转常规数字，无需去除尾数0降低了些难度，只需要记住小数点的位置即可。\n注意到题目给出的科学计数法正则表达式为，说明在小数点前永远是【符号位+一个数字】。那么先把其中E前底数去掉符号位和小数点单独取出，然后读取E后面的指数（），如果假设首个数字索引为0，那么小数点就在第个数字前面。而最后我们需要输出的数字索引范围即为，注意如果小数点在第一个数字前面就需要把前置0也输出因此，超出数字个数则需要把尾0补上。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s, n;\n    cin &gt;&gt; s;\n    int point;\n    for (int i = 1; i &lt; int(s.size()); ++i)\n    {\n        if (isdigit(s[i]))\n            n += s[i];\n        else if (s[i] == 'E')\n        {\n            point = 1 + stoi(s.substr(i + 1));\n            break;\n        }\n    }\n    cout &lt;&lt; (s[0] == '+' ? \"\" : \"-\");\n    for (int i = min(point - 1, 0); i &lt; max(point, int(n.size())); ++i)\n    {\n        cout &lt;&lt; (i == point ? \".\" : \"\");\n        if (i &lt; 0 || i &gt;= int(n.size()))\n            cout &lt;&lt; '0';\n        else\n            cout &lt;&lt; n[i];\n    }\n\n}\n\n⚠️ size_t和int比较计算时别忘转成int⚠️\n","slug":"「1073」Scientific-Notation","date":"2022-10-05T15:29:56.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"74ba177c21feee6c064587dc81699431","title":"「1072」Gas Station","content":"A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range.\nNow given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers: , the total number of houses; M (≤10), the total number of the candidate locations for the gas stations; , the number of roads connecting the houses and the gas stations; and DS​, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM.\nThen K lines follow, each describes a road in the format\nP1 P2 Dist\n\nwhere P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road.\nOutput Specification:For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution.\nSample Input 1:4 3 11 5\n1 2 2\n1 4 2\n1 G1 4\n1 G2 3\n2 3 2\n2 G2 1\n3 4 2\n3 G3 2\n4 G1 3\nG2 G1 1\nG3 G2 2\n\nSample Output 1:G1\n2.0 3.3\n\nSample Input 2:2 1 2 10\n1 G1 9\n2 G1 20\n\nSample Output 2:No Solution\n\n\nΩ加油站选址问题，给出一个房子和加油站备选地点的有权无向图，我们需要从可选地点中选择一个最优地点，使加油站到所有房子的最小距离最大（可能不希望来往车辆噪声影响居民），但也需要所有房子在服务距离内（同时不忘获利最大）。如果有多个最优解则选择与房子之间平均距离最短的解，若依然有多个就选择序号最小的地点。\n第一个麻烦鬼是输入中的加油站处理，对于直接把G叉出去转成数字后+N。然后对每个加油站选址采取Dijkstra算法，一旦有节点的最短距离就break并直接进入下一个选址。如果所有房子都在服务范围内，那么再与最优解依次比较最短距离（bigger）和平均距离（smaller）。\n其实整体思路不难，但Sample就搞人心态。注意到Sample 1中的3.3，其实本来是3.25，这里进行了四舍五入。于是乎我在最后输出平均距离的时候加了个0.05，结果case 4炸了，把0.05去掉却过了，而Sample 1输出3.2。是不是有什么大病？\n\n10.6 续ummm我知道原因了家人们。跑了下网上前几个题解，大部分Sample 1的运行结果是3.2，有一个是3.3。Amazing，我赶忙看了波他的四舍五入，他用了cmath库中的round函数：round(avg*10)/10，确实也通过了所有测试点。\n我不禁陷入了沉思，莫非…按照我的思路做了个测试：\n\n\n果不其然，是因为浮点数运算的精度误差导致的。另外浮点数运算时都是转成double参与运算的，因此double结果也一样。看来0.05还是不靠谱啊，四舍五入就得round。\n\n10.11 续蚌埠住了家人们，\"%.nf\"也是四舍五入，见「1079」Total Sales of Supply Chain，补课去了。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, ds, p1, p2, d;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; ds;\n    vector&lt;map&lt;int, int&gt;&gt; dist(n + m + 1);\n    string a, b;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;\n        p1 = a[0] == 'G' ? stoi(a.substr(1, a.size() - 1)) + n : stoi(a);\n        p2 = b[0] == 'G' ? stoi(b.substr(1, b.size() - 1)) + n : stoi(b);\n        dist[p1][p2] = dist[p2][p1] = d;\n    }\n    tuple&lt;int, int, float&gt; ans{0, 0, INT32_MAX};\n    for (int i = n + 1; i &lt; m + n + 1; ++i)\n    {\n        vector&lt;int&gt; min_dist(n + m + 1, INT32_MAX);\n        vector&lt;bool&gt; isVisited(n + m + 1, false);\n        isVisited[i] = true;\n        for (auto &amp;v: dist[i])\n            min_dist[v.first] = v.second;\n        int cnt = n, sum = 0;\n        while (cnt)\n        {\n            int min = INT32_MAX, idx = -1;\n            for (int j = 1; j &lt; n + m + 1; ++j)\n                if (!isVisited[j] &amp;&amp; min_dist[j] &lt; min)\n                {\n                    min = min_dist[j];\n                    idx = j;\n                }\n            if (min &gt; ds) break;\n            for (auto &amp;v: dist[idx])\n                if (!isVisited[v.first] &amp;&amp; v.second + min &lt; min_dist[v.first])\n                    min_dist[v.first] = v.second + min;\n            isVisited[idx] = true;\n            cnt -= (idx &lt;= n ? (sum += min, 1) : 0);\n        }\n        if (!cnt)\n        {\n            int dmin = *min_element(min_dist.begin() + 1, min_dist.begin() + n + 1);\n            float avg = 1.0 * sum / n;\n            if (dmin &gt; get&lt;1&gt;(ans) || dmin == get&lt;1&gt;(ans) &amp;&amp; avg &lt; get&lt;2&gt;(ans))\n                ans = {i - n, dmin, avg};\n        }\n    }\n    if (get&lt;0&gt;(ans))\n        printf(\"G%d\\n%.1f %.1f\", get&lt;0&gt;(ans), float(get&lt;1&gt;(ans)), round(get&lt;2&gt;(ans) * 10) / 10);\n    else\n        printf(\"No Solution\");\n}\n","slug":"「1072」Gas-Station","date":"2022-10-05T10:12:26.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph,Dijkstra,min_element","author_index":"Starlit Rover"},{"id":"7e7e82299d0e2e6bf939755399447a21","title":"「1071」Speech Patterns","content":"People often have a preference among synonyms of the same word. For example, some may prefer “the police”, while others may prefer “the cops”. Analyzing such patterns can help to narrow down a speaker’s identity, which is useful when validating, for example, whether it’s still the same person behind an online avatar.\nNow given a paragraph of text sampled from someone’s speech, can you find the person’s most commonly used word?\n\n\nInput Specification:Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage return \\n. The input contains at least one alphanumerical character, i.e., one character from the set [0-9 A-Z a-z].\nOutput Specification:For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a “word” is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.\nNote that words are case insensitive.\nSample Input:Can1: \"Can a can can a can?  It can!\"\n\nSample Output:can 5\n\n\nΩ统计一句话中出现频次最高的word，这里word指的是一串只有数字字母的连续字符串。\nmap统计每个word的频次，isalnum函数判断是否为数字字母，tolower函数负责转换大写字母。\n万事俱备，只欠东风。我们每次先将non-alphanumerical的字符跳过，然后连续采集alphanumerical字符，顺便转换成小写字母，tolower函数只对大写字母有效果，其余字符返回本身。计数的同时比较是否是当前频次最高的单词，如果与最大频次一样再比较字母序。\n思路简单明了，中途遇到了一个有意思的小bug，分享一下：\nfor (int i = -1; i &lt; s.size(); ++i)\n\n这个循环不论s.size()多大都不会进入，我一开始也很疑惑，这说明i&lt;s.size()是false，后来想起size()的返回类型是无符号整型size_t，比较运算实质是做减法，那么编译器在做一个无符号数减一个有符号数时都会先将有符号数转为无符号数，那么这里-1就会直接变成最大的无符号数，因此返回false不会进入循环。\n不得不说，细节决定成败。和绝对理性的机器打交道就必须注意这些不起眼的小点。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, int&gt; cnt;\n    string s, word, ans;\n    int max = -1;\n    getline(cin, s);\n    for (int i = 0; i &lt; s.size(); ++i)\n    {\n        while (i &lt; s.size() &amp;&amp; !isalnum(s[i++]));\n        i -= 1;\n        for (; i &lt; s.size() &amp;&amp; isalnum(s[i]); ++i)\n            word += tolower(s[i]);\n        if (++cnt[word] &gt; max)\n        {\n            max = cnt[word];\n            ans = word;\n        }\n        else if (cnt[word] == max &amp;&amp; word &lt; ans)\n            ans = word;\n        word.clear();\n    }\n    cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; max;\n}\n","slug":"「1071」Speech-Patterns","date":"2022-09-29T06:36:48.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map","author_index":"Starlit Rover"},{"id":"7776532a38433935aad29c44c794b489","title":"「1070」Mooncake","content":"Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region’s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.\nNote: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans).\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers N (≤1000), the number of different kinds of mooncakes, and D (≤500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.\nSample Input:3 200\n180 150 100\n7.5 7.2 4.5\n\nSample Output:9.45\n\n\nΩ如何卖月饼能获利最大，月饼可以拆分，简化版背包问题。\n由于市场需求是固定的，因此先计算单价，然后将月饼按单价排序，依次卖出，直到卖出总量达到市场需求为止。\n只是没想到水题里面还暗藏水雷，测试点2一直过不去实在令人狂躁抓头。原来。。月饼库存说的是positive inventory amounts，没说过整数哦，样例中的整数只是特殊情况而已啦，你自己要说是整数我也没有办法诶。\nPTA的misdirection一直是有一手的。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;double, double, double&gt; tddd;\n\nint main()\n{\n    int n;\n    double d, p = 0;\n    cin &gt;&gt; n &gt;&gt; d;\n    vector&lt;tddd&gt; info(n);\n    for (auto &amp;k: info)\n        cin &gt;&gt; get&lt;0&gt;(k);\n    for (auto &amp;k: info)\n    {\n        cin &gt;&gt; get&lt;1&gt;(k);\n        get&lt;2&gt;(k) = get&lt;1&gt;(k) / get&lt;0&gt;(k);\n    }\n    sort(info.begin(), info.end(), [](tddd &amp;a, tddd &amp;b) { return get&lt;2&gt;(a) &gt; get&lt;2&gt;(b); });\n    for (int i = 0; i &lt; n &amp;&amp; d &gt; 0; ++i)\n    {\n        p += (d &lt; get&lt;0&gt;(info[i]) ? d * get&lt;2&gt;(info[i]) : get&lt;1&gt;(info[i]));\n        d -= get&lt;0&gt;(info[i]);\n    }\n    printf(\"%.2f\", p);\n}\n","slug":"「1070」Mooncake","date":"2022-09-29T05:43:39.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,tuple","author_index":"Starlit Rover"},{"id":"4639b5ea2946dd4eb301e11b5cb60396","title":"「1068」Find More Coins","content":"Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many as  coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (, the total number of coins) and M (, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the face values  such that M. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output “No Solution” instead.\nNote: sequence  is said to be “smaller” than sequence  if there exists  such that  for all , and .\nSample Input 1:8 9\n5 9 8 7 2 3 4 1\n\nSample Output 1:1 3 5\n\nSample Input 2:4 8\n7 2 4 3\n\nSample Output 2:No Solution\n\n\nΩ在给定数组中找到一串数之和等于给定值A，如果有多个解则取最小序列。\n没什么好的想法，先排序后枚举。从最小的数开始，往后依次累加找到就return。虽然说是枚举，但为了不超时还是需要有避免无意义枚举的前验工作和停止的条件。\n首先如果所有数总和都没有到A，那么直接“No Solution”；如果刚好==A，那么直接把排序完数组打印一遍。在枚举过程中如果当前单个数值&gt;remain，说明无解及时停止。\n看了一些题解，基本是用01背包的思想来求的。把所有数都看成是重量与价值都一致的物品，然后背包限制就是A，那么我们只要用01背包的思路来求解最大价值即可，如果最大价值&lt;A说明无解，==A则有解。01背包是一种动态规划算法，即自底向上，也不失为一剂良策。最近被学校操作系统实验整的头疼，就不实现了（逃\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; coin, solution;\n\nbool dfs(int pos, int m)\n{\n    if (!m) return true;\n    for (int i = pos; i &lt; coin.size(); ++i)\n    {\n        if (m - coin[i] &lt; 0) break;\n        solution.push_back(coin[i]);\n        if (dfs(i + 1, m - coin[i])) return true;\n        else solution.pop_back();\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    int n, m,sum=0;\n    cin &gt;&gt; n &gt;&gt; m;\n    coin.resize(n);\n    for (auto &amp;k: coin) cin &gt;&gt; k, sum+=k;\n    sort(coin.begin(), coin.end());\n    if (sum &lt; m)\n        cout &lt;&lt; \"No Solution\" &lt;&lt; endl;\n    else if (sum == m)\n        for (int i = 0; i &lt; coin.size(); ++i)\n            cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; coin[i];\n    else if (dfs(0, m))\n        for (int i = 0; i &lt; solution.size(); ++i)\n            printf(\"%d%c\", solution[i], i == solution.size() - 1 ? '\\n' : ' ');\n    else printf(\"No Solution\\n\");\n\n}\n","slug":"「1068」Find-More-Coins","date":"2022-09-28T13:00:31.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"f66bf5b8d2fc86417cb09b027c83ec14","title":"「1067」Sort with Swap(0, i)","content":"Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:\nSwap(0, 1) =&gt; {4, 1, 2, 0, 3}\nSwap(0, 3) =&gt; {4, 1, 2, 3, 0}\nSwap(0, 4) =&gt; {0, 1, 2, 3, 4}\n\nNow you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.\n\n\nInput Specification:Each input file contains one test case, which gives a positive  followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space.\nOutput Specification:For each case, simply print in a line the minimum number of swaps need to sort the given permutation.\nSample Input:10\n3 5 7 2 6 4 9 0 8 1\n\nSample Output:9\n\n\nΩ给出{0,1,…,N-1}的一个排列，只能交换0和其他数字的位置，试问最少需要几次交换才能使其升序排列。\n事实上这跟排序毫无关系，我们可以认为每个数都有一个自己的座位，最后需要让每个数都在自己的位置上，这道题为了方便起见就规定每个数的位置序号与自己相等。\n乍看像是排列组合问题，一个很贪心的思路就是每次0都和本应该在它位置上的数交换，这样能保证每次交换都能让一个数归位。但试着手排几次会发现有时候排着排着0自己就会归位，然而后面的数组还并不是有序的，此时就需要让0和其中一个还不在自己位置上的数进行交换，但这样的交换不会让任何数归位，即效益为0。\n我们知道一次交换最多让两个数归位，但由于其中一个是常驻嘉宾0，我们可以暂且不考虑，因为其余数归位后0也必然归位。这意味着交换一次让一个数归位就是最大效益。那么我们能否避免无效交换的产生呢？答案是不行，你会发现每个位置事实上都早已决定下次交换的位置。\n如果我们来表示数的位置序号，节点编号，定义有向边。这张图就是0的路线图，然而图并不一定是连通的，对于那些0不在内部的连通分图，就需要0进行一次无效交换进入，还需要一次交换把踢出去的元素换回来。这样一来就会比0所在的连通分图多2次交换。\n对于原本就在正确位置上的数一开始就标记排除，然后求连通分图数就完事了。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, cnt = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; ptm(n), flag(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; ptm[i];\n        flag[i] = (ptm[i] == i);\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (flag[i]) continue;\n        int j = i;\n        cnt += (i == 0 ? -1 : 1);\n        while (!flag[j])\n        {\n            flag[j] = true;\n            j = ptm[j];\n            ++cnt;\n        }\n    }\n    cout &lt;&lt; cnt;\n}\n","slug":"「1067」Sort-with-Swap-0-i","date":"2022-09-25T09:25:33.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Graph","author_index":"Starlit Rover"},{"id":"1b4d009413a4a1733c93e882f288fd9a","title":"Lab2: system calls","content":"上周打了一场数模国赛，打前元气超人，打完葛优躺平。Lab2只有两个小实验，聚焦于如何创建系统调用命令，也并不是那么简单，实验文档戳这。\n\n\n\n\n\n\n❖ Coding\n☑︎ System call tracing (moderate)我们需要创建一个trace系统调用来追踪一个命令中指定的系统调用，并打印出相应的返回值。\n$ trace 2147483647 grep hello README\n4: syscall trace -&gt; 0\n4: syscall exec -&gt; 3\n4: syscall open -&gt; 3\n4: syscall read -&gt; 1023\n4: syscall read -&gt; 966\n4: syscall read -&gt; 70\n4: syscall read -&gt; 0\n4: syscall close -&gt; 0\n\n指令格式：trace mask cmd。mask用来指定需要追踪的系统调用，在操作系统中每个系统调用都会有自己唯一的编号SYS_syscall（在kernel/syscall.h中的宏定义），比如说fork的编号就是SYS_fork，如果mask&amp;(1&lt;&lt;SYS_syscall)!=0就说明需要追踪该syscall，需要打印出其返回值，本质上如果假设代表其二进制低位数字的话，那么就代表需要追踪SYS_syscall=的系统调用。\n那么我们就需要在进程结构体proc中加入int mask，注意到一个进程中执行不同系统调用是通过fork来实现的，本质上又创建了一个proc实体，因此在fork的实现（kernel/proc.c）中我们需要实现mask的传递：\n    np-&gt;mask = p-&gt;mask;\n\n那么接下来就可以打印信息pid: syscall name -&gt; return_value。我们可以在每个系统调用都必经的函数syscall（kernel/syscall.c）里面实现，首先观察syscall函数：\nvoid syscall(void)\n{\n  int num;\n  struct proc *p = myproc();\n\n  num = p-&gt;trapframe-&gt;a7;\n  if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])\n  {\n    p-&gt;trapframe-&gt;a0 = syscalls[num]();\n  }\n  else\n  {\n    printf(\"%d %s: unknown sys call %d\\n\",p-&gt;pid, p-&gt;name, num);\n    p-&gt;trapframe-&gt;a0 = -1;\n  }\n}\n\n可以看出p里面存储了我们需要的pid，但p-&gt;name并不是我们想要的系统调用名称，注意到fork实现中（kernel/proc.c：304）是直接拷贝原proc的name，即name里存储的其实是进程名：\nsafestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name)）;\n\n这里需要注意进程与线程之间的差别。虽然fork完后也是一个proc结构体，但事实上只是p-&gt;name进程下的一个线程而已。进程是对运行程序的封装，是系统进行资源调度和分配的基本单位，各进程之间相互隔离不共享数据，实现了操作系统的并发性；而线程则是一个进程中的子任务，是CPU调度的最小单位，一个进程中的所有线程共享该进程的数据资源。那么每个命令就是一个进程，里面会执行多个系统调用，每个系统调用都是一个线程。\n虽然p里面没有线程名称的直接信息，但肯定有其他相关信息。注意到\np-&gt;trapframe-&gt;a0 = syscalls[num]();\n\n这里调用了syscalls[num]，然后将返回值传递给了a0寄存器（RISC-V的C规范是把返回值放在a0中）。syscalls是一个无符号整型指针数组，即函数指针。那么可以肯定这个num将是一个重要的突破口，我们只要按照syscalls中系统调用的顺序定义一个字符串数组sysname，sysname[num]就是系统调用的名称了。同时p-&gt;trapframe-&gt;a0就是函数返回值。\n107 + │ extern uint64 sys_trace(void);\n\n132 + │ [SYS_trace]   sys_trace, //static uint64 (*syscalls[])(void)\n\n136 + │ char *sysname[] = {\n137 + │ [SYS_fork]    \"fork\",\n138 + │ [SYS_exit]    \"exit\",\n139 + │ [SYS_wait]    \"wait\",\n140 + │ [SYS_pipe]    \"pipe\",\n141 + │ [SYS_read]    \"read\",\n142 + │ [SYS_kill]    \"kill\",\n143 + │ [SYS_exec]    \"exec\",\n144 + │ [SYS_fstat]   \"stat\",\n145 + │ [SYS_chdir]   \"chdir\",\n146 + │ [SYS_dup]     \"dup\",\n147 + │ [SYS_getpid]  \"getpid\",\n148 + │ [SYS_sbrk]    \"sbrk\",\n149 + │ [SYS_sleep]   \"sleep\",\n150 + │ [SYS_uptime]  \"uptime\",\n151 + │ [SYS_open]    \"open\",\n152 + │ [SYS_write]   \"write\",\n153 + │ [SYS_mknod]   \"mknod\",\n154 + │ [SYS_unlink]  \"unlink\",\n155 + │ [SYS_link]    \"link\",\n156 + │ [SYS_mkdir]   \"mkdir\",\n157 + │ [SYS_close]   \"close\",\n158 + │ [SYS_trace]   \"trace\",\n159   │ };\n160   │ \n161   │ void\n162   │ syscall(void)\n163   │ {\n164   │   int num;\n165   │   struct proc *p = myproc();\n166   │ \n167   │   num = p-&gt;trapframe-&gt;a7;\n168   │   if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {\n169   │     p-&gt;trapframe-&gt;a0 = syscalls[num]();\n170 + │     if(1&lt;&lt;num &amp; p-&gt;mask)\n171 + │         printf(\"%d: syscall %s -&gt; %d\\n\",p-&gt;pid,sysname[num],p-&gt;trapframe-&gt;a0);\n172   │   } else {\n173   │     printf(\"%d %s: unknown sys call %d\\n\",\n174   │             p-&gt;pid, p-&gt;name, num);\n175   │     p-&gt;trapframe-&gt;a0 = -1;\n176   │   }\n177   │ }\n\no对，我们甚至还没实现trace函数💦。你可能会觉得上面的做法已经间接实现了trace，但事实上trace是在用户模式（user mode）调用的，因此传入的参数还在用户空间，而系统调用都是在内核空间内执行的，为了操作系统不受进程影响两者是分隔的。\n\n\n用户态的trace函数已经帮我们实现：\n#include \"kernel/param.h\"\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n  char *nargv[MAXARG];\n\n  if(argc &lt; 3 || (argv[1][0] &lt; '0' || argv[1][0] &gt; '9')){\n    fprintf(2, \"Usage: %s mask command\\n\", argv[0]);\n    exit(1);\n  }\n\n  if (trace(atoi(argv[1])) &lt; 0) {\n    fprintf(2, \"%s: trace failed\\n\", argv[0]);\n    exit(1);\n  }\n\n  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++){\n    nargv[i-2] = argv[i];\n  }\n  exec(nargv[0], nargv);\n  exit(0);\n}\n\n不难看出关键函数是int trace(int)，那我们需要先在user/user.h中声明该系统调用，同时在user/usys.pl（生成汇编文件user/usys.S）中加入entry(\"trace\")使trace函数可以进入内核模式，并在kernel/syscall.h中添加一个系统调用号，整个系统调用过程如下所示：\n\nuser/user.h：用户态程序调用跳板函数 trace()\n\nuser/usys.S：跳板函数 trace 使用 CPU 提供的 ecall 指令，进入内核模式\n\nkernel/syscall.c：到达内核模式统一执行系统调用处理函数syscall，所有系统调用都会跳到这里来处理\n\nkernel/syscall.c：syscall根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用\n\nkernel/sysproc.c：到达 sys_trace 函数，执行具体内核操作\n\n\n接下来只需在kernel/sysproc.c中实现sys_trace，该函数只要把用户空间的mask拿进来就行，cmd在执行时事实上可以认为是trace的多个子线程，因此mask会一直传递下去。\nuint64\nsys_trace(void)\n{\n   int mask;\n   if(argint(0, &amp;mask) &lt; 0)\n       return -1;\n   myproc()-&gt;mask=mask;\n   return 0;\n}\n\n\n\n☑︎ Sysinfo (moderate)实现一个系统调用sysinfo，它接受一个指向struct sysinfo的指针，然后向这个结构体写入剩余空间的字节数和状态非”UNUSED”的进程数。\n───────┬─────────────────────────────────────────────────────────\n       │ File: kernel/sysinfo.h\n───────┼─────────────────────────────────────────────────────────\n   1   │ struct sysinfo {\n   2   │   uint64 freemem;   // amount of free memory (bytes)\n   3   │   uint64 nproc;     // number of process\n   4   │ };\n───────┴─────────────────────────────────────────────────────────\n\n首先我们需要实现统计剩余空间字节数和已使用进程数的函数。关于空间分配的实现在kernel/kalloc.c，注意到kmem中有一项freelist链表，然后看kfree函数\n46   │ void\n47   │ kfree(void *pa)\n48   │ {\n49   │   struct run *r;\n50   │ \n51   │   if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)\n52   │     panic(\"kfree\");\n53   │ \n54   │   // Fill with junk to catch dangling refs.\n55   │   memset(pa, 1, PGSIZE);\n56   │ \n57   │   r = (struct run*)pa;\n58   │ \n59   │   acquire(&amp;kmem.lock);\n60   │   r-&gt;next = kmem.freelist;\n61   │   kmem.freelist = r;\n62   │   release(&amp;kmem.lock);\n63   │ }\n\nkfree函数将pa地址开始PGSIZE大小的空间都初始化为1，然后将pa挂到freelist的头上，再将freelist指向pa，而kalloc函数则是每次都使用freelist的第一块PGSIZE空间。说明freelist是可用空间的链表，而且每次分配的最小单元是PGSIZE字节，那么我们只要数一下freelist的元素个数然后乘个PGSIZE即可。\nuint64\ncount_freemem(void)\n{\n  acquire(&amp;kmem.lock);\n  struct run *r = kmem.freelist;\n  uint64 cnt = 0;\n  while (r)\n  {\n    ++cnt;\n    r = r-&gt;next;\n  }\n  release(&amp;kmem.lock);\n  return cnt * PGSIZE;\n}\n\n为防止竞态条件产生，在统计时需要先给kmem上锁。\n\n\n对于统计状态为非”UNUSED”的进程数也不难，注意到kernel/proc.c中\n11   │ struct proc proc[NPROC];\n\n可知最大进程数即为NPROC，那么我们只要遍历proc，然后依次检查状态即可。\nuint64\ncount_process(void)\n{\n  uint64 cnt = 0;\n  for (int i = 0; i &lt; NPROC; ++i)\n    if (proc[i].state != UNUSED)\n      ++cnt;\n  return cnt;\n}\n\n最后我们只要将这个sysinfo结构体拷贝至用户空间即可。首先通过argaddr函数获取用户态int sysinfo(struct sysinfo *)传入的sysinfo虚地址，然后结合该进程的页表pagetable可以得到该地址对应的物理地址，最后将内核中的sysinfo结构体拷贝过去。\nuint64\nsys_sysinfo(void)\n{\n  struct proc *p = myproc();\n  struct sysinfo sf;\n  uint64 addr;\n  sf.freemem = count_freemem();\n  sf.nproc = count_process();\n  if (argaddr(0, &amp;addr) &lt; 0 || copyout(p-&gt;pagetable, addr, (char *)&amp;sf, sizeof(sf)) &lt; 0)\n    return -1;\n  return 0;\n}\n\nargaddr第一个参数0是指从a0寄存器获取，我特地回去翻了一下计组PPT\n\n\n果然，a0、a1存储函数参数，as I guess。\n其余声明之类的与上面的trace类似。另外别忘了在kernel/sysproc.c中加入\n9 + │ #include \"kernel/sysinfo.h\"\n\n如果一切正常，在xv6启动后输入sysinfotest会输出OK。\n$ sysinfotest\nsysinfotest: start\nsysinfotest: OK\n\n\n\n❖ Reference\n[1]MIT 6.S081 2020 Lab2 system calls讲解\n[2][mit6.s081] 笔记 Lab2: System calls | 系统调用\n","slug":"Lab2-system-calls","date":"2022-09-25T03:57:05.000Z","categories_index":"操作系统","tags_index":"走码观花,xv6","author_index":"Starlit Rover"},{"id":"42640cc884e7d3b61d24e0f58f7990cd","title":"「1066」Root of AVL Tree","content":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.\n\n\n \n \nNow given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the root of the resulting AVL tree in one line.\nSample Input 1:5\n88 70 61 96 120\n\nSample Output 1:70\n\nSample Input 2:7\n88 70 61 96 120 90 65\n\nSample Output 2:88\n\n\nΩAVL，平衡二叉搜索树，不仅拥有BST的性质，同时每个顶点左右两棵子树的高度差不超过1，从而使树的高度尽可能维持在一个较低水平，提高搜索效率。给出一组数据，输出最终AVL的根节点，注意每个元素插入后都应及时调整为AVL。\n当初看树这一块的时候，AVL的旋转调整让我头疼不已，现在亦是如此。苦苦思索，原来这是第一次撞上AVL的题目，于是我又回去重温了一遍《数据结构与算法分析》里的相关内容。\n每次插入一个数后我们都从该树开始向根节点回溯，找到第一个左右子树高度差&gt;1的节点X，只要将这棵子树恢复至插入前的高度即可重新满足AVL。\n接下来我们将插入后不满足平衡性的情形分为两种（每种都包含两个镜像对称的情况）：\n\n向X节点的左（右）子节点的左（右）子树插入后不满足\n\n\n向X节点的左（右）子节点的右（左）子树插入后不满足\n\n\n我们用来表示子树，来表示子树的高度，首先显然\n\n那么不可能是空树，因为。因此我们还可以将进行拆分：\n\n\n其次，否则在插入之前就已经不满足平衡性，另外由于节点X是第一个不满足平衡性的节点，因此。\n综上所述，，且。\n\n\n接下来，我们通过两种不同的旋转方法在不破环BST的前提下使其重新符合平衡性（序号与上述情形相对应，只考虑镜像对称中的一种情况）：\n\n拎住绿点向上提，成为节点X的左子树\n\n\n显然满足平衡性，且BST的有序性也未被破坏\n\n拎住节点R向上提成为根节点，想象每条边的端点都是有磁性的，在上提的过程中脱落自动吸附到其他节点上，绿节点和节点X成为其左右子树，而成为绿节点的右子树，成为X节点的左子树 \n\n\n 和的高度关系无法确定，但注意到 ，因此依然可以肯定是符合平衡性要求的。\n\n\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nmap&lt;int, pair&lt;int, int&gt;&gt; avl;\nmap&lt;int, int&gt; height;\n\nint insert(int r, int m)\n{\n    if (!r) return m;\n    if (m &gt; r) avl[r].second = insert(avl[r].second, m);\n    else avl[r].first = insert(avl[r].first, m);\n    int left = height[avl[r].first], right = height[avl[r].second], t;\n    if (abs(left - right) &gt; 1)\n    {\n        bool up1 = left &gt; right, up2;\n        auto &amp;son = up1 ? avl[r].first : avl[r].second;\n        up2 = height[avl[son].first] &gt; height[avl[son].second];\n        if (up1 == up2)\n        {\n            auto &amp;gs = up1 ? avl[son].second : avl[son].first;\n            t = gs, gs = r, r = son, son = t;\n            height[gs] = max(height[avl[gs].first], height[avl[gs].second]) + 1;\n        }\n        else\n        {\n            auto &amp;gs = up1 ? avl[son].second : avl[son].first;\n            auto &amp;out_ggs = up1 ? avl[gs].first : avl[gs].second;\n            auto &amp;in_ggs = up1 ? avl[gs].second : avl[gs].first;\n            t = gs, gs = out_ggs, out_ggs = son, son = in_ggs, in_ggs = r, r = t;\n            height[out_ggs] = max(height[avl[out_ggs].first], height[avl[out_ggs].second]) + 1;\n            height[in_ggs] = max(height[avl[in_ggs].first], height[avl[in_ggs].second]) + 1;\n        }\n    }\n    height[r] = max(height[avl[r].first], height[avl[r].second]) + 1;\n    return r;\n}\n\nint main()\n{\n    int n, m, r = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m, height[m] = 1;\n        r = insert(r, m);\n    }\n    cout &lt;&lt; r;\n}\n\nTips\n用几个引用来替代内/外侧的儿子、孙子、曾孙节点，从而无需考虑镜像对称的情况\n\n用一个map来存储每个节点子树的高度，在进行旋转调整时需要对改变的节点高度进行维护\n\ninsert函数完成插入操作，并对回溯过程中第一个不满足平衡性的节点子树进行旋转调整，结束后返回新子树的根节点\n\n注意节点关系的赋值次序，否则可能出现将赋值后的变量当作老变量使用\n\n\n","slug":"「1066」Root-of-AVL-Tree","date":"2022-09-24T16:14:37.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,Tree,AVL","author_index":"Starlit Rover"},{"id":"42e41f54cdd74aae9e65b00439b07d2c","title":"「1065」A+B and C (64bit)","content":"Given three integers A, B and C in , you are supposed to tell whether A+B&gt;C.\n\n\nInput Specification:The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.\nOutput Specification:For each test case, output in one line Case #X: true if A+B&gt;C, or Case #X: false otherwise, where X is the case number (starting from 1). Each line should ends with '\\n'.\nSample Input:3\n1 2 3\n2 3 4\n9223372036854775807 -9223372036854775808 0\n\nSample Output:Case #1: false\nCase #2: true\nCase #3: false\n\n\nΩ很迷惑，第一行写的还是开区间，结果sample就来了一个。经过实际测试，测试数据的真实数据范围应在，即long long int的范围。\n虽然读取数据时不会溢出，但在A、B相加时可能会发生溢出，那么最简单的一个方法就是通过移项将可能溢出的加法变为减法。根据只有同号相加才可能溢出的原理可以分为以下四种情况：\n\nA、B同号，此时判断C是否也同号：\n\nA、B、C都同号，将不等式改为A&gt;C-B\n\nA、B和C不同号， true /  false\n\n\n\nA、B异号，A+B不会溢出，直接判断\n\n\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    long long int n, a, b, c;\n    string s[] = {\"false\", \"true\"};\n    cin &gt;&gt; n;\n    bool otc;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c);\n        if ((a ^ b) &gt;= 0)\n            otc = ((a ^ c) &gt;= 0) ? a &gt; c - b : (a &gt;= 0);\n        else\n            otc = a + b &gt; c;\n        printf(\"Case #%d: %s\\n\", i + 1, s[otc].c_str());\n    }\n}\n","slug":"「1065」A-B-and-C-64bit","date":"2022-09-24T03:10:52.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"fc7708d5c5ede5940549730140fdd222","title":"「1064」Complete Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nA Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.\nNow given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.\nOutput Specification:For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input:10\n1 2 3 4 5 6 7 8 9 0\n\nSample Output:6 3 8 1 5 7 9 0 2 4\n\n\nΩ给出一组数，输出其完全（最后一层节点从左至右无间隔排列）有序二叉数的层次遍历。\n首先我们对所有数字进行排序得到序列，我们只要按照层次遍历的顺序依次求出每个数在中的索引即可，而索引值即为小于该数的数字个数。\n对于根节点很显然其索引值即为左子树的节点个数，而对于其他节点的索引值计算我们可以分为两部分：\n\n以该节点为根节点的子树，其中小于该数的节点个数依然是左子树节点个数\n\n其余部分（CBT-上述子树），这里我们需要分两种情况讨论：\n\n该节点P为某节点的左子节点，那么小于该数的节点个数就是其父节点F的Part 2值，即父节点F的其余部分小于父节点值的节点个数。注意到，P和F的其余部分相比仅多了F本身和F的右子树，即P的兄弟子树，而右子树上的节点和F的值都&gt;P，因此两者是相等的\n\n该节点是某节点的右子节点，那么小于该数的节点个数是小于其父节点F的节点个数+1。注意到，父节点F的其余部分与该节点其余部分仅相差F本身与F的左子树，而F的左子树是F的Part 1值，因此将其与F的其余部分相加即为小于F的节点个数，最后再算上F本身+1\n\n\n\n\n首先我们可以计算出每个节点中左右子树的节点个数（自底向上，逐层遍历），用pair&lt;int,int&gt;来存储，然后根据上述分析不难发现计算索引时我们只需用到左子树的节点个数，于是pair.second（原本存储右子树节点个数的部分）就可以用存储Part 2的值。注意到Part 2在计算节点本身索引时不需要用到（子节点需要），所以在计算完索引后顺便更新其pair.second。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, level = 1, prod = 2;\n    cin &gt;&gt; n;\n    while (prod &lt; n + 1)\n    {\n        prod *= 2;\n        level += 1;\n    }\n    vector&lt;pair&lt;int, int&gt;&gt; node_num;\n    node_num.resize(prod - 1, pair(0, -1));\n    for (int i = prod / 2 - 1; i &lt; n; ++i)\n        node_num[i] = std::move(pair(0, 0));\n    for (int i = prod / 4; i &gt; 0; i /= 2)\n        for (int j = i - 1; j &lt; 2 * i - 1; ++j)\n            node_num[j] = std::move(pair(node_num[2 * j + 1].first + node_num[2 * j + 1].second + 1,\n                                         node_num[2 * j + 2].first + node_num[2 * j + 2].second + 1));\n    vector&lt;int&gt; keys(n);\n    for (auto &amp;k: keys)\n        cin &gt;&gt; k;\n    sort(keys.begin(), keys.end());\n    cout &lt;&lt; keys[node_num[0].first];\n    node_num[0].second = 0;\n    for (int i = 0; i &lt; n - 1; ++i)\n    {\n        int idx = (i % 2 ? node_num[i / 2].first + 1 : 0) + node_num[i / 2].second + node_num[i + 1].first;\n        cout &lt;&lt; \" \" &lt;&lt; keys[idx];\n        node_num[i + 1].second = idx - node_num[i + 1].first;\n    }\n}\n\n\nΠ上述的思考模式又是一种逆推的过程，多少有点反人类。仔细观察能够发现有序二叉树的中序遍历即为排序结果，那么题目就能转化为已知二叉树的中序遍历如何求其层次遍历的问题。那么我们就顺势而为，模拟一遍中序遍历，然后在模拟过程中顺便计算每个节点在层次遍历中的索引，然后根据索引进行赋值即可。简单地说，就是站在层次遍历的角度去做中序遍历。\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nint n;\nvector&lt;int&gt; level, keys;\n\nvoid InOrder(int node)\n{\n    if (node &gt;= n) return;\n    static int idx = 0;\n    InOrder(2 * node + 1);\n    level[node] = keys[idx++];\n    InOrder(2 * node + 2);\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    keys.resize(n);\n    level.resize(n);\n    for (auto &amp;k: keys)\n        cin &gt;&gt; k;\n    sort(keys.begin(), keys.end());\n    InOrder(0);\n    for (int i = 0; i &lt; level.size(); ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; level[i];\n}\n","slug":"「1064」Complete-Binary-Search-Tree","date":"2022-09-22T08:21:20.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,traversal order,Tree","author_index":"Starlit Rover"},{"id":"70201c87e9f11a4fa65c8ac00911ccba","title":"「1063」Set Similarity","content":"Given two sets of integers, the similarity of the sets is defined to be , where ​ is the number of distinct common numbers shared by the two sets, and  is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.\n\n\nInput Specification:Each input file contains one test case. Each case first gives a positive integer which is the total number of sets. Then N lines follow, each gives a set with a positive  and followed by M integers in the range [0,109]. After the input of sets, a positive integer  is given, followed by  lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to ). All the numbers in a line are separated by a space.\nOutput Specification:For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.\nSample Input:3\n3 99 87 101\n4 87 101 5 87\n7 99 101 18 5 135 18 99\n2\n1 2\n1 3\n\nSample Output:50.0%\n33.3%\n\n\nΩ求两集合的相似度=交集元素/并集元素。\n实际求解过程中只需要求交集元素即可，并集元素数=集合1+集合2-交集。由于C++里面已经支持求交集的函数，可以直接使用，不过用法不是那么好记，当然我们也可以直接用类似归并排序的思想直接实现：\ntemplate&lt;class InputIt1, class InputIt2,\n         class OutputIt, class Compare&gt;\nOutputIt set_intersection(InputIt1 first1, InputIt1 last1,\n                          InputIt2 first2, InputIt2 last2,\n                          OutputIt d_first, Compare comp)\n{\n    while (first1 != last1 &amp;&amp; first2 != last2) {\n        if (comp(*first1, *first2)) {\n            ++first1;\n        } else {\n            if (!comp(*first2, *first1)) {\n                *d_first++ = *first1++; // *first1 and *first2 are equivalent.\n            }\n            ++first2;\n        }\n    }\n    return d_first;\n}\n\n事实上Python中的set容器做的挺好，交并运算都符号化了，实现起来也很快。\n\n🐎#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n;\n    set&lt;int&gt; s[n];\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k;\n            s[i].insert(k);\n        }\n    }\n\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m &gt;&gt; k;\n        set&lt;int&gt; inter;\n        set_intersection(s[m - 1].begin(), s[m - 1].end(), s[k - 1].begin(), s[k - 1].end(),\n                         inserter(inter, inter.begin()));\n        printf(\"%.1f%%\\n\", inter.size() * 1.0 / (s[m - 1].size() + s[k - 1].size() - inter.size()) * 100);\n    }\n}\n\n🐎🐎num=eval(input())\nsets=[set() for i in range(num)]\nfor i in range(num):\n    nums=list(map(eval,input().split()))\n    n=nums[0]\n    for j in range(n):\n        m=nums[j+1]\n        sets[i].add(m)\nn=eval(input())\nfor i in range(n):\n    a,b=map(eval,input().split())\n    inter=sets[a-1]&amp;sets[b-1]\n    print(\"%.1f%%\"%(len(inter)/(len(sets[a-1])+len(sets[b-1])-len(inter))*100))\n","slug":"「1063」Set-Similarity","date":"2022-09-21T08:11:18.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,set","author_index":"Starlit Rover"},{"id":"61bd7651739e9a5cb7671d4227eb7db6","title":"「1062」Talent and Virtue","content":"About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue.\nNow given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory.\n\n\nInput Specification:Each input file contains one test case. Each case first gives 3 positive integers in a line: , the total number of people to be ranked; , the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and , the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are considered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below H, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the L line are ranked after the “fool men”.\nThen N lines follow, each gives the information of a person in the format:\nID_Number Virtue_Grade Talent_Grade\n\nwhere ID_Number is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.\nOutput Specification:The first line of output must give , the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s.\nSample Input:14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n\nSample Output:12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n\n\nΩ除了排序规则有点复杂外，也只是一道简单的信息分类输出题。根据司马光先生（砸缸的那位\n）的理论，人分为圣人（）、君子（）、愚人（）、小人（）。给出人数N、H、L，以及每人的T、V，请按照前述的顺序分类并输出，同一类中按照降序排列，相等时按照降序排序，再相等时按照ID升序排列。\n对于排序规则，只需要写一个cmp函数然后sort即可，其余就是如何组织数据结构的问题了。一开始我用map存储了ID所对应的T、V，然后分类时只存储ID，将map作为全局变量从而实现对ID的sort。不幸的是，提交后出现了超时，其实仔细想想，排序时需要不断地访问map，最后输出还要再访问一遍。而，如果说所有人都在同一类，那么访问map的时间将会是致命的。最后我采用了tuple，将ID、T、V都存储在一起（类似于结构体），消除了访问时间，Run Time陡跌。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;string, int, int&gt; tsii;\n\nbool cmp(tsii &amp;a, tsii &amp;b)\n{\n    if (get&lt;1&gt;(a) + get&lt;2&gt;(a) != get&lt;1&gt;(b) + get&lt;2&gt;(b))\n        return get&lt;1&gt;(a) + get&lt;2&gt;(a) &gt; get&lt;1&gt;(b) + get&lt;2&gt;(b);\n    else if (get&lt;1&gt;(a) != get&lt;1&gt;(b))\n        return get&lt;1&gt;(a) &gt; get&lt;1&gt;(b);\n    else\n        return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);\n}\n\nint main()\n{\n    int N, L, H, t, v;\n    scanf(\"%d %d %d\", &amp;N, &amp;L, &amp;H);\n    int valid = N;\n    vector&lt;tuple&lt;string, int, int&gt;&gt; men[4];\n    string s;\n    s.resize(8);\n    for (int i = 0; i &lt; N; ++i)\n    {\n        scanf(\"%s %d %d\", &amp;s[0], &amp;v, &amp;t);\n        if (t &lt; L || v &lt; L)\n        {\n            valid -= 1;\n            continue;\n        }\n        else if (t &gt;= H &amp;&amp; v &gt;= H)\n            men[0].emplace_back(s, v, t);\n        else if (t &lt; H &amp;&amp; v &gt;= H)\n            men[1].emplace_back(s, v, t);\n        else if (t &lt;= v &amp;&amp; v &lt; H)\n            men[2].emplace_back(s, v, t);\n        else\n            men[3].emplace_back(s, v, t);\n    }\n    printf(\"%d\\n\", valid);\n    for (auto &amp;m: men)\n    {\n        sort(m.begin(), m.end(), cmp);\n        for (auto &amp;k: m)\n            printf(\"%s %d %d\\n\", get&lt;0&gt;(k).c_str(), get&lt;1&gt;(k), get&lt;2&gt;(k));\n    }\n}\n","slug":"「1062」Talent-and-Virtue","date":"2022-09-21T03:12:33.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,tuple","author_index":"Starlit Rover"},{"id":"1e574a5e3fca1a756fff12eb87b95cbe","title":"Lab1: Xv6 and Unix utilities","content":"这学期开始学操作系统啦，一周五节课，是一位老教师，除了讲话慢了点还经常请同学们回答一些神奇问题外感觉还好，和上学期的寄网还是有差距的。暑假想预习来着的，不过经历了一些事情有点颓，现在回忆起来像是上个世纪的假期了。众所周知，大学=大不了自学，所以打开了MIT·S081。\n课程配套实验基于教授们自己写的一个类UNIX教学操作系统——xv6，通过xv6上的实验你能够对操作系统中的一些概念以及操作理解更深，精品良心，废话不多说，希望这学期能好好做实验（\\认真脸）。\n第一个实验主要以熟悉xv6以及系统调用函数为主，实验文档戳这。\n\n\n\n\n❖ 安装xv6\n众所周知，环境两小时，实验5分钟。不过安装xv6似乎十分顺利并没有遭遇太多的不测，当然很大一部分原因是站在别人的血泪史上。如果你也是M1用户，可以参考MIT 6.S081/Fall 2020 搭建risc-v与xv6开发调试环境这篇博客。\n前置环境主要是：\n\ngcc / clang ：用来编译riscv-gnu-toolchain 工具链\n\nriscv-gnu-toolchain 工具链：用来编译调试xv6，需要下载源码进行编译\n\nqemu：可以运行不同架构下操作系统的虚拟机，用C语言来模拟硬件的执行，由于xv6是运行在RISC-V架构上的，因此需要qemu来运行.\n\n\n上述环境配置完成后，即可\n&gt; git clone git://g.csail.mit.edu/xv6-labs-2021\n&gt; cd xv6-labs-2021\n&gt; git checkout util\n\n最后通过make qemu来编译xv6并运行，接下来就可以在xv6的命令行中输入命令了。\n\n\n❖ Coding\n☑︎ sleep (easy)第一个实验非常简单，实现用户指定时间的停顿，而xv6系统内置sleep函数，主要是熟悉码命令时的一些基本格式。首先每个命令都会传入两个参数：int argc&amp;char *argv[]，argc是传入参数的个数，而argv是所有传入参数的字符串形式数组。那么这个问题就非常的清晰明了了，只需要把用户传入的时间转为数字，然后调用sleep()即可。\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int arg, char *argv[])\n{\n    if (arg &lt;= 1)\n    {\n        fprintf(2, \"usage: sleep n\\n\");\n        exit(1);\n    }\n    else if (arg &gt; 2)\n    {\n        fprintf(2, \"ERROR: too much arguments!\\nusage: sleep n\\n\");\n        exit(1);\n    }\n\n    char *s = argv[1];\n    int n = 0;\n    while (*s &gt;= '0' &amp;&amp; *s &lt;= '9')\n        n = 10 * n + *s++ - '0';\n    if (*s != 0)\n    {\n        fprintf(2, \"ERROR: the second parameter must be a number!\\n\");\n        exit(0);\n    }\n    sleep(n);\n    exit(0);\n}\n\n⚠️argv[0]是命令名称，真正的参数从argv[1]开始。另外不要忘记错误处理与错误提示。\n\n\n☑︎ pingpong (easy)先用fork函数创建子进程，然后使用pipe函数进行进程间通讯，最后通过getpid函数获取进程id并输出“PID：received …”。\n首先通过fork返回值是否为0判断是子进程or父进程（父进程返回子进程id），fork完之后两者的资源都是一样的而且都从fork函数继续运行。那么我们先用pipe创建一个管道，用一个int p[2]来记录管道两端的文件描述符，p[1]写p[2]读。\n那么先在父进程中write，然后子进程read完输出并write，父进程通过wait函数（等待第一个子进程结束，如果没有子进程直接继续）等待子进程结束再继续read并输出。\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int arg, char *argv[])\n{\n    int p[2];\n    pipe(p);\n    char buff[5];\n    if (fork() == 0)\n    {\n        if (read(p[0], buff, 5) != 5)\n        {\n            printf(\"Read Parent ERROR!\\n\");\n            exit(1);\n        }\n        close(p[0]);\n        printf(\"%d: received %s\\n\", getpid(), buff);\n        write(p[1], \"pong\", 5);\n        close(p[1]);\n    }\n    else\n    {\n        write(p[1], \"ping\", 5);\n        close(p[1]);\n        wait(0);\n        if (read(p[0], buff, 5) != 5)\n        {\n            printf(\"Read Child ERROR!\\n\");\n            exit(1);\n        }\n        printf(\"%d: received %s\\n\", getpid(), buff);\n        close(p[0]);\n    }\n    exit(0);\n}\n\nread函数返回读取的字节数，达到文件末尾返回0，出错返回-1，write类似。\n⚠️读写完及时close，不要忘记字符串末尾的’\\0’。\n至于为什么父进程写的比子进程读的快，我想是因为子进程因为需要复制资源还需要耗费额外的时间，因此开始执行的时间会晚于父进程。\n$ pingpong\n4: received ping\n3: received pong\n$\n\n\n\n☑︎ primes (moderate/hard)不是一个命令，但有助于你理解pipe的工作流程。输入primes命令后输出2-35之间的素数。虽然个数有限而且很少可以直接枚举，但希望你利用pipe制作一个埃氏素数筛。大致的流程如下图所示：\n\n\n它的思想很简单，首先用最小素数2筛去为其倍数的数字，然后再筛去为第二小素数3的倍数，依次类推。不难发现，如果该数组是以2开始的一串连续数字的话，那么每次筛完后的最小数字一定是素数，否则必然还存在比其小的素数未被筛选，这是矛盾的。因此我们只要每次输出最小数字然后筛去该数字的倍数即可。\n很显然这里需要pipe实现传递的功能，那么我们可以每次先从上一个pipe中读出剩下的数组，然后创建一个新的pipe，将该轮筛选后剩余的数字写入新pipe中，接着fork一个新进程，有点类似函数递归调用，我下面用循环代替了递归。\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main()\n{\n    int buff[34], p[2], size = 34;\n    for (int i = 0; i &lt; 34; ++i)\n        buff[i] = i + 2;\n    pipe(p);\n    write(p[1], buff, size * sizeof(int));\n    close(p[1]);\n\n    while(size)\n    {\n        if (fork() == 0)\n        {\n            read(p[0], buff, size * sizeof(int));\n            close(p[0]);\n            pipe(p);\n            printf(\"prime %d\\n\", buff[0]);\n            int cnt = 0, prime = buff[0];\n            for (int i = 0; i &lt; size; ++i)\n                if (buff[i] % prime != 0)\n                    buff[cnt++] = buff[i];\n            size = cnt;\n            write(p[1], buff, cnt * sizeof(int));\n            close(p[1]);\n        }\n        else\n        {\n            wait(0);\n            exit(0);\n        }\n    }\n    exit(0);\n}\n\n之所以父进程需要wait是因为如果不wait第一个进程在执行完后就直接exit(0)了，这样就会导致系统以为你执行完了事实上并没有的局面：\n$ primes\np$r ime 2\nprime 3\nprime 5\nprime 7\nprime 11\nprime 13\nprime 17\nprime 19\nprime 23\nprime 29\nprime 31\n\n你会发现在输出第一条信息的过程中系统以为进程结束，于是输出【$ 】，其实只是第一个进程结束了，但它需要对创建的所有进程负责。\n⚠️创建新管道前记得把老管道的端口close，否则就丢失了。\n☑︎ find (moderate)实现一个简单的查找文件命令find，命令格式为【find rootfile filename】，共计两个参数，那么这里我们需要学会如何访问文件。\n通过阅读user/ls.c，不难得知每个路径都是一个文件，文件内记录该路径下的子文件信息，首先通过open(char *path, int flag)函数打开对应路径path的文件，返回相应的文件描述符，flag是读写标志。然后用stat(int fd, struct stat *st)将fd对应的文件夹/文件的信息写入结构体st，其中st.type表示其（文件夹T_DIR/文件T_FILE）类型。\n这是一方面，但更重要的是获取路径下子文件的信息，例如文件名。fd对应的文件内部记录了所有子文件的信息，可以通过read(fd, &amp;de, sizeof(de))    来获取一个子文件信息，其中de是子文件信息结构体类型的一个实体。de包含inum和name，inum给不同文件夹和文件编号，name为文件名或文件夹名。\n那么通过stat(path+'/'+de.name, &amp;st)就能获取子文件的相关信息，再由st。tyoe判断是否为文件夹进行递归搜索。\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\nvoid search(char *path, char *name)\n{\n    struct dirent de;\n    struct stat st;\n    char buf[512], *p;\n    int fd;\n\n    if ((fd = open(path, 0)) &lt; 0)\n    {\n        fprintf(2, \"find: cannot open %s\\n\", path);\n        return;\n    }\n\n    if (fstat(fd, &amp;st) &lt; 0)\n    {\n        fprintf(2, \"find: cannot stat %s\\n\", path);\n        close(fd);\n        return;\n    }\n\n    switch (st.type)\n    {\n    case T_FILE:\n        printf(\"find: %s is a file instead of a path.\\n\", path);\n        break;\n    case T_DIR:\n        if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof(buf))\n        {\n            printf(\"find: path too long!\\n\");\n            break;\n        }\n        strcpy(buf, path);\n        p = buf + strlen(path);\n        *p++ = '/';\n\n        while (read(fd, &amp;de, sizeof(de)) == sizeof(de))\n        {\n            // dno't forget inum==0!\n            if (!strcmp(de.name, \".\") || !strcmp(de.name, \"..\") || de.inum == 0)\n                continue;\n            memmove(p, de.name, DIRSIZ);\n            p[DIRSIZ] = 0;\n            if (stat(buf, &amp;st) &lt; 0)\n            {\n                printf(\"find: cannot stat %s\", buf);\n                continue;\n            }\n            switch (st.type)\n            {\n            case T_DIR:\n                search(buf, name);\n                break;\n            case T_FILE:\n                if (!strcmp(de.name, name))\n                    printf(\"%s\\n\", buf, path);\n                break;\n            // default:\n            //    break;\n            }\n        }\n        break;\n    }\n    close(fd);\n}\n\nint main(int argc, char *argv[])\n{\n    if (argc &lt; 3)\n    {\n        fprintf(2, \"usage: find rootpath filename.\\n\");\n        exit(1);\n    }\n\n    search(argv[1], argv[2]);\n    exit(0);\n}\n\n简单地说，de是子文件信息结构体，st是本身信息结构体。DIRSIZ是文件名固定长度，方便处理。memmove( void* dest, const void* src, size_t count )从src拷贝count个字节到dest，如果是字符串记得补0。buf来存储路径以及子目录的路径字符串。\n⚠️子文件信息里面会包含当前目录【.】、上级目录【..】还有一个inum==0 &amp;&amp; de.name==\"\"的节点（大概查阅了一下，de.inum==0表示这是一块已经初始化并且可以用来创建文件或者文件夹的位置），注意绕道避免无限递归，无限递归将导致栈溢出，运行时会出现usertrap()。\n    $ echo &gt; b\n$ mkdir a\n$ echo &gt; a/b\n$ find . b\n./b\n./a/b\n$ \n\n\n\n☑︎ xargs (moderate)xargs命令是一个可以扩展输入参数的命令，通过cmd1 ｜ xargs cmd2可以将cmd1命令的输出添加到cmd2的输入参数中，如果cmd1输出有多行则分别添加执行，效果与UNIX中的xargs -n 1等同：\n$ echo \"1\\n2\" | xargs -n 1 echo line\nline 1\nline 2\n\n$ echo hello too | xargs echo bye\nbye hello too\n\n首先我们需要把xargs后面命令原本就跟着的参数拷贝过去，我这里是直接把字符串指针拷贝过去（相当于浅拷贝），并没有malloc一块新空间。\n对于追加的参数，我们从标准输入（fd为0）读入。然后就一个一个字符地读，读到’\\n’或’ ‘就malloc一块新的空间将这个参数复制过来并将头指针存入char *para[MAXARG]，如果读到了’\\n’或者文件结尾就执行一次exec函数（⚠️exec函数不会返回调用函数，如果返回就说明执行失败exit(1)）。\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"kernel/param.h\"\n#include \"user/user.h\"\n#define MAXLEN 512\n\nint main(int argc, char *argv[])\n{\n    if (argc &lt; 2)\n    {\n        fprintf(2, \"usage: xargs command.\\n\");\n        exit(1);\n    }\n\n    char buf[MAXLEN], *para[MAXARG];\n    int flag = 1;\n\n    // shallow copy xisting parameters\n    for (int i = 1; i &lt; argc; ++i)\n        para[i - 1] = argv[i];\n\n    // flag==0 means EOF\n    while (flag)\n    {\n        int cnt = argc - 1, len = 0;\n        // read a line from standard input\n        while ((flag = read(0, buf + len, 1)))\n        {\n            if (buf[len] == '\\n' || buf[len] == ' ')\n            {\n                if (len)\n                {\n                    para[cnt] = (char *)malloc(len + 1);\n                    memmove(para[cnt], buf, len);\n                    para[cnt][len] = 0;\n                    len = 0;\n                    if (++cnt &gt; MAXARG)\n                    {\n                        printf(\"xargs: too many arguments!\\n\");\n                        exit(1);\n                    }\n                }\n\n                if (buf[len] == '\\n')\n                    break;\n            }\n            else if (len + 1 &gt; MAXLEN)\n            {\n                printf(\"xargs: argument too long!\\n\");\n                exit(1);\n            }\n            else\n                ++len;\n        }\n        if (!fork())\n        {\n            exec(para[0], para);\n            exit(1);\n        }\n        else\n            wait(0);\n    }\n    exit(0);\n}\n\n⚠️命令参数个数有限制（MAXARG），另外需要关注一个参数长度不能超过自己定义的buf（MAXLEN）。\n\n\n❖ Grading &amp; Debug\ncd xv6-labs-2021\n./grade-lab-util command_name\n\ne.g.\n&gt; ./grade-lab-util sleep   \nmake: `kernel/kernel' is up to date.\n== Test sleep, no arguments == sleep, no arguments: OK (1.3s) \n== Test sleep, returns == sleep, returns: OK (0.9s) \n== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) \n\n所有Test都显示OK即可。\n\n\nDebug需要用gdb进行远程调试，首先在一个命令框中（在xv6-labs-2021目录下）make qemu-gdb，然后新建一个命令框窗口（还是在xv6-labs-2021目录下）riscv64-unknown-elf-gdb user/_xargs（【_】+命令名称 ）。如果连接失败在gdb界面输入target remote localhost:25501（端口号见qemu界面最后一行tcp::xxxxx）。不希望每次输入可以写入~/.gdbinit。b设置断点，c运行至断点，n单步执行，p arg查看arg值。\n\n","slug":"Lab1-Xv6-and-Unix-utilities","date":"2022-09-13T10:32:31.000Z","categories_index":"操作系统","tags_index":"走码观花,xv6","author_index":"Starlit Rover"},{"id":"0eaf91694ac904eb1b9bccba53543259","title":"「1060」Are They Equal","content":"If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved as  with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\n\n\nInput Specification:Each input file contains one test case which gives three numbers  and , where  is the number of significant digits, and A and B are the two float numbers to be compared. Each float number is non-negative, no greater than , and that its total digit number is less than 100.\nOutput Specification:For each test case, print in a line YES if the two numbers are treated equal, and then the number in the standard form 0.d[1]...d[N]*10^k (d[1]&gt;0 unless the number is 0); or NO if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\nNote: Simple chopping is assumed without rounding.\nSample Input 1:3 12300 12358.9\n\nSample Output 1:YES 0.123*10^5\n\nSample Input 2:3 120 128\n\nSample Output 2:NO 0.120*10^3 0.128*10^3\n\n\nΩ给定底数的存取精度，忽略指数的精度范围，判断两个数用科学计数法表示后（有精度的损失）是否相等。\n这种题目就是那种月球村，到处都是环形坑，当然碰到这种题目也不要害怕，把所有坑都踩一遍就无敌啦。\n科学计数法无非就两个重要数据——底数和指数，我们可以建一个科学计数法的class来统一格式化。\n对于刚读入的纯天然数字字符串n，我们先求指数。用find('.')函数确定小数点的位置，如果不存在小数点就取【最后一个字符索引+1=n.size()】，然后将小数点去除（⚠️去除后小数点的索引就变成了小数点后一位数字的索引，也是格式化中第一个非0数字将要移到的位置）找第一个非0数字的位置，找到后就将所有前置0去除。此时若字符串为空说明为0（大坑），单独指定一下指数为0；非空就用【小数点位置（终点）-第一个非0数字位置（起点）】，即为所求指数。\n然后如果此时字符串不足n位的话就通过添加后置‘0’来补到n位，这样就得到了底数和指数。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Float\n{\npublic:\n    string data;\n    int bias = 0;\n\n    explicit Float(int n)\n    {\n        cin &gt;&gt; data;\n        size_t point = data.find('.');\n        if (point == string::npos)\n            point = data.size();\n        else\n            data.erase(data.begin() + point);\n\n        for (char &amp;it: data)\n        {\n            if (it != '0')\n                break;\n            ++bias;\n        }\n        data.erase(0, bias);\n        if (data.empty())\n        {\n            data = \"0\";\n            bias = 0;\n        }\n        else\n            bias = point - bias;\n        while (data.size() &lt; n)\n            data += \"0\";\n    }\n\n    inline string format(int n)\n    {\n        return \"0.\" + data.substr(0, n) + \"*10^\" + to_string(bias);\n    }\n};\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    Float a(n), b(n);\n    if (a.bias == b.bias &amp;&amp; a.data.substr(0, n) == b.data.substr(0, n))\n        cout &lt;&lt; \"YES \" &lt;&lt; a.format(n) &lt;&lt; endl;\n    else\n        cout &lt;&lt; \"NO \" &lt;&lt; a.format(n) &lt;&lt; \" \" &lt;&lt; b.format(n) &lt;&lt; endl;\n}\n\n\nTips☔︎\nstring.find(char)返回第一个字符所在的下标索引（不是迭代器），如果没找到就会返回string::npos，即size_t类型的最大值\n\n字符串的删除函数string.erase()有两种用法：\n\nstring.erase(iterator pos)：直接传入该字符的迭代器进行删除\n\nstring.erase(int start,int num)：指定起始索引和连续删除的字符个数，删除string[start:start+num]，start+num处字符保留\n\n\n\n\n","slug":"「1060」Are-They-Equal","date":"2022-09-11T08:00:39.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"d25a64f6e3048948d06ba269622dda29","title":"「1059」Prime Factors","content":"Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format ​.\n\n\nInput Specification:Each input file contains one test case which gives a positive integer N in the range of long int.\nOutput Specification:Factor N in the format N = p1​^k1​*p2​^k2​*…*pm​^km​, where pi​’s are prime factors of N in increasing order, and the exponent ki​ is the number of pi​ – hence when there is only one pi​, ki​ is 1 and must NOT be printed out.\nSample Input:97532468\n\nSample Output:97532468=2^2*11*17*101*1291\n\n\nΩ经典分解质因数，感觉已经不会做大一的题目了，真的年纪大了。\n有两种思路，首先建立一个素数表，我们知道一个数的质因数不会超过其平方根，那么由于，因此我们只需找出所有5000以内的素数然后一个一个素数去除。\n这种做法没什么美感。我采取了一点优化，不建立素数表，首先可以肯定最小的因数一定是素数，否则还会存在更小的因数而矛盾。根据这一条性质，我们只需每次找最小的因子即可，必然是素数，然后接着找的最小素因子，周而复始。另外循环搜索的范围也不必从2开始，根据我们的策略可以发现每轮发现的最小素因子必然上一轮找到的最小素因子（否则必然更早找到），因此可以将循环范围定为（事实证明比更快）。另外每找到一个就更新并重新开始循环，直到不再变化为止。\n如此一来，我们就能对搜索区间的两端同时进行优化，运行时用一个map记录每个出现的次数最后统一输出即可。\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;int, int&gt; pf;\n    int n, m = -1, pre = 2;\n    cin &gt;&gt; n;\n    cout &lt;&lt; n &lt;&lt; \"=\";\n    if (n == 1) cout &lt;&lt; \"1\";\n    else\n    {\n        while (m != n)\n        {\n            m = n;\n            for (int i = pre; i &lt;= n / 2; ++i)\n                if (n % i == 0)\n                {\n                    pf[i] += 1;\n                    n /= (pre = i);\n                    break;\n                }\n        }\n        pf[n] += 1;\n        bool flag = true;\n        for (auto &amp;k: pf)\n            cout &lt;&lt; (flag ? (flag = false, \"\") : \"*\") &lt;&lt; k.first &lt;&lt; (k.second == 1 ? \"\" : \"^\" + to_string(k.second));\n    }\n}\n","slug":"「1059」Prime-Factors","date":"2022-09-08T13:23:41.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,prime","author_index":"Starlit Rover"},{"id":"2d08ef1e83c7532f13470f67dbd15fc9","title":"「1058」A+B in Hogwarts","content":"If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of Galleon.Sickle.Knut (Galleon is an integer in , Sickle is an integer in , and Knut is an integer in ).\n\n\nInput Specification:Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space.\nOutput Specification:For each test case you should output the sum of A and B in one line, with the same format as the input.\nSample Input:3.2.1 10.16.27\n\nSample Output:14.1.28\n\n\nΩ不难，可以看成是一个各数位进制不同的三位数相加，个位数是29进制，十位是17进制，输出最终和。\n想用tuple练练手（温馨提示：事实证明没事不要用奇奇怪怪的容器），然后发现tuple的取元素函数get&lt;&gt;()是一个模版函数，尖括号内的值必须在编译阶段确定，因此不能是变量。幸好只有三位，枚举一波。。。也很累，另外只要设置一个carry变量模拟竖式加法即可。\n\n#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\nusing namespace std;\n\nint main()\n{\n    tuple&lt;int, int, int&gt; a, b, c;\n    scanf(\"%d.%d.%d %d.%d.%d\", &amp;get&lt;0&gt;(a), &amp;get&lt;1&gt;(a), &amp;get&lt;2&gt;(a), &amp;get&lt;0&gt;(b), &amp;get&lt;1&gt;(b), &amp;get&lt;2&gt;(b));\n    int carry = 0;\n    get&lt;2&gt;(c) = (get&lt;2&gt;(a) + get&lt;2&gt;(b) + carry) % 29;\n    carry = (get&lt;2&gt;(a) + get&lt;2&gt;(b) + carry) / 29;\n    get&lt;1&gt;(c) = (get&lt;1&gt;(a) + get&lt;1&gt;(b) + carry) % 17;\n    carry = (get&lt;1&gt;(a) + get&lt;1&gt;(b) + carry) / 17;\n    get&lt;0&gt;(c) = get&lt;0&gt;(a) + get&lt;0&gt;(b) + carry;\n    printf(\"%d.%d.%d\", get&lt;0&gt;(c), get&lt;1&gt;(c), get&lt;2&gt;(c));\n}\n","slug":"「1058」A-B-in-Hogwarts","date":"2022-09-08T12:03:34.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,tuple","author_index":"Starlit Rover"},{"id":"c3a496a07a213e1385fa77bc05492d6e","title":"「1057」Stack","content":"Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian – return the median value of all the elements in the stack. With N elements, the median value is defined to be the -th smallest element if N is even, or -th if N is odd.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer . Then N lines follow, each contains a command in one of the following 3 formats:\nPush key\nPop\nPeekMedian\n\nwhere key is a positive integer no more than .\nOutput Specification:For each Push command, insert key into the stack and output nothing. For each Pop or PeekMedian command, print in a line the corresponding returned value. If the command is invalid, print Invalid instead.\nSample Input:17\nPop\nPeekMedian\nPush 3\nPeekMedian\nPush 2\nPeekMedian\nPush 1\nPeekMedian\nPop\nPop\nPush 5\nPush 4\nPeekMedian\nPop\nPop\nPop\nPop\n\nSample Output:Invalid\nInvalid\n3\n2\n2\n1\n2\n4\n4\n5\n3\nInvalid\n\n\nΩ本以为是一个模拟栈的小题，没想到外加PeekMedian功能；本以为只需输出栈中间元素即可，没想到是所有元素排序后的中间元素。\n本来想用multiset容器来实现元素自动排序的，不过中间元素的迭代器并不好求。不想超时还是只能用线性容器vector+二分搜索。\n思想非常纯朴，一个stack来模拟，一个vector来排序。vector的插入和删除都使用二分搜索来寻找位置，勉勉强强不会超时。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, left, right, mid;\n    cin &gt;&gt; n;\n    stack&lt;int&gt; stk;\n    vector&lt;int&gt; order;\n    string s;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; s;\n        if (s == \"Push\")\n        {\n            cin &gt;&gt; m;\n            left = 0, right = stk.size(), mid = (left + right) / 2;\n            while (left &lt; right - 1)\n            {\n                (order[mid] &gt; m) ? (right = mid) : (left = mid);\n                mid = (left + right) / 2;\n            }\n            int fix = (!order.empty() &amp;&amp; order[left] &lt; m) ? 1 : 0;\n            order.insert(order.begin() + left + fix, m);\n            stk.push(m);\n        }\n        else if (!stk.empty())\n        {\n            if (s == \"Pop\")\n            {\n                int t = stk.top();\n                cout &lt;&lt; t &lt;&lt; endl;\n                left = 0, right = stk.size(), mid = (left + right) / 2;\n                while (left &lt; right)\n                {\n                    if (order[mid] != t)\n                        (order[mid] &gt; t) ? (right = mid) : (left = mid);\n                    else break;\n                    mid = (left + right) / 2;\n                }\n                stk.pop();\n                order.erase(order.begin() + mid);\n            }\n            else\n                cout &lt;&lt; order[(stk.size() - 1) / 2] &lt;&lt; endl;\n        }\n        else\n            cout &lt;&lt; \"Invalid\" &lt;&lt; endl;\n    }\n}\n\n\nTips两次二分搜索还是有点差异的，Pop时你可以确定存在该元素，只要order[mid]==value    即可退出循环，而Push时我们寻找的是插入该元素的位置，退出循环的时候right和lleft最多差1（left &lt; right - 1为防止right=left+1 &amp;&amp; mid==left时而无限循环），此时order[mid]既有可能==m，也有可能&lt;m，后者不能直接插入，因此引入一个fix对位置进行修正。\n","slug":"「1057」Stack","date":"2022-09-08T02:14:58.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search,stack","author_index":"Starlit Rover"},{"id":"f2cca43e895bb7a04b6723f4b34dca34","title":"「1056」Mice and Rice","content":"Mice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse.\nFirst the playing order is randomly decided for  programmers. Then every ​ programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every  ​ winners are then grouped in the next match until a final winner is determined.\nFor the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: ​ and , the number of programmers and the maximum number of mice in a group, respectively. If there are less than  ​ mice at the end of the player’s list, then all the mice left will be put into the last group. The second line contains NP​ distinct non-negative numbers  where each  is the weight of the -th mouse respectively. The third line gives the initial playing order which is a permutation of  (assume that the programmers are numbered from 0 to ). All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the final ranks in a line. The -th number is the rank of the -th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line.\nSample Input:11 3\n25 18 0 46 37 3 19 22 57 56 10\n6 0 8 7 10 5 9 1 4 2 3\n\nSample Output:5 5 5 2 5 5 5 3 1 3 5\n\n\nΩ奇奇怪怪，莫名其妙。\n由于对题目的高超解读，导致我手算Sample都算不出Output。\n对只老鼠的体重进行分组比较，每组不超过个老鼠。每组最胖的那只肥仔将赢得组内比赛，进入下一轮比赛，每组输掉的老鼠都将获得相同的名次。下一轮比赛还是按照不超过个老鼠进行分组比赛，以同样的方式选择出winner进入下一轮直至诞生第一名肥仔。\n输入就三行，前两行就是和各个老鼠的体重，而第三行题目中说是“initial playing order”，即初始比赛顺序。那么我想0号是第一位选手，而是最后一位选手，结果发现算出来不对，懵了。其实第二行已经给每个老鼠按照顺序编了号，第三行是根据编号给出参赛顺序，，，可能中午吃太多把脑子塞住了。\n\n\n由于最后需要按编号输出，因此可以用pair记录每只老鼠的体重和编号，然后根据参赛顺序对老鼠进行排列：\nfor (int i = 0; i &lt; np; ++i)\n{\n    cin &gt;&gt; k;\n    order[k] = i;\n}\nsort(weight.begin(), weight.end(), [](pii &amp;a, pii &amp;b) { return order[a.second] &lt; order[b.second]; });    \n\n接下来每只老鼠选出最胖肥仔作为赢家，并将其的名次赋为（其中w为本轮将要选出的赢家数，-1解决了整除时无需+1的问题），也就是说先把进入下一轮比赛老鼠的名次都赋成下一轮输家的名次，那么只要计算下一轮赢家数+1即可。直到选出唯一的赢家结束。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; weight;\nvector&lt;int&gt; order;\ntypedef pair&lt;int, int&gt; pii;\n\nint main()\n{\n    int np, ng, k;\n    cin &gt;&gt; np &gt;&gt; ng;\n    order.resize(np);\n    for (int i = 0; i &lt; np; ++i)\n    {\n        cin &gt;&gt; k;\n        weight.emplace_back(k, i);\n    }\n    for (int i = 0; i &lt; np; ++i)\n    {\n        cin &gt;&gt; k;\n        order[k] = i;\n    }\n    sort(weight.begin(), weight.end(), [](pii &amp;a, pii &amp;b) { return order[a.second] &lt; order[b.second]; });\n    int r = np == 1 ? 1 : (np - 1) / ng + 2;\n    vector&lt;int&gt; rank(np, r);\n    vector&lt;pii&gt; next;\n    while (weight.size() != 1)\n    {\n        r = r == 2 ? 1 : (r - 2) / ng + 2;\n        for (int i = 0; i &lt; weight.size(); i += ng)\n        {\n            int maxw = weight[i].first;\n            auto iter = weight.begin() + i;\n            for (int j = i + 1; j &lt; i + ng &amp;&amp; j &lt; weight.size(); ++j)\n                if (weight[j].first &gt; maxw)\n                {\n                    maxw = weight[j].first;\n                    iter = weight.begin() + j;\n                }\n            rank[iter-&gt;second] = r;\n            next.push_back(*iter);\n        }\n        weight = std::move(next);\n        next = vector&lt;pii&gt;();\n    }\n    for (int i = 0; i &lt; np; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; rank[i];\n}\n\n\nTips你可能会对r = r == 2 ? 1 : (r - 2) / ng + 2;感到疑惑，为什么需要对2单独设置一种情况。经过上面的讲解，你会知道后面那个式子计算的就是下一轮输家的名次，那么我们把2代入会发现结果还是2，2似乎是一个不动点，那么为什么无法计算出排名1的结果呢？首先r=2是该轮输家的名次，那么下一轮很显然就只有一个人参赛了。我们计算下一轮输家名次的思路很简单，就是计算比赛组数+1，注意到这个名次就是通过排除掉所有赢家才计算出来给输家的。然而一个人的比赛中那个人既是赢家也是输家，所以计算出来的名次2根本不会落到已经被作为赢家而排除的他头上，也就毫无意义。这是一个挺有意思的逻辑悖论。\n","slug":"「1056」Mice-and-Rice","date":"2022-09-07T09:55:58.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"a7cca520edea6b39e829c30cbac4d862","title":"「1055」The World's Richest","content":"Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers:  - the total number of people, and  - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in ), and the net worth (integer in ) of a person. Finally there are K lines of queries, each contains three positive integers:  - the maximum number of outputs, and [Amin, Amax] which are the range of ages. All the numbers in a line are separated by a space.\nOutput Specification:For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M richest people with their ages in the range [Amin, Amax]. Each person’s information occupies a line, in the format\nName Age Net_Worth\n\nThe outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None.\nSample Input:12 4\nZoe_Bill 35 2333\nBob_Volk 24 5888\nAnny_Cin 95 999999\nWilliams 30 -22\nCindy 76 76000\nAlice 18 88888\nJoe_Mike 32 3222\nMichael 5 300000\nRosemary 40 5888\nDobby 24 5888\nBilly 24 5888\nNobody 5 0\n4 15 45\n4 30 35\n4 5 95\n1 45 50\n\nSample Output:Case #1:\nAlice 18 88888\nBilly 24 5888\nBob_Volk 24 5888\nDobby 24 5888\nCase #2:\nJoe_Mike 32 3222\nZoe_Bill 35 2333\nWilliams 30 -22\nCase #3:\nAnny_Cin 95 999999\nMichael 5 300000\nAlice 18 88888\nCindy 76 76000\nCase #4:\nNone\n\n\nΩ又是一道名单罗列题，给出福布斯排行榜上所有用户的姓名、年龄和身价，需要你输出给定年龄段之间身价最高的前M位用户信息，若身价一致则按年龄降序排列，若年龄也一致则按姓名降序排列。不存在输出None。\n没想到C++里有tuple这种神奇的数据结构，本质上是泛化的pair容器，是一个可以包含不同类型数据的结构体类型，那么用户信息就无需建class了。\n由于最终需要输出指定年龄段之间身价最高的人，因此不能简单地通过几次sort就直接输出。但思想也很简单，按照【身价&gt;年龄&gt;姓名】的优先级对所有用户进行排序，然后从高身价开始遍历，同时计数符合给定年龄段的用户个数，一旦达到M便退出循环。\n一开始懒得写compare函数，直接就sort了3次：\n// sort name\nsort(info.begin(),info.end(),[](tsii &amp;a,tsii &amp;b){return get&lt;0&gt;(a)&lt; get&lt;0&gt;(b);});\n// sort age \nsort(info.begin(),info.end(),[](tsii &amp;a,tsii &amp;b){return get&lt;1&gt;(a)&lt; get&lt;1&gt;(b);});\n// sort net worths\nsort(info.begin(),info.end(),[](tsii &amp;a,tsii &amp;b){return get&lt;2&gt;(a)&gt; get&lt;2&gt;(b);});\n\n提交后发现有两个数据量较大的测试点挂了，可以说明一点：sort函数在处理大量数据时采用的不是稳定排序算法，即在cmp函数中满足（注意cmp函数必须严格弱序）的两个对象在排序后次序会和原先不同（P.s. 事实上稳定排序可以用stable_sort函数）。所以只能自己写个cmp函数了：\nbool cmp(tsii &amp;a, tsii &amp;b)\n{\n    if (get&lt;2&gt;(a) != get&lt;2&gt;(b))\n        return get&lt;2&gt;(a) &gt; get&lt;2&gt;(b);\n    else if(get&lt;1&gt;(a) != get&lt;1&gt;(b))\n        return get&lt;1&gt;(a) &lt; get&lt;1&gt;(b);\n    else\n        return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);\n}\n\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;string, int, int&gt; tsii;\n\ninline bool cmp(tsii &amp;a, tsii &amp;b)\n{\n    if (get&lt;2&gt;(a) != get&lt;2&gt;(b))\n        return get&lt;2&gt;(a) &gt; get&lt;2&gt;(b);\n    else if (get&lt;1&gt;(a) != get&lt;1&gt;(b))\n        return get&lt;1&gt;(a) &lt; get&lt;1&gt;(b);\n    else\n        return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);\n}\n\nint main()\n{\n    vector&lt;tsii&gt; info;\n    int n, k, age, net;\n    string name;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; age &gt;&gt; net;\n        info.emplace_back(name, age, net);\n    }\n    sort(info.begin(), info.end(), &amp;cmp);\n    int m, amin, amax, cnt;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cnt = 0;\n        cin &gt;&gt; m &gt;&gt; amin &gt;&gt; amax;\n        printf(\"Case #%d:\\n\", i + 1);\n        for (auto &amp;t: info)\n            if (get&lt;1&gt;(t) &gt;= amin &amp;&amp; get&lt;1&gt;(t) &lt;= amax)\n            {\n                printf(\"%s %d %d\\n\", get&lt;0&gt;(t).c_str(), get&lt;1&gt;(t), get&lt;2&gt;(t));\n                if (++cnt == m)\n                    break;\n            }\n        if (cnt == 0)\n            printf(\"None\\n\");\n    }\n}\n","slug":"「1055」The-World-s-Richest","date":"2022-09-06T12:17:47.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,tuple","author_index":"Starlit Rover"},{"id":"f1b87526b0a747be6a4f224868f65aa7","title":"「1053」Path of Equal Weight","content":"Given a non-empty tree with root R, and with weight Wi​ assigned to each tree node Ti​. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.\nNow given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.\n\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing , the number of nodes in a tree, , the number of non-leaf nodes, and , the given weight number. The next line contains N positive numbers where  corresponds to the tree node . Then M lines follow, each in the format:\nID K ID[1] ID[2] ... ID[K]\n\nwhere ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID‘s of its children. For the sake of simplicity, let us fix the root ID to be 00.\nOutput Specification:For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.\nNote: sequence is said to be greater than sequence if there exists  such that  for , and .\nSample Input:20 9 24\n10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2\n00 4 01 02 03 04\n02 1 05\n04 2 06 07\n03 3 11 12 13\n06 1 09\n07 2 08 10\n16 1 15\n13 3 14 16 17\n17 2 18 19\n\nSample Output:10 5 2 7\n10 4 10\n10 3 3 6 2\n10 3 3 6 2\n\n\n\nΩ\n输出所有从根节点到叶子结点权重和为给定值的权重路径。\n其实上面这个真的小儿科，不管是DFS还是BFS都三下五除二，这个输出顺序是真的麻烦，害得我重构了两次。\n讲讲我的心路历程吧。一开始想的比较粗糙，觉得输出顺序应该和BFS是一致的，所以上来就BFS找到权重和符合要求的所有叶子结点，根据父节点进行回溯然后依次输出。然后就发现最先输出的只能说明路径上的节点数是最少的，中间节点的权重也可以较小。\n转念一想，输出顺序的思想是每次先找权重较大的节点进行遍历，事实上与DFS是一致的，我们只需要将便利的顺序先对权重排序一遍即可。于是乎简单地重构了下代码，还是很快的，春风拂面，小手一点。唯有最后一个测试点是绿的，百思不得其解，夜深了，看了些网上的题解，豁然开朗，问题就在于对权重相同节点的便利顺序是不确定的，最典型的栗子如下图所示，由于第二层权重相等，因此可能会先往左边遍历。\n\n\n当然实在不行我们就先一股脑儿找到所有节点最后再一起排个序，但没什么意思。我想借助并查集的思想，将属于同一个父节点而且权重相同的子节点进行合并，即一个节点不会存在权重一样的子节点，如此一来就可以把这些同权异父同爷（这些父节点的父节点相同）的子节点放在一起sort了。\n大致流程如下：\n\n设置一个向量，用来表示节点将自己所有子节点托付给同权同父的节点\n⚠️我们需要将叶节点的属性也一并托付，让DFS知道这个节点也能作为叶子节点：\n\n\n每读入非叶子节点的子节点时，建立一个权重到节点编号的map映射，表示当前节点已存在权重为的子节点，之后对所有权重为的子节点，都采取；若不存在该权重映射则\n\n对所有节点更新父节点：，然后将该节点压入真正父节点的孩子向量中：.push_back()\n\n对所有节点的子节点根据权重进行降序排序\n\n从根节点开始DFS，最后依次回溯输出权重路径\n\n\n\n\n🐎🧬\nBFS#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, s, id, k, child;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    vector&lt;int&gt; weight(n), dad(n, -1), ans, nxt, crt, sum(n, 0);\n    for (auto &amp;w: weight)\n        cin &gt;&gt; w;\n    sum[0] = weight[0];\n    vector&lt;vector&lt;int&gt;&gt; children(n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; k;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; child;\n            dad[child] = id;\n            children[id].push_back(child);\n        }\n    }\n    crt = children[0];\n    while (!crt.empty())\n    {\n        for (auto &amp;c: crt)\n        {\n            sum[c] += sum[dad[c]] + weight[c];\n            if (sum[c] == s &amp;&amp; children[c].empty())\n                ans.push_back(c);\n            else if (sum[c] &lt; s)\n                nxt.insert(nxt.end(), children[c].begin(), children[c].end());\n        }\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    }\n    vector&lt;int&gt; path;\n    for (auto c: ans)\n    {\n        path.push_back(weight[c]);\n        while (dad[c] != -1)\n        {\n            c = dad[c];\n            path.push_back(weight[c]);\n        }\n        for (auto item = path.rbegin(); item &lt; path.rend(); ++item)\n            cout &lt;&lt; (item == path.rbegin() ? \"\" : \" \") &lt;&lt; *item;\n        cout &lt;&lt; endl;\n        path.clear();\n    }\n}\n\n\n\nDFS#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; weight, ans, sum;\nvector&lt;vector&lt;int&gt;&gt; children;\nvector&lt;bool&gt; isLeaf;\n\nvoid search(int papa, int &amp;s)\n{\n    if (sum[papa] == s &amp;&amp; isLeaf[papa])\n        ans.push_back(papa);\n    for (auto k: children[papa])\n    {\n        sum[k] = weight[k] + sum[papa];\n        if (sum[k] &lt;= s)\n            search(k, s);\n    }\n}\n\nint main()\n{\n    int n, m, s, id, k, child;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n\n    vector&lt;int&gt; dad(n, -1), real;\n    weight.resize(n);\n    sum.resize(n, 0);\n    isLeaf.resize(n, true);\n    real.resize(n);\n    iota(real.begin(), real.end(), 0);\n\n    for (auto &amp;w: weight)\n        cin &gt;&gt; w;\n    sum[0] = weight[0];\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; k;\n        isLeaf[id] = false;\n        map&lt;int, int&gt; idx;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; child;\n            if (idx.find(weight[child]) == idx.end())\n                idx[weight[child]] = child;\n            else\n            {\n                real[child] = idx[weight[child]];\n                isLeaf[real[child]] = isLeaf[real[child]] || isLeaf[child];\n            }\n            dad[child] = real[id];\n        }\n    }\n\n    children.resize(n);\n    for (int i = 1; i &lt; n; ++i)\n    {\n        dad[i] = real[dad[i]];\n        children[dad[i]].push_back(i);\n    }\n\n    for (auto &amp;v: children)\n        sort(v.begin(), v.end(), [](int &amp;a, int &amp;b) { return weight[a] &gt; weight[b]; });\n\n    search(0, s);\n\n    vector&lt;int&gt; path;\n    for (auto c: ans)\n    {\n        path.push_back(weight[c]);\n        while (dad[c] != -1)\n        {\n            c = dad[c];\n            path.push_back(weight[c]);\n        }\n        for (auto item = path.rbegin(); item &lt; path.rend(); ++item)\n            cout &lt;&lt; (item == path.rbegin() ? \"\" : \" \") &lt;&lt; *item;\n        cout &lt;&lt; endl;\n        path.clear();\n    }\n}\n\n\n\nTips\n\n给一个vector增序赋值：\n#include &lt;numeric&gt;\n       ……\nvector&lt;int&gt; v(num); //需要先确定向量大小\niota(v.begin(),v.end(),start);\n\n最终就会得到\n\n将vector v1插入到v2的最后：\nv2.insert(v2.end(), v1.begin(), v1.end());\n\n","slug":"「1053」Path-of-Equal-Weight","date":"2022-09-04T04:51:05.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,并查集,numeric,Tree","author_index":"Starlit Rover"},{"id":"3f7468577cc2a85a47786082d8825b1f","title":"「1052」Linked List Sorting","content":"A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive  and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Key Next\n\nwhere Address is the address of the node in memory, Key is an integer in , and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.\nOutput Specification:For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order.\nSample Input:5 00001\n11111 100 -1\n00001 0 22222\n33333 100000 11111\n12345 -1 33333\n22222 1000 12345\n\nSample Output:5 12345\n12345 -1 00001\n00001 0 11111\n11111 100 22222\n22222 1000 33333\n33333 100000 -1\n\n\nΩ对链表进行排序，显然本题不用链表容器。这个例子坏得很，事实上给出的所有节点并不一定都在头节点所在的链表上。\n首先读入所有节点并用两个map分别建立从address到value和next address的映射，然后根据头节点遍历该链表上所有节点建立从value到address的映射，那么此时value作为键值就已有序，接下来按顺序输出即可。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, key;\n    string head, add, nxt;\n    cin &gt;&gt; n &gt;&gt; head;\n    map&lt;string, string&gt; next;\n    map&lt;string, int&gt; keys;\n    map&lt;int, string&gt; addr;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; add &gt;&gt; key &gt;&gt; nxt;\n        keys[add] = key;\n        next[add] = nxt;\n    }\n    while (head != \"-1\")\n    {\n        addr[keys[head]] = head;\n        head = next[head];\n    }\n    cout &lt;&lt; addr.size() &lt;&lt; \" \";\n    for (auto &amp;k: addr)\n        printf(\"%s\\n%s %d \", k.second.c_str(), k.second.c_str(), k.first);\n    cout &lt;&lt; \"-1\";\n}\n","slug":"「1052」Linked-List-Sorting","date":"2022-09-02T01:38:56.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,list","author_index":"Starlit Rover"},{"id":"78ee87089723b81f295cec55a974e19f","title":"「1051」Pop Sequence","content":"Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.\nOutput Specification:For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.\nSample Input:5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\n\nSample Output:YES\nNO\nNO\nYES\nNO\n\n\n\nΩ\n难得见到的栈题，数字1-N依次入栈，给出K组出栈序列和栈的最大容量，判断它们是否可行。\n首先分析出栈意味着所有比小的数字都已入过栈，由此为突破口切入。我们可以用pair来表示栈中的一串连续数字，然后我们设立一个模拟栈sim和两个变量：top——当前栈顶元素；exp——还未进栈的最小元素，接下来根据读入的数字判断是压入数字串还是出栈：\n\n：出栈\n\n：压入数字串（因为是出栈序列，所以已出栈，但考虑栈此时的容量时必须算上），更新、\n\n：无需改变栈sim，但需要更新\n\n：不存在的出栈情况，如果一开始没有读入全部的出栈序列就不能直接break，因为后面还没读完\n\n\n\n\n事实上，上述算法是一种逆向模拟过程，思考起来相对反人类，还有一种正向思路。由于入栈顺序肯定是1-N，那么就模拟入栈过程，将1-N逐一压栈，在压栈的过程中顺便比对出栈序列，当发现压栈数字和出栈序列当前数字吻合时，开始出栈，并将出栈序列的索引号向后移动直到栈顶元素与出栈序列当前索引元素不符，另外每次压栈时都要检查栈容量是否符合要求。最后若栈空就说明“YES”。\n\n\n🐎\n⥂⥂⥂#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k, s;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        stack&lt;pair&lt;int, int&gt;&gt; sim;\n        int top = 0, exp = 1, size = 0;\n        bool flag = true;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            cin &gt;&gt; s;\n            if (!flag) continue;\n            if (top == s)\n            {\n                if (sim.top().first == sim.top().second)\n                {\n                    sim.pop();\n                    top = sim.empty() ? 0 : sim.top().second;\n                }\n                else\n                    sim.top().second = (--top);\n                size -= 1;\n            }\n            else if (s &gt; exp)\n            {\n                sim.emplace(exp, s - 1);\n                if ((size + s - exp + 1) &gt; m)\n                    flag = false;\n                else size += (s - exp);\n                top = s - 1;\n                exp = s + 1;\n            }\n            else if (s == exp)\n                exp += 1;\n            else\n                flag = false;\n        }\n        cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl;\n    }\n}\n\n⥬⥬⥬#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        vector&lt;int&gt; seq(n);\n        stack&lt;int&gt; sim;\n        for (auto &amp;s: seq)\n            cin &gt;&gt; s;\n        int idx = 0;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            sim.push(j + 1);\n            if (sim.size() &gt; m) break;\n            while (!sim.empty() &amp;&amp; sim.top() == seq[idx])\n            {\n                sim.pop();\n                ++idx;\n            }\n        }\n        cout &lt;&lt; (sim.empty() ? \"YES\" : \"NO\") &lt;&lt; endl;\n    }\n}\n","slug":"「1051」Pop-Sequence","date":"2022-09-01T13:57:33.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,stack","author_index":"Starlit Rover"},{"id":"2b81f5e1a24a7a3ee74c167bb705ac9b","title":"「1050」String Subtraction","content":"Given two strings S1​ and S2​, S=S1​−S2​ is defined to be the remaining string after taking all the characters in S2​ from S1​. Your task is simply to calculate S1​−S2​ for any given strings. However, it might not be that simple to do it fast.\n\n\nInput Specification:Each input file contains one test case. Each case consists of two lines which gives S1​ and S2​, respectively. The string lengths of both strings are no more than 104. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.\nOutput Specification:For each test case, print S1​−S2​ in one line.\nSample Input:They are students.\naeiou\n\nSample Output:Thy r stdnts.\n\n\nΩ将S2中字符从S1中去除，100ms时间限制。\n用map&lt;char,bool&gt; flag记录S2中所有字符，然后遍历S1输出，只有flag[c]=false的字符才能输出。\n\n🐎#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s1, s2;\n    getline(cin, s1);\n    map&lt;char, bool&gt; flag;\n    getline(cin, s2);\n    for (auto &amp;c: s2)\n        flag[c] = true;\n    for (auto &amp;c: s1)\n        if (!flag[c])\n            cout &lt;&lt; c;\n}\n","slug":"「1050」String-Subtraction","date":"2022-09-01T09:19:53.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map","author_index":"Starlit Rover"},{"id":"97a7c2039503607af8d71bdb64c1e600","title":"「1049」Counting Ones","content":"The task is simple: given any positive integer , you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to . For example, given  being 12, there are five 1’s in 1, 10, 11, and 12.\n\n\nInput Specification:Each input file contains one test case which gives the positive .\nOutput Specification:For each test case, print the number of 1’s in one line.\nSample Input:12\n\nSample Output:5\n\n\nΩ短小精悍的题目往往暗藏杀气。\n题意很简单，给出正整数，需要输出1-N之间所有数字中1出现的次数。\n怎么乱入一个高中排列组合的问题，脑子锈的简直叮当响。第一想法是用的表达式直接写出表达式然后（计算机：那我走？），确实没什么必要。这时候你就会发现编程和数学题之间思考方式的差异所在。编程时你必须牢记计算机最擅长的就是繁杂重复的劳动，而人的意义只是借助自身感性的优势将问题抽象以后用一种更为理性的方式告诉计算机具体的处事规则。\n本质上来讲，人从解决问题的主体变成了制定规则计划的主体。\n\n\n既然不是我算，那枚举一波就好啦（试试就逝世）。\n其实当确定时，1所能出现的位数就已确定，因此我们只需计算每个位置上出现1的个数最后相加即可。那么接下来我们分析如何计算第位（）为1的数字个数。\n假设\n\n如何计算1-N中形如的数字个数呢？我们可以做如下考量：\n\n当时，可以任取，即此时共有种可能（之所以不用-1是因为还有全为0的情况）\n\n当时，必须考虑的取值了\n\n，那么在该位上就不会出现1，不存在满足要求的情况\n\n，那么意味着的取值只有种可能\n\n，意味着可以任取，因此共计种情况\n\n\n\n\n将上述两者相加即为所求。那么我们只要对每一个可能位都应用上述算法计算最后求和就好啦。\n若，表明为空串，那么相应值也为0。\n\n🐎#include &lt;iostream&gt;\n\nusing namespace std;\n\ninline int time10(int a, int n)\n{\n    for (int i = 0; i &lt; n; ++i)\n        a *= 10;\n    return a;\n}\n\nint main()\n{\n    int sum = 0, a, b;\n    string n;\n    cin &gt;&gt; n;\n    int m = n.size();\n    for (int i = 0; i &lt; m; ++i)\n    {\n        if (i == 0) a = 0;\n        else a = time10(stoi(n.substr(0, i)), m - i - 1);\n        if (n[i] == '0') b = 0;\n        else if (n[i] == '1')\n            b = (m == i + 1 ? 0 : stoi(n.substr(i + 1, m - i - 1))) + 1;\n        else\n            b = time10(1, m - i - 1);\n        sum += a + b;\n    }\n    cout &lt;&lt; sum;\n}\n\n⚠️这里用了将字符串转为int的函数stoi，但注意将空串传入stoi时会抛出异常，需单独处理，而atoi则会直接作0处理。\n","slug":"「1049」Counting-Ones","date":"2022-08-31T09:58:01.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"0d4898cefd298a76df1cccb4e68d417b","title":"「1048」Find Coins","content":"Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as  coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (, the total number of coins) and M (, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the two face values ​ and ​ (separated by a space) such that  and ​. If such a solution is not unique, output the one with the smallest ​. If there is no solution, output No Solution instead.\nSample Input 1:8 15\n1 2 8 7 2 4 11 15\n\nSample Output 1:4 11\n\nSample Input 2:7 14\n1 8 7 2 4 11 15\n\nSample Output 2:No Solution\n\n\nΩIn a word，找到一对相差最大的数字之和为给定数字。\n因为限制了数对的个数，直接遍历感觉也行。我用一个map来记录每种面值硬币的个数，然后直接遍历map，寻找的硬币是否存在，一旦就可以break了。\n为了防范两个相同面值硬币作祟的情况，判断前应先将。\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, f, ans = -1;\n    cin &gt;&gt; n &gt;&gt; m;\n    map&lt;int, int&gt; cnt;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; f;\n        ++cnt[f];\n    }\n    for (auto &amp;c: cnt)\n    {\n        if (c.first &gt; m / 2)\n            break;\n        c.second -= 1;\n        if (cnt[m - c.first])\n        {\n            ans = c.first;\n            break;\n        }\n    }\n    cout &lt;&lt; (ans == -1 ? \"No Solution\" : to_string(ans) + \" \" + to_string(m - ans));\n}\n","slug":"「1048」Find-Coins","date":"2022-08-31T07:03:51.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map","author_index":"Starlit Rover"},{"id":"031d2c36fd739bf94778d5ddc84b6f38","title":"模拟退火","content":"模拟退火算法，顾名思义，模拟晶体退火过程。晶体在加热后固体化为液态，内部原子运动加剧，会离开原有位置向四周扩散。此时慢慢进行退火冷却使其重新固化，粒子往往会停留在比原先能量低得多的位置上，本质上也是通过随机性跳出局部最优。\n本文尝试用模拟退火算法对TSP问题（travelling salesman problem）进行求解，并与Gurobi求解器进行对比。\n\n\n\n\n\n\nΩ\n模拟退火的算法流程非常简单，一般用来求解最小化的优化问题：\n\n给出一个满足所有约束条件的初始解，制定对解空间进行编码的规则，并设定初始温度、降温参数、最低温度\n\n通过2变换法/3变换法/随机调换对解进行改造：\n\n2变换法：随机取两个随机数，将该解索引为之间的序列进行反转（逆序排列）\n3变换法：随机取3个随机数，取出索引之间的序列置于索引元素的后面\n随机调换：随机取两个随机数，将两位置处的元素进行调换\n\n\n求改造解与原解之间的目标函数差：\n\n按照下述概率接受改造解，产生一随机数与P进行比较，若则否则维持原解\n\n\n\n\n\n降温：\n\n若或者连续多次的迭代过程中都没有接受改造解就退出循环，否则重复2～5步\n\n\n\n\n可见模拟退火中最核心的内容便是\n\n 时直接接受非常容易理解，毕竟目标函数更小了；而模拟退火算法的核心就在于时还是以一定概率接受，而且分析上式可以发现当初始情况下T更大时P也会较大，随着T慢慢降低后P也会趋近于0。很显然，这是利用随机性避免粒子在初始情况中就落于局部最优。刚开始降温时粒子还是有一定概率跳出当前所处区域，扩大搜寻范围；到后来温度逐渐降低，粒子的状态开始收敛，跳出的概率就很小了，这是避免粒子跳出最优解所在区域而难以收敛。\n\n\n\nTSP：旅行推销员问题\n旅行推销员是一个非常经典的NP-Hard问题，即在多项式时间内也无法验证解的正确性。问题大意非常简单，就是有个城市，两两之间距离已知，有个salesman从某个城市出发希望能够游历其他每座城市一遍，同时最后回到出发城市，重度强迫症患者的他希望设计出一条满足上述要求的最短路线。\n如果你是他的朋友，你会如何劝退他，请写一篇不少于200词的感化信。（100）\n\n\n✦ 初始化城市坐标和距离矩阵可以通过随机生成或者加载之前生成的坐标来初始化\nimport numpy as np\nimport random as rd\n\n# 随机生成城市坐标\nloc = np.zeros([100, 2])\nfor i in range(len(loc)):\n    loc[i] = (rd.random() * 100, rd.random() * 100)\nnp.save(\"loc.npy\", loc) # 保存生成坐标\n\n# 导入之前城市坐标\n# loc=np.load(\"loc.npy\")\n\nnum = len(loc)\n# 多一列方便处理回到原城市的约束\ndist = np.zeros([num, num + 1])\n\n# 计算距离矩阵\nfor i in range(num):\n    for j in range(i + 1, num):\n        dist[i, j] = dist[j, i] = np.linalg.norm(loc[i] - loc[j])\ndist[:, num] = dist[:, 0]\n\n✦ 贪心求初始解TSP问题的解基本不需要编码，包含所有城市一个全排列的列表就可以作为可行解的编码。我这里规定了0号作为起点和终点。\n用贪心算法构造初始解，即从起点城市开始每次选择离当前城市最近的且还未访问过的城市作为下一个目的地。在城市数较少时贪心结果几乎就是最优解，城市数大了就嘻嘻。\n# 贪心求初始解\npath=[0]\nisVisited=[False]*num\nisVisited[0]=True\ncrt=0\nsum_d=0\nfor i in range(num):\n    idx=np.argsort(dist[crt])\n    for j in idx:\n        if j!=num and not isVisited[j] and j!=crt:\n            path.append(j)\n            sum_d+=dist[crt,j]\n            isVisited[j]=True\n            crt=j\n            break\npath.append(0)\nsum_d+=dist[crt,0]\ninit_sum=sum_d\nprint(\"distance of initial solution:\",sum_d)\n\n\n    \n  \n\n\n✦ 模拟退火设置好初始温度、降温参数、最低温度之后即可开始退火。我在这里尝试了2变换法、3变换法、2 3变换法相结合（设置dice骰子随机选择）的模式，最后发现还是2变换法的效果最佳。\n# 设置初始参数\nT=1\na=0.999\n\npath_opt=path\nsum_opt=sum_d\ncnt=0\nwhile T&gt;1e-300:\n    # dice=rd.randint(1,2)\n    # if dice==1:\n    m=rd.randint(1,num-2)\n    n=rd.randint(m+1,num)\n    delta=dist[path[m-1],path[n-1]]+dist[path[m],path[n]]-dist[path[m-1],path[m]]-dist[path[n-1],path[n]]\n    # elif dice==2:\n    #     m=rd.randint(1,num-3)\n    #     n=rd.randint(m+2,num-1)\n    #     delta=dist[path[m],path[n-1]]+dist[path[m],path[n+1]]+\\\n    #       dist[path[n],path[m-1]]+dist[path[n],path[m+1]]-\\\n    #       dist[path[m],path[m-1]]-dist[path[m],path[m+1]]-\\\n    #       dist[path[n],path[n-1]]-dist[path[n],path[n+1]]\n\n    if delta&lt;0 or rd.random()&lt;np.exp(-delta/T):\n        # if dice==1:\n        path[m:n]=path[n-1:m-1:-1]\n        # elif dice==2:\n        #     path[m],path[n]=path[n],path[m]\n\n        sum_d+=delta\n        cnt=0\n        if sum_d&lt;sum_opt:\n            path_opt=path\n            sum_opt=sum_d\n    else:\n        cnt+=1\n        if cnt==300:\n            break\n    T=a*T\n\nprint(\"Current Temperature:\\t\",T)\nprint(\"Minimum Distance:\\t\\t\",sum_opt)\nprint(\"Initial Distance:\\t\\t\",init_sum)\nx=loc[path_opt,0]\ny=loc[path_opt,1]\nplt.plot(x,y,'b*-',linewidth=1)\nplt.show()\n\n其中一例的结果如下：\n\n\n顺便将其可视化：\n\n\n\n\nGurobi\n想着用Gurobi也来插一脚，没想到花的时间比码上面的模拟退火还长。因为这里有个问题——如何保证Gurobi给出的解是一个连通图？\n仔细想想，会发现多个连通图和一个连通图的总边数以及每个顶点度要求都是相同的，如果优化模型对连通性没有限制的话会出大问题：\n\n\n\n\n\n\n后来发现Gurobi官方有给出求解TSP问题的案例，详情戳这。\n他在上述模型中又添加了以下约束（*）：\n\n简单地说，如果一个解中包含多个连通分图，那么肯定存在真子集，S中所有的边数（两个端点都在S中）之和==S中的城市数量，且满足这个条件的S即为一个连通分图。因此他就非常暴力地把所有真子集都枚举一遍，让他们都不满足这个条件。\n然而在实际实现的过程中，这是个糟糕透顶的想法。因为如此一来约束个数会随着城市数的增加而呈指数式增长。说实在一点，理想是理想，现实是现实。那咋办呢？不要慌，既然Gurobi出了官方文档，说明他们还是有能力解决的。\n于是乎他们拿出了名叫Lazy Constraints的法宝，翻译一下应该叫惰性约束，顾名思义，这个约束非常的懒，只有在指定条件才会跳出来判断解的合理性。也就是说，在正常求解的过程中不会添加该约束，在用户指定的情况下再去判断，这样就轻松多啦。\n本来想着直接套用官方模版跑一通，奈何他刚开始直接读取了一个json文件，不是很清楚读完后的数据格式，部分地方也没看懂在做什么，导致在套用自己变量后总会出现这样那样的小bug，很烦，简单地重构了下。\n\n\n想要构造惰性约束需要自己实现一个Callback函数来指定什么条件调用该函数，然后该函数再决定满足什么要求时添加Lazy Constraint：\ndef delSubtour(model, where):\n    # GRB.Callback.MIPSOL：发现新的MIP解\n    if where == GRB.Callback.MIPSOL:\n        # make a list of edges selected in the solution\n        vals = model.cbGetSolution(model._vars)\n        edges = gp.tuplelist((i, j) for i, j in model._vars.keys()\n                             if vals[i, j] &gt; 0.5)\n        adj = {}\n        for i, j in edges:\n            adj.setdefault(i, set()).add(j)\n            adj.setdefault(j, set()).add(i)\n        circle = set([0])\n        next = set([0])\n        new = set()\n        while next:\n            for k in next:\n                new |= adj[k]\n            next = new - circle\n            circle |= next\n\n        if len(circle) &lt; num:\n            model.cbLazy(gp.quicksum(model._vars[i, j] for i, j in combinations(circle, 2)) &lt;= len(circle) - 1)\n\nCallback函数的条件选项可以见官方文档。where指定调用条件，我这里的MIPSOL是指当Gurobi找到一个混合整数规划（MIP）解（SOL）时，就会执行该函数的主体部分。而主体部分先通过cbGetSolution函数获取找到的该解，然后将的顶点元组对放入一个列表中，根据该列表建立一个通过城市编号可以访问连接顶点的邻接字典adj，最后求出0号城市所在连通图的城市个数，与城市总数进行比较就能说明所有城市是否连通。如果不连通，此时再添加约束（*）。\n\n\nGurobi求解的完整代码如下：\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\nimport random as rd\n# combinations(list,n): 枚举所有长度为n的全排列\nfrom itertools import combinations, product\n\n\ndef delSubtour(model, where):\n    # GRB.Callback.MIPSOL：发现新的MIP解\n    if where == GRB.Callback.MIPSOL:\n        # make a list of edges selected in the solution\n        vals = model.cbGetSolution(model._vars)\n        edges = gp.tuplelist((i, j) for i, j in model._vars.keys()\n                             if vals[i, j] &gt; 0.5)\n        adj = {}\n        for i, j in edges:\n            adj.setdefault(i, set()).add(j)\n            adj.setdefault(j, set()).add(i)\n        circle = set([0])\n        next = set([0])\n        new = set()\n        while next:\n            for k in next:\n                new |= adj[k]\n            next = new - circle\n            circle |= next\n\n        if len(circle) &lt; num:\n            model.cbLazy(gp.quicksum(model._vars[i, j] for i, j in combinations(circle, 2)) &lt;= len(circle) - 1)\n\n\nm = gp.Model(\"TSP\")\n\nvars = m.addVars(dist.keys(), obj=dist, vtype=GRB.BINARY)\n\n# Symmetry\nm.addConstrs(vars[j, i] == vars[i, j] for i, j in dist.keys())\n\n# two edges to each city\nm.addConstrs((vars.sum(i, '*') == 2) for i in range(num))\n\n# Optimize the model\nm._vars = vars\nm.Params.lazyConstraints = 1\n# setObjective函数此时似乎没用\n# m.setObjective(vars.prod(dist), GRB.MINIMIZE)\nm.optimize(delSubtour)\n\n\nvals = m.getAttr('x', vars)\nedges = gp.tuplelist((i, j) for i, j in vals.keys() if vals[i, j] &gt; 0.5 and i &lt; j)\nadj = {}\nfor i, j in edges:\n    adj.setdefault(i, []).append(j)\n    adj.setdefault(j, []).append(i)\nisVisited = [False] * num\nx = [];\ny = []\nidx = 0\ntotal = 0\nfor i in range(num - 1):\n    x.append(loc[idx, 0])\n    y.append(loc[idx, 1])\n    pre = idx\n    isVisited[idx] = True\n    idx = adj[idx][0] if not isVisited[adj[idx][0]] else adj[idx][1]\n    total += dist[pre, idx]\n\ntotal += dist[idx, 0]\nx.append(loc[0, 0])\ny.append(loc[0, 1])\nprint(\"Minimum Distance：\", total)\n\n\nimport matplotlib.pyplot as plt\n# 设置字体\nplt.rc('font', family='Times New Roman')\n# 设置图像的像素\nplt.rcParams['figure.dpi'] = 150\n# 设置字体的颜色\nplt.rcParams['text.color'] = 'black'\nplt.plot(x, y, 'b*-', linewidth=1)\nplt.show()\n\n由于Gurobi求解的是最优解，因此规模一旦稍大就要跑很久。城市数量为50左右的求解速度还是很快的，100就开始思考人生了。\n\n    \n  \n\n\n\n    \n  \n\n\n\n    \n  \n\n","slug":"模拟退火","date":"2022-08-28T05:33:08.000Z","categories_index":"智能算法","tags_index":"python,数学煎馍,TSP,Gurobi","author_index":"Starlit Rover"},{"id":"6791030d5707ab0b9f17e02b4e398cd4","title":"「1047」Student List for Course","content":"Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤40,000), the total number of students, and K (≤2,500), the total number of courses. Then N lines follow, each contains a student’s name (3 capital English letters plus a one-digit number), a positive number C (≤20) which is the number of courses that this student has registered, and then followed by C course numbers. For the sake of simplicity, the courses are numbered from 1 to K.\nOutput Specification:For each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students’ names in alphabetical order. Each name occupies a line.\nSample Input:10 5\nZOE1 2 4 5\nANN0 3 5 2 1\nBOB5 5 3 4 2 1 5\nJOE4 1 2\nJAY9 4 1 2 5 4\nFRA8 3 4 2 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 5 4 2\nLOR6 4 2 4 1 5\n\nSample Output:1 4\nANN0\nBOB5\nJAY9\nLOR6\n2 7\nANN0\nBOB5\nFRA8\nJAY9\nJOE4\nKAT3\nLOR6\n3 1\nBOB5\n4 7\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n5 9\nAMY7\nANN0\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n\n\nΩ打印课程选课名单，妈妈再也不用担心我在浙大找工作啦。（浙大：保安考虑一下？）\n题目的逻辑非常清晰简单，而且最后需要字母序输出很容易就想到了set容器，于是乎一通代码猛如虎，信心满满地超时了。这丝毫难不住码龄高达二年的我，三下五除二就把cin和cout给换了，竟然还是超时。最后把set换成vector，然后再sort一下，勉勉强强。\nTo sum up，一般超时排雷方向：\n\ncin→ scanf ；cout→ printf\n\nset、map→ vector\n\n优化算法，减少重复计算\n\n\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, c, d;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;vector&lt;string&gt;&gt; info(m);\n    string name(5, ' ');\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;name[0], &amp;c);\n        for (int j = 0; j &lt; c; ++j)\n        {\n            scanf(\"%d\", &amp;d);\n            info[d - 1].push_back(name);\n        }\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        printf(\"%d %lu\\n\", i + 1, info[i].size());\n        sort(info[i].begin(), info[i].end());\n        for (auto &amp;s: info[i])\n            printf(\"%s\\n\", s.c_str());\n    }\n}\n","slug":"「1047」Student-List-for-Course","date":"2022-08-26T05:56:35.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,vector","author_index":"Starlit Rover"},{"id":"40786dbbe04360f3225c33f6e57bde2b","title":"「1046」Shortest Distance","content":"The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains an integer, followed by  integer distances ​, where ​ is the distance between the i-th and the (i+1)-st exits, and DN​ is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer， with  lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than .\nOutput Specification:For each test case, print your results in  lines, each contains the shortest distance between the corresponding given pair of exits.\nSample Input:5 1 2 4 14 9\n3\n1 3\n2 5\n4 1\n\nSample Output:3\n10\n7\n\n\nΩ估计是火星上的高速公路，出口能围成一个圈。\n给出相邻出口的距离，然后需要你输出几对指定出口之间的最短距离。\n那么显然只有两条路，且路长之和是圆的周长。\n首先，如果每次都是对中间所有相邻路长进行相加必然是会超时的，我们必须限制计算量。本质上可以将圈看成一段弯了的数轴，那么计算在和上的出口距离时，只需比较和即可（为圆周长）。而数轴上的坐标计算直接以第一个出口作为原点然后依次相加即可。\n“The task is really simple.”\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; dist(n + 1);\n    dist[0] = 0;\n    for (int i = 1; i &lt; n + 1; ++i)\n    {\n        cin &gt;&gt; dist[i];\n        dist[i] += dist[i - 1];\n    }\n    int m, a, b;\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        int d = dist[(a &gt; b ? a : b) - 1] - dist[(a &gt; b ? b : a) - 1];\n        if (d &gt; dist[n] / 2)\n            cout &lt;&lt; dist[n] - d &lt;&lt; endl;\n        else\n            cout &lt;&lt; d &lt;&lt; endl;\n    }\n}\n","slug":"「1046」Shortest-Distance","date":"2022-08-26T03:40:01.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,vector","author_index":"Starlit Rover"},{"id":"126557f0372d68b5bf8540ce837256a8","title":"「1045」Favorite Color Stripe","content":"Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.\nIt is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.\nNote that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer  which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer  followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer  which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space.\nOutput Specification:For each test case, simply print in a line the maximum length of Eva’s favorite stripe.\nSample Input:6\n5 2 3 1 5 6\n12 2 2 4 1 5 5 6 3 1 1 5 6\n\nSample Output:7\n\n\nΩ不得不说，废话真多，背景也奇奇怪怪，看个题费了我老半天。\n人话版，给定一串数字序列，我们需要从另一个数字序列中尽可能多地按顺序抽出数字，但抽出的数字必须按照的顺序排列，即中的数字可以重复也可以缺失，但数字必须是这个顺序出现的。\n很显然，不在中的数字其实是噪音，直接过滤。首先我们定义用比较运算符+括号的形式来表示数字在中的排列：\n\n另外我们规定符合中顺序的数字串是合法的。\n那么对于，我们可以统计出当前（读入序列的过程中）序列中所含数字均的最大合法数字串长度。当我们读入一个数字后，只需，然后同时更新\n\n最后输出即可。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; next(n + 1, -1);\n    map&lt;int, int&gt; cnt;\n    cin &gt;&gt; a;\n    for (int i = 1; i &lt; m; ++i)\n    {\n        cin &gt;&gt; b;\n        next[a] = b;\n        a = b;\n    }\n    next[a] = 0;\n    auto &amp;ans = cnt[a];\n\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; a;\n        if (next[a] != -1)\n        {\n            b = ++cnt[a];\n            while (next[a] != 0)\n            {\n                if (b &gt; cnt[next[a]])\n                    cnt[next[a]] = b;\n                else break;\n                a = next[a];\n            }\n        }\n    }\n    cout &lt;&lt; ans;\n}\n","slug":"「1045」Favorite-Color-Stripe","date":"2022-08-23T08:40:23.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"动态规划,C＋＋","author_index":"Starlit Rover"},{"id":"e150e507cccee9246ee324168daabc61","title":"「1044」Shopping in Mars","content":"Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options:\n\nCut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).\nCut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).\nCut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).\n\nNow given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer.\nIf it is impossible to pay the exact amount, you must suggest solutions with minimum lost.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: , the total number of diamonds on the chain, and, the amount that the customer has to pay. Then the next line contains N positive numbers which are the values of the diamonds. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print i-j in a line for each pair of  such that . Note that if there are more than one solution, all the solutions must be printed in increasing order of i.\nIf there is no solution, output i-j for pairs of  such that  with  minimized. Again all the solutions must be printed in increasing order of i.\nIt is guaranteed that the total value of diamonds is sufficient to pay the given amount.\nSample Input 1:16 15\n3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13\n\nSample Output 1:1-5\n4-6\n7-8\n11-11\n\nSample Input 2:5 13\n2 4 5 7 9\n\nSample Output 2:2-4\n4-5\n\n\nΩ最近怎么全是Mars的题目，妈妈再也不用担心我在老家找工作啦。\n火星人喜欢用一串钻石来付钱，上面每颗钻石的价值不一，而且只能用其中连续的一小串来付。给定这一串钻石的价值和需要付费的商品价格，输出所有损失最小的钻石子串，题目保证钻石总价值&gt;商品价格，拒绝吃霸王餐，难得有原则的题目，点赞。\n很显然的一个想法，从每一颗钻石开始往后遍历，找到钻石总价值刚好≥商品价值的end index，计算（钻石总价-商品价值），与全局最小值进行比较，若更小则替换原先序列；若相等则添加至当前序列尾部。\nHowever，你很快会发现，这里面其实有着大量的重复计算，尤其是相邻的起始钻石所引导的序列之间会有很大一部分重合。简化的方式也非常简单，在for循环遍历中不必改变end index，因为下一个起始钻石的end index只会比当前大而不会小。我们只需要在进入下一次循环前将该轮钻石总价减去当前起始钻石的价值即可，这样就无需重复计算中间钻石，相当于整个过程每个钻石价值只会加一次。\n一旦发现即使把后面的钻石都加上也无法达到商品价格，那么就可以直接break。\n另外需要提防价值为0的石头钻石。\n\nC ☺ D E# include &lt;iostream&gt;\n# include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; dia(n);\n    vector&lt;pair&lt;int, int&gt;&gt; seq;\n    for (auto &amp;d: dia)\n        cin &gt;&gt; d;\n    int min_lost = m, end = 0, sum = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        while (end &lt; n &amp;&amp; sum &lt; m)\n            sum += dia[end++];\n        if (end == n &amp;&amp; sum &lt; m)\n            break;\n        if (sum - m &lt; min_lost)\n        {\n            min_lost = sum - m;\n            seq.clear();\n            seq.emplace_back(i + 1, end);\n        }\n        else if (sum - m == min_lost)\n            seq.emplace_back(i + 1, end);\n        sum -= dia[i];\n    }\n    for (auto &amp;s: seq)\n        cout &lt;&lt; s.first &lt;&lt; \"-\" &lt;&lt; s.second &lt;&lt; endl;\n}\n","slug":"「1044」Shopping-in-Mars","date":"2022-08-23T05:43:36.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"动态规划,C＋＋","author_index":"Starlit Rover"},{"id":"67f2a5903961e96580b14bb51c7ce9c9","title":"粒子群算法","content":"通过上一节我们得知遗传算法是一种智能的随机搜索算法，胡乱随机的过程中隐隐透着一丝章法，这是借鉴了大自然的生存法则。而今天登场的粒子群算法也源于日常生活。\n当地上掉落一坨蜂蜜时，我们希望找到它的方位，怎么办呢？于是乎我们放出100只蚂蚁，让他们在这片广袤无垠的土地上随机搜索。但并不是完全随机，当有一只蚂蚁嗅到了极高浓度的蜂蜜气息时，它会对其他蚂蚁大喊（触角：你礼貌吗）：“Come here！“，于是乎所有蚂蚁会往它的方位靠拢。然而每一只蚂蚁也是一个单独的个体，它们会有自己的搜索记忆，对于自己搜索路径上出现过最高浓度的方位也一直念念不忘，因此每一只蚂蚁还会向自己的历史最强方位靠拢。由此每个蚂蚁的运动方式都是通过运动惯性+个体认知+群体协作决定的。\n\n\n\n\n\n\n\nΩ基础的算法流程非常简单易懂：\n\n有必要的话需对优化问题的可行解进行编码\n\n初始化各粒子的位置和速度，每个位置坐标对应一个可行解\n\n指定粒子适应度（蜂蜜气息浓度）计算方式，计算各个粒子的适应值\n\n与个体最高适应值进行比较，更高则进行替换，并记录当前位置\n\n与群体最高适应值进行比较，更高则进行替换，并记录当前位置\n\n更新当前粒子速度\n\n其中为惯性系数，表示维持当前速度的趋势因子；均为每次更新时产生的随机数；则为对个体最优、群体最优方位的学习因子；分别为个体最优位置坐标、群体最优位置坐标\n\n更新当前粒子方位\n\n\n\n\n\n那么在算法开始前，我们往往需要指定【粒子个数、最大迭代次数、学习因子*2、惯性系数】，另外由于可行解域往往是一块有限的区域，因此我们不能让速度过大，需要设定一个速度上限，而这个上限往往通过方位的最大绝对值进行设定，即\n\n注意算法中的，都可以是维向量，下面请欣赏我随便应用的一个案例。\n\nƺ这个案例是Gurobi求解器（不是广告！不过学生版免费申请还是很香的，Python体验也不错）官方给出的，一个建塔问题，官方文档见这。\n简单地说，就是设计一个通讯塔的选址方案，每个塔的搭建费用和覆盖的地区不同，不同地区所涵盖的人口也不同，由于资金有预算限制，因此我们需要在预算范围内求出能够覆盖最大人数的搭建方案。\n∻ 导入数据原题中只有6座塔，那么意味着只有64种情况，我30个粒子就已经占了一大半，这还迭代个毛球，于是乎我把塔数改成了10，同时更改了个别塔所涵盖的地区。下面是基本信息的导入：\nimport numpy as np\nimport random as rd\n\n# 各地区人口数量\npop = np.array([523, 690, 420, 1010, 1200, 850, 400, 1008, 950])\n# 建塔费用\ncost = np.array([4.2, 6.1, 5.2, 5.5, 4.8, 9.2, 7.6, 5.8, 8.7, 4.9])\ntn = len(cost)\n# 资金预算\nbudget = 20\n# 每座塔涵盖的地区\ncover = np.array([[False] * len(pop)] * tn)\ncover[0][[0, 5]] = True\ncover[1][[8]] = True\ncover[2][[3, 4]] = True\ncover[3][[2, 6]] = True\ncover[4][[6, 8]] = True\ncover[5][[0]] = True\ncover[6][[1, 5]] = True\ncover[7][[2]] = True\ncover[8][[3, 7]] = True\ncover[9][[7]] = True\n\n∻ 特殊化处理在本题中没有直接的坐标，我们需要对每个方案进行编码，由于每座塔只有建/不建两种情况，那么一个10位二进制数即可表示一种方案\n\n但是这里有最大资金约束，意味着并不是随便一个10位二进制数就是可行解。这里我采取的方法是，初始粒子生成的都是可行解，但对于搜索过程中产生的不可行解，我们将其适应值设为0，从而对搜索过程不会造成太大影响。\n∻ 参数设置接下来设置各个参数：\n# 参数设定\npn = 20           # 粒子数量\niter = 500        # 迭代次数\nmaxx = 2**tn-1    # x_max(全为1)\nr_vx = 0.5        # x_max/v_max\nmaxv = r_vx*maxx  # v_max\nw = 0.5           # 惯性系数\nc1 = 5            # 个体学习因子\nc2 = 3            # 群体学习因子\n\n∻ 解码函数在计算下一步坐标时我们不直接对一个十维向量进行操作，毕竟每一位就两个选择也不能存在小数。我先将二进制数转换为十进制数，在进行坐标的计算，即这里的坐标和速度都是1维的，那么我们就需要一个将十进制数转换为十位二进制列表的解码函数：\ndef decode(p):\n    b = list(bin(p)[2:])\n    a = ['0'] * (tn - len(b))\n    a.extend(b)\n    a = list(map(int, a))\n    return a\n\n转换时别忘了把前置0补全。\n∻ 粒子群初始化初始化起点坐标和速度，这里构造的每个粒子都是可行解：\n# 初始化粒子群\nx = []\nv = []\nfor i in range(pn):\n    a = [1] * tn\n    while sum(cost * a) &gt; budget:\n        c = rd.randint(0, maxx)\n        a = decode(c)\n    x.append(c)\n    v.append(r_vx * c)\n\n∻ 适应度函数很显然本问中的适应度函数即为涵盖的人口总数，我们只需判断每个地区是否有塔覆盖即可，对于不可行解则直接返回0。\n⚠️在else里会出大问题，由于idx为空，所以和pop相乘的也是个None。\n# 适应度函数\ndef adpt(p):\n    a = decode(p)\n    if sum(cost * a) &gt; budget or p == 0:\n        return 0\n    else:\n        idx = list(np.where(np.array(a) == 1)[0])\n        return sum(list(map(bool, sum(cover[idx]))) * pop)\n\n∻ 迭代搜索这里注意当速度和坐标超出上下限时需要及时调整。\n# 粒子群搜索\nmaxp = 0\noptx = 0\nmaxp_idv = list(map(adpt, x))\noptx_idv = x\nrecord_p = []\nrecord_iter = []\nfor i in range(iter):\n    for j in range(pn):\n        v[j] = w * v[j] + c1 * rd.random() * (optx - x[j]) + c2 * rd.random() * (optx_idv[j] - x[j])\n        if abs(v[j]) &gt; maxv:\n            v[j] = maxv if v[j] &gt; 0 else -maxv\n        x[j] = round(x[j] + v[j])\n        if x[j] &lt; 0:\n            x[j] = 0\n        elif x[j] &gt; maxx:\n            x[j] = maxx\n        new_adpt = adpt(x[j])\n        if new_adpt &gt; maxp_idv[j]:\n            maxp_idv[j] = new_adpt\n            optx_idv[j] = x[j]\n            if new_adpt &gt; maxp:\n                maxp = new_adpt\n                optx = x[j]\n                record_p.append(new_adpt)\n                record_iter.append(i)\n\nprint(\"最大覆盖人数：\\t\", maxp)\nprint(\"最佳建塔计划：\\t\", decode(optx))\n\n最终求得的结果：\n\n\n这与Gurobi给出的最优解结果一致：\n\n\n∻ 绘制搜索过程import matplotlib.pyplot as plt\n\n# 设置字体\nplt.rc('font', family='Times New Roman')\n# 设置图像的像素\nplt.rcParams['figure.dpi'] = 150\n# 设置字体的颜色\nplt.rcParams['text.color'] = 'black'\n\nplt.plot(record_iter, record_p, color='b', linestyle='-.', marker='*', label='Survived')\nplt.ylabel('max Population', fontsize=13)\nplt.xlabel('iteration num', fontsize=13)\nplt.xticks(ticks=record_iter)\nplt.show()\n\n用matplotlib库我们可以绘制出最大人口数的变化过程，由于运行速度很快，所以我多运行了几次：\n\n\n    \n  \n\n\n    \n    \n\n\n咳咳，虽然吧算法鲁棒性不高，不过就以上四种情况来看，五百轮迭代是足够了，最坏也就408次。只能说调参真的是一门技术活，我觉得我这里的参数肯定不是最优的，或许用智能算法搜索智能算法的参数会是个好主意（禁止套娃\\doge）。\n","slug":"粒子群算法","date":"2022-08-22T02:55:53.000Z","categories_index":"智能算法","tags_index":"python,数学煎馍,Gurobi","author_index":"Starlit Rover"},{"id":"77ba14d37a0bc8ef24c6a9af2180a766","title":"「1043」Is It a Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node’s key.\nBoth the left and right subtrees must also be binary search trees.\n\nIf we swap the left and right subtrees of every node, then the resulting tree is called the Mirror Image of a BST.\nNow given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤1000). Then N integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, first print in a line YES if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, or NO if not. Then if the answer is YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:7\n8 6 5 7 10 8 11\n\nSample Output 1:YES\n5 7 6 8 11 10 8\n\nSample Input 2:7\n8 10 11 8 6 7 5\n\nSample Output 2:YES\n11 8 10 7 5 6 8\n\nSample Input 3:7\n8 6 8 5 10 9 11\n\nSample Output 3:NO\n\n\nΩ给定一串数字，需要你判断是否为一颗二叉搜索树（BST）或镜像BST的前序遍历结果，若是则输出该BST的后序遍历。\n判断是否为BST的前序遍历结果，我们就先假设it’s true，那么第一个数字即为首节点，然后我们可以将后面的数字跟首节点数字进行比较分为左子树和右子树部分，然后递归判断左子树(&lt;top node)和右子树(≥top node)是否为前后连续的两部分，如果是非连续的则说明不是BST的前序遍历。而后续遍历则刚好可以在递归判断中完成，注意到后续刚好与前序是相反的，因此我们可以先递归判断然后再输出当前节点的数字，这样可以保证先输出子树然后再输出中间节点。\n对于树的顺序遍历问题，核心点永远是准确划分出前、中、后三部分。\n所谓镜像BST是指一颗BST的镜像翻转结果，也是本题一个棘手之处。那么我们可以设置一个isMIrror变量，然后将直接比较改成将比较结果与该变量连等进行判断： ，这样就可以创造镜像世界（对转错，错转对）。因此如果时判断失败，那就再判断，对一即可。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre, post;\nbool isMirror = false;\n\nbool isPreOrder(int start, int end)\n{\n    if (start == end)\n    {\n        post.push_back(pre[start]);\n        return true;\n    }\n    else if (start &gt; end)\n        return true;\n    int mid = pre[start], less_end = start + 1, great_end;\n    while (less_end &lt;= end &amp;&amp; (pre[less_end] &lt; mid) == !isMirror)\n        ++less_end;\n    great_end = less_end;\n    less_end -= 1;\n    while (great_end &lt;= end &amp;&amp; (pre[great_end] &gt;= mid) == !isMirror)\n        ++great_end;\n    if (great_end != end + 1)\n        return false;\n    bool flag = isPreOrder(start + 1, less_end) &amp;&amp; isPreOrder(less_end + 1, great_end - 1);\n    post.push_back(mid);\n    return flag;\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    pre.resize(n);\n    for (auto &amp;k: pre)\n        cin &gt;&gt; k;\n    bool flag;\n    if (isPreOrder(0, n - 1))\n        flag = true;\n    else\n    {\n        isMirror = true;\n        flag = isPreOrder(0, n - 1);\n    }\n    cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl;\n    if (flag)\n        for (int i = 0; i &lt; n; ++i)\n            cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; post[i];\n}\n","slug":"「1043」Is-It-a-Binary-Search-Tree","date":"2022-08-21T16:26:25.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search,traversal order,Tree","author_index":"Starlit Rover"},{"id":"0a8ba608dac170a09a78aa1ee9a709bb","title":"「1042」Shuffling Machine","content":"Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.\nThe machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:\nS1, S2, ..., S13, \nH1, H2, ..., H13, \nC1, C2, ..., C13, \nD1, D2, ..., D13, \nJ1, J2\n\nwhere “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.\nSample Input:2\n36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47\n\nSample Output:S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5\n\n\nΩ简答的洗牌模拟程序，妈妈再也不用担心我在澳门找工作啦。\n给出洗牌轮数和每张牌下一次的位置，其中第个数字代表原本的第张牌应被洗到第的位置上，不断迭代洗牌直至达到指定次数。\n非常的easy，用两个vector不断记录每次洗前的顺序和洗之后的顺序，最后按顺序输出即可。\n哦对，构造初始序列还真是一件麻烦事。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;string&gt; cards(54), next(54);\n    vector&lt;int&gt; order(54);\n    string shcd[] = {\"S\", \"H\", \"C\", \"D\"};\n    for (int i = 0; i &lt; 4; ++i)\n        for (int j = 1; j &lt; 14; ++j)\n            cards[i * 13 + j - 1] = (shcd[i] + to_string(j));\n    cards[52] = \"J1\";\n    cards[53] = \"J2\";\n    for (auto &amp;k: order)\n        cin &gt;&gt; k;\n    for (int j = 0; j &lt; n; ++j)\n    {\n        for (int i = 0; i &lt; 54; ++i)\n            next[order[i] - 1] = cards[i];\n        cards = next;\n    }\n    cout &lt;&lt; cards[0];\n    for (int i = 1; i &lt; 54; ++i)\n        cout &lt;&lt; \" \" &lt;&lt; cards[i];\n}\n","slug":"「1042」Shuffling-Machine","date":"2022-08-21T14:57:46.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,vector","author_index":"Starlit Rover"},{"id":"0b17d25479bad782d0ac02fc7689837c","title":"「1041」Be Unique","content":"Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins.\n\n\nInput Specification:Each input file contains one test case. Each case contains a line which begins with a positive integer N (≤) and then followed by N bets. The numbers are separated by a space.\nOutput Specification:For each test case, print the winning number in a line. If there is no winner, print None instead.\nSample Input 1:7 5 31 5 88 67 88 17\n\nSample Output 1:31\n\nSample Input 2:5 888 666 666 888 888\n\nSample Output 2:None\n\n\nΩ我老家那边卖彩票，规则很有趣，第一个买到唯一数字的人中奖。按照时间顺序给出所有买家所买的数字，要求输出winner的数字，没有则None。\n那么可以用一个vector来记录彩票数字的时间顺序，那么如何快速判断在此之前是否已有相同数字呢。这里我另外用了一个map建立起了（lottery number，vector index）的映射，从而能快速找到vector中的位置，找到后直接将其的中奖资格置false，因此vector的类型为&lt;int,bool&gt;，最后再从头找的一个true的数字即可。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, bool&gt;&gt; lottery;\n    map&lt;int, int&gt; idx;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        if (idx.find(m) == idx.end())\n        {\n            idx[m] = lottery.size();\n            lottery.push_back({m, true});\n        }\n        else\n            lottery[idx[m]].second = false;\n    }\n    for (auto &amp;k: lottery)\n        if (k.second)\n        {\n            cout &lt;&lt; k.first;\n            return 0;\n        }\n    cout &lt;&lt; \"None\";\n}\n","slug":"「1041」Be-Unique","date":"2022-08-20T15:19:44.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"6e5180ebfe96513fbbfe6405ce489018","title":"「1040」Longest Symmetric String","content":"Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11.\n\n\nInput Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000.\nOutput Specification:For each test case, simply print the maximum length in a line.\nSample Input:Is PAT&amp;TAP symmetric?\n\nSample Output:11\n\n\nΩ输出最长对称子串的长度，简洁明了，跟这篇博客一样，我喜欢。\n对于对称字符串我们可以根据对称中心点去寻找，而中心点可能是字符（奇对称）也可能是两个字符中间（偶对称），那么中心点共有种选择。然后计算中心点周围两个邻近字符的索引，循环找出最长对称子串。\n\nC ☺ D E#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    getline(cin, s);\n    int max = 1;\n    for (int i = 0; i &lt; 2 * s.size(); ++i)\n    {\n        int left = i / 2, right = (i + i % 2) / 2 + 1, sum = i % 2;\n        while (left &gt;= 0 &amp;&amp; right &lt; s.size())\n        {\n            if (s[left--] == s[right++])\n                sum += 2;\n            else\n                break;\n        }\n        if (sum &gt; max)\n            max = sum;\n    }\n    cout &lt;&lt; max;\n}\n","slug":"「1040」Longest-Symmetric-String","date":"2022-08-20T14:23:27.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"925a25c8e70f189f82f27070d123048d","title":"「1039」Course List for Student","content":"Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤40,000), the number of students who look for their course lists, and K (≤2,500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students Ni​ (≤200) are given in a line. Then in the next line, Ni​ student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space.\nOutput Specification:For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line.\nSample Input:11 5\n4 7\nBOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\n1 4\nANN0 BOB5 JAY9 LOR6\n2 7\nANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6\n3 1\nBOB5\n5 9\nAMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\nZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9\n\nSample Output:ZOE1 2 4 5\nANN0 3 1 2 5\nBOB5 5 1 2 3 4 5\nJOE4 1 2\nJAY9 4 1 2 4 5\nFRA8 3 2 4 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 2 4 5\nLOR6 4 1 2 4 5\nNON9 0\n\n\nΩ难得水题放松，给出每个课程的选课名单，为前来查询课程的学生增序输出他们所选课程号。\nmap、set搭配，干活不累。读完即输出。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, set&lt;int&gt;&gt; info;\n    int n, k, idx, m;\n    string name;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; idx &gt;&gt; m;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; name;\n            info[name].insert(idx);\n        }\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name;\n        cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; info[name].size();\n        for (auto &amp;c: info[name])\n            cout &lt;&lt; \" \" &lt;&lt; c;\n        cout &lt;&lt; endl;\n    }\n}\n","slug":"「1039」Course-List-for-Student","date":"2022-08-20T13:47:05.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set","author_index":"Starlit Rover"},{"id":"5e05676005a67b187c728a6e49c065fb","title":"遗传算法","content":"“物竞天择，适者生存“，进化界的名言没想到也能用在算法里，不得不承认每个算法工程师也是天马行空的魔法师。由于经常参加数学煎馍美食烹饪大赛，因此时不时需要和启发式算法打交道，这些智能算法的思想充满着活力和开拓性，coding的时候甚至感觉自己像上帝一样为自己的世界制定着规则，不禁连连感叹。\n今天开启智能算法篇章，首先上场的是遗传大法。\n\n\n\n\nΩ启发式算法的目的往往是寻求一个优化模型的最优解，但由于模型的过于庞大或是复杂，想要把精确的最优解揪出来需要花费大量的时间和算力。那么我们退而求其次，争取尽可能逼近最优解，接受一定范围的误差，从而有了各种启发式算法八仙过海。\n遗传算法，顾名思义，我们将每一个可行解看作为一个个体，让这些个体生存繁衍，我们作为上帝制定出如何计算个体对于环境适应值（目标函数）的规则。接下来就交给大自然去选择，经过一代一代的淘汰进化，最终出现在我们面前就是适应度最高的个体们。\n那么繁衍淘汰这么复杂的生理过程如何在计算机内表达呢，我们知道繁衍的本质就是基因的交换重组，而基因的本质是对遗传信息的编码，计算机最擅长的莫过于此。因此我们首先需要将每个个体（可行解）进行编码为基因串，为了贴合计算机并方便起见一般都是转换为二进制编码，那么繁衍的过程很显然就是对基因进行切片重组。问题是大自然如果只靠单纯的基因重组繁衍后代，那么物种的多样性将被限制，之所以物种能够进化一方面是自然选择，另外一个重要的机制是变异，变异使得原本的基因片段得以改变，从而物种朝着不同的方向发展（搜索），大大增加了算法的鲁棒性。\n下面是一个数模比赛中遇到的简化版案例。\n\nƺ简单地说，有一些交易订单，首先根据每个订单的计算结果对所有订单进行降序排序，其中两个与订单无关的待定权重，然后排序结果会送入一个贪心算法中，最终输出一个结果。那么很显然不同的会影响订单的排序结果，从而影响到最终的输出结果。此时我希望得到最大结果，但对于权重的取值无从下手。那么就让大自然的遗传大法来筛选吧。\n⚤ 编码解码在此我们需要先确定的取值范围，从而才能对有限的基因进行编码解码。根据初步的估计可以得出两者最优解的分布范围\n\n那么一组可行解即为7位十进制数，根据可知需要24位{0,1}二进制串来编码\n\n前16位为α，后8位为β，那么可以写出解码函数：\ndef decode(gene):\n    alpha = eval(gene[0:16]) * 0.0001\n    beta = eval('0b' + gene[16:]) * 0.00001\n    return [alpha, beta]\n\n⚤ 初始化种群个体不能无中生有，我们必然需要先随机生成一个祖先种群，即第一代个体，这些个体没有什么特别要求，只要满足约束条件即可（可行解）。在我们这个问题中对没有约束，只要在上述范围内即可。\n注意这里由于二进制表示范围大于我们的上述范围，因此还是先分别生成十进制数然后转化为二进制，最后拼接在一起的。\nimport random as rd\ndef init(num):\n    pop = []\n    for i in range(num):\n        b1 = bin(rd.randint(0, 10000))\n        b2 = bin(rd.randint(0, 1000))\n        if len(b1) &lt; 16:\n            b1 = list(b1)\n            b1.insert(2, '0' * (16 - len(b1)))\n            b1 = ''.join(b1)\n        if len(b2) &lt; 12:\n            b2 = list(b2)\n            b2.insert(2, '0' * (12 - len(b2)))\n            b2 = ''.join(b2)\n        pop.append(b1 + b2[2:])\n    return pop\n\n⚤ 适应性评价在开启大自然的选拔机制前，我们需要定义每个个体的适应度，本质上来说就是有多合我们的心意，在运行过程中代表着存活率。如果目标函数是最大化，那么往往是直接将目标函数作为适应性函数；若是最小化，则可以进行取负平移或是取倒数等操作。\n另外适应性计算不需要是一个函数，在本例中就是一个贪心算法来计算个体适应性的。\n对于个体假设其适应性为，那么其生存率为\n\n⚤ 轮盘赌选择这是一个比较经典常用的优胜劣汰方式，根据淘汰率生成个随机数，每个随机数选择满足下列条件的第个个体，未被选择的个体将被淘汰\n\n有点像上帝掷骰子。这里不直接选择生存率最高的个体也是在模拟现实世界中的意外，给算法加入了更大的随机性，毕竟未必优良个体繁衍的后代就一定还是优良的，相反劣势个体也是一样。这样的处理方式大大增加了算法的灵活性。\njdg = np.array(list(map(adpt, pop)))\nout_num = int(out_rate * len(pop))\nnext_pop = []\nin_num = len(pop) - out_num\nfor i in range(in_num):\n    dice = rd.random() * jdg.sum()\n    sum = 0\n    for j in range(len(pop)):\n        sum += jdg[j]\n        if sum &gt; dice:\n            next_pop.append(pop[j])\n            break\n\n⚤ 交叉重组对上一步中幸存下来的个体，随机选取两者进行交叉重组。首先随机生成一个交叉位点，然后将两个个体的基因在交叉位点处拆分重组后形成的两个新个体加入当前的种群中。我在这里的处理方式是不断繁衍至种群个体数量恢复如初，如果按指数方式增加种群数量的话，迭代次数稍微一大就会很慢。\nfor i in range(round(out_num / 2)):\n       x = rd.randint(0, in_num - 1)\n       y = rd.randint(0, in_num - 1)\n       node = rd.randint(3, 25)\n       next_pop.append(next_pop[x][0:node] + next_pop[y][node:])\n       next_pop.append(next_pop[y][0:node] + next_pop[x][node:])\n\n⚤ 个体变异对新一代种群中的每个个体生成一个随机数，若（是变异概率，一般较小）则随意生成一个变异位点，将该位点处的编码进行二进制反转（0→1,1→0）。过大会导致进化收敛到最后的优良种群基因不稳定，即使迭代次数较大也难以收敛。\n🧟‍♀️丧尸就是变异过猛的结果🧟‍♂️\nBUT，如果说搜索范围非常大的话，我们将适当调大可能会有着意想不到的结果，但前提是每次迭代后都要更新当前最优个体基因和适应性，这样就相当于一种变相的随机搜索。当然可以两者相结合，那你将面向搜索。\nfor i in range(len(next_pop)):\n    if rd.random() &lt; pm:\n        node = rd.randint(2, 25)\n        next_pop[i] = next_pop[i][0:node] + ('1' if next_pop[i][node] == '0' else '0') + next_pop[i][node + 1:]\n\n⚤ 重复迭代一般设置300-500轮迭代，更重要的是观察适应性是否逐渐收敛。\n\n\n\n那么上帝是不是也在运行着高阶的遗传算法呢？\n","slug":"遗传算法","date":"2022-08-19T16:37:41.000Z","categories_index":"智能算法","tags_index":"python,数学煎馍","author_index":"Starlit Rover"},{"id":"f0575046ba6429b64e77d36d9af8e107","title":"「1038」Recover the Smallest Number","content":"Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.\n\n\nInput Specification:Each input file contains one test case. Each case gives a positive integer N () followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the smallest number in one line. Notice that the first digit must not be zero.\nSample Input:5 32 321 3214 0229 87\n\nSample Output:22932132143287\n\n\nΩ有点意思，给出几个长度不一的数字切片，希望你重组为一个最小的数。\n刚开始没想到贪心算法，总是想着全部读入然后构建一棵排序树，但处理起来总是相对麻烦。后来突然灵光一现，完全可以一边读入一边排序，找到适当的位置插入后成为当前最小的数字，这是很经典的贪心算法。\n那么如何证明这个贪心算法得出的结果一定是题目所求呢。我们只需证明每一次的最优解能通过排序插入的方式找到下一次的最优解即可。如果对于一个最小排列，我们随机从中抽走一个切片后的结果不是最小排列，那么我们一定能够将抽走的切片与剩余切片的最小排列构造出一个比原排列更小的新排列，矛盾。这说明所有最小排列都可拆分成一个切片和另一个最小排列，从而归纳证明了贪心的正确性。\n排序插入的流程是从当前最左边的切片开始比较放置在前面和后面的大小，若放置在前面更小则停止比较并将其插入到该切片的前面，否则继续与下一个切片进行比较。之所以可以这么比较是因为当前的切片序列也是有序的，而这种比较方式类似于冒泡排序。\n众所周知，排序冒泡在排列逆序数据时会耗时巨大，这也导致最后一个测试点无法通过。由于是在有序切片内进行插入，因此可以采取二分的方式。但更为简便的方式是采用&lt;algorithm&gt;库中的sort函数，指定cmp函数为return a+b&lt;b+a;。\n最后需要找到第一个非零数字，注意前面的0不要输出，另外别忘了全0大坑。\n\nC ☺ D E➢ 二分法#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nchar r[10];\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    string s;\n    vector&lt;string&gt; arrange;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s\", r);\n        s = r;\n        if (i == 0)\n            arrange.push_back(s);\n        else\n        {\n            string x, y;\n            int left = 0, right = arrange.size();\n            while (left &lt; right)\n            {\n                int mid = (left + right) / 2;\n                x = s + arrange[mid];\n                y = arrange[mid] + s;\n                if (x &gt; y)\n                    left = mid + 1;\n                else\n                    right = mid;\n            }\n            arrange.insert(arrange.begin() + left, s);\n        }\n    }\n\n    bool flag = false;\n\n    for (auto &amp;k: arrange)\n    {\n        if (flag)\n            printf(\"%s\", k.c_str());\n        else\n        {\n            flag = !(k == string(k.size(), '0')) || flag;\n            for (int i = 0; i &lt; k.size(); ++i)\n                if (k[i] != '0')\n                {\n                    printf(\"%s\", k.substr(i, k.size() - i).c_str());\n                    break;\n                }\n        }\n    }\n    if (!flag)\n        printf(\"0\");\n}\n\n➣ sort#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;string&gt; arrange(n);\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; arrange[i];\n\n    sort(arrange.begin(), arrange.end(), [](string &amp;a, string &amp;b) { return a + b &lt; b + a; });\n\n    bool flag = false;\n    for (auto &amp;k: arrange)\n    {\n        if (flag)\n            printf(\"%s\", k.c_str());\n        else\n        {\n            flag = !(k == string(k.size(), '0')) || flag;\n            for (int i = 0; i &lt; k.size(); ++i)\n                if (k[i] != '0')\n                {\n                    printf(\"%s\", k.substr(i, k.size() - i).c_str());\n                    break;\n                }\n        }\n    }\n    if (!flag)\n        printf(\"0\");\n}\n","slug":"「1038」Recover-the-Smallest-Number","date":"2022-08-19T04:22:22.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search,sort,vector","author_index":"Starlit Rover"},{"id":"0738eb06f86d646ed22a63acbd8bab64","title":"「1037」Magic Coupon","content":"The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N’s!\nFor example, given a set of coupons , and a set of product values  (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop.\nEach coupon and each product may be selected at most once. Your task is to get as much money back as possible.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the number of coupons ​, followed by a line with  coupon integers. Then the next line contains the number of products ​, followed by a line with ​ product values. Here ,  and it is guaranteed that all the numbers will not exceed .\nOutput Specification:For each test case, simply print in a line the maximum amount of money you can get back.\nSample Input:4\n1 2 4 -1\n4\n7 6 -2 -3\n\nSample Output:43\n\n\nΩ火星超市，嗯，我故居，发优惠券，一张优惠券只能和一件产品搭配使用，给出一系列优惠券和商品价格（均可为负），优惠券和商品价格的乘积为可以返还的火星币数，要求你计算出最大的返还币数。（就是排列组合最大化目标函数，背景整的花里胡哨）\n不难，注意优惠券和产品并不是要全部使用，所以我们只要找同号的数相乘即可。根据排序不等式，两组相同个数的数唯有【大数乘大数，小数乘小数】时乘积之和最大。第一想法就是，先对两组数进行排序，然后均从第一个数开始相乘累加，直到遇见异号数；然后再从最后一个开始相乘累加，同样直到异号数。\n这里有两个问题：\n\n如果从头和从尾开始都不会遇到异号数，那么部分优惠券和产品会被计算两次\n\n如果所有优惠券和产品价格都是同号的，那么先从头开始的时候就会把优惠券用在价格最小的产品上\n\n\nQ1只要记住第一次把优惠券用到第几张了即可，Q2其实换一下遍历顺序就好了，即先从最后一个开始累乘相加，然后再从第一个开始。Q2比较容易被忽视，但只要自己多构造几个测试用例就会发现。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n;\n    cin &gt;&gt; m;\n    vector&lt;int&gt; c(m);\n    for (auto &amp;k: c)\n        cin &gt;&gt; k;\n    sort(c.begin(), c.end());\n    cin &gt;&gt; n;\n    vector&lt;int&gt; p(n);\n    for (auto &amp;k: p)\n        cin &gt;&gt; k;\n    sort(p.begin(), p.end());\n    int sum = 0;\n    for (m -= 1, n -= 1; m &gt;= 0 &amp;&amp; n &gt;= 0; --m, --n)\n    {\n        if ((c[m] ^ p[n]) &gt;= 0)\n            sum += c[m] * p[n];\n        else\n            break;\n    }\n    for (int i = 0; i &lt; min(m, n); ++i)\n    {\n        if ((c[i] ^ p[i]) &gt;= 0)\n            sum += c[i] * p[i];\n        else\n            break;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\n\na^b≥0用于判断两数是否同号，本质是判断符号位是否一致。\n","slug":"「1037」Magic-Coupon","date":"2022-08-05T15:10:40.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,vector","author_index":"Starlit Rover"},{"id":"26c80e72f01819f2ff80ad4c0899d687","title":"「1036」Boys vs Girls","content":"This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.\n\n\nInput Specification:Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct.\nOutput Specification:For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference ​. If one such kind of student is missing, output Absent in the corresponding line, and output NA in the third line instead.\nSample Input 1:3\nJoe M Math990112 89\nMike M CS991301 100\nMary F EE990830 95\n\nSample Output 1:Mary EE990830\nJoe Math990112\n6\n\nSample Input 2:1\nJean M AA980920 60\n\nSample Output 2:Absent\nJean AA980920\nNA\n\n\nΩ难得水题，打个霍害。\n找出分数最高的女生和分数最低的男生，并输出分数差。奇怪的意图，，，可能是想说明女生不比男生差吧。\n由于只需要找出最高和最低，因此不需要保存所有人的成绩，一边读入一边比较更新即可。一路三元运算下来，懒癌晚期了。\n\nC ☺ D E#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, s, Fmax = -1, Mmin = 101;\n    pair&lt;string, string&gt; m, f;\n    cin &gt;&gt; n;\n    string name, gender, id;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; gender &gt;&gt; id &gt;&gt; s;\n        (gender == \"M\" &amp;&amp; s &lt; Mmin) ? (m = {name, id}, Mmin = s) : NULL;\n        (gender == \"F\" &amp;&amp; s &gt; Fmax) ? (f = {name, id}, Fmax = s) : NULL;\n    }\n    cout &lt;&lt; (Fmax == -1 ? \"Absent\" : (f.first + \" \" + f.second)) &lt;&lt; endl;\n    cout &lt;&lt; (Mmin == 101 ? \"Absent\" : (m.first + \" \" + m.second)) &lt;&lt; endl;\n    cout &lt;&lt; (Fmax == -1 || Mmin == 101 ? \"NA\" : to_string(Fmax - Mmin)) &lt;&lt; endl;\n}\n","slug":"「1036」Boys-vs-Girls","date":"2022-08-05T13:45:26.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋","author_index":"Starlit Rover"},{"id":"a53e7c68139d24254c9d824823f3fbc3","title":"「1035」Password","content":"To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.\n\n\nInput Specification:Each input file contains one test case. Each case contains a positive integer N (≤1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.\nOutput Specification:For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead.\nSample Input 1:3\nTeam000002 Rlsp0dfa\nTeam000003 perfectpwd\nTeam000001 R1spOdfa\n\nSample Output 1:2\nTeam000002 RLsp%dfa\nTeam000001 R@spodfa\n\nSample Input 2:1\nteam110 abcdefg332\n\nSample Output 2:There is 1 account and no account is modified\n\nSample Input 3:2\nteam110 abcdefg222\nteam220 abcdefg333\n\nSample Output 3:There are 2 accounts and no account is modified\n\n\nΩ简单的字符替换，注意一下单复数语法，一路switch。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;string, string&gt;&gt; acc;\n    string user, pass;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; user &gt;&gt; pass;\n        bool flag = false;\n        for (auto &amp;k: pass)\n            switch (k)\n            {\n                case '1':\n                    k = '@';\n                    flag = true;\n                    break;\n                case '0':\n                    k = '%';\n                    flag = true;\n                    break;\n                case 'l':\n                    k = 'L';\n                    flag = true;\n                    break;\n                case 'O':\n                    k = 'o';\n                    flag = true;\n                    break;\n                default:\n                    continue;\n            }\n        if (flag)\n            acc.emplace_back(user, pass);\n    }\n    if (acc.size() == 0)\n    {\n        switch (n)\n        {\n            case 1:\n                printf(\"There is 1 account and no account is modified\\n\");\n                break;\n            default:\n                printf(\"There are %d accounts and no account is modified\\n\", n);\n        }\n        return 0;\n    }\n    cout &lt;&lt; acc.size() &lt;&lt; endl;\n    for (auto &amp;k: acc)\n        cout &lt;&lt; k.first &lt;&lt; \" \" &lt;&lt; k.second &lt;&lt; endl;\n}\n","slug":"「1035」Password","date":"2022-08-02T06:09:39.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,vector","author_index":"Starlit Rover"},{"id":"f5b9a425a8b15196437bbb108fb7f4af","title":"「1034」Head of a Gang","content":"One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format:\nName1 Name2 Time\n\nwhere Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes.\nOutput Specification:For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.\nSample Input 1:8 59\nAAA BBB 10\nBBB AAA 20\nAAA CCC 40\nDDD EEE 5\nEEE DDD 70\nFFF GGG 30\nGGG HHH 20\nHHH FFF 10\n\nSample Output 1:2\nAAA 3\nGGG 3\n\nSample Input 2:8 70\nAAA BBB 10\nBBB AAA 20\nAAA CCC 40\nDDD EEE 5\nEEE DDD 70\nFFF GGG 30\nGGG HHH 20\nHHH FFF 10\n\nSample Output 2:0\n\n\nΩ警察要通过通话记录来确定帮派团伙，认为两个有通话记录的人是有联系的，那么如果有联系的人所构成的连通图人数&gt;2且其中所有通话时长之和超过给定阈值K 就被认定为一个团伙，而通话时长最长的人则认为是团伙头目。现在给出阈值K和一些通话记录，需要你输出团伙个数、团伙头目、团伙人数。\n不是很难，都是对图论基础的考察。看似本题是一道有权图，实则通话记录可以单独放一边，然后将通话关系网看成无权无向图。因为权重只涉及团伙判定，跟个体联系无关，我们只需将一个连通图内每个人的通话时长全部相加/2就能得到该分图的权重之和，顺便找出通话记录最长的头头即可。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, t;\n    cin &gt;&gt; n &gt;&gt; k;\n    map&lt;string, set&lt;string&gt;&gt; adj;\n    map&lt;string, bool&gt; visited;\n    map&lt;string, int&gt; weight, otc;\n    string a, b;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t;\n        adj[a].insert(b);\n        adj[b].insert(a);\n        weight[a] += t;\n        weight[b] += t;\n        visited[a] = visited[b] = false;\n    }\n    for (auto &amp;u: visited)\n    {\n        if (u.second) continue;\n        set&lt;string&gt; gang{u.first}, tmp1{u.first}, tmp2;\n        visited[u.first] = true;\n        while (!tmp1.empty())\n        {\n            for (auto &amp;v: tmp1)\n                for (auto &amp;w: adj[v])\n                    if (!visited[w])\n                    {\n                        tmp2.insert(w);\n                        visited[w] = true;\n                    }\n            gang.insert(tmp2.begin(), tmp2.end());\n            tmp1 = tmp2;\n            tmp2.clear();\n        }\n\n        if (gang.size() &gt; 2)\n        {\n            int sum = 0, max = weight[*gang.begin()];\n            string head = *gang.begin();\n            for (auto &amp;h: gang)\n            {\n                if (weight[h] &gt; max)\n                {\n                    max = weight[h];\n                    head = h;\n                }\n                sum += weight[h];\n            }\n            if (sum / 2 &gt; k)\n                otc[head] = gang.size();\n        }\n    }\n    cout &lt;&lt; otc.size() &lt;&lt; endl;\n    for (auto &amp;r: otc)\n        cout &lt;&lt; r.first &lt;&lt; \" \" &lt;&lt; r.second &lt;&lt; endl;\n}\n\n一遍就过，爽\n","slug":"「1034」Head-of-a-Gang","date":"2022-08-02T03:50:15.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set","author_index":"Starlit Rover"},{"id":"75a7b4e5def88b644c70f785b7585976","title":"「1033」To Fill or Not to Fill","content":"With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax​ (≤ 100), the maximum capacity of the tank; D (≤30000), the distance between Hangzhou and the destination city; Davg​ (≤20), the average distance per unit gas that the car can run; and N (≤ 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: , the unit gas price, and  (≤D), the distance between this station and Hangzhou, for . All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print The maximum travel distance = X where X is the maximum possible distance the car can run, accurate up to 2 decimal places.\nSample Input 1:50 1300 12 8\n6.00 1250\n7.00 600\n7.00 150\n7.10 0\n7.20 200\n7.50 400\n7.30 1000\n6.85 300\n\nSample Output 1:749.17\n\nSample Input 2:50 1300 12 2\n7.10 0\n7.00 600\n\nSample Output 2:The maximum travel distance = 1200.00\n\n\nΩ终于见到需要动点脑子的题目了（然而脑子已生锈。\n一条直线上有多个加油站，每个加油站的油价不同，给出四元组（最大油量，总路程长度，单位油耗能跑的里程数，加油站个数），以及每个加油站距离起点的距离和油价，计算到达终点时所需的最便宜总油费，若无法到达则输出最远里程。\n本质上是考虑到达每一个加油站时做出是否加油的决策，如果要加则加多少。\n\n问题❶：加不加。很显然，如果我们能开到前面一个油价更便宜的加油站就可以不加，但如果我们前面能开到的加油站油价都比当前这家高，那没办法我们必须加。\n\n问题❷：加多少。很显然，如果在加满油的里程范围内有一家油价更低的加油站，那么我们只要加到能够达到这家加油站的油量即可。另外我们找的不是里程范围内油价最低的那家P，而是第一家油价比当前油站K低的油站Q，否则QP（P比Q远）路程所付的油价就不划算了。如果该范围内没有价格更低的油站，那么直接把油加满将是最优选择，因为加满油的这段路上没有更划算的加油站。\n\n\n看透本质后一切都明了了起来，我们首先对得到的油站信息根据到起点的距离进行排序，然后依次便利所有油站，即对每个油站都进行是否加油的决策。根据当前油量计算可行驶里程，在该里程范围中寻找油价更低的油站，若有则不加油。若加油则在加满油的里程范围内寻找第一家油价更低的油站，找到后计算到当该油站还差多少油，根据结果加油付费。\n弥天大坑：第一个油站如果不在起点，汽车开局就嗝屁了，最大里程：0。（case 2）\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;double, double&gt; pdd;\n\nint main()\n{\n    int t, d, da, n;\n    double gas = 0, price = 0;\n    cin &gt;&gt; t &gt;&gt; d &gt;&gt; da &gt;&gt; n;\n    vector&lt;pdd&gt; stations(n);\n    for (auto &amp;k: stations)\n        cin &gt;&gt; k.second &gt;&gt; k.first;\n    stations.emplace_back(d, 0);\n    sort(stations.begin(), stations.end(), [](pdd &amp;a, pdd &amp;b) { return a.first &lt; b.first; });\n    // ！！！\n    if (stations[0].first != 0)\n    {\n        printf(\"The maximum travel distance = 0.00\");\n        return 0;\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        double crt_d = stations[i].first, gas_d = crt_d + gas * da;\n        int k = i + 1;\n        bool flag = false;\n        while (k &lt; (n + 1) &amp;&amp; stations[k].first &lt;= gas_d)\n        {\n            if (stations[k].second &lt; price)\n            {\n                flag = true;\n                break;\n            }\n            ++k;\n        }\n        if (!flag)\n        {\n            int idx = i;\n            while (k &lt; (n + 1) &amp;&amp; stations[k].first &lt;= crt_d + t * da)\n            {\n                flag = true;\n                if (stations[k].second &lt; stations[idx].second)\n                {\n                    idx = k;\n                    break;\n                }\n                ++k;\n            }\n            if (!flag)\n            {\n                printf(\"The maximum travel distance = %.2lf\", crt_d + t * da);\n                return 0;\n            }\n            else if (idx == i)\n            {\n                price += (t - gas) * stations[i].second;\n                gas = t;\n            }\n            else\n            {\n                gas += (stations[idx].first - gas_d) / da;\n                price += (stations[idx].first - gas_d) / da * stations[i].second;\n            }\n        }\n        gas -= (stations[i + 1].first - crt_d) / da;\n    }\n    printf(\"%.2lf\", price);\n}\n\nTips\n在油站向量stations的最后加入了终点作为一个虚油站，方便最后一个油站的决策\n\ncrt_d表示当前里程，gas_d表示当前油量最大里程\n\nflag二次利用，第二次是检验当前站点加满油后能否行驶到下一个站点\n\n每次循环的结束都将行驶到下一个站点的油量进行扣除\n\n\n","slug":"「1033」To-Fill-or-Not-to-Fill","date":"2022-08-01T14:04:54.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,vector","author_index":"Starlit Rover"},{"id":"2aa4f707763887fd968ccc8e9446d574","title":"「1032」Sharing","content":"To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1.\n\nFigure 1\n\nYou are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1).\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (≤105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\n\nwhereAddress is the position of the node, Data is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and Next is the position of the next node.\nOutput Specification:For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead.\nSample Input 1:11111 22222 9\n67890 i 00002\n00010 a 12345\n00003 g -1\n12345 D 67890\n00002 n 00003\n22222 B 23456\n11111 L 00001\n23456 e 67890\n00001 o 00010\n\nSample Output 1:67890\n\nSample Input 2:00001 00002 4\n00001 a 10001\n10001 s -1\n00002 a 10002\n10002 t -1\n\nSample Output 2:-1\n\n\nΩ这题废话真多，输入也是。一种将字母化为节点来存储单词的机制，为了节省空间就需要寻找公共后缀，现在给你一坨节点以及连接关系，还有两个单词的头节点，需要你给出公共后缀的首地址，若无则输出-1。\n首先用map存储所有节点地址的连接关系，然后将第一个单词所有的节点进行标记，随后遍历第二个单词，遇到的第一个标记过的节点地址即为所求。\n有以下几个注意点：\n\n两个单词可能是同一个\n\n其中一个单词可能不存在（开头即为-1）\n\n给出的节点并非是两个单词中的\n\n\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b, e, f;\n    int n;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;\n    map&lt;string, pair&lt;string, bool&gt;&gt; next;\n    char c;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; e &gt;&gt; c &gt;&gt; f;\n        next[e] = {f, false};\n    }\n    while (a != \"-1\")\n    {\n        next[a].second = true;\n        a = next[a].first;\n    }\n    while (b != \"-1\")\n    {\n        if (next[b].second)\n        {\n            cout &lt;&lt; b;\n            return 0;\n        }\n        b = next[b].first;\n    }\n    cout &lt;&lt; \"-1\";\n}\n","slug":"「1032」Sharing","date":"2022-08-01T07:30:35.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map","author_index":"Starlit Rover"},{"id":"786aa9c8aedf18362cb4846354e16ec2","title":"「1031」Hello World for U","content":"Given any string of N (≥5) characters, you are asked to form the characters into the shape of U. For example, helloworld can be printed as:\nh  d\ne  l\nl  r\nlowo\n\nThat is, the characters must be printed in the original order, starting top-down from the left vertical line with ​ characters, then left to right along the bottom line with  characters, and finally bottom-up along the vertical line with ​ characters. And more, we would like U to be as squared as possible —— that is, it must be satisfied that  with .\n\n\nInput Specification:Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.\nOutput Specification:For each test case, print the input string in the shape of U as specified in the description.\nSample Input:helloworld!\n\nSample Output:h   !\ne   d\nl   l\nlowor\n\n\nΩ难得来一道画画题放松放松。给出一个字符串，需要你尽可能画成【U】的样子，而且这个U尽可能贴近正方形，另外高度不能超过宽度。那么很显然\n\n于是乎，构造一个的空格字符串，稍微操作一下，就画完了。\n\nC ☺ D E#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin &gt;&gt; s;\n    int m = (s.size() + 2) / 3, n = s.size() - 2 * m + 2;\n    string blank(n - 2, ' ');\n    for (int i = 0; i &lt; m - 1; ++i)\n        cout &lt;&lt; s[i] &lt;&lt; blank &lt;&lt; s[s.size() - i - 1] &lt;&lt; endl;\n    cout &lt;&lt; s.substr(m - 1, n);\n}\n\nstring.substr(m,n)可以截取字符串第m个位置（0是第一个位置）起n个字符的字符串。\n","slug":"「1031」Hello-World-for-U","date":"2022-07-21T09:30:51.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,string","author_index":"Starlit Rover"},{"id":"ed8d01651cc47c3cf52012b240c9dde7","title":"「1030」Travel Plan","content":"➳ENTRY\nA traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:\nCity1 City2 Distance Cost\n\nwhere the numbers are all integers no more than 500, and are separated by a space.\nOutput Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.\nSample Input:4 5 0 3\n0 1 1 20\n1 3 2 30\n0 3 4 10\n0 2 2 20\n2 3 1 20\n\nSample Output:0 2 3 3 40\n\n\nΩ一个无向有（双）权图，给定起点和终点，还有每一条路的长度与花费，求出最短的路径，如果有多条最短路径，那么选择其中花费最少的路径，题目保证该路径唯一。\n如果只需考虑单一权重那么就是一道经典的Dijkstra算法题，而双权重的本质思想其实也是一样的，只是将算法中所有权重比较变成先比较路径长度若长度相等则再比较花费的方式，简单地概括就是\n(distance1 &lt; distance2) ? true : ((distance1 == distance2) ? (cost1 &lt; cost2) : false)\n\n然后对于路径的记录则采取记录每一个节点的最短路径中前一个节点的编号，那么最后就可以从终点回溯出整条路径。\n采用vector&lt;map&lt;city(int),pair&lt;dist(int),cost(int)&gt;&gt;&gt;的数据结构来存储路径长度和花费。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n#define MAXDIST 100000000\n\nint main()\n{\n    int m, n, s, d, p, q;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s &gt;&gt; d;\n    vector&lt;map&lt;int, pair&lt;int, int&gt;&gt;&gt; path(m);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; p &gt;&gt; q;\n        cin &gt;&gt; path[p][q].first &gt;&gt; path[p][q].second;\n        path[q][p] = path[p][q];\n    }\n    vector&lt;pair&lt;int, int&gt;&gt; dist(m, {MAXDIST, 0});\n    vector&lt;int&gt; pre(m, -1);\n    for (auto &amp;k: path[s])\n    {\n        dist[k.first] = k.second;\n        pre[k.first] = s;\n    }\n    vector&lt;bool&gt; visited(m, false);\n    visited[s] = true;\n    while (!visited[d])\n    {\n        int min_dist = MAXDIST + 1, cost = 0, min_idx = -1;\n        for (int i = 0; i &lt; m; ++i)\n            if (!visited[i] &amp;&amp; dist[i].first &lt;= min_dist)\n            {\n                min_idx = (dist[i].first &lt; min_dist) ? i : min_idx;\n                cost = (dist[i].first &lt; min_dist) ? dist[i].second : cost;\n                min_dist = dist[i].first;\n            }\n        visited[min_idx] = true;\n        for (auto &amp;k: path[min_idx])\n        {\n            // 已确定节点必须跳过，否则会干扰pre\n            if (visited[k.first]) continue;\n            auto &amp;single = path[min_idx][k.first];\n            int flag1 = (dist[k.first].first - dist[min_idx].first - single.first), flag2 = (dist[k.first].second - dist[min_idx].second - single.second);\n            if (flag1 &gt; 0 || flag1 == 0 &amp;&amp; flag2 &gt; 0)\n            {\n                pre[k.first] = min_idx;\n                dist[k.first] = {dist[min_idx].first + single.first, dist[min_idx].second + single.second};\n            }\n        }\n    }\n    vector&lt;int&gt; way;\n    while (d != -1)\n    {\n        way.push_back(d);\n        d = pre[d];\n    }\n    for (auto k = way.rbegin(); k != way.rend(); ++k)\n        cout &lt;&lt; *k &lt;&lt; \" \";\n    cout &lt;&lt; dist[way[0]].first &lt;&lt; \" \" &lt;&lt; dist[way[0]].second &lt;&lt; endl;\n}\n","slug":"「1030」Travel-Plan","date":"2022-07-21T08:23:49.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,pair,vector,Dijkstra","author_index":"Starlit Rover"},{"id":"8cee37557b0d2d5a2b6286881eecf21d","title":"「1029」Median","content":"➳ENTRY\nGiven an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.\nGiven two increasing sequences of integers, you are asked to find their median.\n\n\nInput Specification:Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N () is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int.\nOutput Specification:For each test case you should output the median of the two given sequences in a line.\nSample Input:4 11 12 13 14\n5 9 10 15 16 17\n\nSample Output:13\n\n\nΩ两个升序序列，我们需要找到他们合并后有序数列里的中位数。\n不难，第一个想法就是把他们都放到一个set里，然后用迭代器找到中位数。事实证明可以实现，不过如果使用cin、cout最后一个测试点会超时，这位已经是老钉子户了，换成scanf和printf即可。\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k;\n    scanf(\"%d\", &amp;m);\n    set&lt;int&gt; s;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        s.insert(k);\n    }\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        s.insert(k);\n    }\n    auto median = s.begin();\n    for (int i = 0; i &lt; (m + n - 1) / 2; ++i, ++median);\n    printf(\"%d\", *median);\n}\n\n⚠️由于set的迭代器没有重载过+但重载过++，因此需要用循环加到中位数的位置。\n\n\n当然我们也可以先读入第一个序列，然后在读入第二个序列的个数时已经可以推算出中位数在总序列中的序号了，那么每读入第二序列中的一个数时就计算该数以及第一序列中比该数小的数在总序列中的位置，一旦到了中位数的位置即可停止读入，直接输出。如果第二序列读完还是没到中位数的位置，那么我们也可以通过最后一个数在总序列中的位置计算出中位数在第一序列中的序号。\n\nC ☺ D E#include &lt;iostream&gt;\n\nint main()\n{\n    int m, n, k;\n    scanf(\"%d\", &amp;m);\n    int a[m];\n    for (int i = 0; i &lt; m; ++i)\n        scanf(\"%d\", &amp;a[i]);\n    scanf(\"%d\", &amp;n);\n    int mid = (m + n + 1) / 2, cnt = 0, idx = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        while (idx &lt; m &amp;&amp; a[idx] &lt;= k)\n        {\n            ++idx; ++cnt;\n            if (cnt == mid) break;\n        }\n        cnt += 1;\n        if (cnt &gt;= mid)\n        {\n            printf(\"%d\", (cnt == mid) ? k : a[idx - 1]);\n            break;\n        }\n    }\n    if (cnt &lt; mid)\n        printf(\"%d\", a[idx + mid - cnt - 1]);\n}\n","slug":"「1029」Median","date":"2022-07-20T07:58:20.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort","author_index":"Starlit Rover"},{"id":"0267edd43b1463151f0a6cef88e4adee","title":"「1028」List Sorting","content":"➳ENTRY\nExcel can sort records according to any column. Now you are supposed to imitate this function.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two integers N (≤105) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).\nOutput Specification:For each test case, output the sorting result in N lines. That is, if C = 1 then the records must be sorted in increasing order according to ID’s; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order.\nSample Input 1:3 1\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n\nSample Output 1:000001 Zoe 60\n000007 James 85\n000010 Amy 90\n\nSample Input 2:4 2\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n000002 James 98\n\nSample Output 2:000010 Amy 90\n000002 James 98\n000007 James 85\n000001 Zoe 60\n\nSample Input 3:4 3\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n000002 James 9\n\nSample Output 3:000002 James 9\n000001 Zoe 60\n000007 James 85\n000010 Amy 90\n\n\nΩ根据C值输出对第C列增序排序的结果，值相同的记录则按照ID增序排列。水题。\n先对所有记录的ID进行排序，然后根据C值再进行不同的列排序。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass record\n{\npublic:\n    int id, score;\n    string name;\n};\n\nint main()\n{\n    int n, c;\n    cin &gt;&gt; n &gt;&gt; c;\n    vector&lt;record&gt; r(n);\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; r[i].id &gt;&gt; r[i].name &gt;&gt; r[i].score;\n    sort(r.begin(), r.end(), [](record &amp;a, record &amp;b) { return a.id &lt; b.id; });\n    switch (c)\n    {\n        case 2:\n            sort(r.begin(), r.end(), [](record &amp;a, record &amp;b) { return a.name &lt; b.name; });\n            break;\n        case 3:\n            sort(r.begin(), r.end(), [](record &amp;a, record &amp;b) { return a.score &lt; b.score; });\n            break;\n        default:\n            break;\n    }\n    for (auto &amp;k: r)\n        printf(\"%06d %s %d\\n\", k.id, k.name.c_str(), k.score);\n}\n","slug":"「1028」List-Sorting","date":"2022-07-20T04:16:09.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,vector","author_index":"Starlit Rover"},{"id":"410d655c4b8c89722b8e2a9076e1f7ed","title":"「1026」Table Tennis","content":"➳ENTRY\nA table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours.\nYour job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day.\nOne thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the privilege to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains an integer N (≤10000) - the total number of pairs of players. Then N lines follow, each contains 2 times and a VIP tag: HH:MM:SS - the arriving time, P - the playing time in minutes of a pair of players, and tag - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the players’ info, there are 2 positive integers: K (≤100) - the number of tables, and M (&lt; K) - the number of VIP tables. The last line contains M table numbers.\nOutput Specification:For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed.\nSample Input:10\n20:52:00 10 0\n08:00:00 20 0\n08:02:00 30 0\n20:51:00 10 0\n08:10:00 30 0\n08:12:00 10 1\n20:40:00 13 0\n08:01:30 15 1\n20:53:00 10 1\n20:54:00 10 0\n3 1\n2\n\nSample Output:08:00:00 08:00:00 0\n08:01:30 08:01:30 0\n08:02:00 08:02:00 0\n08:12:00 08:16:30 5\n08:10:00 08:20:00 10\n20:40:00 20:40:00 0\n20:51:00 20:51:00 0\n20:52:00 20:52:00 0\n20:53:00 20:53:00 0\n4 3 2\n\n\nΩ麻了，这题目又让我觉得自己是个复健病人，踩坑达人是我没错了，脑子像被包子塞住了一样。。。\n不耐烦的极简翻译，一家乒乓球馆里面有好几张球桌，每一对玩家到达时会自动选择编号最小的空闲球桌，没有空闲球桌时只能排队等候，你以为这就结束了吗？哈哈我们还有VIP机制，没想到吧，有几张球桌被指定为VIP球桌，当这些球桌空闲时队伍中的VIP用户可省去枯燥无味的排队直接开打（咳咳，当然普通用户在用VIP球桌时不能把人家赶走）。当然在没有VIP用户时可以提供给普通用户，VIP用户在没有VIP球桌时也可以用普通球桌。一对玩家最长只能玩2h，怎么样，心动了吗，赶紧拨打VIP热线（打住\n烦躁的夏日，鸡血的蝉鸣，长的跟催眠符一样的题目，看到最后一句已经忘了前面的条件，又不是一个善茬。条件多了，理清情况就需要一点时间。我们可以码球桌，给每个球桌设置一条时间线，考虑最先空闲下来的球桌：如果是一张VIP球桌，我们就必须瞅瞅队伍里有没有VIP，没有就可以把它当普通球桌处理；对于普通球桌，则直接分配给队伍中的第一对玩家。第一个坑点已悄然出现，对于VIP用户会优先选择编号最小的VIP球桌（还挺有优越感哈）。因此在分配球桌时，如果是VIP用户，我们需要瞅瞅有没有空的VIP球桌。\n这种地雷题，真就摸黑踩雷，我梳理了以下几个雷点：\n\n输入最后一行中的M个数是VIP球桌编号，一开始看了半天\n\nVIP用户优先选择编号最小的VIP球桌，即使有编号更小的普通球桌\n\n21:00来玩的玩家不提供服务（不能输出）\n\n一对玩家最多只能玩两小时，超过两小时按两小时算\n\n如果玩家来的时候很多球桌都是空闲的，此时不能分配最早空闲的球桌（对该玩家来说没有意义），而是需要把这些球桌的时间线都拉到玩家到达的时间\n\n按照提供服务的时间顺序输出用户记录（VIP可以晚到早玩）\n\n最后的等待时间需要按分钟四舍五入（≥ 30s 入，&lt; 30s 舍）\n\n\n如果上述雷都心知肚明，秒这玩意轻轻松松吧～\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass customer\n{\npublic:\n    bool isVIP = false, isAssigned = false;\n    int arrival;\n    int playing;\n    int serving;\n};\n\ninline void printRecord(customer &amp;c)\n{\n    int a = c.arrival, s = c.serving, w = s - a;\n    printf(\"%02d:%02d:%02d \", a / 3600, (a % 3600) / 60, a % 60);\n    printf(\"%02d:%02d:%02d \", s / 3600, (s % 3600) / 60, s % 60);\n    // 四舍五入\n    printf(\"%d\\n\", w / 60 + ((w % 60 &lt; 30) ? 0 : 1));\n}\n\nint main()\n{\n    int n, h, m, s;\n    cin &gt;&gt; n;\n    vector&lt;customer&gt; cus(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d:%d:%d\", &amp;h, &amp;m, &amp;s);\n        cus[i].arrival = h * 3600 + m * 60 + s;\n        cin &gt;&gt; cus[i].playing &gt;&gt; cus[i].isVIP;\n        // playing time &lt;= 2h\n        cus[i].playing = (cus[i].playing &gt; 120) ? 7200 : cus[i].playing * 60;\n    }\n    // 需要先按到达时间进行排序\n    sort(cus.begin(), cus.end(), [](customer &amp;a, customer &amp;b) { return a.arrival &lt; b.arrival; });\n    int table, vip, v;\n    cin &gt;&gt; table &gt;&gt; vip;\n    vector&lt;int&gt; time(table, 28800), total(table, 0), list;\n    vector&lt;bool&gt; isVIP(table, false);\n    for (int i = 0; i &lt; vip; ++i)\n    {\n        cin &gt;&gt; v;\n        isVIP[v - 1] = true;\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (cus[i].isAssigned) continue;\n        // 将时间线都拉到玩家到达的时间\n        for (int j = 0; j &lt; table; ++j)\n            if (time[j] &lt; cus[i].arrival)\n                time[j] = cus[i].arrival;\n        auto crt = min_element(time.begin(), time.end());\n        //【&gt;=】21：00不提供服务\n        if (*crt &gt;= 21 * 3600) break;\n        // VIP球桌需查找【之前】最早到达的VIP用户\n        if (isVIP[crt - time.begin()])\n        {\n            int j = i;\n            bool flag = false;\n            // j &lt; n !!!\n            while (j &lt; n &amp;&amp; cus[j].arrival &lt;= *crt)\n            {\n                if (cus[j].isVIP &amp;&amp; !cus[j].isAssigned)\n                {\n                    cus[j].serving = *crt;\n                    *crt += cus[j].playing;\n                    cus[j].isAssigned = flag = true;\n                    list.push_back(j);\n                    total[crt - time.begin()] += 1;\n                    // 别忘当前普通玩家还在排队！\n                    i -= 1;\n                    break;\n                }\n                ++j;\n            }\n            if (flag) continue;\n        }\n        // VIP用户优先选择VIP球桌\n        if (cus[i].isVIP)\n            for (int k = 0; k &lt; table; ++k)\n                if (time[k] == *crt &amp;&amp; isVIP[k])\n                {\n                    crt = time.begin() + k;\n                    break;\n                }\n        cus[i].serving = *crt;\n        *crt += cus[i].playing;\n        total[crt - time.begin()] += 1;\n        cus[i].isAssigned = true;\n        list.push_back(i);\n    }\n    for (auto &amp;k: list)\n        printRecord(cus[k]);\n    cout &lt;&lt; total[0];\n    for (int i = 1; i &lt; table; ++i)\n        cout &lt;&lt; \" \" &lt;&lt; total[i];\n}\n","slug":"「1026」Table-Tennis","date":"2022-07-19T14:49:11.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,vector,min_element","author_index":"Starlit Rover"},{"id":"9d68ae743a5d7221c7dc3eed3cb529a9","title":"「1025」PAT Ranking","content":"➳ENTRY\nProgramming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:\nregistration_number final_rank location_number local_rank\n\nThe locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.\nSample Input:2\n5\n1234567890001 95\n1234567890005 100\n1234567890003 95\n1234567890002 77\n1234567890004 85\n4\n1234567890013 65\n1234567890011 25\n1234567890014 100\n1234567890012 85\n\nSample Output:9\n1234567890005 1 1 1\n1234567890014 1 2 1\n1234567890001 3 1 2\n1234567890003 3 1 2\n1234567890004 5 1 4\n1234567890012 5 2 2\n1234567890002 7 1 5\n1234567890013 8 2 3\n1234567890011 9 2 4\n\n\nΩPAT考试有多个考场，现给出考场个数以及每个考场内考生的考号与成绩，需要你输出考生总数并按名次从高到低输出考生的考号、总排名、考场号、考场排名，分数相同则按学号升序排列。\n注意到考场内排名和总排名计算方式是一致的，只需要考虑数据结构如何设计。最后既然是按照分数降序排列，那么我们可以用map&lt;score(int),set&lt;registration number(string)&gt; &gt;来存储，即以分数为键值索引得到获得该分数的考生学号集合。对于考场内排名的获取，我们只需先存在一个小map中，计算出排名后将其加入大map中，最后在大map中计算总排名即可。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, r, sum = 0, rank;\n    string s;\n    cin &gt;&gt; n;\n    map&lt;int, set&lt;string&gt;, greater&lt;&gt;&gt; score, loc_score;\n    map&lt;string, int&gt; loc, loc_rank;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        sum += k;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; s &gt;&gt; r;\n            loc[s] = i + 1;\n            loc_score[r].insert(s);\n        }\n        rank = 1;\n        for (auto &amp;u: loc_score)\n        {\n            for (auto &amp;v: u.second)\n                loc_rank[v] = rank;\n            rank += u.second.size();\n        }\n        for (auto &amp;m: loc_score)\n            score[m.first].insert(m.second.begin(), m.second.end());\n        loc_score.clear();\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    rank = 1;\n    for (auto &amp;u: score)\n    {\n        for (auto &amp;v: u.second)\n            cout &lt;&lt; v &lt;&lt; \" \" &lt;&lt; rank &lt;&lt; \" \" &lt;&lt; loc[v] &lt;&lt; \" \" &lt;&lt; loc_rank[v] &lt;&lt; endl;\n        rank += u.second.size();\n    }\n}\n\n∅ Tips\nmap&lt;key,value,greater&lt;&gt;&gt;可以使map中的键值按照降序存储\n\nmap1.insert(map2.begin(),map2.end())可以将两个map合并，本质只会将map2中存在map1中不存在的键值补充到map1，对于两者共有的键值，map1保持原值。\n这里我们需要合并键值相同的两个集合，因此不能直接用insert\n\n\n","slug":"「1025」PAT-Ranking","date":"2022-07-17T15:53:20.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set","author_index":"Starlit Rover"},{"id":"0aa37f9889d7930f068072177d0f0eba","title":"「1024」Palindromic Number","content":"➳ENTRY\nA number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.\nNon-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484.\nGiven any positive integer N, you are supposed to find its paired palindromic number and the number of steps taken to find it.\n\n\nInput Specification:Each input file contains one test case. Each case consists of two positive numbers N and K, where N (≤) is the initial numer and K (≤100) is the maximum number of steps. The numbers are separated by a space.\nOutput Specification:For each test case, output two numbers, one in each line. The first number is the paired palindromic number of N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found after K steps, just output the number obtained at the Kth step and K instead.\nSample Input 1:67 3\n\nSample Output 1:484\n2\n\nSample Input 2:69 3\n\nSample Output 2:1353\n3\n\n\nΩ极简翻译，给定一个以内的正整数N和一个100以内的整数K，在K次循环内，如果N是一个回文数就退出并输出该回文数和相应的次数，否则将该数的逆序数加上N再赋值给N。若K次之后N还不是回文数，则输出当前N与K。\n乍一看，so easy。虽然说，N最大是11位，有可能超出int的范围，那我换个long long int不就完事了。小手一点，有两个绿的。干，忘记考虑运算过程中的N了。考虑极端情况，如果N是一个11位数K取20而且每次和逆序数相加都会增加一位，那么K次之后N早就超出100位了。好吧，回归字符串。\n我们只需实现两个字符串大数的相加即可，非常easy不赘述了。每次循环开始的时候判断一下N是否是回文串，是则退出循环。\n\nC ☺ D E#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ninline bool isPalindromic(string s)\n{\n    string r = s;\n    reverse(r.begin(), r.end());\n    return s == r;\n}\n\nstring addReverse(string &amp;s)\n{\n    int len = s.size(), flag = 0, single;\n    string otc = \"\";\n    for (int i = 0; i &lt; len; ++i)\n    {\n        single = (s[i] - '0') + (s[len - 1 - i] - '0') + flag;\n        otc = to_string(single % 10) + otc;\n        flag = single / 10;\n    }\n    if (flag)\n        otc = to_string(flag) + otc;\n    return otc;\n}\n\nint main()\n{\n    string n;\n    int k, i;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (i = 0; i &lt; k &amp;&amp; !isPalindromic(n); ++i)\n        n = addReverse(n);\n    cout &lt;&lt; n &lt;&lt; endl &lt;&lt; i &lt;&lt; endl;\n}\n\nreverse函数可以直接在容器内实现逆序，还挺神奇。\n","slug":"「1024」Palindromic-Number","date":"2022-07-17T11:27:49.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,reverse,string","author_index":"Starlit Rover"},{"id":"9b81a29ab125985da823773d07744634","title":"「1023」Have Fun with Numbers","content":"➳ENTRY\nNotice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!\nNow you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.\n\n\nInput Specification:Each input contains one test case. Each case contains one positive integer with no more than 20 digits.\nOutput Specification:For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.\nSample Input:1234567899\n\nSample Output:Yes\n2469135798\n\n\nΩ趣味数，是指乘2后的数是原数中所有数字的一个排列的数。给出一个不超过20位的数，我们需要判断该数是否为趣味数，同时输出乘2后的数。\n由于最大是20位数，因此不能直接用整型参与运算，需要自己实现大数乘2算法，然后用一个数字计数vector统计原数中0-9各数字个数，在进行乘2运算每产生一位都在计数器中减去相应数字的个数，最后计数器中若都为0则说明为趣味数，反之则不是。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    string num, num2 = \"\";\n    cin &gt;&gt; num;\n    vector&lt;int&gt; check(10, 0);\n    for (auto &amp;c: num)\n        ++check[c - '0'];\n    int flag = 0, single;\n    for (auto i = num.rbegin(); i != num.rend(); ++i)\n    {\n        single = 2 * (*i - '0') + flag;\n        flag = single / 10;\n        num2 = to_string(single % 10) + num2;\n        --check[single % 10];\n    }\n    if (flag)\n    {\n        num2 = to_string(flag) + num2;\n        --check[flag];\n    }\n    bool isFun = true;\n    for (auto k: check)\n        if (k != 0)\n        {\n            isFun = false;\n            break;\n        }\n    cout &lt;&lt; (isFun ? \"Yes\" : \"No\") &lt;&lt; endl &lt;&lt; num2 &lt;&lt; endl;\n}\n","slug":"「1023」Have-Fun-with-Numbers","date":"2022-07-07T02:33:40.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set","author_index":"Starlit Rover"},{"id":"8e6bb31e56ec41155c96a89b29398eaf","title":"「1022」Digital Library","content":"➳ENTRY\nA Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer  which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines:\n\nLine #1: the 7-digit ID number;\nLine #2: the book title – a string of no more than 80 characters;\nLine #3: the author – a string of no more than 80 characters;\nLine #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;\nLine #5: the publisher – a string of no more than 80 characters;\nLine #6: the published year – a 4-digit number which is in the range [1000, 3000].\n\nIt is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.\nAfter the book information, there is a line containing a positive integer M (≤1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below:\n\n1: a book title\n2: name of an author\n3: a key word\n4: name of a publisher\n5: a 4-digit number representing the year\n\nOutput Specification:For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print Not Found instead.\nSample Input:3\n1111111\nThe Testing Book\nYue Chen\ntest code debug sort keywords\nZUCS Print\n2011\n3333333\nAnother Testing Book\nYue Chen\ntest code sort keywords\nZUCS Print2\n2012\n2222222\nThe Testing Book\nCYLL\nkeywords debug book\nZUCS Print2\n2011\n6\n1: The Testing Book\n2: Yue Chen\n3: keywords\n4: ZUCS Print\n5: 2011\n3: blablabla\n\nSample Output:1: The Testing Book\n1111111\n2222222\n2: Yue Chen\n1111111\n3333333\n3: keywords\n1111111\n2222222\n3333333\n4: ZUCS Print\n1111111\n5: 2011\n1111111\n2222222\n3: blablabla\nNot Found\n\n\nΩ输入每本书的编号，书名，作者，关键词，出版社和年份，然后根据不同的查询方式给出相应的查询结果。\n本题看着很复杂，但是用map容器可以直接秒杀。对于关键词，我们并不清楚一行有几个，但题目明确告知是以单个空格分隔的，因此我们可以先读取一行然后单个字符地加入word变量遇到空格后再加入map并清空word。\n大概有两个注意事项：\n\n一行中最后一个关键词是没有空格的\n\n如果将书本的ID用int类型来存储，那么需要注意有前置0的ID，输出的时候需要格式化，否则测试点3、4将过不去\n\n\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    map&lt;string, set&lt;int&gt;&gt; title, author, publisher, keyword, year;\n    string str;\n    int id;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id;\n        cin.get();\n        getline(cin, str);\n        title[str].insert(id);\n        getline(cin, str);\n        author[str].insert(id);\n        getline(cin, str);\n        string word = \"\";\n        for (auto c: str)\n        {\n            if (c != ' ')\n                word += c;\n            else\n            {\n                keyword[word].insert(id);\n                word = \"\";\n            }\n        }\n        keyword[word].insert(id);\n        getline(cin, str);\n        publisher[str].insert(id);\n        getline(cin, str);\n        year[str].insert(id);\n    }\n\n    int m, format;\n    cin &gt;&gt; m;\n    cin.get();\n    for (int i = 0; i &lt; m; ++i)\n    {\n        getline(cin, str);\n        cout &lt;&lt; str &lt;&lt; endl;\n        format = str[0] - '0';\n        str.erase(0, 3);\n        switch (format)\n        {\n            case 1:\n                if (title[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: title[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 2:\n                if (author[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: author[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 3:\n                if (keyword[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: keyword[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 4:\n                if (publisher[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: publisher[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 5:\n                if (year[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: year[str])\n                        printf(\"%07d\\n\",k);\n                break;\n        }\n    }\n}\n","slug":"「1022」Digital-Library","date":"2022-07-06T10:55:03.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set","author_index":"Starlit Rover"},{"id":"984c45eac2cbd15ed424e46306609be5","title":"「1021」Deepest Root","content":"➳ENTRY\nA graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer  which is the number of nodes, and hence the nodes are numbered from 1 to . Then  lines follow, each describes an edge by given the two adjacent nodes’ numbers.\n\n\nOutput Specification:For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print Error: K components where K is the number of connected components in the graph.\nSample Input 1:5\n1 2\n1 3\n1 4\n2 5\n\nSample Output 1:3\n4\n5\n\nSample Input 2:5\n1 3\n1 4\n2 5\n3 4\n\nSample Output 2:Error: 2 components\n\n\nΩ给出节点个数和条边，首先判断该无向图是否构成树，然后按升序输出作为根节点时能使树高度最高的节点编号。\n首先边的个数已经满足树的要求，因此如果不是树的话就一定不是连通的。所以首先需要求取连通分图数，这里用DFS和BFS皆可。然后如果连通分图数为1，再寻找作为根节点可以使高度最高的节点。\n虽说找的是高度最高，但本质上是在树中找一条最长且节点不重复的路径，最终输出的则是所有最长路径的左右两个节点编号。我们可以将其中一条最长路径拉成直线，其他不属于该路径的边可以视作该直线的分支，那么显然在该直线上的所有节点都属于至少一条最长路径（即直线本身），而且所有最长路径必然会经过直线上的至少一个节点，另外直线上每个节点对最长路径的长度划分都是固定的（否则必然会产生更长的）。不管从哪个节点开始BFS都迟早会达到直线上的某个节点，不失一般性，我们假设节点将最长路径划分后的左端&gt;右端，首先可以肯定最终必然会到达直线最左端节点，另外必然可以到达经过左边节点们的最长路径的一端（因为直线上每个节点对最长路径长度划分都是一致的，因此到达的其他端点到距其最近的直线上节点的距离=到直线最左端节点的距离）。然而右侧的端点被忽略了，因此我们还需要从第一次BFS得到的端点中选一个重新开始BFS（注意直线上分支的最大长度必然≤最长路径/2，因此距离第一次BFS得到的任意端点最近的直线节点将最长距离划分的结果会是 右端&gt;左端，从而可以互补），最后取并集得到所有端点。\n这些证明只是为了说明该算法的合理性，在代码中并不体现。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    map&lt;int, set&lt;int&gt;&gt; path;\n    for (int i = 0; i &lt; n - 1; ++i)\n    {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        path[x].insert(y);\n        path[y].insert(x);\n    }\n    vector&lt;bool&gt; flag(n + 1, false);\n    int cnt = 0;\n\n    for (int k = 1; k &lt;= n; ++k)\n    {\n        if(flag[k]) continue;\n        set&lt;int&gt; next{k}, tmp;\n        while (!next.empty())\n        {\n            for (auto i: next)\n            {\n                if (flag[i]) continue;\n                flag[i] = true;\n                tmp.insert(path[i].begin(), path[i].end());\n            }\n            next = tmp;\n            tmp.clear();\n        }\n        cnt += 1;\n    }\n\n    set&lt;int&gt; deepestA, deepestB, tmp{1};\n    if (cnt &gt; 1)\n        printf(\"Error: %d components\", cnt);\n    else\n    {\n        flag.assign(n + 1, false);\n        while (!tmp.empty())\n        {\n            deepestA = tmp;\n            tmp.clear();\n            for (auto i: deepestA)\n            {\n                for (auto &amp;k: path[i])\n                    if (!flag[k]) tmp.insert(k);\n                flag[i] = true;\n            }\n        }\n        tmp.insert(*deepestA.begin());\n        flag.assign(n + 1, false);\n        while (!tmp.empty())\n        {\n            deepestB = tmp;\n            tmp.clear();\n            for (auto i: deepestB)\n            {\n                for (auto &amp;k: path[i])\n                    if (!flag[k]) tmp.insert(k);\n                flag[i] = true;\n            }\n        }\n    }\n    deepestA.insert(deepestB.begin(), deepestB.end());\n    for (auto &amp;k: deepestA)\n        cout &lt;&lt; k &lt;&lt; endl;\n}\n\nTips\n先用BFS计算连通分图个数\n\n在BFS求最大深度时勿将父节点加入下一轮遍历节点中\n\n\n","slug":"「1021」Deepest-Root","date":"2022-07-05T03:27:49.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,set,BFS,vector","author_index":"Starlit Rover"},{"id":"ecd0b7f9610ba01de460fb7fa358ee35","title":"「1020」Tree Traversals","content":"➳ENTRY\nSuppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.\n\n\nOutput Specification:For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:7\n2 3 1 5 7 6 4\n1 2 3 4 5 6 7\n\nSample Output:4 1 6 3 5 7 2\n\n\nΩ题意简单明了，就是通过二叉树的后序遍历序列和中序遍历序列求出层次遍历序列。\n我们只需抓住后序和中序的重要特征即可，后序的中间节点是在最后的，中序的中间节点则是在左右子树的中间。那么我们可以采取如下算法构建二叉树：\n\n先取出后序的最后一个数字即可知当前节点的编号\n\n在中序序列中找到该编号所处的位置，那么中序序列就被该节点划分成了左右两棵子树的中序序列，同时我们也得到了两棵子树的节点个数\n\n根据得到的左右子树节点个数也可以将后序序列划分成左右两棵子树的后序序列\n\n如此一来我们就分别得到了左右子树的后序和中序遍历序列，从而划分成了两个子问题再重复上述过程进行解决\n\n\n很显然，划分为子问题是递归的思想，因此只需码一个递归构建二叉树的函数即可，传入当前子树的后序和中序序列在原序列中的位置即可。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; tree;\nvector&lt;int&gt; post, in;\n\nvoid build(int in_start, int in_end, int post_start, int post_end)\n{\n    if (in_start &gt;= in_end)\n        return;\n    int crt = post[post_end], in_pos = find(in.begin() + in_start, in.begin() + in_end, crt) - in.begin() - in_start;\n    tree[crt].first = (in_pos == 0) ? 0 : post[post_start + in_pos - 1];\n    build(in_start, in_start + in_pos - 1, post_start, post_start + in_pos - 1);\n    tree[crt].second = (in_pos == in_end - in_start) ? 0 : post[post_end - 1];\n    build(in_start + in_pos + 1, in_end, post_start + in_pos, post_end - 1);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    post.resize(n);\n    in.resize(n);\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; post[i];\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; in[i];\n    build(0, n - 1, 0, n - 1);\n    vector&lt;int&gt; level, tmp;\n    cout &lt;&lt; post[n - 1];\n    if (tree[post[n - 1]].first != 0)\n        level.push_back(tree[post[n - 1]].first);\n    if (tree[post[n - 1]].second != 0)\n        level.push_back(tree[post[n - 1]].second);\n    while (!level.empty())\n    {\n        for (auto &amp;k: level)\n        {\n            cout &lt;&lt; \" \" &lt;&lt; k;\n            if (tree[k].first != 0)\n                tmp.push_back(tree[k].first);\n            if (tree[k].second != 0)\n                tmp.push_back(tree[k].second);\n        }\n        level = tmp;\n        tmp.clear();\n    }\n}\n\nTips\n用map&lt;int,pair&lt;int,int&gt;&gt;来表示二叉树，通过节点编号可以直接得知左右节点，若节点编号为0则代表该节点为空\n\n注意左右子树为空的情况，也是递归结束的时候\n\n在本题中其实可以无需构建出完整的二叉树，因为只需输出层次遍历序列，所以我们可以给每个编号都给予一个层次遍历的索引，最后按索引输出编号即可，详见柳婼 の blog\n\n\n","slug":"「1020」Tree-Traversals","date":"2022-07-04T03:51:27.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,vector","author_index":"Starlit Rover"},{"id":"1a8f64477679eeab68479d654eb4e8ee","title":"<11> Left Factoring","content":"本文实现了一个较为简单的算法——文法的左公因子提取。umm其实也称不上是算法。\n\n\n\n\n\n\n我们的目标非常明确，就是将文法产生式的左公因式都提出来，需要注意以下几点：\n\n在一个产生式中需要提取范围最大的公因式，即拥有该左公因式的右部应该尽可能得多\n\n提取左公因子之后会产生新的产生式，该产生式也可能存在左公因子，需要一并提取，因此是一种递归的思想\n\n好像也就这两点…\n\n\n那么我们只需要从广度和深度进行确定即可。首先确定左公因子广度，即最多的含有左公因子的右部个数。很显然，对于最大的广度，只要找第一个符号相等的右部即可。确定最大广度后，我们再求这些首字符相等右部的最大深度（最长的左公因子）即可，那么就一遍一遍地遍历，直到发现其中一个右部和其他右部的第位字符不同时，退出循环。构造新产生式，然后对新产生式进行左公因子提取即可。\n\nC ☺ D Edef extract(gen, left):\n    gen[left].sort()\n    k = 0\n    flag = True\n    next_str = left + \"'\"\n    while k &lt; len(gen[left]) - 1:\n        kk = k + 1\n        # 确定横向最大距离\n        while kk &lt; len(gen[left]) and gen[left][kk][0] == gen[left][kk - 1][0]:\n            kk += 1\n        if kk == k + 1:\n            k += 1\n            continue\n        # 确定纵向最大深度\n        common = gen[left][k][0]\n        depth = 0\n        for depth in range(1, len(gen[left][k])):\n            flag = True\n            for i in range(k + 1, kk):\n                if depth &gt;= len(gen[left][i]) or gen[left][i][depth] != gen[left][i - 1][depth]:\n                    flag = False\n                    break\n            if flag:\n                common += gen[left][k][depth]\n            else:\n                break\n        # 当整个gen[left][k]均为左公因式（flag始终为True）时必须将depth+=1，因为depth指的是左公因式的后一位\n        depth += (1 if flag else 0)\n        # extract common part\n        gen[next_str] = ([gen[left][k][depth:]] if depth &lt; len(gen[left][k]) else ['ε'])\n        gen[left][k] = common + next_str\n        for i in range(k + 1, kk):\n            gen[next_str].append((gen[left][k + 1][depth:] if depth &lt; len(gen[left][k + 1]) else ['ε']))\n            gen[left].pop(k + 1)\n        # 递归调用\n        extract(gen, next_str)\n        next_str += \"'\"\n        k = k + 1\n\n\nn = eval(input('请输入文法产生式的个数：'))\nprint('请输入文法产生式：')\ngen = dict()\nfor i in range(n):\n    g = input().replace(' ', '')\n    assert g[1:3] == '-&gt;'\n    gen.setdefault(g[0], [])\n    start = 3\n    for i in range(3, len(g)):\n        if g[i] == '|' or i == len(g) - 1:\n            i += (1 if i == len(g) - 1 else 0)\n            assert start &lt; i\n            gen[g[0]].append(g[start:i])\n            start = i + 1\n    extract(gen, g[0])\n\nprint(\"\\nAfter left factoring:\")\nfor key in gen:\n    print(key + ' -&gt; ', end='')\n    print(*gen[key], sep=' | ')\n\n\nTips\n数据结构与 NO Left Recursion\">&lt;10&gt; NO Left Recursion的类似，只是列表中无需分终结符开头还是非终结符开头，提取左公因子一视同仁\n\n由于相同字符开头的右部可能很分散，不太好直接找，因此我们在提取之前可以对一个产生式的右部先按照字符序进行排序\n\n用[k,kk)来表示最大广度范围，depth是最大深度，next_str是下一个新产生式左部的名称（就是每次加一个【‘】）\n\n注意有时其中一个右部本身就是左公因式的特殊情况，此时提取后的新产生式右部需要加上【ε】\n\n\n\nOutcome","slug":"11-Left-Factoring","date":"2022-06-06T15:29:06.000Z","categories_index":"编译原理","tags_index":"python,走码观花","author_index":"Starlit Rover"},{"id":"e7d5cd857c1aa61505680c49d614561a","title":"Lexer（Ver. Hand）","content":"本文介绍如何手撕词法分析器，整体来说难度不大，还是文件读取麻烦。\n\n\n\n\nlexer.h#ifndef LEXER_H\n#define LEXER_H\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nenum token_type\n{\n    INT,\n    VOID,\n    CONST,\n    IF,\n    ELSE,\n    WHILE,\n    BREAK,\n    CONTINUE,\n    RETURN,\n    ID,\n    NUM,\n    ASSIGN,\n    OR,\n    AND,\n    CMP,\n    LPARENT,\n    RPARENT,\n    LBRACKET,\n    RBRACKET,\n    LBRACE,\n    RBRACE,\n    SEMICN,\n    COMMA,\n    BINOPP,\n    PLUSSUB,\n    NOT\n};\n\nvector&lt;string&gt; token_name =\n{\n    \"INT\\t\\t\",\n    \"VOID\\t\",\n    \"CONST\\t\",\n    \"IF\\t\\t\",\n    \"ELSE\\t\",\n    \"WHILE\\t\",\n    \"BREAK\\t\",\n    \"CONTINUE\",\n    \"RETURN\\t\",\n    \"ID\\t\\t\",\n    \"NUM\\t\\t\",\n    \"ASSIGN\\t\",\n    \"OR\\t\\t\",\n    \"AND\\t\\t\",\n    \"CMP\\t\\t\",\n    \"LPARENT\\t\",\n    \"RPARENT\\t\",\n    \"LBRACKET\",\n    \"RBRACKET\",\n    \"LBRACE\\t\",\n    \"RBRACE\\t\",\n    \"SEMICN\\t\",\n    \"COMMA\\t\",\n    \"BINOPP\\t\",\n    \"PLUSSUB\\t\",\n    \"NOT\\t\\t\"\n};\n\nint lineno = 1;\nvector&lt;pair&lt;token_type, string&gt;&gt; tokens;\nstring token_str;\n\nbool isHexDigit(char ch)    //返回是否是16进制的字符，即0~9,a~f,A~F\n{\n    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') return true;\n    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') return true;\n    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') return true;\n    return false;\n}\n\nbool isIdentifierChar(char ch)    //返回是否是组成标识符的字符\n{\n    return isalpha(ch) || isdigit(ch) || ch == '_';\n}\n\n// token identifiers\nbool Number(ifstream &amp;fin)\n{\n    char ch;\n    //代表是否是非法十六进制、八进制、十进制数\n    bool isInvalidHex = 0, isInvalidOct = 0, isInvalidDec = 0;\n\n    //第一位的处理，根据0与非0分别考虑\n    if (token_str == \"0\")            //OCT or HEX or ZERO\n    {\n        int decnum = 0;\n        if (fin.peek() == 'x' || fin.peek() == 'X')    //HEX\n        {\n            fin.get(ch);\n            token_str += ch;\n            bool is0x = 1;     //判断是否是单个的0x，能进入下面的while就证明不是\n            while (isHexDigit(fin.peek()))\n            {\n                is0x = 0;\n                fin.get(ch);\n                token_str += ch;\n                decnum &lt;&lt;= 4;\n                if (isdigit(ch))\n                {\n                    decnum += ch - '0';\n                }\n                else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')\n                {\n                    decnum += ch - 'a' + 10;\n                }\n                else\n                {\n                    decnum += ch - 'A' + 10;\n                }\n            }\n            if (isIdentifierChar(fin.peek()) || is0x)//混入了不是16进制的其它字母\n            {\n                isInvalidHex = 1;\n            }\n            else\n            {\n                token_str = to_string(decnum);\n            }\n        }\n        else if (fin.peek() &gt;= '1' &amp;&amp; fin.peek() &lt;= '7') //OCT\n        {\n            while (fin.peek() &gt;= '0' &amp;&amp; fin.peek() &lt;= '7')\n            {\n                fin.get(ch);\n                token_str += ch;\n                decnum &lt;&lt;= 3;\n                decnum += ch - '0';\n            }\n            if (isIdentifierChar(fin.peek()))         //混入了8以上的数字或字母\n            {\n                isInvalidOct = 1;\n            }\n            else\n            {\n                token_str = to_string(decnum);\n            }\n        }\n        else if (isIdentifierChar(fin.peek()))        //invalid oct\n        {\n            isInvalidOct = 1;\n        }\n        else                                        //ZERO\n        {\n            token_str = \"0\";\n        }\n    }\n    else                            //DEC\n    {\n        while (isdigit(fin.peek()))\n        {\n            fin.get(ch);\n            token_str += ch;\n        }\n        if (isIdentifierChar(fin.peek()))    //混入了字母\n        {\n            isInvalidDec = 1;\n        }\n    }\n\n    if (isInvalidHex || isInvalidOct || isInvalidDec) //是非法数字，就把剩下的字母数字读完\n    {\n        while (isIdentifierChar(fin.peek()))\n        {\n            fin.get(ch);\n            token_str += ch;\n        }\n        if (isInvalidHex) printf(\"\\033[1;31mInvalid Hex number at Line %d: %s\\033[0m\\n\", lineno, token_str.c_str());\n        if (isInvalidOct) printf(\"\\033[1;31mInvalid Oct number at Line %d: %s\\033[0m\\n\", lineno, token_str.c_str());\n        if (isInvalidDec) printf(\"\\033[1;31mInvalid Dec number at Line %d: %s\\033[0m\\n\", lineno, token_str.c_str());\n        return false;\n    }\n    else                                               //是合法数字，正常返回\n    {\n        tokens.emplace_back(token_type::NUM, token_str);\n        return true;\n    }\n}\n\nbool Identifier(ifstream &amp;fin)\n{\n    char ch;\n    string st;\n    st = token_str;\n    while (ch = fin.peek(), (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || ch == '_' || ch &gt;= '0' &amp;&amp; ch &lt;= '9')\n    {\n        fin.get(ch);\n        st += ch;\n    }\n\n    if (st == \"int\")\n    {\n        tokens.emplace_back(INT, st);\n    }\n    else if (st == \"void\")\n    {\n        tokens.emplace_back(VOID, st);\n    }\n    else if (st == \"const\")\n    {\n        tokens.emplace_back(CONST, st);\n    }\n    else if (st == \"if\")\n    {\n        tokens.emplace_back(IF, st);\n    }\n    else if (st == \"else\")\n    {\n        tokens.emplace_back(ELSE, st);\n    }\n    else if (st == \"while\")\n    {\n        tokens.emplace_back(WHILE, st);\n    }\n    else if (st == \"break\")\n    {\n        tokens.emplace_back(BREAK, st);\n    }\n    else if (st == \"continue\")\n    {\n        tokens.emplace_back(CONTINUE, st);\n    }\n    else if (st == \"return\")\n    {\n        tokens.emplace_back(RETURN, st);\n    }\n    else\n    {\n        tokens.emplace_back(ID, st);\n    }\n    return 1;\n}\n\nbool Annotation(ifstream &amp;fin)\n{\n    char ch;\n    if (token_str == \"/\")\n    {\n        if (fin.peek() == '/')\n        {\n            while (fin.peek() != EOF)\n            {\n                fin.get(ch);\n                if (ch == '\\n')\n                {\n                    ++lineno;\n                    break;\n                }\n            }\n            if (ch == '\\n' || fin.peek() == EOF) return true;\n            else return false;\n        }\n        else if (fin.peek() == '*')\n        {\n            int lineno2 = lineno;\n            while (fin.peek() != EOF)\n            {\n                fin.get(ch);\n                if (ch == '\\n') ++lineno;\n                if (ch == '*' &amp;&amp; fin.peek() == '/') break;\n            }\n            if (ch == '*' &amp;&amp; fin.peek() == '/')\n            {\n                fin.get(ch);\n                return true;\n            }\n            else\n            {\n                printf(\"\\033[1;31mUnterminated %s comment at line %d.\\033[0m\\n\", \"/*\", lineno2);\n                return false;\n            }\n        }\n        else return false;\n    }\n    else return false;\n}\n\nbool And(ifstream &amp;fin)\n{\n    tokens.emplace_back(AND, \"&amp;&amp;\");\n    if (fin.peek() == '&amp;')\n        return true;\n    else\n    {\n        printf(\"\\033[1;31mInvalid token \\\"&amp;\\\" at Line %d: Do you mean \\\"&amp;&amp;\\\" ?\\033[0m\\n\", lineno);\n        return false;\n    }\n}\n\nbool Or(ifstream &amp;fin)\n{\n    tokens.emplace_back(OR, \"||\");\n    if (fin.peek() == '|')\n        return true;\n    else\n    {\n        printf(\"\\033[1;31mInvalid token \\\"|\\\" at Line %d: Do you mean \\\"||\\\" ?\\033[0m\\n\", lineno);\n        return false;\n    }\n}\n\n#endif //LEXER_H\n\nmain.cppp#include \"lexer.h\"\n\nint main()\n{\n    // read file\n    ifstream fin;\n    fin.open(\"../sample.c\");\n    if (!fin)\n    {\n        cout &lt;&lt; \"File not found\" &lt;&lt; endl;\n        return 0;\n    }\n\n    char ch;\n    while (fin.get(ch))\n    {\n        token_str = move(string(1, ch));\n        switch (ch)\n        {\n            case '\\n':\n                ++lineno;\n                continue;\n            case ' ':\n            case '\\t':\n                continue;\n            case '{':\n                tokens.emplace_back(token_type::LBRACE, \"{\");\n                continue;\n            case '}':\n                tokens.emplace_back(token_type::RBRACE, \"}\");\n                continue;\n            case '(':\n                tokens.emplace_back(token_type::LPARENT, \"(\");\n                continue;\n            case ')':\n                tokens.emplace_back(token_type::RPARENT, \")\");\n                continue;\n            case '[':\n                tokens.emplace_back(token_type::LBRACKET, \"[\");\n                continue;\n            case ']':\n                tokens.emplace_back(token_type::RBRACKET, \"]\");\n                continue;\n            case ';':\n                tokens.emplace_back(token_type::SEMICN, \";\");\n                continue;\n            case ',':\n                tokens.emplace_back(token_type::COMMA, \",\");\n                continue;\n            case '+':\n            case '-':\n                tokens.emplace_back(token_type::PLUSSUB, string(1, ch));\n                continue;\n            case '*':\n            case '%':\n                tokens.emplace_back(token_type::BINOPP, string(1, ch));\n                continue;\n            case '/':\n                if (fin.peek() == '*' || fin.peek() == '/')\n                    Annotation(fin);\n                else\n                    tokens.emplace_back(token_type::BINOPP, string(1, ch));\n                continue;\n            case '!':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"!=\");\n                }\n                else\n                    tokens.emplace_back(token_type::NOT, \"!\");\n                continue;\n            case '&amp;':\n                And(fin);\n                continue;\n            case '|':\n                Or(fin);\n                continue;\n            case '=':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"==\");\n                }\n                else\n                    tokens.emplace_back(token_type::ASSIGN, \"=\");\n                continue;\n            case '&gt;':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"&gt;=\");\n                }\n                else\n                    tokens.emplace_back(token_type::CMP, \"&gt;\");\n                continue;\n            case '&lt;':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"&lt;=\");\n                }\n                else\n                    tokens.emplace_back(token_type::CMP, \"&lt;\");\n                continue;\n            default:\n                if (isdigit(ch))\n                    Number(fin);\n                else if (isalpha(ch) || ch == '_')\n                    Identifier(fin);\n                else if (!Annotation(fin))\n                    printf(\"\\033[1;31mUnexpected character \\\"%c\\\" at Line %d.\\033[0m\\n\", ch, lineno);\n        }\n    }\n\n    for (auto &amp;t: tokens)\n        cout &lt;&lt; token_name[t.first] &lt;&lt; \"\\t\\t\" &lt;&lt; t.second &lt;&lt; endl;\n}\n\n\nTips\nfin是一个文件输入流，我们从中读取需要识别的程序代码\n\n顶层逻辑是读取当前文件指针指向的字符ch，根据ch用switch分配到各个token识别子函数，用子函数读取一个完整的token（一两个字符的token就不设置函数了）\n\n单个和双个字符的token识别已经在顶层中完成，即’\\n’、‘\\t’、空格、所有括号、逗号分号、所有运算符和比较符，可以参照这部分代码 \n\ntoken的数据结构是 vector&lt;pair&lt;token_type,string&gt;&gt;·，其中token_type是一个枚举类型，表示该token的类型；string则是存储该token的内容，一般为其字面值\n\n用tokens.emplace_back(TYPE,Str)添加token，参见switch中的语句\n\n每个token识别函数都会返回一个bool·值来表明该类型的token是否识别成功，如果识别成功则返回true，并需要将相应的token pair添加到tokens；若识别失败则返回false，并给出相应的错误提示.   \n\n错误提示规范：\n printf(“\\033[1;31m【Error Type】 at Line %d：【info】\\033[0m\\n”,lineno);\n 【Error Type】是错误类型；【info】是附加信息，可以省略\n\n注意如果识别失败，将有两种策略\n\n将文件读指针退回去：比如说在识别关键字token的函数Keyword(fin)中发现这其实是一个变量名，那么我们需要将文件指针退回到调用函数之前\n将错就错：对于一些很好理解的错误，我们可以直接帮他进行修复，比如说读入一个’&amp;’结果发现下一个字符不是’&amp;’，很明显是用户少打了，那么我们依然可以采取tokens.emplace_back(AND, \"&amp;&amp;\");，并给出错误提示“Do you mean “&amp;&amp;” ?”（And和Or函数采用的就是这个策略）\n\n\ntoken识别函数可以参照 bool And(ifstream &amp;fin)和bool Or(ifstream &amp;fin)\n\n需要在本地运行时，只需在main.cpp同目录下创建sample.c即可\n\n每个token识别函数的形参都是文件输入流变量fin的引用，主要使用fin的以下三个函数\n\n\n\n\n\n函数\n作用\n\n\n\nfin.get(ch)\n获取文件的下一个字符给ch，并将文件读指针往下移动一位\n\n\nch=fin.peek()\n获取文件的下一个字符给ch，但不移动文件读指针（peek v. 窥视；窥见）\n\n\nfin.seekg(-k, ios::cur)\n将文件读指针回退k位，一般用于读入一连串字符后发现识别失败，那么需要将文件指针退回去\n\n\n\n几个全局变量及其含义\n\n\n\n\n全局变量\n含义\n\n\n\ntoken_name\n通过token_name[token_type] 可以获取token_type的字面字符串（因为枚举类型的本质是整数）\n\n\nlineno\n当前文件读指针的行数，报错时需要显示\n\n\ntokens\n存取所有token pair的vector\n\n\ntoken_str\n存取当前token的字符串值，一方面根据该变量的长度可以确定回退位数，另一方面作为token的内容   ⚠️读入的第一个字符会存在这个变量中\n\n\n\n实现的token识别函数\n\n\n\n\n函数名\n识别对象\n备注\n\n\n\nNumber\n八进制、十进制、十六进制\ntoken.emplace_back(token_type::NUM,转成十进制数值后的字符串)需要具备识别非法数值的能力\n\n\nIdentifier\n变量名\ntoken.emplace_back(token_type::ID,变量名)⚠️重复的变量名不添加\n\n\nKeyword\n关键字\ntoken.emplace_back(token_type::关键字相应的TYPE,关键字字符串)\n\n\nAnnotation\n注释\n无需生成token，两类注释：1.//···\\n 2./*···*/\n\n\n\n\n\nSample.cint main()\n{\n    int abc = 0123;\n    const 123abc;\n    if(xxx != yyy)\n    {\n        _do_something(); //wow\n    }\n    else if(xxx / yyy == zzz)\n    {\n        _hello_world_123() //haha\n    }\n    else\n    {\n        HAhaHa0000__ = 3;\n    }\n    void hello0 =0world;\n    while(1)\n    {\n        i = i-1;\n        if(0+1==2)    break;\n        else        continue;\n    }\n    /*\n        qwertyuiop;\n        HAHAHAHAH;\n        aaaaaaaaaaaaaaaaaa;\n        return 0;\n    */\n    intvoidconstbreakwhilecontinueifelse;\n    return 0xff; /**/\n}\n/*\n * sdadsdda/*/","slug":"Lexer（Ver-Hand）","date":"2022-05-29T16:39:19.000Z","categories_index":"编译原理","tags_index":"走码观花,C＋＋","author_index":"Starlit Rover"},{"id":"27d8ddbd7db795b00aa745f14f40ef75","title":"Apply ANN in MNIST","content":"看完了3Blue1Brown的神经网络三部曲，感觉眼睛明亮了，内心更通透了，手指控制不住地就开始跳动。\n接下来请欣赏寿司神经网络——手写数字集MNIST登场！\nimport numpy as np\nimport pandas as pd\nimport joblib as jb\n\n\n激活函数及导数定义def Activater(x,option='sigmoid'):\n    if option=='relu':\n        return np.maximum(0,x)\n    elif option=='sigmoid':\n        return 1/(1+np.exp(-x))\n    else:\n        print(\"WRONG TYPE!!!\")\n        exit(0)\n\n\n\ndef Derivative(x,option='sigmoid'):\n    if option=='relu':\n        x[x&gt;0] = 1\n        x[x&lt;=0] = 0\n        return x\n    elif option=='sigmoid':\n        return np.exp(-x)/((1+np.exp(-x))**2)\n    else:\n        print(\"WRONG TYPE!!!\")\n        exit(0)\n\n\n\n前向传播def forward_propagation(X, W, b, option='sigmoid'):\n    Z = []\n    A = [X]\n    for i in range(len(W)):\n        Z.append(np.dot(W[i], A[i]) + b[i])\n        A.append(Activater(Z[i],option))\n    return Z, A\n\n\n反向传播def backward_propagation(Y, Z, A, W, b, option='sigmoid'):\n    dZ = [[] for i in range(len(Z))]\n    dW = [np.zeros(W[i].shape) for i in range(len(W))]\n    db = [[] for i in range(len(b))]\n    dA = [[] for i in range(len(A)-1)]\n    dA[-1] = 2*(A[-1] - Y)\n    for i in range(len(W) - 1, -1, -1):\n        dZ[i] = dA[i] * Derivative(Z[i],option)\n        for j in range(dZ[i].shape[1]):\n            dW[i] += dZ[i][:,j:(j+1)].dot(A[i][:,j:(j+1)].T)\n        dW[i] /= dZ[i].shape[1]\n        db[i] = np.sum(dZ[i], axis=1, keepdims=True) / dZ[i].shape[1]\n        if i&gt;0:\n            dA[i-1] = np.dot(W[i].T, dZ[i])\n    return dW, db\n\n误差函数\n反向传播链式法则\n\n\n\ndef update_parameters(W, b, dW, db, learning_rate=1e-3):\n    W = [W[i] - learning_rate * dW[i] for i in range(len(W))]\n    b = [b[i] - learning_rate * db[i] for i in range(len(b))]\n    return W, b\n\ndef Train(X, Y, W, b, epochs=300, option='sigmoid'):\n    print(\"Training...\")\n    sum_10epoches=0\n    for i in range(epochs):\n        sum=0\n        for j in range(len(X)):\n            Z, A = forward_propagation(X[j], W, b, option)\n            sum += np.sum(np.square(A[-1]-Y[j]))\n            dW, db = backward_propagation(Y[j], Z, A, W, b, option)\n            W, b = update_parameters(W, b, dW, db)\n\n        sum_10epoches += sum/len(X)\n        if (i+1) % 10 == 0:\n            print(\"Epoch %d DONE , average loss: %f\"%((i+1), sum_10epoches/10))\n            sum_10epoches = 0\n            # save outcome\n            jb.dump(W, 'weight.pkl')\n            jb.dump(b, 'b.pkl')\n\n    return W, b\n\n\n预测函数def predict(X, W, b, option='sigmoid'):\n    Z, A = forward_propagation(X, W, b, option)\n    return [np.argmax(A[-1][:,i]) for i in range(A[-1].shape[1])]\n\n指定每层神经元个数，并初始化权重W和bias# intialize W &amp; b\nlayers_dims = [784,100,16,10]\nW=[]\nb=[]\n# He initialization\nfor i in range(1,len(layers_dims)):\n    W.append(np.random.randn(layers_dims[i], layers_dims[i - 1]) * np.sqrt(2 / layers_dims[i - 1]))\n    b.append(np.zeros((layers_dims[i], 1)))\n\nTrain！# Train\ndata=pd.read_csv(\"../input/ml2021-2022-2-nn/train.csv\")\ntrain=np.array(data.iloc[:,1:]) / 255\nlabel=data.iloc[:,0]\nbatches=[]\nbatch_size=10\nvals=[]\nfor i in range(0,int(data.shape[0]/batch_size)):\n    batches.append(train[i*batch_size:(i+1)*batch_size].T)\n    vals.append(np.zeros((layers_dims[-1],batch_size)))\n    for j in range(batch_size):\n        vals[i][label[i*batch_size+j],j]=1\n\nW,b=Train(batches,vals,W,b)\n\nTraining...\nEpoch 10 DONE , average loss: 9.178379\nEpoch 20 DONE , average loss: 8.475545\nEpoch 30 DONE , average loss: 7.614375\nEpoch 40 DONE , average loss: 6.724141\nEpoch 50 DONE , average loss: 5.594986\nEpoch 60 DONE , average loss: 4.538067\nEpoch 70 DONE , average loss: 3.720301\nEpoch 80 DONE , average loss: 3.125564\nEpoch 90 DONE , average loss: 2.718955\nEpoch 100 DONE , average loss: 2.435576\nEpoch 110 DONE , average loss: 2.230198\nEpoch 120 DONE , average loss: 2.075574\nEpoch 130 DONE , average loss: 1.954850\nEpoch 140 DONE , average loss: 1.857425\nEpoch 150 DONE , average loss: 1.776534\nEpoch 160 DONE , average loss: 1.707753\nEpoch 170 DONE , average loss: 1.648106\nEpoch 180 DONE , average loss: 1.595520\nEpoch 190 DONE , average loss: 1.548511\nEpoch 200 DONE , average loss: 1.505992\nEpoch 210 DONE , average loss: 1.467156\nEpoch 220 DONE , average loss: 1.431390\nEpoch 230 DONE , average loss: 1.398221\nEpoch 240 DONE , average loss: 1.367273\nEpoch 250 DONE , average loss: 1.338241\nEpoch 260 DONE , average loss: 1.310877\nEpoch 270 DONE , average loss: 1.284973\nEpoch 280 DONE , average loss: 1.260356\nEpoch 290 DONE , average loss: 1.236881\nEpoch 300 DONE , average loss: 1.214426\n\nPredict !!# predict\ntest=np.array(pd.read_csv(\"../input/ml2021-2022-2-nn/test.csv\")).T / 255\npre_otc=predict(test,W,b,'sigmoid')\nsub=np.array([range(test.shape[1]),pre_otc]).T\nsub=pd.DataFrame(sub,columns=['id','label'])\nsub.to_csv('submission.csv',index=False, header=True)\n","slug":"Apply-ANN-in-MNIST","date":"2022-05-20T03:44:06.000Z","categories_index":"Machine Learning","tags_index":"python,走码观花,ANN","author_index":"Starlit Rover"},{"id":"0ec694a906049225d6d529b78f724448","title":"<10> NO Left Recursion","content":"本文介绍消除文法左递归的算法，并输出新文法产生式。\n\n\n\n\n\n\n\n消除左递归在语法分析阶段是比较重要的一个过程，尤其在自顶向下的分析过程中，编译器会尝试各个推导式，如果存在左递归，那么推导过程将会用永无止境。\n比较显式的左递归我们称之为直接左递归，比如说\n\n其中表示非空的表达式，表示不以非终结符A开头的表达式。\n那么我们知道对于非终结符A来说，最终只能以到来结束，否则依然会含有非终结符A，因此我们可以将文法直接改为\n\n然而并非所有的左递归都这么显而易见，还是会存在很多间接左递归\n\n那么我们就需要一个通用的算法来消除所有的直接左递归和间接左递归。\n\n⫸ Algorithm算法也不难理解，大致流程如下：\n\n将所有非终结符先进行整理编号，即所有非终结符转换为\n\n\n对每一个，我们将其所有满足的产生式替换为，其中\n\n从开始至，依次执行步骤2，每完成一个的替换就消除当前该的所有直接左递归\n\n\n该算法的伪代码如下图所示：\n\n\n我们可以注意到，每一个完成替换后，那么所有产生式右边的第一个符号要么是终结符，要么是编号的非终结符，在消除此时产生式中的直接左递归后，就只剩下终结符和编号非终结符打头的右部了。这样一来，最终的文法一方面不可能有直接左递归，另一方面不可能有间接左递归（因为只能小编号的非终结符推出大编号的非终结符）。\n\nC ☺ D Efrom copy import deepcopy\n\nn = eval(input('请输入文法产生式的个数：'))\nprint('请输入文法产生式：')\ngen = dict()\nleft = dict()\nnum = 0\nfor i in range(n):\n    g = input().replace(' ', '')\n    assert g[1:3] == '-&gt;'\n    gen.setdefault(g[0], [[], []])\n    left[g[0]] = num\n    num += 1\n    start = 3\n    for i in range(3, len(g)):\n        if g[i] == '|' or i == len(g) - 1:\n            i += (1 if i == len(g) - 1 else 0)\n            assert start &lt; i\n            if g[0].isupper():\n                gen[g[0]][0].append(g[start:i])\n            elif g[0].islower():\n                gen[g[0]][1].append(g[start:i])\n            start = i + 1\n\n# 将没有出现在产生式左部的非终结符当作终结符\nfor key in gen:\n    nonterminal = deepcopy(gen[key][0])\n    for item in nonterminal:\n        if item[0] not in left.keys():\n            gen[key][0].remove(item)\n            gen[key][1].append(item)\n    assert gen[key][1] != []\n\n# 替换Ai-&gt;Ajβ (j&lt;i)\nmore_gen = dict()\nfor key in gen:\n    rmv = []\n    for item in gen[key][0]:\n        if left[item[0]] &lt; left[key]:\n            rmv.append(item)\n            for k in gen[item[0]][1]:\n                gen[key][1].append(k + item[1:])\n            for k in gen[item[0]][0]:\n                gen[key][0].append(k + item[1:])\n    for r in rmv:\n        gen[key][0].remove(r)\n\n   # 消除直接左递归\n    nonterminal = deepcopy(gen[key][0])\n    flag = True\n    terminal = deepcopy(gen[key][1])\n    for item in nonterminal:\n        if item[0] == key:\n            sym = '[' + key + '\\']'\n            more_gen.setdefault(sym, []).extend([item[1:], (item[1:]) + sym])\n            if flag:\n                for k in terminal:\n                    gen[key][1].append(k + sym)\n            gen[key][0].remove(item)\n            flag = False\n\nfor key in gen:\n    gen[key][0].extend(gen[key][1])\n    gen[key] = gen[key][0]\ngen.update(more_gen)\n\nprint(\"\\nAfter Remove Left Recursion:\")\nfor key in gen:\n    print(key + ' -&gt; ', end='')\n    print(*gen[key], sep=' | ')\n\n➷ Tips\n读入输入时先除去所有空格，并规定终结符和非终结符仅能为单个字母，小写字母代表终结符，大写字母代表非终结符\n\n所有产生式用一个字典存储，每个产生式左边的非终结符作为键值，每个键值对应一个列表，列表里有两个子列表（见3）\n\n对每一个产生式的右部进行分类，非终结符打头的一类，终结符打头的一类\n\n这里将没有出现在产生式左部的非终结符当作终结符，从而无需对这些非终结符进行编号\n⚠️ Python中可迭代对象的直接赋值是引用，复制赋值则需要deepcopy()\n\n\n\nOutcome\n","slug":"10-NO-Left-Recursion","date":"2022-05-17T07:58:36.000Z","categories_index":"编译原理","tags_index":"python,走码观花","author_index":"Starlit Rover"},{"id":"876685c2961fc61a4c5638eee32e520e","title":"<01> NFA2DFA","content":"本文借助Graphviz库实现了NFA转DFA，并输出DFA的状态转移图。\n\n\n\n\n\n\n\n∅ Graphviz库介绍你一定很疑惑我昨天刚介绍完Transitions库今天怎么就就换了一个绘制库。ummm…Transitions库其实更注重于状态机本身的实现，当你想用状态机来实现某些功能时，Transitions库是一个很好的选择，而绘制状态转移图只是其中的一个子功能，更重要的是无法（我不知道可不可以）显示多个接收状态（GraphMachine中的initial选项只能指定一个节点）。追根溯源，我们不难发现Transitions库其实是用Graphviz库来绘制状态转移图的，那我们为何不直接用它来绘制呢？\n还是直接用一个简单直观的栗子来说明，\nfrom graphviz import Digraph\n\n# Graph()--Undirected Graph ; Digraph()--Directed Graph\n# engine: choose layout patterns\nDot = Digraph(engine='circo')\n# add nodes: you can specify color and shape of nodes\nDot.node('A')\nDot.node('B', style='filled', fillcolor='red', shape='circle')\nDot.node('C', style='filled', fillcolor='green', shape='rectangle')\n# add single edge: (source,destination,label)\nDot.edge('A', 'B', 'Hello')\nDot.edge('B', 'A', 'Hola')\nDot.edge('C', 'B', 'Bye')\n# add edges\nDot.edges(['AC', 'BC'])\n# specify save format\nDot.format = 'png'\n# save output\nDot.render('First Demo', view=True)\n\n输出除了有点ugly有点重合外其实也还好，至少可以自己指定颜色和形状：\n\n初始化的时候可以指定渲染引擎，常见的渲染引擎有\n\nDot：默认引擎，主要用于有向图。布局算法将边缘指向相同方向（从上到下或从左到右），然后尝试避免边缘交叉并减少边长。\nNeato：这是一种“弹簧模型”的布局，基于spring-model（namely force-based）算法，输出缺乏方向性。\nFdp：这是一种类似于neato的布局，是通过减少力而不是使用能量来实现的，多用于无向图。\nSfdp：渲染大型图，缺乏方向性。\nTwopi：放射性布局，节点根据它们与给定根节点的距离放置在同心圆上。\nCirco：适合绘制某些多循环结构的图表，例如某些电信网络。\n\n有兴趣进一步了解可以参阅官方文档。\n\nℵ NFA 2 DFADFA具有确定性，无ε边，所有状态对于每一个输入字符都有唯一的跳转方向。显然，DFA的每一个状态都是若干个NFA状态的集合。\n基本算法思想如下：\n\n先求出NFA中每一个状态的（可以通过ε边到达的状态集，包括自己）并确定输入字符集（可能出现的字符）；\n\n将开始状态的放入待更新状态集和历史状态集；\n\n从待更新状态集里取出一个状态，计算读入每一个字符（）时跳转到的目的状态\n\n其中表示NFA中状态读入字符后跳转到的状态；\n\n若目的状态未出现在历史状态中，那么将其加入待更新状态列表，同时加入历史状态集。每次都从待更新状态集中取出一个状态重复上述步骤，直至待更新状态集为空。\n\n\n\n\n可以参阅这一个例子：Converting an NFA to a DFA - Example\n\nC☺DEfrom graphviz import Digraph\n\nnum = eval(input('请输入状态转移函数的个数：'))\nstart = input('请输入初始状态序号：')\n# end is a list\nend = set(input('请输入所有接收状态序号：').split())\nsymbols = set()\n# transfer[sym][source]=dest ⇔ (source)--sym--&gt;(dest)\ntransfer = dict()\nclosure = dict()\nprint('请依次输入【trigger】【source】【destination】:')\nfor i in range(num):\n    a, b, c = input().split()\n    closure.setdefault(b, {b})\n    closure.setdefault(c, {c})  # 防止终结节点没有入度\n    # '#' is equivalent with 'ε'\n    if a != '#':\n        symbols.add(a)\n        transfer.setdefault(a, dict()).setdefault(b, {c}).add(c)\n    else:\n        closure[b].add(c)\n\n# 上述代码得到的closure只是邻接ε节点，还需要迭代计算真正的ε-closure\nfor state in closure:\n    upd = closure[state]\n    # upd是每一轮新增节点的集合\n    # 当upd不为空时需要继续迭代更新\n    while upd:\n        closure[state] |= upd\n        nxt = set()\n        for n in upd:\n            nxt |= closure[n]\n        upd = nxt - closure[state]\n\n# 历史状态集\nDFA_states = [closure[start]]\n# 待更新状态集\nto_update = [closure[start]]\ntransitions = []\nwhile to_update:\n    status = to_update.pop()\n    # status的状态转移列表\n    single_trans = []\n    for sym in symbols:\n        new = set()\n        tmp = set()\n        for s in status:\n            tmp |= transfer[sym].setdefault(s, set())\n        for s in tmp:\n            new |= closure[s]\n        if new not in DFA_states:\n            to_update.append(new)\n            DFA_states.append(new)\n        # 将具有相同source和dest的有向边label进行合并\n        flag = True\n        for t in single_trans:\n            if t[2] == str(new):\n                t[0] = t[0] + '|' + sym\n                flag = False\n                break\n        if flag:\n            single_trans.append([sym, str(status), str(new)])\n\n    transitions.extend(single_trans)\n\nDFA = Digraph(engine='dot')\nDFA.edge('start', str(DFA_states[0]))\nfor n in DFA_states:\n    if n &amp; end:\n        DFA.node(str(n), style='filled', fillcolor='green', shape='rectangle')\n    else:\n        DFA.node(str(n), shape='rectangle')\nfor t in transitions:\n    DFA.edge(t[1], t[2], label=t[0])\nDFA.format = 'png'\nDFA.render('DFA', view=True)\n\n\n≯ INPUT我们就用上一篇文章中最后的DEMO来作为输入，其中【#】代表ε：\n请输入状态转移函数的个数：23\n请输入初始状态序号：6\n请输入所有接收状态序号：17\n请依次输入【trigger】【source】【destination】:\na 0 1\na 2 3\n# 1 2\nb 4 5\n# 6 4\n# 6 0\n# 5 7\n# 3 7\n# 6 7\n# 7 6\na 8 9\n# 7 8\na 10 11\nb 12 13\nb 14 15\n# 13 14\n# 16 12\n# 16 10\n# 15 17\n# 11 17\n# 16 17\n# 17 16\n# 9 16\n\n\n\n\n\n≮ OUTPUT\n\n上图中的set()其实是空集，可以看到一旦到达空集状态就无法再出去，以至于永远无法被接收，因此我们也称之为陷阱（trap）。另外接收状态全部用绿色标注出来了，非常清晰明了。\n\n「Reference」\n[1] Graphviz入门，https://www.cnblogs.com/born2run/p/9581386.html\n[2] 探索Graphviz，https://zhuanlan.zhihu.com/p/81853828\n\n","slug":"01-NFA2DFA","date":"2022-05-11T03:07:43.000Z","categories_index":"编译原理","tags_index":"python,走码观花","author_index":"Starlit Rover"},{"id":"6fcdc9dd323137269ea9dcabb8b1efc8","title":"<00> REG2NFA","content":"本文借助transitions库基于逆波兰表示法（Reverse Polish Notation，RPN）实现了正则表达式转NFA，并画出相关的状态转移图。\n\n\n\n\n\n\n\n∅ Transitions库介绍引用官网中的一句话“They say a good example is worth 100 pages of API documentation, a million directives, or a thousand words.”\nHere is an example:\nfrom transitions.extensions import GraphMachine\n\n# The states\nstates = ['solid', 'liquid', 'gas', 'plasma']\n\n# The transitions\ntransitions = [\n                {'trigger': 'melt', 'source': 'solid', 'dest': 'liquid'},\n                ['evaporate', 'liquid', 'gas'],\n                ['sublimate', 'solid', 'gas']\n              ]\n\n# Initialize\nmachine = GraphMachine(states=states, transitions=transitions, initial='liquid', title='my STD')\nmachine.add_transition('ionize', 'gas', 'plasma')\nmachine.get_graph().draw('my_state_diagram.png', prog='dot')\n\nHere is the output:\n\n\n上面的栗子基本包含了本文所用到的所有操作，另外说明几点：\n\ntransitions列表中既可以是字典，也可以是列表，甚至是两者的结合，但都需要按照[trigger , source , destination]的顺序写\nadd_transition()函数增加转移函数，输入参数也需要按照上述顺序\nGraphMachine函数中的initial参数指定初始状态，并标注为不同的颜色，然而我们在画状态转移图时标注的往往不是初始状态而是接收状态，因此我一般将initial参数赋为接收状态\n更多使用方式请参见transitions/README.md\n\n\n∇ 逆波兰表示法RPN逆波兰表示法，是一种是由波兰数学家扬·武卡谢维奇于1920年引入的数学表达式形式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。\n比如说\n$$5\\ +\\ ((1\\ +\\ 2)\\ \\ 4)\\ -\\ 3\\  ==\\mathbf{RPN}=⇒\\ 5\\ 1\\ 2\\ +\\ 4\\ \\ +\\ 3\\ -$$\n首先阐述一下逆波兰表达式是如何得到的，我们采取如下算法：\n\n需要两个栈，一个存数，一个存符号，下面分别称之为数栈和符号栈\n\n顺序读入中缀表达式（正常的运算式）\n\n遇到数（完整的数，不是逐位）时压入数栈\n\n遇到运算符时，首先从符号栈栈顶开始检查，如果栈顶符号优先级&gt;(=)读入运算符，则将栈顶符号弹出压入数栈中，然后检查符号栈下一个符号，循环往复，直到符号栈栈顶符号优先级&lt;读入运算符时，将读入运算符压入符号栈\n⚠️由于运算符基本是左结合的，因此我们可以认为左边（符号栈内）的运算符优先级&gt;右边（读入）的同级运算符\n\n当读入【(】时，直接压入符号栈，且只有读入【)】时才可以弹出\n\n当读入【)】时，将符号栈内的符号依次弹出压入数栈，直到遇到第一个【(】，注意【(】直接弹出不压入数栈\n\n读完运算式后，依次弹出符号栈并压入数栈，那么数栈【栈底→栈顶】即为逆波兰表达式\n\n\n那么逆波兰表达式有什么优点呢，既然是关于运算式的那必然涉及到计算。对于逆波兰表达式，我们只需顺序读入，遇到数字压入栈中，遇到运算符则弹出栈顶的两个数字直接计算再压入栈中，最终的栈里只会剩余一个数，即为运算结果。\n$$$\\ 5\\ 1\\ 2\\ +\\ 4\\ \\ +\\ 3\\ -→ \\ 5\\ 3\\ $\\ 4\\ \\ +\\ 3\\ -→ \\ 5\\ \\ 12\\ $+\\ 3\\ -→ \\ 17\\ $3\\ -→ 14$ $$\n\nℵ Regular Expression 2 NFA这里的正则表达式我们认为仅有三种符号：Kleene闭包【*】，连接运算符【·】（一般省略），或运算符【｜】（三者的优先级依次降低）。那么正则表达式转为NFA的规则基本可以由下图概括，\n\n\n\n\n基本思想是先将正则表达式转为逆波兰表达式，然后用开始节点和最终节点的编号对[start node num , end node num]来表示正则表达式的运算结果，在用逆波兰表达式计算的同时生成列表transitions，最后绘制相应的状态转移图。\n\nC☺DEfrom transitions.extensions import GraphMachine\n\nrpn = []\npriority = {'|': 0, '*': 2, '.': 1, '(': -1}\n\n# 补全正则表达式的连接运算符\ndef dotREG(s):\n    i = 1\n    while i &lt; len(s):\n        if s[i].islower() or s[i] == '(':\n            if s[i - 1] == '*' or s[i - 1].islower() or s[i - 1] == ')':\n                s = s[:i] + '.' + s[i:]\n                i += 1\n        i += 1\n    return s\n\n# 计算正则表达式的逆波兰表达式rpn\ndef REG2RPN(r):\n    global rpn\n    i = 0\n    ops = []\n    while i &lt; len(r):\n        if r[i].islower():\n            rpn.append(r[i])\n        elif r[i] in ['.', '|', '*']:\n            while ops:\n                if priority[ops[-1]] &gt;= priority[r[i]]:\n                    rpn.append(ops.pop())\n                else:\n                    break\n            ops.append(r[i])\n        elif r[i] == '(':\n            ops.append('(')\n        elif r[i] == ')':\n            while ops[-1] != '(':\n                rpn.append(ops.pop())\n            ops.pop()\n        i += 1\n\n    while ops:\n        rpn.append(ops.pop())\n\n\nr = input(\"Input regular expression: \")\nr = dotREG(r)\nREG2RPN(r)\nstatus = 0\ncrt_stt = []\ntransitions = []\nfor i in range(len(rpn)):\n    if rpn[i].islower():\n        crt_stt.append([status, status + 1])\n        transitions.append([rpn[i], str(status), str(status + 1)])\n        status += 2\n    elif rpn[i] == '*':\n        transitions.append(['ε', str(crt_stt[-1][0]), str(crt_stt[-1][1])])\n        transitions.append(['ε', str(crt_stt[-1][1]), str(crt_stt[-1][0])])\n    elif rpn[i] == '.':\n        stt1 = crt_stt.pop()\n        stt2 = crt_stt.pop()\n        transitions.append(['ε', str(stt2[1]), str(stt1[0])])\n        crt_stt.append([stt2[0], stt1[1]])\n    elif rpn[i] == '|':\n        stt1 = crt_stt.pop()\n        stt2 = crt_stt.pop()\n        crt_stt.append([status, status + 1])\n        transitions.append(['ε', str(status), str(stt1[0])])\n        transitions.append(['ε', str(status), str(stt2[0])])\n        transitions.append(['ε', str(stt1[1]), str(status + 1)])\n        transitions.append(['ε', str(stt2[1]), str(status + 1)])\n        status += 2\n\ntransitions.append(['ε', 'start', str(crt_stt[0][0])])\nstates = list(map(str, range(status))).append('start')\n\nNFA = GraphMachine(states=states,\n                   transitions=transitions,\n                   initial=str(crt_stt[0][1]), title='REG2NFA')\nNFA.get_graph().draw('REG2NFA.png', prog='dot')\n\n⊈ Few Tips\n虽然【(】的优先级最高，但由于【(】在遇到【)】之前不能弹出，因此我们将其优先级置为最低 \npython的list自带pop()函数，不仅弹出最后一个元素，同时返回其值，这与C++的&lt;stack&gt;不同\nNFA起点是’start’，接收状态为序号最大的状态，颜色与其他状态不同\nrpn为数栈，ops为符号栈\n\n(aa|b)*a(a|bb)*\n\n\n\n\n\n\n「Reference」\n逆波兰表示法. (2021, September 24). Retrieved from 维基百科, 自由的百科全书\n\n","slug":"00-REG2NFA","date":"2022-05-09T15:49:12.000Z","categories_index":"编译原理","tags_index":"python,走码观花","author_index":"Starlit Rover"},{"id":"4eb946cc0edf20ceda9a686ce0927f5a","title":"YOLOv5说明书","content":"YOLO 的全称是 You Only Look Once，指只需要浏览一次就可以识别出图中的物体的类别和位置。YOLOv5 是由 Ultralytics LLC 公司于 2020 年 5 月所提出，其图像推理速度最快达 0.007 s，即每秒可处理 140 帧，满足视频图像实时检测需求，同时结构更为小巧。\n本文介绍YOLOv5的打开方式及一些注意事项。\n\n\n\n\n\n\n\n⨇ Preface五一前参加了一个名叫泰迪杯的比赛，名字听着像个野鸡比赛，其实是个机器学习比赛，也办了挺多届。这学期有选机器学习（大半个学期过去了，我只会KNN和逻辑斯蒂回归）和数据挖掘（老师讲的挺认真，但我经常上课mo鱼），因此就和同学报名参加了。\n我们选择的是农田害虫识别赛题，顾名思义，就是给出害虫照片集与相应的害虫标签及位置框坐标，需要我们训练模型来识别图片中的害虫位置与种类。第一次参加机器学习比赛，没什么经验，基础也不太行，所以我们主要的时间都花在数据集处理上面了。训练模型直接采用了比赛培训中讲的YOLOv5，在浏览了大量博客之后算是上手了，本文就分享一下使用方式以及一些tips。\n\n\n\n⚠️下文中所有的相对路径都默认在下载的文件夹yolov5/下\n\n\n\nΩ\n首先从github上将这个官方仓库clone下来（或直接在官网Code→Download zip）\ngit clone https://github.com/ultralytics/yolov5.git\n\n速度太慢的话就用镜像\ngit clone https://gitee.com/monkeycc/yolov5.git\n\n在下载的文件夹中打开terminal，安装运行环境所需要的依赖包\npip install -r requirements.txt\n\n创建训练配置文件：data/*.yaml ，格式示例如下\n# path of training and validation set\ntrain: dataset/images/train\nval: dataset/images/val\n\n# Classes\nnc: 8  # number of classes\nnames: ['6','apple','7','dog','cat','485','pear','673'] \n\n\ntrain和val是训练集和验证集（自行划分）的图片文件夹目录，相对路径和绝对路径均可\nnc是类数，names则是包含所有类名的列表\n\n\n使用预训练权重可以缩短训练时间，并提高训练精度，预训练规模越大，训练精度相对更高，但检测时间更长.\n 在此下载预训练权重，并将下载的pt文件置于models/下，一般选择yolov5s.pt即可，权重大小即代表了权重规模\n\n\n下载的预训练权重为yolov5*.pt，那么就修改相对应的models/yolov5*.yaml文件，只需将其中的nc改为你自己的类数即可\n\n训练数据集一般存放于dataset/，且dataset的文件树结构需要如下所示\ndataset\n├── images\n│   ├── train\n│   └── val\n└── labels\n    ├── train\n    └── val\n\n\ndataset下分为两个文件夹images/和labels/，前者存放图像，后者存放每张图像的txt文件\n\ntxt中存放图片中含有的类别和相应的方框坐标，格式为\nclass_num box中心横坐标与图像宽度比值 box中心纵坐标与图像高度比值 box宽度与图像宽度比值 box高度与图像高度比值\n\n\nclass_num是【3】中yaml文件里的names索引（从0开始计数），如class_num=2，那么表示的就是‘7’\n\n坐标的原点在图像的左上角，向右是轴正方向，向下是轴正方向，坐标单位是像素\n\n，后面四个值均\n\n一个识别目标一行，若该图片中没有目标则为空即可\n\n\n\nimages/和labels/下又分别含有两个文件夹，训练集train/和验证集val/\n\nimages/train/和labels/train/，images/val/和labels/val/ 下的文件除后缀外数量和文件名必须完全一致，即图片和txt必须一一对应（没有目标也必须有相应的txt），否则训练时会报错\n\n\n\n如果想手动画框并生成YOLO格式的txt，可以使用labelimg工具\npip install labelimg\n\n安装完成后直接在terminal中输入labelimg即可使用（注意使用时先将【PascalVOC】格式 改为【YOLO】格式）\n\ntrain.py是训练代码，其中只需修改parse_opt(known=False) 函数的定义部分\n\n--weights部分是预训练权重的地址，也可以选择上一次训练中效果最好的权重：runs/train/exp/weights/best.pt\n\n--cfg是【3】中的yaml文件地址\n\n--data是【5】中的yaml文件地址\n\n--epochs可以设置训练的轮数，一般设置300轮较为合适\n\n--resume将default改为True可以继续上一次未完成的训练（如果前一次训练意外中断或者人为终止），此时将忽略--weights设置的预训练权重\n\n其他一般无需修改\n\n\n\n用训练权重来识别图片（一般将需要识别的图片放置在data/images/下）\n\n生成识别结果的图片和txt\npython detect.py --weights path_weight --source path_images --device cpu --save-txt\n\n仅生成识别结果图片\npython detect.py --weights path_weight --source path_iamges --device cpu --img 640\n\n其中path_weight是权重的地址，path_images是识别图片所在文件夹地址\n\n如果可以调用GPU，请将--device cpu去掉\n\nExp：\npython detect.py --weights runs/train/exp13/weights/best.pt --source data/images/ --device cpu --save-txt\n\n\nruns/train/下存放着每一次的训练结果；runs/detect/下存放着每一次的识别结果. exp表示第次结果.\n\n\n\n⚡︎ training ⚡︎\n\n\n\n≫ Outcome ≪","slug":"Yolov5说明书","date":"2022-05-07T03:54:21.000Z","categories_index":"Machine Learning","tags_index":"python,走码观花","author_index":"Starlit Rover"},{"id":"1ebcc2044e1859de323771c4cf459a30","title":"Bison^Flex=语法分析生成中","content":"上古时代的时候（前一段时间参加了些些小竞赛，状态有点迷糊，五一又浪里个浪，所以…虽迟但到！），我们有讲解过借助Flex实现SysY词法分析。词法分析是编译的第一阶段，仅仅只是将代码进行切块归类，得到的只是些零散的tokens。现在我们进入第二阶段，对这些token进行整理排序，以便后面可以方便地解读每句code的含义，即语义分析——构建抽象语法树AST。\n本文将阐述如何使用Bison联合Flex来生成语法分析器，并输出抽象语法树。\n\n\n\n抽象语法树用树的数据结构将token们进行关联，非常抽象地展现了整体与部分的关系，就好似为一句话断句，使其结构一览无余。既然要为代码块进行“断句”，那么我们势必需要先清楚代码块拥有哪些结构层次。但结构层次并不是死板的，例如英语中正常的句子结构都是主谓宾，但并不是所有句子只有这种模式，句子中还可以有状语、补语等。代码也是如此，那么如何来描述一种编程语言所有可能的结构层次呢，就是所谓的文法。\n\n\n栗子胜千言，例如下面这个简单的文法\nS → aSb | aAb\nA → bAa | ba\n\n其中是开始符号，即文法推导中的第一个非终结符，也就是说这个文法描述的所有句子都可以由推导而来。一般大写字母表示的都是非终结符，即还可以继续推导的符号，小写字母就相对应的终结符。那么很显然，这个文法描述的所有句子可以用集合来表示。\n可以看到有限的推导式足以描述无穷的句子，但这些句子是具有一定语法规则的。而一种编程语言本身就是一些具有特定语法规则的句子，因此也可以用一个文法来表示，只不过推导式的数量稍微多了亿些。\n在不借助任何工具的情况下，要实现一个语法分析器就会有两种思路，其一是自底向上，就是将读入的token不断归约（推导的逆过程）为非终结符，直到剩下开始符号；另一种则是自顶向下，即从开始符号找到生成当前代码的推导过程，这里其实就是选择哪一条产生式的问题。两种思路本质上就是选择树的根还是叶子结点作为分析的起点来考虑的，但这并不是本文的重点，你只需知道Bison生成的语法分析器代码采用的是自底向上的思路，而我们只要提供给Bison相应的文法即可得到该文法对应语言的语法分析器。\n不过，带着一点语法分析原理的学习来阅读本文体验会更好哦\n\nGNU Bison是一款用于自动生成语法分析器的程序，基于并兼容yacc，可用于所有常见的操作系统。Bison把LALR形式的上下文无关文法描述转换为可做语法分析的C或C++程序。\nBison的输入文件*.y的基本格式如下，使用者需要将文法的一些基本信息写入该文件\n%start CompUnit\n%expect 1\n\n%{\n    #include \"parser.h\"\n    ...\n%}\n\n%union\n{\n    int     num;\n    char*   str;\n}\n\n/*声明Flex产生的token有三种格式，其中&lt;type&gt;不是必须的*/\n%token &lt;type1&gt; tokens1 /*类型为type1的token们*/\n%right &lt;type2&gt; tokens2 /*类型为type2的右结合token们*/\n%left &lt;type3&gt; tokens3  /*类型为type3的左结合token们*/\n\n/*声明非终结符的类型*/\n%type&lt;num&gt; Number CompUnit Decl ...\n\n%%\n/*Grammar Productions and Corresponding Actions*/\nCompUnit:       CompUnit Decl                     {$$=$1+$2;}\n                | CompUnit FuncDef                {$$=$1-$2;}\nDecl:           ConstDecl    %prec    token3      {$$=$1*10;}\n                | /*ε*/                                {}\n...\n%%\n\nint main()\n{\n    yyparse();\n    ...\n}\n\n\n第一句%start ...是声明文法的开始符号，后面紧跟一个非终结符\n\n%expect n表示你知道这个文法中存在n个移入/归约冲突（在某一个时刻既可以选择归约为非终结符也可以选择读入下一个token），并且认同Bison默认的处理方式，那么在生成语法分析器时若Bison确实发现了n个冲突就不会提醒你，否则会有提示（不加也没有关系，这句不是必要的）\n*.y: conflicts: n shift/reduce\n\n%{...}%中间则和Flex类似，可以放一些头文件，这一部分会被直接添入生成代码的靠前部分\n\n%union{...}则是对之后需要用到的类型声明，即后面token和非终结符的类型都只能取自union中声明的符号，在上面的文件中只能用num、str来声明类型\n\n对Flex生成的token进行声明，使Bison知道有哪些token存在，另外可以通过&lt;type&gt;对token的类型进行声明（默认为int），这样当Flex返回token时我们可以认为返回的是一个type类型的变量，而对于token的赋值则是在Flex中完成的，如此可以使Bison和Flex之间存在信息交互\n\n%right和%left也是token的一种声明方式，分别表示右结合和左结合，多用于运算符token的声明上\n\ntoken的声明顺序决定了语法优先级，从上至下优先级逐渐升高，同一行的token优先级相同，多用于运算符token的声明，优先级高的token先进行归约\n\n%type&lt;&gt; ...则是声明非终结符的类型，类型依然只能取自%union{...}中，token的值是在Flex与Bison之间传递，而非终结符的值则是在产生式之间传递，即当一个非终结符A被归约出来后，我们可以对其进行相应类型的赋值，随后在A被归约时则会带着之前的赋值从产生式左部转移到另一个产生式的右部，那么我们就可以用A的值来定义新归约出来的非终结符的值\n\n%%...%%之间则是最重要的语法规则以及相应的动作，只不过产生式中的【→】变成了【:】\n\n每一个产生式的右部可能有好几种推导结果（由【｜】进行分隔），我们认为不同的右部代表着不同的产生式，而每一个产生式后面都可以跟相应的一系列操作【{…}】，表示发生这一个产生式的归约时会执行的相应动作\n\n操作中我们可以用【$】来引用产生式中的每一个token以及终结符，其中【$$】表示产生式左部的非终结符（冒号左边的非终结符），【$n】表示产生式右部第n个非终结符/token/字符串的值\n⚠️当【$n】是一个字符串常量时，Bison会提示这个【$n】没有声明类型，但不会影响程序的运行，当然你觉得难受的话可以直接将其替换成字符串的字面值\n\n产生式的右部是可以为空的，这就相当于文法中的空串\n\n产生式中%prec token_name可以使%prec左边的产生式具有和token_name相同的优先级\n\n最下面的部分也跟Flex类似，会被直接复制到生成代码的底部，函数yyparse()会执行语法分析过程，接下来你可以增加一些输出分析结果的代码\n\n以上只是Bison最基础的规则，希望更加全面系统地学习可以参阅《flex与bison》.\n\n\n\n∫  “parser.h”#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdarg.h&gt;\n\nextern int yylineno;\nextern char* yytext;\nextern int yylex();\n\ntypedef enum {NUM,TEXT} TYPE;\n\nvoid yyerror(const char* msg)\n{\n    printf(\"\\033[1;31m%s at line %d\\033[0m: %s\\n\",msg,yylineno,yytext);\n}\n\nint OCT2DEC(char* text)\n{\n    int sum=0;\n    for(int i=1;i&lt;strlen(text);++i)\n        sum=sum*8+(text[i]-'0');\n    return sum;\n}\n\nint HEX2DEC(char* text)\n{\n    int sum=0;\n    for(int i=2;i&lt;strlen(text);++i)\n    {\n        if(text[i]&gt;='0'&amp;&amp;text[i]&lt;='9')\n            sum=sum*16+(text[i]-'0');\n        else if(text[i]&gt;='a'&amp;&amp;text[i]&lt;='f')\n            sum=sum*16+(text[i]-'a'+10);\n        else\n            sum=sum*16+(text[i]-'A'+10);\n    }\n    return sum;\n}\n\ntypedef struct ASTnode\n{\n    TYPE type;\n    char* text;\n    int num;\n    struct ASTnode* next;\n    struct ASTnode* child;\n}ASTnode;\n\nASTnode* ASThead=NULL;\n\n//generate new node\nASTnode* newASTnode(TYPE type, char* text, int num, ASTnode* nxt, ASTnode* child)\n{\n    ASTnode* node=(ASTnode*)malloc(sizeof(ASTnode)); //不是sizeof(ASTnode*)!!!\n    node-&gt;type=type;\n    if(type==TEXT)\n        node-&gt;text=strdup(text);\n    else\n        node-&gt;num=num;\n    node-&gt;next=nxt;\n    node-&gt;child=child;\n    return node;\n}\n\n//connect sibling nodes\nvoid connectASTnode(int num,...)\n{\n    va_list valist;\n    va_start(valist,num);\n    ASTnode* node=va_arg(valist,ASTnode*);\n    for(int i=1;i&lt;num;++i)\n    {\n        ASTnode* next=va_arg(valist,ASTnode*);\n        node-&gt;next=next;\n        node=next;\n    }\n    node-&gt;next=NULL;\n    va_end(valist);\n}\n\nvoid outputAST(ASTnode* head,int tab)\n{\n    switch (head-&gt;type)\n    {\n        case NUM:\n            printf(\"\\033[1;35m%d\\033[0m\\n\",head-&gt;num);\n            break;\n        case TEXT:\n            if(head-&gt;child!=NULL)\n                printf(\"\\033[1;32m%s\\033[0m\\n\",head-&gt;text);\n            else\n                printf(\"\\033[1;34m%s\\033[0m\\n\",head-&gt;text);\n            break;\n    }\n    ASTnode* node=head-&gt;child;\n    while(node!=NULL)\n    {\n        for(int i=0;i&lt;tab;++i)\n            printf(\"\\t\");\n        printf(\"└───────\");\n        outputAST(node,tab+1);\n        node=node-&gt;next;\n    }\n}\n\nvoid freeAST(ASTnode *head)\n{\n    ASTnode *node=head-&gt;child;\n    while (node!=NULL)\n    {\n        freeAST(node);\n        node=node-&gt;next;\n    }\n    if(head-&gt;type==TEXT)\n        free(head-&gt;text);\n    free(head);\n}\n\n\n这个头文件中主要包括了AST的构建、输出、释放等函数，还有8进制、16进制转十进制数的函数\n\n节点ASTnode中既可以存字符串也可以存整型，TYPE type指明了这个节点存储的数据类型，其中TYPE是一个枚举类型\n\n前面3个extern声明了Flex（lex.yy.c）中自带的三个变量，从而可以在Bison中使用\n\nyyerror是Bison无法归约时会调用的报错函数，这里它会输出出错信息、出错行数以及出错字符串\n\nconnectASTnode函数使用了C语言中多参数函数的机制，可以连接任意个数的兄弟节点，每天一个make bug小魔法\n#include &lt;stdarg.h&gt;\n// num is number of parameters in ...\ntype func_name(int num,...)\n{\n  // 声明参数列表\n    va_list valist;\n    va_start(valist,num);\n  // 以TYPE类型取出参数\n    TYPE val=va_arg(valist,TYPE);\n    for(int i=1;i&lt;num;++i)\n    {\n        TYPE next=va_arg(valist,TYPE);\n        ...\n    }\n    va_end(valist);\n}\n\nC语言不知道怎么输出树，所以采用了文件树的形式，以tab数表示该节点所处的深度，每个节点的父节点都是其上方最近的tab-1节点\n\n用全局变量ASThead来存储AST的头节点，我们只需要在每次执行归约到开始符号（即左部是开始符号）的产生式时将开始符号的节点赋值给ASThead，那么最后一次赋值（即最后一次归约）的必然是AST的头节点\n\n\n\n∬ SysY.l%option yylineno\n\n%{\n    #include \"SysY.tab.h\"\n    #define UNEXPECTED 0\n%}\n\nINT                 int\nVOID                void\nCONST               const\nIF                  if\nELSE                else\nWHILE               while\nBREAK               break\nCONTINUE            continue\nRETURN              return\nMULDIVSUR           \"*\"|\"/\"|\"%\"\nADDSUB              \"+\"|\"-\"\nCMP                 \"&lt;\"|\"&gt;\"|\"&lt;=\"|\"&gt;=\"\nEQNEQ               \"==\"|\"!=\"\nASSIGN              \"=\"\nNONZERO             [1-9]\nDIGIT               [0-9]\nLETTER              [A-Za-z]\nOCTAL_DIGIT         [0-7]\nOCTAL_CONST         0{OCTAL_DIGIT}*\nILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z]({LETTER}|{DIGIT})*\nHEX_PREFIX          0x|0X\nHEX_DIGIT           [0-9a-fA-F]\nHEX_CONST           {HEX_PREFIX}{HEX_DIGIT}+\nILLEGAL_HEX_CONST   {HEX_PREFIX}({LETTER}|{DIGIT})*\nNONDIGIT            {LETTER}|\"_\"\nID                  {NONDIGIT}({DIGIT}|{NONDIGIT})*\nDEC_CONST           {NONZERO}{DIGIT}*  \nCOMMENT1            \"/*\"[^*]*\"*\"+([^*/][^*]*\"*\"+)*\"/\"\nCOMMENT2            \"//\".*                                                                                \n\n%%\n\n{INT}                   { yylval.str=strdup(yytext); return INT; }\n{VOID}                  { yylval.str=strdup(yytext); return VOID; }\n{OCTAL_CONST}           { yylval.str=strdup(yytext); return OCTAL_CONST; }\n{ILLEGAL_OCTAL_CONST}   { yylval.str=strdup(yytext); return HEX_CONST; }\n{HEX_CONST}             { yylval.str=strdup(yytext); return HEX_CONST; }\n{ILLEGAL_HEX_CONST}     { yylval.str=strdup(yytext); return DEC_CONST; }\n{DEC_CONST}             { yylval.str=strdup(yytext); return DEC_CONST; }\n{CONST}                 { yylval.str=strdup(yytext); return CONST; }\n{IF}                    { yylval.str=strdup(yytext); return IF; }\n{ELSE}                  { yylval.str=strdup(yytext); return ELSE; }\n{WHILE}                 { yylval.str=strdup(yytext); return WHILE; }\n{BREAK}                 { yylval.str=strdup(yytext); return BREAK; }\n{CONTINUE}              { yylval.str=strdup(yytext); return CONTINUE; }\n{RETURN}                { yylval.str=strdup(yytext); return RETURN; }\n{MULDIVSUR}             { yylval.str=strdup(yytext); return MULDIVSUR; } \n{ADDSUB}                { yylval.str=strdup(yytext); return ADDSUB; } \n{CMP}                   { yylval.str=strdup(yytext); return CMP; } \n{EQNEQ}                 { yylval.str=strdup(yytext); return EQNEQ; } \n{ASSIGN}                { yylval.str=strdup(yytext); return ASSIGN; }\n{ID}                    { yylval.str=strdup(yytext); return ID; }\n\"(\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\")\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"[\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"]\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"{\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"}\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\";\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\",\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"&amp;&amp;\"                    { yylval.str=strdup(yytext); return AND; }\n\"||\"                    { yylval.str=strdup(yytext); return OR; }\n{COMMENT1}|{COMMENT2}   { }\n[ \\t\\n]                 { }\n.                       { yylval.str=strdup(yytext); return UNEXPECTED; }\n%%\n\nint yywrap(void) \n{ \n    return 1;\n}\n\n\n“SysY.tab.h”是bison -d SysY.y产生的，Bison会将你声明的token进行enum放在生成的头文件”SysY.tab.h”中，所以你无需自己再写一个”translator.h”\n注意在Flex中需要完成对token的赋值，如果token的类型为TYPE（取自%union），那么你需要以yylval.TYPE=...的形式进行赋值，然后return token_name;\nchar* strdup(char *s)函数会开辟一段新的空间并复制字符串s的值，然后返回新空间的指针（需要free）\n\n\n∭ SysY.y%start CompUnit\n%expect 1\n\n%{\n    #include \"parser.h\"\n%}\n\n%union\n{\n    int     num;\n    char*   str;\n    struct ASTnode* node; /*\"struct\" is indispensable*/\n}\n\n%token &lt;str&gt; INT VOID CONST IF ELSE WHILE BREAK CONTINUE RETURN ID OCTAL_CONST HEX_CONST DEC_CONST\n%right &lt;str&gt; ASSIGN\n%left &lt;str&gt; OR\n%left &lt;str&gt; AND\n%left &lt;str&gt; EQNEQ\n%left &lt;str&gt; CMP\n%left &lt;str&gt; ADDSUB\n%left &lt;str&gt; MULDIVSUR\n\n%type&lt;node&gt; Number CompUnit Decl FuncDef ConstDecl VarDecl ConstDef ConstDefBlock ConstExpBlock ConstInitVal ConstExp ConstInitFlag ConstValBlock VarDef\n    VarDefFlag InitVal Exp InitValFlag InitValBlock FuncFParams Block FuncFParam FuncFParamBlock ExpBlockFlag ExpBlock BlockItemBlock BlockItem \n    Stmt LVal ExpFlag StmtFlag Cond AddExp LOrExp PrimaryExp UnaryExp FuncFParamsFlag FuncRParams UNARYOP CommaExpBlock MulExp RelExp EqExp LAndExp\n\n%%\nCompUnit:       CompUnit Decl                           {\n                                                            connectASTnode(2,$1,$2);\n                                                            ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);\n                                                        }\n                | CompUnit FuncDef                      {\n                                                            connectASTnode(2,$1,$2);\n                                                            ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);\n                                                        }\n                | Decl                                  {ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);}\n                | FuncDef                               {ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);}\nDecl:           ConstDecl                               {$$=newASTnode(TEXT,\"Decl\",0,NULL,$1);}\n                | VarDecl                               {$$=newASTnode(TEXT,\"Decl\",0,NULL,$1);}\nConstDecl:      CONST INT ConstDef ConstDefBlock ';'    {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n5=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(5,n1,n2,$3,$4,n5);\n                                                            $$=newASTnode(TEXT,\"ConstDecl\",0,NULL,n1);\n                                                        }\nConstDefBlock:  ConstDefBlock ',' ConstDef              {\n                                                            ASTnode *n=newASTnode(TEXT,\",\",0,$3,NULL);\n                                                            connectASTnode(3,$1,n,$3);\n                                                            $$=newASTnode(TEXT,\"ConstDefBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstDefBlock\",0,NULL,n);\n                                                        }\nConstDef:       ID ConstExpBlock ASSIGN ConstInitVal    {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,$3,0,NULL,NULL);\n                                                            connectASTnode(4,n1,$2,n3,$4);\n                                                            $$=newASTnode(TEXT,\"ConstDef\",0,NULL,n1);\n                                                        }\nConstExpBlock:  ConstExpBlock '[' ConstExp ']'          {\n                                                            ASTnode *n2=newASTnode(TEXT,\"[\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\"]\",0,NULL,NULL);\n                                                            connectASTnode(4,$1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"ConstExpBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstExpBlock\",0,NULL,n);\n                                                        }\nConstInitVal:   ConstExp                                {$$=newASTnode(TEXT,\"ConstInitVal\",0,NULL,$1);}\n                |'{'ConstInitFlag'}'                    {\n                                                            ASTnode *n1=newASTnode(TEXT,\"{\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"}\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"ConstInitVal\",0,NULL,n1);\n                                                        }\nConstInitFlag:  ConstInitVal ConstValBlock              {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"ConstInitFlag\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstInitFlag\",0,NULL,n);\n                                                        }\nConstValBlock:  ConstValBlock ',' ConstInitVal          {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"ConstValBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstValBlock\",0,NULL,n);\n                                                        }\nVarDecl:        INT VarDef VarDefFlag ';'               {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(4,n1,$2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"VarDecl\",0,NULL,n1);\n                                                        }\nVarDefFlag:    ',' VarDef VarDefFlag                    {\n                                                            ASTnode *n1=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,$3);\n                                                            $$=newASTnode(TEXT,\"VarDefFlag\",0,NULL,n1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"VarDefFlag\",0,NULL,n);\n                                                        }\nVarDef:         ID ConstExpBlock                        {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            connectASTnode(2,n1,$2);\n                                                            $$=newASTnode(TEXT,\"VarDef\",0,NULL,n1);\n                                                        }\n                | ID ConstExpBlock ASSIGN InitVal       {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,$3,0,NULL,NULL);\n                                                            connectASTnode(4,n1,$2,n3,$4);\n                                                            $$=newASTnode(TEXT,\"VarDef\",0,NULL,n1);\n                                                        }\nInitVal:          Exp                                   {$$=newASTnode(TEXT,\"InitVal\",0,NULL,$1);}\n                | '{'InitValFlag'}'                     {\n                                                            ASTnode *n1=newASTnode(TEXT,\"{\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"}\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"InitVal\",0,NULL,n1);\n                                                        }\nInitValFlag:    InitVal InitValBlock                    {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"InitValFlag\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"InitValFlag\",0,NULL,n);\n                                                        }\nInitValBlock:   InitValBlock ',' InitVal                {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"InitValBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"InitValFlag\",0,NULL,n);\n                                                        }\nFuncDef:        INT ID '(' FuncFParams')' Block         {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n5=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(6,n1,n2,n3,$4,n5,$6);\n                                                            $$=newASTnode(TEXT,\"FuncDef\",0,NULL,n1);\n                                                        }\n                | VOID ID '(' FuncFParams')' Block      {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n5=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(6,n1,n2,n3,$4,n5,$6);\n                                                            $$=newASTnode(TEXT,\"FuncDef\",0,NULL,n1);\n                                                        }\nFuncFParams:    FuncFParam FuncFParamBlock              {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"FuncFParams\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"FuncFParams\",0,NULL,n);\n                                                        }\nFuncFParamBlock:FuncFParamBlock ',' FuncFParam          {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"FuncFParamBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"FuncFParamBlock\",0,NULL,n);\n                                                        }\nFuncFParam:     INT ID ExpBlockFlag                     {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,n1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"FuncFParam\",0,NULL,n1);\n                                                        }\nExpBlockFlag:   '['']' ExpBlock                         {\n                                                            ASTnode *n1=newASTnode(TEXT,\"[\",0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"]\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"ExpBlockFlag\",0,NULL,n1);\n                                                        }\nExpBlock:       ExpBlock '['Exp']'                      {\n                                                            ASTnode *n2=newASTnode(TEXT,\"[\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\"]\",0,NULL,NULL);\n                                                            connectASTnode(4,$1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"FuncDef\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ExpBlock\",0,NULL,n);\n                                                        }\nBlock:          '{' BlockItemBlock '}'                  {\n                                                            ASTnode *n1=newASTnode(TEXT,\"{\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"}\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"Block\",0,NULL,n1);\n                                                        }\nBlockItemBlock: BlockItemBlock BlockItem                {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"BlockItemBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"BlockItemBlock\",0,NULL,n);\n                                                        }\nBlockItem:        Decl                                  {$$=newASTnode(TEXT,\"BlockItem\",0,NULL,$1);}\n                | Stmt                                  {$$=newASTnode(TEXT,\"BlockItem\",0,NULL,$1);}\nStmt:           LVal ASSIGN Exp ';' %prec ASSIGN        {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(4,$1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,$1);\n                                                        }\n                | ExpFlag';'                            {\n                                                            ASTnode *n2=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(2,$1,n2);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,$1);\n                                                        }\n                | Block                                 {$$=newASTnode(TEXT,\"Stmt\",0,NULL,$1);}\n                | IF'('Cond')' Stmt StmtFlag            {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(6,n1,n2,$3,n4,$5,$6);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | WHILE'('Cond')' Stmt                  {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(5,n1,n2,$3,n4,$5);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | BREAK';'                              {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(2,n1,n2);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | CONTINUE';'                           {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(2,n1,n2);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | RETURN ExpFlag';'                     {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\nExpFlag:          Exp                                   {$$=newASTnode(TEXT,\"ExpFlag\",0,NULL,$1);}\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ExpFlag\",0,NULL,n);\n                                                        }\nStmtFlag:       ELSE Stmt                               {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            connectASTnode(2,n1,$2);\n                                                            $$=newASTnode(TEXT,\"StmtFlag\",0,NULL,n1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"StmtFlag\",0,NULL,n);\n                                                        }\nExp:            AddExp                                  {$$=newASTnode(TEXT,\"Exp\",0,NULL,$1);}\nCond:           LOrExp                                  {$$=newASTnode(TEXT,\"Cond\",0,NULL,$1);}\nLVal:           ID ExpBlock                             {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            connectASTnode(2,n1,$2);\n                                                            $$=newASTnode(TEXT,\"LVal\",0,NULL,n1);\n                                                        }\nPrimaryExp:     '('Exp')'                               {\n                                                            ASTnode *n1=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,n1);\n                                                        }\n                | LVal                                  {$$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,$1);}\n                | Number                                {$$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,$1);}\nNumber:         OCTAL_CONST                             {\n                                                            ASTnode *n=newASTnode(NUM,NULL,OCT2DEC($1),NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"Number\",0,NULL,n);\n                                                        }\n                | HEX_CONST                             {\n                                                            ASTnode *n=newASTnode(NUM,NULL,HEX2DEC($1),NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"Number\",0,NULL,n);\n                                                        }\n                | DEC_CONST                             {\n                                                            ASTnode *n=newASTnode(NUM,NULL,atoi($1),NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"Number\",0,NULL,n);\n                                                        }\nUnaryExp:       PrimaryExp                              {$$=newASTnode(TEXT,\"UnaryExp\",0,NULL,$1);}\n                | ID '(' FuncFParamsFlag ')'            {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(4,n1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,n1);\n                                                        }\n                | UNARYOP UnaryExp                      {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"UnaryExp\",0,NULL,$1);\n                                                        }\nFuncFParamsFlag:FuncRParams                             {$$=newASTnode(TEXT,\"FuncFParamsFlag\",0,NULL,$1);}\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"FuncFParamsFlag\",0,NULL,n);\n                                                        }\nFuncRParams:    Exp CommaExpBlock                       {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"FuncRParams\",0,NULL,$1);\n                                                        }\nCommaExpBlock:  CommaExpBlock ',' Exp                   {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"CommaExpBlock\",0,NULL,$1);\n                                                        }\n                | /*ε*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"ε\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"CommaExpBlock\",0,NULL,n);\n                                                        }\nUNARYOP:        ADDSUB                                  {\n                                                            ASTnode *n=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"UNARYOP\",0,NULL,n);\n                                                        }\n                | '!'                                   {\n                                                            ASTnode *n=newASTnode(TEXT,\"!\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"UNARYOP\",0,NULL,n);\n                                                        }\nMulExp:         UnaryExp                                {$$=newASTnode(TEXT,\"MulExp\",0,NULL,$1);}\n                | MulExp MULDIVSUR UnaryExp             {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"MulExp\",0,NULL,$1);\n                                                        }\nAddExp:         MulExp                                  {$$=newASTnode(TEXT,\"AddExp\",0,NULL,$1);}\n                | AddExp ADDSUB MulExp                  {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"MulExp\",0,NULL,$1);\n                                                        }\nRelExp:         AddExp                                  {$$=newASTnode(TEXT,\"RelExp\",0,NULL,$1);}\n                | RelExp CMP AddExp                     {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"RelExp\",0,NULL,$1);\n                                                        }\nEqExp:          RelExp                                  {$$=newASTnode(TEXT,\"EqExp\",0,NULL,$1);}\n                | EqExp EQNEQ RelExp                    {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"EqExp\",0,NULL,$1);\n                                                        }\nLAndExp:        EqExp                                   {$$=newASTnode(TEXT,\"LAndExp\",0,NULL,$1);}\n                | LAndExp AND EqExp                     {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"LAndExp\",0,NULL,$1);\n                                                        }\nLOrExp:         LAndExp                                 {$$=newASTnode(TEXT,\"LOrExp\",0,NULL,$1);}\n                | LOrExp OR LAndExp                     {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"LOrExp\",0,NULL,$1);\n                                                        }\nConstExp:       AddExp                                  {$$=newASTnode(TEXT,\"ConstExp\",0,NULL,$1);}\n%%\n\nint main()\n{\n    yyparse();\n    outputAST(ASThead,0);\n    freeAST(ASThead);\n    return 0;\n}\n\n\nTest.cint main()\n{\n    int bb = 0x12d23;\n    if (abc &gt;= bb) // hello\n            return 8;\n    /*This is a test\n    */\n}\n\nCast Magic 🪄flex SysY.l\nbison -d SysY.y\nclang SysY.tab.c lex.yy.c\ncat test.c|./a.out\n\nOutput\n","slug":"Bison-Flex-语法分析生成中","date":"2022-05-05T14:23:51.000Z","categories_index":"编译原理","tags_index":"走码观花","author_index":"Starlit Rover"},{"id":"f49316d46cb145f81e643476c18ee695","title":"「1018」Public Bike Management","content":"There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.\nThe Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.\n\n\nWhen a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.\n\nThe above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex  is the current number of bikes stored at . Given that the maximum capacity of each station is 10. To solve the problem at , we have 2 different shortest paths:\n\nPBMC -&gt;  -&gt; . In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from  and then take 5 bikes to , so that both stations will be in perfect conditions.\nPBMC -&gt;  -&gt; . This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 numbers: , always an even number, is the maximum capacity of each station; , the total number of stations; , the index of the problem station (the stations are numbered from 1 to , and PBMC is represented by the vertex 0); and , the number of roads. The second line contains  non-negative numbers  where each  is the current number of bikes at  respectively. Then  lines follow, each contains 3 numbers: , , and  which describe the time  taken to move betwen stations  and . All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−&gt;−&gt;⋯−&gt;. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of  is adjusted to perfect.\nNote that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.\nSample Input:10 3 3 5\n6 7 0\n0 1 1\n0 2 1\n0 3 3\n1 3 1\n2 3 1\n\nSample Output:3 0-&gt;2-&gt;3 0\n\n\nΩ极繁翻译：PBMC是杭州公共自行车管理部门，负责管理平衡各个自行车租凭点的自行车数量。当一个租凭点的自行车数量刚好是最大数量的一半时，我们认为是恰好的。当一个站点上报至PBMC需要调整其自行车数量时，PBMC会选择一条耗时最短的路前往，同时将沿途站点的自行车数量也调整至恰好的状态。在前往的途中，途经站点多出来的自行车可以填补到后面需要的站点，这样带回PBMC的自行车就会少一些。注意，返回途中不调整任何站点。如果有多条耗时相同的路径则选择带上自行车数量最少的路，如果还是有相同的，则选择带回自行车最少的路。现给出站点的最大容量、站点数量、上报的站点编号、各条路径的耗时情况，需要输出最优路线以及需要带上和带回的自行车数。题目保证最优路径唯一。\n这题目，有毒。深刻理解什么叫，有坑的地方就有我。\n理解错题意，重构了几次代码，废了好多时间。做完再仔细阅读题目，感觉还是没get到那几个坑：\n\n回去的路上不能调整各站点自行车，只能在来的路上用前面站点多出来的自行车填补后面的站点，也就是说后面站点多出来不能填补前面的站点，只能带回去。这是什么人工智障？PBMC早就知道各个站点的自行车数量，为什么不能做到全局规划呢（格局小了，锻炼编程能力而已，以后还要面对各种甲方爸爸呢\n输出要求里说，如果路径不唯一，则输出带回数量最少的路径。当时我也纳闷，因为前面举的那个例子里面选择的是带上数量最少的路。结果其实是先选择带上最少的，再选择带回最少的。。（请打开麦克风好好交流\n\n总之，不懂。\n\n\n显然，这不是一道单纯的Dijkstra算法题，Dijkstra的基本思想本质上是广度优先搜索BFS，但只能找到一条最短路，而我们需要找到所有最短路，因此需要加以改进。\nDijkstra算法中，当一个新点被纳入起点所在的集合中时，我们会更新与该点相连的点到起点的距离，如果更新的距离≥ 原距离的话就不需要更新。那么在这个问题中，如果更新的距离==原距离，我们依然需要记录，从而保留所有长度相同的路径信息。\n首先我们需要一个vector来记录所有站点到PBMC（编号为0）的最短距离（这里的距离是时间），并初始化所有距离为最大值INF：\nvector&lt;int&gt; dist(n + 1, INF); // #define INF INT32_MAX\n\n然后初始化的时候需要将所有与PBMC相连的站点dist修改为他们之间的距离。\n另外还需要标记各个站点是否已被纳入集合，其中表示所有已经求出最短距离的站点编号，初始情况下只含0。\nvector&lt;bool&gt; isVisited(n + 1, false);\nisVisited[0] = true;\n\n最重要的我们还需要存储路径，由于最后是根据带上和带回的自行车数进行最优选择，因此也一并存了，因此诞生了一个究极复杂的类型：\n// vector&lt;vector&lt;pair&lt;pair&lt;send num,take back num&gt;,path points&gt;&gt;&gt;\nvector&lt;vector&lt;pair&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt;&gt;&gt; track(n + 1);\n\n简单地说，就是所有站点都拥有一个vector，里面存储了PBMC到该站点所有最短路径的信息，每个最短路径信息是一个pair&lt;pair&lt;int,int&gt;,vector&lt;int&gt;&gt;，后面的vector&lt;int&gt;就是这条路径上依次的站点编号，前面pair&lt;int,int&gt;则是这条路径到当前站点所必须带上和带回的自行车数量。\n接下来每次循环都从dist中找到距离最小的站点min_idx，将该站点编号纳入集合。在更新与该点相连的站点dist[i]时，如果更短了，那么更新dist[i]并将其track[i]清空，然后进行“如果是相等的”的操作；如果是相等的，说明又找到了一条最短路径，那么将track[min_idx]中的每一条记录更新之后推入track[i]。也就是说，track[i]中存储的路径长度均为dist[i]，因此修改dist[i]时必须清空track[i]。\n另外num_to_perfect[i]存储站点需要多少辆自行车才能到达恰好的状态，为负则表示多出来的自行车数量：\nnum_to_perfect[i] = max_cap / 2 - num_to_perfect[i];\n\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\n#define INF INT32_MAX\n\nusing namespace std;\ntypedef pair&lt;int, int&gt; info;\ntypedef pair&lt;info, vector&lt;int&gt;&gt; path;\n\nbool cmp(path &amp;a, path &amp;b)\n{return a.first.first &lt; b.first.first || a.first.first == b.first.first &amp;&amp; a.first.second &lt; b.first.second;}\n\nint main()\n{\n    int max_cap, n, sp, m, s1, s2, t;\n    cin &gt;&gt; max_cap &gt;&gt; n &gt;&gt; sp &gt;&gt; m;\n    vector&lt;int&gt; num_to_perfect(n + 1, 0), dist(n + 1, INF);\n    for (int i = 1; i &lt; n + 1; ++i)\n    {\n        cin &gt;&gt; num_to_perfect[i];\n        num_to_perfect[i] = max_cap / 2 - num_to_perfect[i];\n    }\n    map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; road;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; t;\n        road[s1].emplace_back(s2, t);\n        road[s2].emplace_back(s1, t);\n    }\n    vector&lt;vector&lt;path&gt;&gt; track(n + 1);\n    vector&lt;bool&gt; isVisited(n + 1, false);\n    isVisited[0] = true;\n    int min_dist = INF, min_idx = 0;\n  //initialization\n    for (auto &amp;s: road[0])\n    {\n        dist[s.first] = s.second;\n        info tmp = move(num_to_perfect[s.first] &lt; 0 ? info{0, -num_to_perfect[s.first]} : info{num_to_perfect[s.first], 0});\n        track[s.first].emplace_back(tmp, vector&lt;int&gt;{s.first});\n        min_dist = s.second &lt; min_dist ? (min_idx = s.first, s.second) : min_dist;\n    }\n    isVisited[min_idx] = true;\n    while (!isVisited[sp])\n    {\n      // update dist[i] for i in neighbor of min_idx\n        for (auto &amp;d: road[min_idx])\n        {\n            if (isVisited[d.first] || dist[min_idx] + d.second &gt; dist[d.first])\n                continue;\n            else if (dist[min_idx] + d.second &lt; dist[d.first])\n            {\n                track[d.first].clear();\n                dist[d.first] = dist[min_idx] + d.second;\n            }\n          // 将min_idx的路径信息延续到d.first\n            // k不能是引用，会直接修改track[min_idx]\n            for (auto k: track[min_idx])\n            {\n                k.second.push_back(d.first);\n              // 包括了num_to_perfect[d.first]&lt;0的情况\n                if (num_to_perfect[d.first] &lt;= k.first.second)\n                    k.first.second -= num_to_perfect[d.first];\n                else\n                {\n                    k.first.first += (num_to_perfect[d.first] - k.first.second);\n                    k.first.second = 0;\n                }\n                track[d.first].push_back(k);\n            }\n        }\n      // 更新完后min_idx的路径信息可以清空以减少空间消耗\n        track[min_idx].clear();\n        min_dist = INF, min_idx = 0;\n        for (int i = 1; i &lt; n + 1; ++i)\n            min_dist = (!isVisited[i] &amp;&amp; dist[i] &lt; min_dist) ? (min_idx = i, dist[i]) : min_dist;\n        isVisited[min_idx] = true;\n    }\n\n    sort(track[sp].begin(), track[sp].end(), cmp);\n    cout &lt;&lt; track[sp][0].first.first &lt;&lt; \" 0\";\n    for (auto &amp;s: track[sp][0].second)\n        cout &lt;&lt; \"-&gt;\" &lt;&lt; s;\n    cout &lt;&lt; \" \" &lt;&lt; track[sp][0].first.second;\n}\n","slug":"1018-Public-Bike-Management","date":"2022-04-13T00:42:21.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,sort,pair,vector,Dijkstra","author_index":"Starlit Rover"},{"id":"f28bb9815d595dfd2f2742951bf93359","title":"「1017」Queueing at Bank","content":"➳ENTRY\nSuppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour.\nNow given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (≤104) - the total number of customers, and K (≤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time.\nNotice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average.\nOutput Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place.\nSample Input:7 3\n07:55:00 16\n17:00:01 2\n07:59:59 15\n08:01:00 60\n08:00:00 30\n08:00:02 2\n08:03:00 10\n\nSample Output:8.2\n\n\nΩ本题算是低配版「1014」Waiting in Line，区别在于每个窗口前不能排队，所有等候的人都在黄线外排成一排，当有窗口空了才能进入。\n极简翻译：银行有个窗口，每个窗口接待一人。顾客按照到来的先后顺序在黄线外排成一排，当有窗口空闲时依次进入。我们已知每个顾客到达的时间，以及事务所需的处理时间，最终输出所有顾客的平均等待时间。注意，银行营业时间为8:00-17:00，17:00后到达的顾客不计入平均等待时间。\n这一题相比1014事实上退化了很多，一方面是每个窗口前不能排队，所有人排在一个队伍里；另一方面，最后需要输出的结果并不是针对具体的个体，而是刻画整体的平均等待时间。因此我们也无需给每一个顾客进行编号，直接用pair存储到达时间和处理时长即可：\n# pair&lt;arrival time in second, processing time in second&gt;\nvector&lt;pair&lt;int,int&gt;&gt; info;\n\n注意到，顾客信息不是按照到达顺序给出的，因此我们需要先对所有顾客的到达时间进行sort排序，然后遍历每一位顾客，选择时间轴最早的窗口，计算相应的等待时间，同时将顾客的处理时长加到该窗口的时间轴上。当循环到某位顾客的到达时间晚于17:00时则break退出循环，并记录有效顾客数rn。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;int, int&gt; ptt;\n\nint main()\n{\n    int n, k, h, m, s, p, rn, sum = 0;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;ptt&gt; info;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d:%d:%d %d\", &amp;h, &amp;m, &amp;s, &amp;p);\n        info.push_back(move(ptt(3600 * h + 60 * m + s, p * 60)));\n    }\n    sort(info.begin(), info.end(), [](const ptt &amp;a, const ptt &amp;b) { return a.first &lt; b.first; });\n    vector&lt;int&gt; windows(k, 8 * 3600);\n    for (rn = 0; rn &lt; n; ++rn)\n    {\n        if (info[rn].first &gt; 17 * 3600)\n            break;\n      # Count waiting time\n        sum += (windows[0] &gt; info[rn].first ? (windows[0] - info[rn].first) : (windows[0] = info[rn].first, 0));\n      # Add processing time to time line\n        windows[0] += info[rn].second;\n        sort(windows.begin(), windows.end());\n    }\n    printf(\"%.1f\", (sum % 60 / 60.0 + sum / 60) / rn);\n}\n\n\n⚡︎ 一些说明\n所有时间都换算成秒\n\n窗口的初始时间轴都设置为8:00就无需考虑早到的情况了\nvector&lt;int&gt; windows(k, 8 * 3600);\n\n当出现窗口空闲而无顾客的时候，需要先将窗口的时间轴拉到顾客到达时间再加上事务处理时长\n(windows[0] = info[rn].first, 0) # 逗号表达式返回后者的值\n\n每次处理完一个顾客都需要对所有窗口的时间线进行排序，那么windows[0]即为最早空闲窗口。\n\n\n","slug":"1017-Queueing-at-Bank","date":"2022-04-08T05:03:29.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,sort,pair,vector","author_index":"Starlit Rover"},{"id":"4cf831a9ea6bfd5b5d2bee7ee829301b","title":"「1016」Phone Bills","content":"➳ENTRY\nA long-distance telephone company charges its customers by the following rules:\nMaking a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.\n\n\nInput Specification:Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.\nThe rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.\nThe next line contains a positive number N (≤1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (MM:dd:HH:mm), and the word on-line or off-line.\nFor each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.\nOutput Specification:For each test case, you must print a phone bill for each customer.\nBills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:HH:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.\nSample Input:10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10\n10\nCYLL 01:01:06:01 on-line\nCYLL 01:28:16:05 off-line\nCYJJ 01:01:07:00 off-line\nCYLL 01:01:08:03 off-line\nCYJJ 01:01:05:59 on-line\naaa 01:01:01:03 on-line\naaa 01:02:00:01 on-line\nCYLL 01:28:15:41 on-line\naaa 01:05:02:24 on-line\naaa 01:04:23:59 off-line\n\nSample Output:CYJJ 01\n01:05:59 01:07:00 61 $12.10\nTotal amount: $12.10\nCYLL 01\n01:06:01 01:08:03 122 $24.40\n28:15:41 28:16:05 24 $3.85\nTotal amount: $28.25\naaa 01\n02:00:01 04:23:59 4318 $638.80\nTotal amount: $638.80\n\n\nΩ有一阵子没码题目了，感觉脑子和手都生锈了。用这道题来复健着实折磨。\n极简翻译：首先给出每小时内通话的收费标准（美分/min）。然后给出同一月内不同用户的通话记录，通话记录的状态包括on-line和off-line，然而对于一个用户而言两者也并非完全匹配，那么就需要找出每个用户所有匹配的通话记录对，最后按字母顺序依次输出本月内每个用户（按时间顺序）的所有匹配记录对，以及每一对相应的时长（min）与收费（$），最后输出该用户在本月的总收费。\n\n\n脑袋隐隐作痛，有几个棘手的地方：\n\n同一个用户通话记录的匹配\n一次通话的费用计算\n用户名字和通话记录都要按顺序输出\n\n首先定义了一个日期类，包含了时间的日时分，以及记录的状态和是否已匹配，同时重载了&lt;，&lt;&lt;运算符，实现了换算成分钟的minutes()\nclass date\n{\npublic:\n    int d, h, m;\n    bool isOnline, isPaired = false;\n\n    inline bool operator&lt;(const date &amp;rhs) const { return this-&gt;minutes() &lt; rhs.minutes(); }\n\n    int minutes() const { return this-&gt;d * 1440 + this-&gt;h * 60 + this-&gt;m; }\n\n    inline friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const date &amp;t)\n    {\n        printf(\"%02d:%02d:%02d\", t.d, t.h, t.m);\n        return os;\n    }\n\n    date(int _d = -1, int _h = -1, int _m = -1, bool flag = true) : d(_d), h(_h), m(_m), isOnline(flag) {};\n};\n\n这里我用set&lt;date&gt;容器来存储一个用户的通话记录，由于我重载了date的&lt;，因此会自动按照时间先后进行存储，而用户与其通话记录集合则用map&lt;string,set&lt;date&gt;&gt;记录，map会自动按照名字顺序排序。\n匹配的要求感觉题目说的不是很清楚，简单地说，只有同一个用户在相邻时间点（之间没有其他记录）的on-line和off-line可以匹配成功，其余无法匹配的记录直接忽略。那么我在遍历集合的时候，遇到on-line就保留其时间，遇到off-line就检查保留的on-line记录是否已匹配，未匹配就计算相应费用，并标记匹配变量。\n计算费用我是直接分类计算，on-line和off-line的当天单独计算，中间的天数直接乘以通话一天的总费用（⚠️这样计算的话还需要单独考虑同一天内，以及同一天同一小时内的通话记录）。还有一种方法是先分别计算两个状态从00:00:00开始的费用，然后直接相减，就不需要考虑这么多了。事实上，这个思路适用所有涉及到时间的计算。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nusing namespace std;\nvector&lt;int&gt; toll(25);\n\nclass date\n{\npublic:\n    int d, h, m;\n    bool isOnline, isPaired = false;\n\n    inline bool operator&lt;(const date &amp;rhs) const { return this-&gt;minutes() &lt; rhs.minutes(); }\n\n    int minutes() const { return this-&gt;d * 1440 + this-&gt;h * 60 + this-&gt;m; }\n\n    inline friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const date &amp;t)\n    {\n        printf(\"%02d:%02d:%02d\", t.d, t.h, t.m);\n        return os;\n    }\n\n    date(int _d = -1, int _h = -1, int _m = -1, bool flag = true) : d(_d), h(_h), m(_m), isOnline(flag) {};\n};\n\nfloat cost(const date &amp;on, const date &amp;off)\n{ \n    if (on.d == off.d &amp;&amp; on.h == off.h)\n        return (off.m - on.m) * toll[on.h] / 100.0;\n    float sum = (60 - on.m) * toll[on.h] + off.m * toll[off.h];\n    if (on.d &lt; off.d)\n    {\n        for (int i = on.h + 1; i &lt; 24; ++i)\n            sum += 60 * toll[i];\n        for (int i = 0; i &lt; off.h; ++i)\n            sum += 60 * toll[i];\n    }\n    else\n        for (int i = on.h + 1; i &lt; off.h; ++i)\n            sum += 60 * toll[i];\n    for (int i = on.d + 1; i &lt; off.d; ++i)\n        sum += 60 * toll[24];\n\n    return sum / 100.0;\n}\n\nint main()\n{\n    for (int i = 0; i &lt; 24; ++i)\n    {\n        cin &gt;&gt; toll[i];\n        toll[24] += toll[i];\n    }\n    int n, M, d, h, m;\n    cin &gt;&gt; n;\n    string name, flag;\n    map&lt;string, set&lt;date&gt;&gt; record;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name;\n        scanf(\"%d:%d:%d:%d\", &amp;M, &amp;d, &amp;h, &amp;m);\n        cin &gt;&gt; flag;\n        record[name].emplace(d, h, m, (flag == \"on-line\") ? true : false);\n    }\n\n    for (auto &amp;r: record)\n    {\n        name = r.first;\n        float money = 0, sum = 0;\n        date pre_online;\n        for (auto &amp;k: r.second)\n        {\n            if (k.isOnline)\n                pre_online = k;\n            else if (!pre_online.isPaired &amp;&amp; pre_online.d != -1)\n            {\n                if (sum == 0)\n                    printf(\"%s %02d\\n\", name.c_str(), M);\n                money = cost(pre_online, k);\n                pre_online.isPaired = true;\n                cout &lt;&lt; pre_online &lt;&lt; \" \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; (k.minutes() - pre_online.minutes());\n                printf(\" $%.2f\\n\", money);\n                sum += money;\n            }\n        }\n        if (sum != 0)\n            printf(\"Total amount: $%.2f\\n\", sum);\n    }\n}\n\n\nΣ Notes\n$1=100美分，/100.0！\n如果一个用户一对匹配的通话记录都没有，那么就无需输出\ntoll[24]存放的是通话一天的收费标准（美分/min）\n测试点说明：0-Sample，1、2-不要输出没有费用的用户，3-含有同一天同一小时内的通话记录\n\n","slug":"1016-Phone-Bills","date":"2022-04-04T03:35:13.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,set","author_index":"Starlit Rover"},{"id":"9c235338e8419467c57a9cf3dae4161a","title":"「Section 8」控制器","content":"\n控制器是整个计算机的指挥中心，协调计算机的各部件进行工作。其实质工作就是解释程序，每次从存储器中读取一条指令，经过分析译码产生一串操作命令，再发给各功能部件，控制各部件的动作，以实现指令和程序的功能。（取指令→分析指令→执行指令→取指令）\n\n\n\n\n总线（bus）\n\n构成\nAB（单向）：地址总线，CPU→AB→存储器或IO设备\nDB（双向）：数据总线，各部件之间\nCB（单/双线）：控制总线，包含多种不同的控制信号线和状态信号线\n\n\n层次\n系统总线（AB，DB，CB）：CPU访问存储器，I/O控制器\n局部总线 / I/O总线\n\n\n\n\n\n存储器结构\n\n普林斯顿结构\n程序和数据共同存放在一个存储器\n一套地址总线与数据总线\n典型CPU：Intel微处理器，ARM7，MIPS处理器\n\n\n哈佛结构\n程序和数据分开存放在两个存储器中\n二套地址总线与数据总线\n指令和数据宽度可以不同\n典型CPU：PIC系列，MC68系列，Z8系列，AVR系列，ARM9、10、11，51单片机（改进型哈佛结构，指令和数据存储器分时复用同一条总线）\n\n\n\n\n中央处理器CPU\n\n组成：运算器和处理器\n\n基本功能\n\n指令控制：确保计算机指令按程序的顺序执行\n操作控制：控制微操作的产生、组合、传送和管理\n时间控制：严格按照时间序列执行微操作和指令\n数据加工：算术运算和逻辑运算\n\n\n本质上就是一个复杂的有限自动机\n\n\n\n～四个状态是所有指令都需要预先执行的公操作\n结束后会根据指令的译码情况进行状态转换\n\n\n指令执行的三个阶段\n\n取指令阶段：从存储器中取出一条指令送到CPU\n指令译码阶段：对当前指令进行译码，分析是哪条指令操作数的寻址方式等\n译码时可能不会对应任何一个状态，也可能包含好几个状态\n\n\n执行阶段：执行该指令，控制相应部件完成指令的操作\n\n\n\n\n控制器组成\n\n专用寄存器\n程序计数器（PC）：存放指令地址\n指令寄存器（IR）：存放指令编码\n地址寄存器（AR）：用于存放CPU访问存储器或者I/O设备的地址码\n数据寄存器（DR）：用于存放CPU访问存储器或者I/O设备的数据\n\n\nAR和DR：总线接口单元BIU (Bus Interface Unit)的重要组成部分，CPU与存储器或者/0系统的一个总线接口\n指令译码器ID：对指令操作码进行译码，以识别该指令所要求的操作\n时序系统：负责提供时钟基准和各级时序信号，规定每个操作的时间\n操作控制信号形成部件：产生指令所需的各种操作控制信号，以便正确地建立数据通路，完成取指令、分析指令和执行指令的控制\n\n\n时序系统及其控制\n\n三大周期\n\n指令周期：指计算机从内存取出一条指令并完成该指令的执行所需要的时间\n时钟周期：节拍（T），指CPU执行一个微操作的最小时间单位，一般是CPU主频脉冲的周期\n机器周期（CPU周期）：用于完成1次内存的读写操作，或者1次ALU运算，或是1次总线传输\n一般规定为CPU与内存交换1次信息（读或写内存）所需要的时间\n一个机器周期可能包含多个时钟周期\n\n\n\n\n\n时序控制方式：同步不同的控制信号序列，并将序列号衔接起来，从而保证各部件有节奏依次执行规定的各种操作\n\n同步控制方式\n所有指令都具有相同的机器周期数、相同的节拍，相同的执行时间\n以微操作序列最长的指令为标准，确定机器周期数和节拍数\n时序系统产生统一的、顺序固定的、周而复始的机器周期和节拍信号\n优点：电路简单；缺点：运行效率低，速度慢\n\n\n异步控制方式\n没有严格的时序信号对微操作进行同步\n每条指令需要多少节拍，就产生多少节拍；当指令执行完毕，发出应答信号；时序部件收到应答信号后，才开始下条指令的执行\n执行不同指令所需的时间完全由实际需要确定，不尽相同\n优点：指令的运行效率高；缺点：控制器电路复杂\n异步控制方式比较好地协调了主从设备速度不一致问题，在计算机中得到广泛的应用\n\n\n联合控制方式：把同步控制方式和异步控制方式结合使用\n现代计算机系统大多采用联合控制方式，一般设计思想是：在功能部件内部采用同步控制方式，而在功能部件之间采用异步控制方式。\n\n\n\n\n\n\n\n","slug":"控制器","date":"2022-04-02T11:10:12.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"d3ed745153d9df10022e8be01ae8a15a","title":"Bézier Curve：交互增强","content":"☘︎ Preface在很久很久的以前，我有介绍过Bézier Curve的理论推导以及基本实现过程（Bézier Curve：小试牛刀）。但不难看出，这个版本的Bézier Curve绘制程序的交互性极差。一旦确定就不能更改，控制点还要一个一个地输入坐标，每次运行还只能画一次，画完之后就什么操作都没了，有时候只想看个曲线却又去不掉花里胡哨的绘制过程（官方吐槽最为致命）。简单地说，除了画得好看简直一无是处。\n在21世纪的今天，我们怎能容忍这种空有其表的程序呢！于是version 2.0横空出世。\n\n\n\n☈ README.txtVersion 2.0在Version 1.0的基础上新增以下功能：\n\n无需事先指定曲线的阶数，更无需输入控制点的坐标，直接在窗口内用鼠标左击确定控制点位置，点击后会出现相应的绿点，并输出相应的世界坐标；\n在确定所有控制顶点位置后，鼠标右击绘制相应的贝塞尔曲线及绘制过程；\n绘制完成后鼠标右击隐藏绘制过程，再次右击显示绘制过程；\n绘制完成后按🆃可以修改值（默认为0.5）；\n绘制完成后按住🅳可以拖动改变当前鼠标所在控制点的位置，同时贝塞尔曲线及绘制过程也会相应变化；\n绘制完成后鼠标左击删除当前曲线及控制点，即清空画板回到第1步；\n按␛退出程序.\n\n\n⚖︎ Tips\n对于实现点击选择控制顶点，首先我们需要将鼠标坐标转换为画布上的世界坐标（原点在中心，），函数void glfwGetCursorPos(GLFWwindow *window, double *xpos, double *ypos)得到的鼠标坐标(xpos,ypos)是一个像素坐标，原点位于窗口的左上角，y轴正方向向下，x轴正方向向右，根据窗口的宽高像素值WIDTH,HEIGHT以及简单的映射变换我们可以得到其世界坐标\nglfwGetCursorPos(window, &amp;click_x, &amp;click_y);\nclick_x = (click_x / WIDTH) * 2 - 1;\nclick_y = 1 - (click_y / HEIGHT) * 2;\n\n对于贝塞尔曲线阶数的获取，我们只要在用户鼠标右击时查看控制顶点的个数即可\norder = control[0].size() - 1\n\n至于如何使鼠标左击和右击时发挥不同的作用，其实是实现了一个简单的DFA。我设了两个布尔变量\nbool start = false, showLine = true;\n\n其中表示是否开始绘制曲线（用户在确定控制点位置时为false），表示是否展示绘制过程。我们将自动机的状态定义为有序对，其中1代表true，0代表false，那么其状态转移图可以表示为\n\n\n分别表示鼠标左击与右击，初始状态为，那么上图清楚地展现了每个状态点击鼠标后的跳转方式。\n\n清空画布就是上图中的情况\n\n为全局变量，当start=true同时监听到按键🆃的按下时，将输入的值直接赋给，然后GeneratePointsViaT0()重新生成绘制过程\n\n对于按键🅳的监听，只要在每个循环中查看🅳是否被按下，若处于按下状态，则计算距离当前鼠标最近的控制顶点，另外需要设定一个阈值（DRAG_SENSITIVITY，可以认为是拖动敏感度），只有最近距离小于阈值时才将该控制顶点移动到鼠标位置，并更新绘制过程与曲线细分点，详见void DragProcess(GLFWwindow *window)\n\nvector.resize()方法可以在保留原有数据的基础上扩充空间\n\n\n\nC☺DE#include &lt;glew.h&gt;\n#include &lt;glfw3.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define WIDTH 800\n#define HEIGHT 600\n#define CURVE_POINTS_NUM 100\n#define DRAG_SENSITIVITY 0.01\n\nusing namespace std;\n\nclass Point\n{\npublic:\n    GLfloat x, y;\n\n    Point(GLfloat _x, GLfloat _y) : x(_x), y(_y) {};\n\n    inline Point operator*(const GLfloat &amp;t) const\n    {\n        return {t * this-&gt;x, t * this-&gt;y};\n    }\n\n    inline Point operator+(const Point &amp;rhs) const\n    {\n        return {this-&gt;x + rhs.x, this-&gt;y + rhs.y};\n    }\n};\n\nint order;\nbool start = false, showLine = true;\ndouble click_x, click_y;\nGLfloat t0 = 0.5;\nvector&lt;vector&lt;Point&gt;&gt; control_points(1, vector&lt;Point&gt;()), middle_points;\n\nvoid GeneratePointsViaT0()\n{\n    order = control_points[0].size() - 1;\n    control_points.resize(order + 1);\n\n    for (int i = 1; i &lt; order + 1; ++i)\n    {\n        control_points[i].clear();\n        for (int j = 0; j &lt; order + 1 - i; ++j)\n            control_points[i].emplace_back(control_points[i - 1][j] * (1 - t0) + control_points[i - 1][j + 1] * t0);\n    }\n}\n\nvoid GenerateMiddlePoints()\n{\n    order = control_points[0].size() - 1;\n    middle_points.clear();\n    middle_points.resize(order + 1);\n    middle_points[0] = control_points[0];\n\n    for (int k = 0; k &lt; CURVE_POINTS_NUM + 1; ++k)\n    {\n        GLfloat t = k / (1.0 * CURVE_POINTS_NUM);\n        for (int i = 1; i &lt; order; ++i)\n        {\n            middle_points[i].clear();\n            for (int j = 0; j &lt; order + 1 - i; ++j)\n                middle_points[i].emplace_back(\n                        middle_points[i - 1][j] * (1 - t) + middle_points[i - 1][j + 1] * t);\n        }\n        middle_points[order].emplace_back(middle_points[order - 1][0] * (1 - t) + middle_points[order - 1][1] * t);\n    }\n}\n\nvoid MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)\n{\n    if (action == GLFW_PRESS)\n        switch (button)\n        {\n            case GLFW_MOUSE_BUTTON_LEFT:\n                if (!start)\n                {\n                    glfwGetCursorPos(window, &amp;click_x, &amp;click_y);\n                    click_x = (click_x / WIDTH) * 2 - 1;\n                    click_y = 1 - (click_y / HEIGHT) * 2;\n                    control_points[0].emplace_back(Point(click_x, click_y));\n                    cout &lt;&lt; \"(\" &lt;&lt; click_x &lt;&lt; \" \" &lt;&lt; click_y &lt;&lt; \")\" &lt;&lt; endl;\n                }\n                else\n                {\n                    order = 0;\n                    control_points = move(vector&lt;vector&lt;Point&gt;&gt;(1, vector&lt;Point&gt;()));\n                    start = false;\n                }\n                break;\n            case GLFW_MOUSE_BUTTON_RIGHT:\n                if (!start)\n                {\n                    if (control_points[0].size() &lt;= 1)\n                    {\n                        cerr &lt;&lt; \"Control points are not enough!\" &lt;&lt; endl;\n                        break;\n                    }\n                    GeneratePointsViaT0();\n                    GenerateMiddlePoints();\n\n                    start = true;\n                    cout &lt;&lt; endl;\n                }\n                else\n                    showLine = !showLine;\n                break;\n        }\n}\n\nvoid KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mode)\n{\n    if (action == GLFW_PRESS)\n        switch (key)\n        {\n            case GLFW_KEY_ESCAPE:\n                glfwSetWindowShouldClose(window, GL_TRUE);\n                break;\n            case GLFW_KEY_T:\n                if (start)\n                {\n//                    showLine = false;\n                    cout &lt;&lt; \"t0(∈(0,1)) = \";\n                    cin &gt;&gt; t0;\n                    GeneratePointsViaT0();\n//                    showLine = true;\n                }\n                break;\n        }\n}\n\nvoid DragProcess(GLFWwindow *window)\n{\n    if (start &amp;&amp; glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n    {\n        int closest_idx = -1;\n        double dist, min_dist = 100;\n        glfwGetCursorPos(window, &amp;click_x, &amp;click_y);\n        click_x = (click_x / WIDTH) * 2 - 1;\n        click_y = 1 - (click_y / HEIGHT) * 2;\n        for (int i = 0; i &lt; order + 1; ++i)\n        {\n            dist = (click_x - control_points[0][i].x) * (click_x - control_points[0][i].x) +\n                   (click_y - control_points[0][i].y) * (click_y - control_points[0][i].y);\n            if (dist &lt; min_dist &amp;&amp; dist &lt; DRAG_SENSITIVITY)\n            {\n                min_dist = dist;\n                closest_idx = i;\n            }\n        }\n        control_points[0][closest_idx] = move(Point(click_x, click_y));\n        GeneratePointsViaT0();\n        GenerateMiddlePoints();\n    }\n}\n\nint main()\n{\n    if (!glfwInit())\n        return -1;\n    GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, \"Bézier Curve\", NULL, NULL);\n    if (!window)\n        glfwTerminate();\n    glfwMakeContextCurrent(window);\n    glfwSetKeyCallback(window, KeyCallback);\n    glfwSetMouseButtonCallback(window, MouseButtonCallback);\n\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n\n        DragProcess(window);\n\n        glClearColor(0.2, 0.1, 0.2, 1);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        if (start)\n        {\n            if (showLine)\n            {\n                glLineWidth(5);\n                for (int i = 0; i &lt; order; ++i)\n                {\n                    glColor3f(1.0 * (order - 1 - i) / (order - 1), 1.0 * i / (order - 1), 0);\n                    glBegin(GL_LINE_STRIP);\n                    for (auto &amp;p: control_points[i])\n                        glVertex2f(p.x, p.y);\n                    glEnd();\n                }\n\n                glColor3f(0, 0.7, 0.7);\n                glPointSize(10);\n                glEnable(GL_POINT_SMOOTH);\n                glBegin(GL_POINTS);\n                glVertex2f(control_points[order][0].x, control_points[order][0].y);\n                glEnd();\n            }\n\n            for (int i = 0; i &lt; control_points[0].size(); ++i)\n            {\n                glColor3f(0, 1, 0);\n                glPointSize(15);\n                glBegin(GL_POINTS);\n                glVertex2f(control_points[0][i].x, control_points[0][i].y);\n                glEnd();\n            }\n\n            glColor3f(0, 0, 1);\n            glBegin(GL_LINE_STRIP);\n            for (auto &amp;p: middle_points[order])\n                glVertex2f(p.x, p.y);\n            glEnd();\n        }\n        else\n        {\n            for (int i = 0; i &lt; control_points[0].size(); ++i)\n            {\n                glColor3f(0, 1, 0);\n                glPointSize(15);\n                glEnable(GL_POINT_SMOOTH);\n                glBegin(GL_POINTS);\n                glVertex2f(control_points[0][i].x, control_points[0][i].y);\n                glEnd();\n            }\n        }\n\n        glfwSwapBuffers(window);\n    }\n\n    glfwTerminate();\n    return 0;\n}\n\n\n☸︎ DEMO \n\n\n\n\n\n❮ Reference ❯\nOpenGL学习笔记——处理键盘输入，https://www.cnblogs.com/saltedreed/p/12321314.html\nGLFW Document，https://www.glfw.org/docs/latest/input_guide.html\n\n","slug":"Bezier-Curve：交互增强","date":"2022-04-01T12:20:10.000Z","categories_index":"计算机图形学","tags_index":"走码观花,OpenGL","author_index":"Starlit Rover"},{"id":"430d590163d20d4eee403c80b7319692","title":"Naive Bayes","content":"朴素贝叶斯是一个非常经典易懂的分类方法，其核心思想是上式即为概率论中的Bayes定理，描述了两个条件概率之间的关系，那么先让我们来回顾一下概率论的知识。\n\n\n\nα Bayes’ theorem对于计算两个事件X和Y同时发生的概率，可以由Y发生的概率与Y已发生时会发生X的概率相乘得到，即根据上式即可得如果Y有很多分属性，且分属性之间相互独立，那么可以认为Y是其所有分属性同时发生的事件，而上式则可以变形为到此Naive Bayes的理论部分就结束了，非常的简单，但你可能还是一头雾水，不要慌，go on～\n\nβ Naive Bayes用一个例子来讲解会帮助你更好地理解，下面的例子取自西瓜书。\n\n\n我们现在有一个关于西瓜的数据集（嗯，这很符合西瓜书的配置）\n\n\n很显然，这是关于如何挑一个好瓜的故事。我们可以看到上面总共有17个西瓜，这里列举了每个西瓜的六大特征，最后一列呢则是根据某人的品味对这些西瓜的好坏进行了一个主观的评判。\n那么当我们得知某个西瓜的六大特征时能否评估它（在那个人眼里的）好坏呢？显然这里的结果只会有两种，要么好要么坏。那么在我们完全凭主观判断时，其实会在潜意识里比较两者的概率。如果第六感告诉我们这个西瓜大概率是坏的，那我们就会推测它是坏的，这不失为一种感性的判断。\n如何将这种模糊判断移植到程序上呢。虽然计算机不感性，但它可以计算概率。假设我们现有一个西瓜的六大特征数据根据感性判断的思路，我们接下来需要比较的大小，其中是瓜的好坏事件，我们假定表示坏瓜事件，表示好瓜事件，那么就表示瓜在具有特征X的情况下为好/坏瓜的概率。\n接下来我们就用Bayes定理计算，你会发现我没有将分母展开，因为显然与的取值无关。因此事实上我们只需要比较分子即可，于是得到和的相对概率上式就是攻克这个问题的它山之石，我们只需分别计算右边的两部分即可。\n\n\n是显然的，17个生瓜蛋子里面有8个好瓜，9个坏瓜，因此对于每个特征的，我们只需数一下条件下的瓜里面有几个即可。比如当乌黑时，我们可以看到8个好瓜中有4个是乌黑的，因此讲的有点啰嗦，相信你已经悟了。\n\nγ Laplace Smooth其实已经结束了，这只是一个小补充。在实际的朴素贝叶斯计算过程中，由于每个概率都是&lt;1的，因此连乘后可能会得到一个很小的数以致计算机直接当0算了。为避免这个问题我们可以取对数相加解决。\n另外还有一个问题——0概率问题。有时候某个特征值在我们的已知数据集中没有出现，但我们需要对具有这个特征值的西瓜进行归类，这时就会很尴尬地发现不管是还是，。为了解决这个问题，我们引入拉普拉斯平滑，名字吓人，操作并不复杂。\n对于的计算，我们改用其中D为样本总数，为样本的数量，N为的取值个数，即最终归的类数。\n对于的计算，我们改用其中为类别下第个特征值为的个数，则为第个特征可能取值的个数。\n\n\n依本人拙见，可以这么理解，假设一个特征的每一种取值都是等可能的，那么理论上我们抽取个样本后会出现1个，因此分子的+1可以理解为我们在原样本的基础上又另外抽取了个样本。\n\nC☺DE@ train.pyimport pandas as pd\nimport numpy as np\nimport joblib as jb\n\ndata = np.array(pd.read_csv('西瓜的数据集.csv'))\nsample_num = len(data)\nattribute_num = len(data[0]) - 1\n# the size of value range of each attribute\nvalues_num = []\n# No. corresponding to each value in one attribute\ndic = [{} for i in range(attribute_num)]\n# calculate the number of possible values for each attribute via 'set'\nfor i in range(attribute_num):\n    values = set()\n    for j in range(sample_num):\n        values = values | {data[j][i]}  # union of two set\n    values_num.append(len(values))\n    # number each different value\n    No = 0\n    for v in values:\n        dic[i][v] = No\n        No += 1\n\np1_cnt = [np.zeros(values_num[i]) for i in range(attribute_num)]\np0_cnt = [np.zeros(values_num[i]) for i in range(attribute_num)]\nfor i in range(sample_num):\n    cnt = p1_cnt if data[i][attribute_num] == '是' else p0_cnt\n    for j in range(attribute_num):\n        cnt[j][dic[j][data[i][j]]] += 1\n\np1 = (sum(p1_cnt[0]) + 1) / (sample_num + attribute_num)\np0 = (sum(p0_cnt[0]) + 1) / (sample_num + attribute_num)\n\nfor i in range(attribute_num):\n    p1_cnt[i] = (p1_cnt[i] + 1) / (sum(p1_cnt[i]) + len(dic[i]))\n    p0_cnt[i] = (p0_cnt[i] + 1) / (sum(p0_cnt[i]) + len(dic[i]))\n\n# save outcome\njb.dump(p1_cnt, 'p1_cnt.pkl')\njb.dump(p0_cnt, 'p0_cnt.pkl')\njb.dump(dic, 'dic.pkl')\njb.dump(p1, 'p1.pkl')\njb.dump(p0, 'p0.pkl')\n\n@ test.pyimport joblib as jb\nimport numpy as np\nimport pandas as pd\nimport math\n\n# load trained byes model\np1 = jb.load('p1.pkl')\np0 = jb.load('p0.pkl')\ndic = jb.load('dic.pkl')\np1_cnt = jb.load('p1_cnt.pkl')\np0_cnt = jb.load('p0_cnt.pkl')\n\ntest_data = np.array(pd.read_csv('西瓜的验证集.csv'))\nsample_num = len(test_data)\nattribute_num = len(test_data[0]) - 1\n\nright_cnt = 0\n\nfor i in range(sample_num):\n    p1_pred = p0_pred = 0\n    for j in range(attribute_num):\n        p1_pred += math.log(p1_cnt[j][dic[j][test_data[i][j]]])\n        p0_pred += math.log(p0_cnt[j][dic[j][test_data[i][j]]])\n    p1_pred += math.log(p1)\n    p0_pred += math.log(p0)\n    if ('是' if p1_pred &gt; p0_pred else '否') == test_data[i][attribute_num]:\n        right_cnt += 1\n\nprint(\"正确个数：\\t%d\\n预测总数：\\t%d\\n正确率：\\t%f\" % (right_cnt, sample_num, right_cnt / sample_num))\n\n\nΣ 一些说明\n首先用集合set求出每个特征（attribute）可能取值的个数，并对每个特征内所有可能的取值进行编号（dic）\n\n然后分别计数统计好瓜和坏瓜中每个特征的每个可能取值的个数\n\n最后用拉普拉斯平滑法计算出（pi）和（pi_cnt）\n\n\n","slug":"Naive-Bayes","date":"2022-03-29T12:46:48.000Z","categories_index":"Machine Learning","tags_index":"python,走码观花","author_index":"Starlit Rover"},{"id":"d8805cb4c52676259ff97b6383bdfab8","title":"「Section 7」寻址方式","content":"\n寻址方式：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法\n\n指令寻址：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址\n顺序寻址：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址\n\n跳跃寻址：当前指令将目标指令的地址置入PC中从而实现跳转（本质上也是顺序寻址的结果）\n\n寄存器PC在开机上电后自动初始化为第一条指令地址\n\n\n\n数据寻址：确定操作数在主存中的地址\n形式地址：指令的地址码字段Addr，通常都不是真实的地址值\n\n有效地址：操作数在主存中的真实地址，由地址码字段Addr与寻址方式共同确定，记作EA\n\n\n\n\n\n数据寻址方式\n\n立即寻址：Addr即为操作数本身，立即可用。一般用于变量赋初值。\nMOV EAX,2008H\n\n直接寻址：操作数存储于主存中，Addr为其在主存中的地址，直接通过Addr访问即可得操作数。\nMOV EAX,[2008H]\n\n间接寻址：相对直接寻址而言，但Addr不是其存储地址，而是操作数的地址的地址，需要访问两次主存才可以得到操作数。\nMOV EAX,@2008H\n\n\n解决了直接寻址地址码长度受限的问题，能用较短的地址码访问较大的主存地址\n\n更加灵活，当操作数地址改变时无需改变指令只需改变Addr指向的主存单元即可\n\n\n\n寄存器寻址：操作数在CPU的某个通用寄存器中，Addr为其通用寄存器编号（通用寄存器组可以视作数组，编号即为下标），访问相应寄存器即可得操作数。\n\n寄存器的访问速度较访问主存更快\n编号长度较短，有利于缩短指令长度\n\nMOV EAX,ECX\n\n寄存器间接寻址：与间接寻址不同的是，操作数的地址存储于寄存器，Addr为该寄存器编号。\nMOV AL,[EBX]\n\n相对寻址：Addr放的是相对PC的偏移量，EA=Addr+PC（为下一条指令的地址）为操作数的有效地址。\n\n只需存储指令与操作数之间的相对距离，因此有利于实现程序的浮动\n\n\n变址寻址：变址寄存器被指定用来存放变化的地址，此时地址码字段Addr会增加一个变址寄存器编号X，X与形式地址D之和即为操作数的有效地址，。\n\n\n\nX提供修改量，D提供基准量。X的内容一直在变，而D的值一经设定执行过程中将不会变化\n主要应用于对线性表之类的数组元素进行重复的访问\n\n\n基址寻址：基址寄存器被指定来存放基地址，与变址寻址类似，多了一段基址寄存器编号B，B与形式地址D之和即为操作数的有效地址。与变址寻址不同的是，基址寄存器的值一经设定运行过程中将不会改变，此时由D来提供修改量。\n\n堆栈寻址：寻找存放在堆栈中的操作数称为堆栈寻址。根据开辟堆栈的位置可以将堆栈分为存储器堆栈和寄存器堆栈。\n\n存储器堆栈\n\n\n\n堆栈指针寄存器SP指向栈顶单元\n入栈：SP=SP-1（低地址在上），M[SP]=R\n出栈：R=M[SP]，SP=SP+1\n\n\n寄存器堆栈\n\n\n\n寄存器堆栈栈顶固定不动\n堆栈操作时，寄存器堆栈内数据整体移动\n寄存器堆栈速度快，但容量有限；存储器堆栈则速度慢，容量大\n寄存器堆栈必须采用专用的堆栈指令进行控制\n\n\n\n\n\n\n\n","slug":"寻址方式","date":"2022-03-23T01:04:09.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"bba1ccc43c803be00dfdf449eaee8924","title":"借助Flex实现SysY词法分析","content":"词法分析（lexical analysis）是编译器的第一阶段，主要是将代码的字符序列转换为token的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说int asd=897;，其词法分析的结果即为\n\nint    ：&lt; TYPE , ‘int’ &gt;\n\nasd    ：&lt; ID , ‘ast’ &gt;\n\n=        ：&lt; OPERATOR , ‘=’ &gt;\n\n897    ：&lt; DEC_CONST , 897 &gt;\n\n;        ：&lt; SEMICN , ‘;’ &gt;\n\n\ntoken的一般形式为&lt;type , literal&gt;，其中type为该词所属类型，literal则为其表值。词法分析的理论部分主要是自动机的构造以及转换，并不是太难，这里不做赘述。本篇文章主要讲述如何借助Flex工具来生成SysY语言（C语言的一个子集，具体语言定义见这）的词法分析。\n\n\n\n\n\n\n\n\n\n\nFlex的前身是Lex。Lex是1975年由Mike Lesk和当时还在AT&amp;T做暑期实习的Eric Schmidt，共同完成的一款基 于Unix环境的词法分析程序生成工具。虽然Lex很出名并被广泛 使用，但它的低效和诸多问题也使其颇受诟病。后 来伯克利实验室的Vern Paxson使用C语言 重写Lex，并将这个新的程序命名为Flex(意为Fast Lexical Analyzer Generator)。无论在效率上还是在稳定性上，Flex都远远好于它的前辈Lex。我们在Linux下使用的是Flex在GNU License下的版本，称作GNU Flex。\nFlex是一个帮助生成词法分析代码的工具，你只需告诉它目标语言中各个词法的正则表达式，Flex就会帮你生成一个lex.yy.c的C代码文件。那么首先你需要提交给Flex一个.l文件来告诉它词法规则，该文件的格式如下：\n%option xxx\n%{\n    Declarations\n%}\n    Definitions\n%%\n    Rules\n%%\n    User Subroutines\n\n第一行的option是来开启Flex自带的一些辅助功能。比如说Flex提供行号记录变量yylineno，我们可以直接通过该变量读取当前行号而且无需维护，但在默认状态下该变量不开放给用户，如需使用就要在开头加入%option yylineno。\n第二部分%{…%}中的Declarations呢，是会直接加入生成代码的靠前部分，一般是引用头文件或者是定义初始变量。\n第三部分%}…%%中的Definitions则是定义段，这里一般会为比较长的正则表达式命名以方便下一模块的描述，类似于C语言中的宏定义。正则表达式具体的语法可以参考Flex 核心规范。\n第四部分%%…%%的Rules则是该文件的核心部分——规则段。规则段就是定义需要被识别出来的词法类型（可以用第三部分中的定义来组合），以及识别到该类型时需要进行的操作。每一次Flex都会使用尽可能长的字符串进行匹配，即选择最长字符串可以匹配到的类型。但当同一个长度的字符串匹配了多个类型时，默认选择第一个匹配到的类型，因此Rules的排列也有讲究。\n第五部分User Subroutines则是用户自己的代码，会直接复制到生成代码的最后。前面词法识别规则会直接被Flex翻译为一个yylex()函数，该函数即为匹配词法类型的函数。那么如果用户需要做一些错误处理（比如识别到该语言中不存在的字符）以及部分类型识别到后需要单独处理时，就可以将处理代码写在这。\n另外，Flex还提供了两个全局变量 yytext 和 yyleng，分别表示刚刚匹配到类型的字符串与该字符串的长度。\n\n❦ SysY.l%option yylineno\n\n%{\n    #include \"translator.h\"\n%}\n\nTYPE                int|void\nKEYWORD             if|else|while|break|continue|return\nOPERATOR            \"+\"|\"-\"|\"!\"|\"*\"|\"%\"|\"/\"|\"=\"\nCOMPARISON          \"==\"|\"!=\"|\"&gt;\"|\"&lt;\"|\"&gt;=\"|\"&lt;=\"\nNONZERO             [1-9]\nDIGIT               [0-9]\nLETTER              [A-Za-z]\nOCTAL_DIGIT         [0-7]\nOCTAL_CONST         0{OCTAL_DIGIT}*\nILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z]({LETTER}|{DIGIT})*\nHEX_PREFIX          0x|0X\nHEX_DIGIT           [0-9a-fA-F]\nHEX_CONST           {HEX_PREFIX}{HEX_DIGIT}+\nILLEGAL_HEX_CONST   {HEX_PREFIX}({LETTER}|{DIGIT})*\nNONDIGIT            {LETTER}|\"_\"\nID                  {NONDIGIT}({DIGIT}|{NONDIGIT})*\nDEC_CONST           {NONZERO}{DIGIT}*  \nCOMMENT1            \"/*\"[^*]*\"*\"+([^*/][^*]*\"*\"+)*\"/\"\nCOMMENT2            \"//\".*                                                                                \n\n%%\n\n{TYPE}                  { printf(\"\\033[1;32mTYPE\\033[0m\\t\\t%s\\n\",yytext);return TYPE; }\n{OCTAL_CONST}           { printf(\"\\033[1;32mOCTAL_CONST\\033[0m\\t\");return OCTAL_CONST; }\n{ILLEGAL_OCTAL_CONST}   { return ILLEGAL_OCTAL_CONST; }\n{HEX_CONST}             { printf(\"\\033[1;32mHEX_CONST\\033[0m\\t\");return HEX_CONST; }\n{ILLEGAL_HEX_CONST}     { return ILLEGAL_HEX_CONST; }\n{DEC_CONST}             { printf(\"\\033[1;32mDEC_CONST\\033[0m\\t%s\\n\",yytext);return DEC_CONST; }\n{KEYWORD}               { printf(\"\\033[1;32mKEYWORD\\033[0m\\t\\t%s\\n\",yytext);return KEYWORD; }\n{ID}                    { printf(\"\\033[1;32mID\\033[0m\\t\\t%s\\n\",yytext);return ID; }\n{OPERATOR}              { printf(\"\\033[1;32mOPERATOR\\033[0m\\t%s\\n\",yytext);return OPERATOR; }\n{COMPARISON}            { printf(\"\\033[1;32mCOMPARISON\\033[0m\\t%s\\n\",yytext);return COMPARISON; }\n\"(\"                     { printf(\"\\033[1;32mLPARENT\\033[0m\\t\\t%s\\n\",yytext);return LPARENT; }\n\")\"                     { printf(\"\\033[1;32mRPARENT\\033[0m\\t\\t%s\\n\",yytext);return RPARENT; }\n\"[\"                     { printf(\"\\033[1;32mLBRACKET\\033[0m\\t%s\\n\",yytext);return LBRACKET; }\n\"]\"                     { printf(\"\\033[1;32mRBRACKET\\033[0m\\t%s\\n\",yytext);return RBRACKET; }\n\"{\"                     { printf(\"\\033[1;32mLBRACE\\033[0m\\t\\t%s\\n\",yytext);return LBRACE; }\n\"}\"                     { printf(\"\\033[1;32mRBRACE\\033[0m\\t\\t%s\\n\",yytext);return RBRACE; }\n\";\"                     { printf(\"\\033[1;32mSEMICN\\033[0m\\t\\t%s\\n\",yytext);return SEMICN; }\n\",\"                     { printf(\"\\033[1;32mCOMMA\\033[0m\\t\\t%s\\n\",yytext);return COMMA; }\n\"&amp;&amp;\"                    { printf(\"\\033[1;32mAND\\033[0m\\t\\t%s\\n\",yytext);return AND; }\n\"||\"                    { printf(\"\\033[1;32mOR\\033[0m\\t\\t%s\\n\",yytext);return OR; }\n{COMMENT1}|{COMMENT2}   { }\n[ \\t\\n]                 { }\n.                       { return UNEXPECTED; }\n\n%%\n\nint main()\n{\n    int token_type;\n    while (token_type = yylex())\n    {\n        if (token_type == UNEXPECTED)\n            printf(\"\\033[1;31mError type A at Line %d: Invalid character \\\"%s\\\"\\033[0m\\n\", yylineno, yytext);\n        else if (token_type == OCTAL_CONST)\n        {\n            int sum = 0;\n            for (int i = 1; i &lt; yyleng; ++i)\n                sum = sum * 8 + (yytext[i] - '0');\n            printf(\"%d\\n\", sum);\n        }\n        else if (token_type == HEX_CONST)\n        {\n            int sum = 0;\n            for (int i = 2; i &lt; yyleng; ++i)\n            {\n                if (yytext[i] &lt;= '9' &amp;&amp; yytext[i] &gt;= '0')\n                    sum = sum * 16 + (yytext[i] - '0');\n                else\n                {\n                    switch (yytext[i])\n                    {\n                    case 'a':\n                    case 'A':\n                        sum = sum * 16 + 10;\n                        break;\n                    case 'b':\n                    case 'B':\n                        sum = sum * 16 + 11;\n                        break;\n                    case 'c':\n                    case 'C':\n                        sum = sum * 16 + 12;\n                        break;\n                    case 'd':\n                    case 'D':\n                        sum = sum * 16 + 13;\n                        break;\n                    case 'e':\n                    case 'E':\n                        sum = sum * 16 + 14;\n                        break;\n                    case 'f':\n                    case 'F':\n                        sum = sum * 16 + 15;\n                        break;\n                    }\n                }\n            }\n            printf(\"%d\\n\", sum);\n        }\n        else if (token_type == ILLEGAL_OCTAL_CONST)\n            printf(\"\\033[1;31mError type B at line %d: Illegal octal number \\'%s\\'\\033[0m\\n\", yylineno, yytext);\n        else if (token_type == ILLEGAL_HEX_CONST)\n            printf(\"\\033[1;31mError type B at line %d: Illegal hex number \\'%s\\'\\033[0m\\n\", yylineno, yytext);\n    }\n}\n\n\n☕︎ 一些说明\n“translator.h”头文件内对需要识别的词法类型（TYPE，OCTAL_CONST，…）进行了enum枚举，本质上就是整数\n第四部分中引用第三部分定义的名字时需要注意在引用名字外面加上{大括号}，否则会变成识别一段字符串\nprintf中的【\\033[1;32m…\\033[0m】是将中间文字上色🎨\n正则表达式中对于注释的识别是一个比较棘手的问题。\n对于单行注释，我们知道开头是“//”，后面需要将该行剩余所有字符都匹配掉，注意到点可以匹配非换行符的任意字符（.==[^\\n]），那么点的Kleene闭包.*即可匹配该行剩余所有字符了\n对于多行注释，我们知道开头是“/*”，中间部分只要不出现“*/”即可。那么我们可以考虑将中间部分（包括结尾“*/”中的“*”）分为多段以“**···*”（）结尾的字符串，每一段的结尾前面都不能出现“*”。那么每一小段都可以先写为[^*]*\"*\"+（⚠️“*”仅表示字符，*表示前面部分的Kleene闭包）。但是每一段连起来的时候不能出现“*/”，因此每一小段的开头都不能是“/”，这时则可以写为[^/*][^*]*\"*\"+。然而第一小段以“/”开头却是没关系的（/*/不是一个完整的注释），因此第一小段单独写为[^*]*\"*\"+。最终多行注释的正则表达式即为\"/*\"[^*]*\"*\"+([^/*][^*]*\"*\"+)*\"/\"。\n\n\n第五部分主要实现了八进制与十六进制的转换，以及一些错误处理，包括识别非法八进制、十六进制字符和非法字符的报错\n八进制与十六进制的非法字符识别是另外定义了两个类型ILLEGAL_OCTAL_CONST与ILLEGAL_HEX_CONST，分别置于第四部分中OCTAL_CONST和HEX_CONST的后面。这样一来如果更长的字符串匹配到了ILLEGAL类型就会返回ILLEGAL，而正确的格式只会匹配前者。\nyylex()函数每次匹配一段字符串，若匹配成功则执行该类型后面的操作，操作中如无return语句则继续识别，如有return语句则返回main函数\n\n\nTest.cint main()\n{\n    int abc = 0123, bb = 0x12d23p, c = 0987, di = 0x45Fc1;\n    if (abc &gt;= bb) // hello\n        while (di == 1)\n            return 8;\n    /*This is a test\n      This is a test\n    */\n    $\n}\n\nCast Magic 🪄flex SysY.l                    \nclang lex.yy.c -ly -ll\ncat test.c|./a.out\n\nOutput\n\n\n\n\n∂ 一个小坑第四部分中我一开始将{KEYWORD}放在{ID}的后面，执行Flex的时候一直报错\nSysY.l:36: warning, rule cannot be matched\n\n很迷，当时改来改去这个warning就一直跟着{KEYWORD}跑，只有行号在变化。\n这条warning的意思应该是无法匹配{KEYWORD}这条规则。\n仔细想想，{KEYWORD}匹配的都是关键字，那么为什么关键字会成为关键字呢？因为在一开始的时候就被{KEYWORD}匹配到了，从而用户不能用关键字来定义变量名。这时候一看{ID}果然放在{KEYWORD}前面，显然{KEYWORD}是{ID}的一个子集，因此{ID}匹配完后{KEYWORD}就是光杆司令一个了。\n","slug":"借助flex实现SysY词法分析","date":"2022-03-22T10:49:25.000Z","categories_index":"编译原理","tags_index":"走码观花","author_index":"Starlit Rover"},{"id":"fbbac3b5688cf257c824005fed6d10e6","title":"Build Qt in arm64","content":"♿︎ 引言自从电脑换成Mac后就需要面对芯片架构不同带来的众多问题，市场上还是有很多软件只适配x86而不支持arm。当然这段时间我体验下来，arm架构采用的是精简指令集，在续航方面全面吊打x86，一般来说不插电工作一天绰绰有余。当然缺点也很明显，就是软件市场依然不是很友好，比如说VS（坦白地说，VS for mac就是微软做出来嘲笑苹果的）。虽然很多软件表示已经在开发arm版，但还是需要一定时间的。这也是本文存在的原因。\n\n\n导师那边有个框架之前我都是在老电脑的VS上用的（之前也只有VS版），然而最近发布的新版本使用了CMake。众所周知，CMake是一款跨平台编译工具，像CLion就是使用CMake进行编译的。Mac人狂喜，然而被学长告知框架所需的Qt目前只支持x86，arm版的需要自己编译。可以自己编译的关键一点是，Qt是开源的，我们可以获得其源码。那么简单地来说，虽然直接下载下来的Qt是x86版的，但只要将其源码在自己电脑编译一遍，生成的就是适配自己电脑的版本啦。\n这就不得不提到makefile文件。该文件是Linux下的一个工程管理文件，类似CMake文件，指出了如何编译软件的规则，有着自己专门的语法。但我目前也不是很了解，只是刚刚入门，以后有机会的话再讲吧。\n\n版本信息\nQt 5.15.2\nCLion 2021.3.4\nMacOS Monterey 12.3\n\n\n⩙ BUILD\n打开terminal，使用homebrew（默认已有）安装依赖项\nbrew install pcre2 harfbuzz freetype\n#下面这一项可能不需要，保险起见就安上\nbrew install cmake ninja python\n\n下载Qt 5.15.2的源码，通道在此\n\n假设下载的压缩包qt-everywhere-src-5.15.2.tar.xz所在文件夹的绝对路径为path，在terminal内\ncd path\n#解压压缩包\nx qt-everywhere-src-5.15.2.tar.xz\n#创建文件夹buildir\nmkdir buildir\ncd buildir\n#设置arm64版编译并生成makefile\n../qt-everywhere-src-5.15.2/configure -release -prefix ./outDir -nomake examples -nomake tests QMAKE_APPLE_DEVICE_ARCHS=arm64 -opensource -confirm-license -skip qt3d -skip qtwebengine\n#接下来会生成很多命令，不用管\n\n在make命令之前我们需要消除两个问题（当然直接打开文件改也行，下面是在terminal中用vim修改）\n\n首先打开第一个更改文件，path是上面那个绝对路径\nvim path/qt-everywhere-src-5.15.2/qtbase/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h\n\n找到下面的语句块\n#include &lt;qpa/qplatformgraphicsbuffer.h&gt;\n#include &lt;private/qcore_mac_p.h&gt;\n\n进入vim的插入模式，在该语句块前加上\n#include &lt;CoreGraphics/CGColorSpace.h&gt;\n\n最后应该是这样子的\n\n\n改完后保存退出：esc+输入:wq\n\n打开第二个更改文件\nvim path/qt-everywhere-src-5.15.2/qtlocation/include/QtLocation/5.15.2/QtLocation/private/../../../../../src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h\n\n输入:set number后显示行号，然后将523行处的typedef struct {改为typedef struct MapPolylineEntry {，改完后保存退出\n\n\n\n接下来开启所有进程进行编译\n#在buildir目录下\nmake -j$(nproc)\n\n上步完成后开始安装\nmake install -j$(nproc)\n\n安装完成后可以把和buildir同层目录内的qt-everywhere-src-5.15.2.tar.xz与qt-everywhere-src-5.15.2给删了\n\n此时arm64版Qt算是安装完成（buildir），接下来（可以忽略）是在CLion上的iGameMeshView工程中使用Qt\n\n修改iGameMeshView的cmake文件\n# MacOS\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"AppleClang\")\n    message(STATUS \"编译器是AppleClang\")\n    #设置QT的目录\n    set(Qt5Core_DIR path/buildir/outDir/lib/cmake/Qt5Core)\n    set(Qt5Gui_DIR path/buildir/outDir/lib/cmake/Qt5Gui)\n    set(Qt5OpenGL_DIR path/buildir/outDir/lib/cmake/Qt5OpenGL)\n    set(Qt5Widgets_DIR path/buildir/outDir/lib/cmake/Qt5Widgets)\n\n完成\n\n\n\n「Reference」\nQt5适配M1：https://www.cnblogs.com/wqcwood/p/15138983.html\n\n[Qt] Fix missing Cocoa include：https://github.com/microsoft/vcpkg/pull/21056/commits/99582d154236b0e7af70cadef8420c4f25829f61\n\n\n\n\n\n❃ 特别鸣谢CJgg两节课的耐心讲解 /doge","slug":"Build-Qt-in-arm64","date":"2022-03-19T02:32:08.000Z","categories_index":"血泪史","tags_index":"arm64","author_index":"Starlit Rover"},{"id":"03afcc3b07031cb1f7cc8d70de23254b","title":"「Section 6」指令系统","content":"α. 指令系统概述\nβ. 指令格式\nγ. 操作数类型\n\n\n\nα 指令系统概述\n现代冯·诺伊曼计算机结构框图是以存储器为中心，计算机的工作过程就是循环往复地取指令、分析指令、执行指令的过程。\n\n\n一些概念\n\n计算机指令：指示计算机硬件进行某种操作的命令。\n\n机器指令（机器字）：使用二进制来表示计算机指令，能被计算机硬件识别并执行的01代码串。\n\n机器语言：机器指令编写程序的规范，是计算机硬件的系统语言。\n\n机器语言程序：机器指令的有序集合，具有特定功能。\n\n指令系统：一台计算机所有机器指令的集合。\n\n\n汇编指令：机器指令的代码助记符，与机器指令几乎一一对应。\n\n微指令：指在机器的一个CPU周期中，一组实现一定操作功能的微命令的组合，属于硬件层面。若干条微指令可以构成一个微程序，而一个微程序就对应了一条机器指令。\n\n\n\n不同级别指令之间的关系\n\n\n\n高级语言与汇编语言指令属于软件层面，而机器指令与微指令则属于硬件层面\n一条高级语言被编译为多条机器指令\n汇编指令与机器指令一一对应\n一条机器指令则依赖于多条微指令的执行\n\n\n指令所包含的信息\n\n指令功能：要执行的操作，一般有运算、传送、移位、跳转等。\n操作对象：要处理或参加运算的数据，称为源操作数。\n操作的结果：存放运算或处理结果的数据，称为目的操作数（⚠️目的操作数也可以为源操作数）。\n下一条指令地址：下一条指令在主存中的地址。\n\n\n指令集体系架构(ISA)：处理器所支持的指令集（汇编指令集及机器指令编码）及其操作数的相关信息（寄存器、存储器、I/O等）\n\n作用：在系统软件设计者和处理器硬件设计者之间提供了一个抽象层\n软件设计者：依据ISA知道如何编写机器语言程序来控制与使用处理器硬件\n硬件设计者：依据ISA来设计微体系结构，并实现能执行机器语言的处理器硬件\n\n\n内容\n★可执行的指令集合，包括指令格式、指令类型、指令功能、指令编码等\n指令可以接受的数据类型\n操作数可以存放的寄存器组和结构\n操作数所能存放的存储空间（存储器和I/O）大小、编址方式、大小端模式等\n指令获取操作数的方式，即数据寻址方式\n指令执行的控制方式，即指令寻址方式，包括程序计数器、条件码定义等\n\n\n\n\n\n\nβ 指令格式\n基本格式：操作码字段（OP）+地址码字段（A）\n\n位二进制操作码最多表示种指令\n地址码用于寻找操作数或下一条指令地址\n\n\n指令寻址方式\n\n程序中的机器指令序列在主存中往往按顺序存放\nCPU使用程序计数器PC（Program Counter）来存储指令地址\n下一条指令地址可以由指出\n转移类指令（即非顺序执行语句，如循环等）依旧读取处指令，只是该指令是跳转指令\n\n\n指令字长：一条机器指令的位数\n\n机器字长：计算机一次能处理的二进制数据的位数\n短格式指令：指令字长≤机器字长，节省空间；长格式指令：指令字长&gt;机器字长，包含更多操作信息（⚠️两者可并存于一个指令系统）\n定长指令系统：所有指令字长相等，一般都等于机器字长，结构简单；变长指令系统：指令字长不固定，通常取字节的整数倍，冗余状态少，结构灵活（单字长指令：指令字长=机器字；双字长指令：指令字长=机器字长*2）\n\n\n地址码：用来寻找执行指令所需要的操作数（分为源和目的操作数）或者下条指令地址，地址码的含义取决于寻址方式。\n\n三地址指令：OP｜A1｜A2｜A3，(A1) OP (A2) →A3\n\n二地址指令：OP｜A1｜A2，(A1) OP (A2) →A1\n\n单地址指令：OP｜A，(AC) OP (A) →AC（AC为隐含操作数） or OP(A)→A（单目运算）\n\n零地址指令：OP，无需操作数如占位和延时而设置的空操作指令NOP、等待指令WAIT、停机指令HALT等，或是隐含操作数的单目运算符\n⚠️上述四种指令可以并存于一个指令系统\n\n\n\n\n\nγ 操作数类型\n根据操作数的存放位置进行分类\n\n立即数类型：操作数是常数，存放在指令的地址字段A上（指令存放在主存 [⚠️即为内存] 中）\n寄存器类型：操作数存放在CPU的通用寄存器中，A为寄存器编号/地址\n存储器类型：操作数存放在主存中，A为其地址信息（取决于寻址方式）\nI/O数据类型：操作数存放在I/O设备接口中，A为其端口地址Port\n\n\n根据操作数的物理含义进行分类\n\n数值数据：整数、浮点数、十进制数，带符号数/ 无符号数\n\n指针/地址：指存储器地址，由访问存储器的指令计算出（⚠️是无符号整数）\n\n位或位串数据：一般用于表示标志位、状态位、控制位等信息\n\n字符或者字符串：一般用于表示文本信息，包括西文字符(ASCIl码）和中文字（内码）等\n\n逻辑数据：用0/1表示真/假的逻辑值，通常用于条件转移指令中对条件码的检测\n⚠️仅根据操作数的二进制代码则无法进行区分其具体的含义\n\n\n\n\n","slug":"指令系统","date":"2022-03-16T01:57:48.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"b75f95681a59c62b9564ea4a8f3a4ec9","title":"「1015」Reversible Primes","content":"➳ENTRY\nA reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.\nNow given any two positive integers  and  (1&lt;≤10), you are supposed to tell if  is a reversible prime with radix .\n\n\nInput Specification:The input file consists of several test cases. Each case occupies a line which contains two integers  and . The input is finished by a negative .\nOutput Specification:For each test case, print in one line Yes if  is a reversible prime with radix , or No if not.\nSample Input:73 10\n23 2\n23 10\n-2\n\nSample Output:Yes\nYes\nNo\n\n\nΩ极简翻译：给出好几组数，一组一行。一组数包含一个十进制数和一个进制数，如果是一个素数且在进制下的反转数也是素数，那么便输出Yes，反之输出No。最后以一个负数表示结束。\n\n\n    《日常水文章系列》\n⚠️本题唯一需要注意的地方是判断素数一定要考虑1。\n对于在进制下求的十进制反转数，由于出来的依次是反转数的最高位到最低位，因此用一个循环即可：\nint rn=0;\nwhile(n&gt;0)\n{\n  rn=rn*d+n%d;\n  n/=d;\n}\n\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    int m = sqrt(n);\n    if (n == 1) return false;\n    for (int i = 2; i &lt;= m; ++i)\n        if (n % i == 0)\n            return false;\n    return true;\n}\n\nint main()\n{\n    int n, d;\n    cin &gt;&gt; n;\n    while (n &gt; 0)\n    {\n        cin &gt;&gt; d;\n        if (!isPrime(n))\n            cout &lt;&lt; \"No\" &lt;&lt; endl;\n        else\n        {\n            int rn = 0;\n            while (n &gt; 0)\n            {\n                rn = rn * d + n % d;\n                n /= d;\n            }\n            cout &lt;&lt; (isPrime(rn) ? \"Yes\" : \"No\") &lt;&lt; endl;\n        }\n        cin &gt;&gt; n;\n    }\n}","slug":"1015-Reversible-Primes","date":"2022-03-15T08:02:21.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,prime","author_index":"Starlit Rover"},{"id":"be23bf1b6bcf5e89051d9bbdaa72f245","title":"「1014」Waiting in Line","content":"➳ENTRY\nSuppose a bank has  windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are:\n\nThe space inside the yellow line in front of each window is enough to contain a line with  customers. Hence when all the  lines are full, all the customers after (and including) the  one will have to wait in a line behind the yellow line.\nEach customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number.\n will take  minutes to have his/her transaction processed.\nThe first  customers are assumed to be served at 8:00 am.\n\n\n\nNow given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done.\nFor example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning,  is served at  while  is served at .  will wait in front of  and  will wait in front of .  will wait behind the yellow line.\nAt 08:01,  is done and  enters the line in front of  since that line seems shorter now.  will leave at 08:02,  at 08:06,  at 08:07, and finally  at 08:10.\nInput Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers:  (≤20, number of windows),  (≤10, the maximum capacity of each line inside the yellow line), K (≤1000, number of customers), and Q (≤1000, number of customer queries).\nThe next line contains K positive integers, which are the processing time of the K customers.\nThe last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K.\nOutput Specification:For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead.\nSample Input:2 2 7 5\n1 2 6 4 3 534 2\n3 4 5 6 7\n\nSample Output:08:07\n08:06\n08:10\n17:00\nSorry\n\n\nΩ极简翻译：银行有个窗口，每个窗口前最多排个人，共有个顾客，每个顾客的事务处理时间都是知道的，其中个顾客来查询自己的结束时间。当窗口未排满的时候，顾客会前往人数最少的窗口，若有多个人数最少的窗口则去编号最小的；当所有窗口都排满时，后面的顾客需等在黄线后直到有顾客完成离开窗口。\n\n\n很显然，本题考查的是队列queue，然后考虑的东西有一点多：\n\n前位顾客按窗口编号从小到大依次排列，不考虑处理时间\n后的顾客则看哪个窗口的第一个（⚠️不是最后一个）顾客最先完成事务就去哪个\n顾客数量并不一定会完全填充满窗口\n同一时刻如果有多个窗口空出来黄线外的第一位顾客前往编号最小的窗口\n若顾客开始处理事务的时间（⚠️不是处理完成时间）≥17:00，那么不受理该顾客的事务\n\n因此我们需要用队列存储每个窗口排队的客户编号来获知每个时刻窗口第一个顾客是谁，另外当我们把一个顾客分配至一个窗口时该顾客的结束时间便已经确定。对于黄线外第一位顾客的窗口选择问题，我们只需要比较当前每个窗口的第一位顾客结束时间，然后分配至结束时间最早的窗口即可。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, q, t, c;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;\n  //proc_time：每个顾客的事务所需时间，end_time：每个顾客的事务完成时间\n  //line_time：每个窗口最后一位顾客的结束时间，fill_time：每个窗口当前第一位顾客的结束时间\n  vector&lt;int&gt; proc_time(k), end_time(k), line_time(n, 480), fill_time(n, 0);\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; t;\n        proc_time[i] = t;\n    }\n  //黄线内的实际顾客数\n    int inline_num = min(n * m, k);\n  //每个窗口的排队队列\n    vector&lt;queue&lt;int&gt;&gt; line(n);\n  //黄线内顾客的窗口分配\n    for (int i = 0; i &lt; inline_num; ++i)\n    {\n        line[i % n].push(i);\n        end_time[i] = line_time[i % n] += proc_time[i];\n    }\n  //如果每个窗口都满了（k≥mn）\n    if (inline_num &lt; k)\n    {\n      //初始化每个窗口第一位顾客的结束时间\n        for (int i = 0; i &lt; n; ++i)\n        {\n            fill_time[i] += proc_time[line[i].front()];\n            line[i].pop();\n        }\n      //分配黄线外的顾客\n        for (int i = inline_num; i &lt; k; ++i)\n        {\n          //求最早空出位置的窗口编号\n            int win = int(min_element(fill_time.begin(), fill_time.end()) - fill_time.begin());\n            end_time[i] = line_time[win] += proc_time[i];\n            fill_time[win] += proc_time[line[win].front()];\n            line[win].pop();\n            line[win].push(i);\n        }\n    }\n    for (int i = 0; i &lt; q; ++i)\n    {\n        cin &gt;&gt; c;\n      //考虑每个顾客开始处理的时间=结束时间-处理时间\n        if (end_time[c - 1] - proc_time[c - 1] &gt;= 1020)\n            cout &lt;&lt; \"Sorry\" &lt;&lt; endl;\n        else\n            printf(\"%02d:%02d\\n\", end_time[c - 1] / 60, end_time[c - 1] % 60);\n    }\n}\n\n\n⚡︎ 算法说明\n所有时间都先按分钟计算，最后转为时间\n给黄线外的第一个顾客分配完窗口后，需要更新该窗口第一个顾客的结束时间\nmin_element(fill_time.begin(), fill_time.end())找到的是最左边最小值的迭代器，因此符合当有多个最小人数窗口时选择编号最小的要求\n\n","slug":"1014-Waiting-in-Line","date":"2022-03-15T03:27:08.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,queue","author_index":"Starlit Rover"},{"id":"d89b7bb9a5cb29131093afe1032ded19","title":"「Section 5」定点运算器（&浮点加减）","content":"由前几节的内容我们知道计算机中的各类算术运算都可以由最基本的定点加法与移位运算迭代实现，那么我们只要将逻辑运算、移位运算、各种算术运算的数字逻辑电路实现集成在一起就可以构成CPU中的运算器。运算器具体可以分为定点运算部件和浮点运算部件，本节主要介绍又称为算术逻辑运算单元的定点运算部件。\nα. 定点运算器\nβ. 浮点数的加减运算\n\n\nα 定点运算器\n基本组成\n\n算术逻辑运算单元ALU：核心部件，实现算术运算和逻辑运算\n\n\n暂存器：用来存放参与计算的数据及运算结果，它只对硬件设计者可见，即只被控制器硬件逻辑控制或微程序所访问。\n\n\n\n通用寄存器堆：用于存放程序中用到的数据，它可以被软件设计者所访问。\n内部总线：用于连接各个部件的信息通道。为避免数据冲突，同一时刻（在一个CPU周期内）总线上只能传输一个数据。\n\n\n基本结构\n\n单总线结构1\n\n\n\n由于总线一次只能传输一个数据，而ALU有两个操作数，且只有两个操作数同时出现在输入端ALU才能正确运算出结果，因此需要在ALU的输入端放置两个暂存器\n\n需要3步：\n其中为寄存器，IB为总线（internal bus），LA/B为暂存器\n\n缓冲器是CPU可以操控的一个阀门，打开时数据可以通过。由于ALU是一个组合逻辑电路，时刻都在运算，因此如果没有缓冲器那么总线将一直被ALU的输出所占用\n\n\n\n单总线结构2\n\n\n\n与前者相比暂存器，但总数未变\n需要3步：\n\n\n双总线结构1\n\n\n\nALU+1个暂存器\n\n只有可以将数据送回GR，因此LC只能连接\n\n总共需要两步：\n\n\n\n\n\n\n\n       \n\n\n\n双总线结构2\n\n\n\n与前者相比暂存器，总数未变\n总共需要两步：\n\n\n三总线结构\n\n\n\n旁路器的作用是不通过ALU实现通用寄存器GR内的数据传输\n速度是上述所有结构中最快的（因为步骤最少）\n仅需1步：\n\n\n\n\n       \n\n\n\n标志寄存器：ALU的输出除运算结果外，还包括若干状态标志位\n\nZF：零标志。运算结果为0，ZF=1，其余情况ZF=0\n\nCF：加法进位()/减法借位()/逻辑左移溢出标志位，仅对无符号数运算有意义\n⚠️无符号数的减法依旧是对减数取反+1再与被减数相加。假设无符号数位是，那么减数的补码可以认为是，若加上被减数后最高位没有产生进位（产生进位才能真正地把跨过去），那么事实上最终结果依旧停留在负数域 （），并没有完全跨过y，那么运算的最终结果将会是一个比都大的无符号数。希望下图能帮助你理解\n\n\nOF：溢出标志，只针对有符号数的加减运算是否溢出（一般指上溢）\n\nSF：符号标志，只针对有符号数\n\nPF：奇偶标志，反映运算结果中“1”个数的奇偶性，偶1奇0\n\n\n\nβ 浮点数的加减运算浮点数的加减运算不难，因此简单说一下。\n\n对阶\n\n小阶向大阶看齐，从而小阶位数看齐时右移舍去小位以减小误差\n小阶位数右移时先保留移出的最低位，称为保留附加位。保留附加位参与中间运算以提高运算精度。运算结束后规格化再舍入。\n\n\n尾数运算：一般采用双符号位进行运算\n\n结果规格化\n\n尾数需要右归操作：尾数运算结果上溢（符号位为01/10）\n尾数需要左归操作：尾数运算结果有前导0\n\n\n舍入\n\n向上/下舍入：总是朝+/-∞舍入\n向0舍入：朝数轴原点舍入\n就近舍入：0舍1入\n\n\n\n\n\n","slug":"定点运算器","date":"2022-03-14T03:08:02.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"74debfb0a3b8fd019ca9b40b7b9af159","title":"「1013」Battle Over Cities","content":"➳ENTRY\nIt is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.\nFor example, if we have 3 cities and 2 highways connecting  and . Then if  is occupied by the enemy, we must have 1 highway repaired, that is the highway .\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.\nOutput Specification:For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.\nSample Input:3 2 3\n1 2\n1 3\n1 2 3\n\nSample Output:1\n0\n0\n\n\nΩ首先极简翻译一波。简单的说就是，有一些城市，部分城市之间连有高速公路。当一个城市被敌人占领后，与其相连的高速公路都无法通行，但要求其余城市必须是连通的，试问最少需要搭几条高速公路。\n乍看题目有点迷，其实只需要求剩余城市的连通分图数即可。若剩余城市含个连通分图，那么显然最少只需条边即可将所有剩余城市相连。\n我采取的是Alg. BFS（广度优先搜索）的思想，按顺序遍历每一座城市，然后将与这座城市相连的城市进行标记，接着再将与这些城市相连的城市进行标记，逐层递归，直至相连的城市数量为0。当然对于被敌人占领的那一座城市我们需要在一开始对其就进行标记，从而后面递归的时候就无法从这座城市经过。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, a, b;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n  //记录高速公路\n    map&lt;int, vector&lt;int&gt;&gt; connect;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        connect[a].push_back(b);\n        connect[b].push_back(a);\n    }\n  //标记变量\n    vector&lt;bool&gt; mark(n + 1);\n    int city, num;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; city;\n        num = 0;\n        fill(mark.begin(), mark.end(), false);\n        mark[city] = true;\n        for (int j = 1; j &lt;= n; ++j)\n        {\n            if (mark[j])\n                continue;\n          //mark[j]=false说明是一个新的连通分图\n            num += 1;\n          //cup存储与next中城市相连的城市\n            set&lt;int&gt; next{j}, cup;\n            while (!next.empty())\n            {\n                for (auto &amp;c: next)\n                    if (mark[c])\n                        continue;\n                    else\n                    {\n                        mark[c] = true;\n                        cup.insert(connect[c].begin(), connect[c].end());\n                    }\n                next = cup;\n                cup.clear();\n            }\n        }\n        cout &lt;&lt; num - 1 &lt;&lt; endl;\n    }\n}\n\n\n⚡︎ 算法说明\n使用map可以直接通过城市序号访问与其相连的城市vector\nfill(mark.begin(), mark.end(), false);将mark迭代器中的值全部填充为false\n用set记录与当前城市相连的城市可以避免重复\ncup.insert(connect[c].begin(), connect[c].end());将vector&lt;int&gt; connect[c]中的值插入到set&lt;int&gt; cup的尾部\n本题也可以采用Alg. DFS（深度优先搜索），详情可见柳婼 の blog\n\n","slug":"1013-Battle-Over-Cities","date":"2022-03-12T11:09:43.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,set,BFS,Graph","author_index":"Starlit Rover"},{"id":"4b69eccade1977efb8c2be2f48efdb06","title":"「Section 3」关系模型","content":"\n关系模型的主要术语\n\n关系（表）：一个关系可用一个表来表示，每个关系都有唯一的名称。\n属性：表（关系）中的每一列即为一个属性，一个表内的属性名都是唯一的，且都显示在行首。\n域：可以认为是属性的定义域。\n元组：表中的一行数据称为一个元组，即一个实体所有属性值的总称。同样的，一个表中的元组都是唯一的。\n\n\n\n\n分量：一个元组在一个属性上的值称为元组在该属性上的分量。\n\n候选码：可以唯一（一一映射）标志元组的属性（组）\n\n主码：其中一个被选定的候选码，每个表唯一。\n\n主属性：在候选码中的属性称为主属性，反之称为非主（码）属性。\n\n外部码：关系的非码属性与关系的码相对应，则称为的外部码。可以与相同，与的域一定相同。（可以认为需要从的码值中选取）\n\n关系模式：一个关系的关系名及其全部属性名的集合称为该关系的关系名，即\n【关系名（属性名1，属性名2，... ，属性名n）】\n\n\n关系的六个基本性质\n\n关系中每个属性具有原子特性，是基本数据项，不可再分\n同一属性属于同一列\n不同的列（属性）可以拥有相同的域\n列（属性）的次序可以相互交换\n行（元组）的次序也可以相互交换\n一个关系中不能有两个相同的元组（行）\n\n\n关系模型的数据操作\n\n操作对象和操作结果都是关系。其理论标准为关系代数和关系演算。\n存取路径对用户隐蔽，用户只需指出操作，而不必考虑如何操作。存取路径是由RDBMS（Relational Database Management System，关系数据库管理系统）自动选择的，提高了数据的独立性。\n\n\n关系的完整性约束：规定了数据必须符合的条件\n\n实体完整性：在主属性上的分量不能为空（实际系统中没有候选码的概念，因此变为任意关系的主码不能为空）\n参照完整性：中的外部码只能取空值或者中某元组的码值（）。这是对关系之间引用数据的一种限制。\n用户定义的完整性：每个数据库都有自己独有的约束要求，比如年龄不能大于60岁等\n\n\nE-R模型向关系模型的转化\n\n实体集：直接转\n\n联系集R\n\nR单独的属性转化为该关系的属性\nR涉及的每个实体集的码属性转化为该关系的属性\n如何选定该关系的码(※)\n若R为1:1的联系，每个相关实体的码均可以作为该关系的码\n若R为1:n的联系，则关系的码为n那一端实体的码\n若R为m:n的联系，则关系的码为相关实体集码的集合\n\n\n拥有相同码的不同关系（表）实质上是同一个实体集，因此可以合并，合并后的关系的属性是两个实体集的所有属性\n根据该规则会发现最后联系留下来的关系只有m:n的才需要建立实体集，从而(※)变为\n若R为1:1的联系，无需建立关系，直接在任意一方的关系属性中加入另一方的码即可\n若R为1:n的联系，无需建立关系，直接在n方关系属性中加入1方的码\n若R为m:n的联系，需要建立关系，而且以双方关系的码的集合作为该关系的码，其余属性为其本身自带属性\n\n\n\n\n\n\nExample\n\n\n\n\n","slug":"关系模型","date":"2022-03-09T13:28:00.000Z","categories_index":"数据库原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"22f37ab474c466341b4a621e124d19bc","title":"「Section 4」定点数的乘除法实现","content":"☙ 定点乘法运算Σ 原码一位乘法原原，其中为符号位。\n\n符号位单独运算：\n\n绝对值部分的数值运算\n\n我们平常列竖式计算的方式实质上可以看成等式\n\n\n只不过平常我们列竖式的对象是十进制。在列竖式的过程中，我们用的每一位去乘，但无需去关注，这是因为我们通过每次将部分积（）左移一位并且省去了末尾的0才实现的，左移的过程就是，而末尾的0对结果无影响因此可以省略，如下图所示\n\n\n我们如何让计算机实现上述操作呢？首先我们可以将第一个乘数保存下来，然后我们需要让的每一位去乘，乘完之后就将右移一位，从而可以保证每次都用的最小位去乘。另外我们需要将部分积进行累加，累加的结果就存放在，然而每一次乘出来的部分积都是位，并没有””，即末尾的0。在手列竖式时我们通过将部分积左移来体现””，同样的，我们可以将累加结果右移然后直接加上4位部分积来实现，这只是一个相对运动。\n\n注意到上述过程中有两个值是需要右移的，其一是，其二是，因此我们可以将它们两个连在一起进行右移，接下来是的原码一位乘法说明\n\n\n\n部分积之和与乘数是连在一起右移的\n部分积运算时的符号位不是最终的符号位，但放在这里可以保留溢出位，当整体右移时溢出位会到最高位（见最后一步）\n考虑符号位后最终结果的原码就应该是\n\n\n\n\n硬件实现\n\n\n\n计数器来控制循环次数，从减到0说明完成原码一位乘法\n当计数器减到0时，连接着的清零端使D触发器归0从而与clock的与门输出为0，此时电路不工作\n的最后一位决定部分积是还是，因此控制逻辑即是与被乘数的与门\n\n\n\nΠ 阵列乘法器这个乘法器思想比较单纯，直接上图\n\n\n这个样子就非常符合我们手列竖式的样子了，事实上也确实是这样的一个想法。上图是两个四位无符号定点整数的乘法。\n\n将两个乘数的任意两位进行相乘得到位乘积，由于只是二进制个位数的乘法，因此用与门即可解决\n传递进位的方式与列竖式不同，每一个全加器FA都将自己的进位传递给下一层的隔壁位，本质上跟竖式差不多\n全加器共有个，每个FA计算上面FA的输出，当前位乘积还有右上角的进位之和，因此每一列最上面的位乘积不需要FA\n每一层之间存在延时，因为需要等待进位数，一层中的FA是同步的\n相对原码一位乘法来说效率更高\n\n\n☙ 定点除法运算除法与乘法类似，符号位单独运算，只考虑绝对值的除法。而除法中我们时常需要比较余数添0后与除数的大小，在计算机中只能通过减法进行比较，当减法结果为负数时我们又根据是否恢复余数将除法细分为原码恢复余数法和原码不恢复余数法。接下来是用两种方法计算的说明，这里为位（不带符号位）定点小数。\nα 原码恢复余数法\n初始余数，计算补\n\n❶ 若则商0并重新得到（⚠️本次余数依然为，只是余数为负），并将（可以视为的正版）乘2（左移一位）减去得到新的余数；\n❷ 若则商1，然后将乘2（左移一位）减去得到。\n本质上，上述两个操作都是余数左移一位减去除数。\n❸ 另外，若则结束运算。\n总的来说就是 比较→上商→左移→比较\n\n\n\n   \n\n\n\n上述过程总共循环次（最后一次无需左移），得到个商（1个整数位+位小数），其中第一次循环得到的商是整数位上的，最后左移会将其移到符号位上（但会被真正的符号位替换掉），因此如果是一个大数除以一个小数将会发生溢出。\n\n如果商的最后一位为0可知当前余数为负，因此想要得到余数还需要加上除数\n\n实际操作过程中，余数和被除数、除数均采用双符号位：在运算时可以保留溢出的最高位\n\n这个算法中恢复余数的次数是未知的从而导致预算时间也是未知的\n\nExample：X=0.1011，Y=-0.1101\n\n\n⚠️注意到商的每一位都是在最右端产生的，然后不断左移过来，而每次余数也需要左移，因此这里也是将余数和商连在一起左移的\n\n\nβ 原码不恢复余数法（加减交替法）显然，后者存在的原因就是为了改进前者。事实上，前面原码恢复余数的式子已经体现了原码不恢复余数的思想，我们稍加整理可得\n\n\n\n\n可见两者的形式非常的统一，不论哪种情况我们都无需恢复余数，而且只要运算2次即可得到下一个余数。由此我们便可以解决运算时间不可预测的问题了。\n\n\n\n\nΣ 原码不恢复余数除法的硬件实现\n\n\n处放每次运算得出的余数，其中为符号位\n的初始值为\n处则存放商的结果，则是每次运算的上商位\n初始值需要为1，保证第一次做的是减法\n说明余数&gt;0，位商1；反之商0\n位商1下一步则需要左移减；位商0则需要左移加\n中存储的是，加则无需对操作（，），减则需要对取补码（，）\n控制逻辑决定异或对象，决定是否+1\n\nΠ 阵列除法器同样基于阵列乘法器的思想，我们可以应用于除法从而加快运算速度。阵列乘法器中的核心部件是CAS可控加减法单元。\n\n\nCAS有8个引脚，4个输入端4个输出端。P控制加减操作，时CAS执行加法，否则执行减法（依旧用异或与配合进行取反+1，注意到最低位的进位端是与相连的）；为进位/借位输入/输出信号；斜向输入和输出的为除数，斜向输出连到下一个CAS单元，相当于手动除法中的右移；垂直输入的是被除数，垂直输出余数。\n代入全加器的逻辑表达式，CAS单元的输出和输入之间的关系可以表示为\n下图为字长为3的阵列除法器基本结构，其中被除数（双字长），除数，商，余数\n\n\n\n阵列除法器采用的是原码不恢复除法的思想\n初始情况保证第一次运算做减法，另外要求，否则运算结果将会溢出\n可以看到连接到最低位的进位输入端，从而当时对除数进行取反+1生成补码，随后完成运算\n斜向传递的是除数的每一位，因此每一层均不会改变\n原码不恢复余数除法的运算过程采用的是双符号位，双符号位中的第一位是真正的符号位，而第二位则可以视为溢出保留位，即实际运算中的最高有效位（本质上来说双符号数只是多了一位的单符号数）。但在阵列乘法器中仅有双符号位的第二位（每一层最左侧的CAS），这是因为余数为正时（符号位0）需要（符号位1），余数为负时（符号位1）需要（符号位0），即在不考虑第二位符号位进位时符号位始终为1，因此我们只需关注每一层最左侧CAS的进位输出端即可。\n当最左侧CAS的进位输出端为0时，符号位为1，说明余数为负，商0并在下一次运算中移位；当进位输出端为1时，说明余数为正，商1并在下一次运算中移位。从中可以看出最左侧CAS的进位输出端不仅等于每一层的商值，同时决定了下一层的加减操作。因此将每一层最左侧CAS的进位输出端连至下一层的加减控制端，另外通过CAS排布的右移来完成余数的左移。\n\n","slug":"定点数的乘除法实现","date":"2022-03-09T01:13:56.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"a39f642fa5f3a366579e792c57ec2418","title":"Bézier Curve：小试牛刀","content":"贝塞尔曲线有着很多特殊的性质在图形设计和路径规划中应用都非常广泛。贝塞尔曲线完全由其控制点决定其形状，n个控制点对应着n-1阶的贝塞尔曲线，并且可以通过递归来定义。本篇文章的重点在于对Bézier Curve的理解以及用OpenGL绘制Bézier Curve。\n\n\n\n\n〄 Bézier Curve·1阶给定两个已知坐标的控制点，，那么1阶贝塞尔曲线可以用一个关于t的参数方程来描述：很显然，这表示的即是两控制点之间的线段，而每一个则表示线段上的一个点，这个关于的动点我们姑且先称之为贝塞尔动点，贝塞尔动点遍历便构成贝塞尔曲线。\n⚠️事实上贝塞尔曲线本身跟是无关的，只是方便描述曲线上的点而存在的，可以认为是画出贝塞尔曲线的画笔。\n〄 Bézier Curve·2阶给定三个已知坐标的控制点，，，那么这时候有两个线段，我们可以先求出这两个线段上的贝塞尔动点，然后求两个贝塞尔动点线段上的贝塞尔动点（三个贝塞尔动点关联同一个），第三个贝塞尔动点将构成2阶贝塞尔曲线：那么2阶贝塞尔曲线的参数方程即为我们可以看到这是一个递归的过程。\n〄 Bézier Curve·3阶同理3阶贝塞尔曲线的方程为下图是当时的贝塞尔动点线段以及相应的3阶贝塞尔曲线\n\n\n\n\n事实上对于贝塞尔曲线参数方程中每个控制点前的系数都是一个关于的函数，而这些系数函数我们可以类比杨辉三角（贝塞尔曲线的递归过程本质上就是个杨辉三角）\n\n\n上图只是一个三阶的杨辉三角，我们可以看到每个控制点所在的叶子节点到根结点（最上面的那个点）的路径乘积乘以其所在叶子节点上的数字即为其系数函数。比如说，我们随便取一条到根结点的路径（不管哪条路径，乘积都是一样的），将路径上的表达式进行相乘得到，再乘以其叶子节点3得到，对照即为的系数。\n〄 Bézier Curve·  阶注意到上图中的杨辉三角其实就是的展开式，因此我们其实可以直接写出阶贝塞尔曲线中控制点的系数为上式又称为n阶的波恩斯坦基底多项式。\n\n接下来就到了激动人心的绘制阶段。不过其实理论内容已经差不多了，剩余的只是C++编程，OpenGL运用。\n代码里没有什么高深的思想，没有啥优化（概括：懒），就是实现了一个点类，然后不断递归求出新的控制点坐标。当然OpenGL不能绘制连续的曲线，因此我们需要化曲为直。这时候就派上用场了，我将从中均匀地取100个出来分别绘制相应的点，最后将这些点连起来即可。\n\n\n⚡︎ 算法说明\n实现了一个点类Point，用于存储一个点的坐标（double x,y），并重载了*、+符号，使坐标可以直接与浮点数进行加乘运算\n\n首先需要用户输入需要绘制的贝塞尔曲线的阶数，随后输入个控制定点的坐标，最后指定来绘制出相应的中间迭代控制点\n\n\n对每个点的坐标都来满足实际绘图坐标的范围（绘制函数传入的坐标范围）\n\nvector&lt;vector&lt;Point&gt;&gt; control_points存储参数所对应的每一次迭代的控制点坐标，control_points[i]存储的是第次迭代的控制点坐标\n\n若表示第次迭代的第个控制点，那么控制点的迭代公式：\n\n\n\n\n绘制贝塞尔曲线是化曲为直，首先均匀取了100个，画出每个所对应的位于贝塞尔曲线上的点，最后将每个点连起来\nvector&lt;vector&lt;Point&gt;&gt; middle_points存储的是每个迭代过程中的中间控制点坐标以及最后所要连起来的100个点\n绘制过程：对应的迭代过程控制点连线→贝塞尔曲线连线→在贝塞尔曲线上对应的点\n\n\n\n其余就看代码注释吧～\n\nC☺DE#include &lt;glew.h&gt;\n#include &lt;glfw3.h&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n//重载了*，+运算符的点类\nclass Point\n{\npublic:\n    double x, y;\n\n    Point(double _x, double _y) : x(_x), y(_y) {};\n\n    inline Point operator*(const double &amp;t) const\n    {\n        return Point(t * this-&gt;x, t * this-&gt;y);\n    }\n\n    inline Point operator+(const Point &amp;rhs) const\n    {\n        return Point(this-&gt;x + rhs.x, this-&gt;y + rhs.y);\n    }\n};\n\nint main(void)\n{\n    int n;\n    cout &lt;&lt; \"Bézier Curve的阶数：\";\n    cin &gt;&gt; n;\n\n    //control_points存储指定t的每一次迭代控制点，middle_points存储绘制过程中的每一次迭代控制点（t会变）\n    vector&lt;vector&lt;Point&gt;&gt; control_points(n + 1), middle_points(n + 1);\n    double x, y, t0;\n    cout &lt;&lt; \"请输入\" &lt;&lt; n + 1 &lt;&lt; \"个控制点坐标（0 ≤ |x|,|y| ≤ 100）：\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n + 1; ++i)\n    {\n        cin &gt;&gt; x &gt;&gt; y;\n        control_points[0].emplace_back(Point(x / 100, y / 100));\n    }\n\n    //输入指定t，可绘制出t0时每一次的迭代控制点\n    cout &lt;&lt; \"t0 = \";\n    cin &gt;&gt; t0;\n    //计算t0时每一次的迭代控制点\n    for (int i = 1; i &lt; n + 1; ++i)\n        for (int j = 0; j &lt; n + 1 - i; ++j)\n            control_points[i].emplace_back(control_points[i - 1][j] * (1 - t0) + control_points[i - 1][j + 1] * t0);\n    //求100个t所对应的点\n    middle_points[0] = control_points[0];\n    for (int k = 0; k &lt; 101; ++k)\n    {\n        double t = k / 100.0;\n        for (int i = 1; i &lt; n; ++i)\n        {\n            middle_points[i].clear();\n            for (int j = 0; j &lt; n + 1 - i; ++j)\n                middle_points[i].emplace_back(middle_points[i - 1][j] * (1 - t) + middle_points[i - 1][j + 1] * t);\n        }\n        middle_points[n].emplace_back(middle_points[n - 1][0] * (1 - t) + middle_points[n - 1][1] * t);\n    }\n    //开始绘制，初始化glfw库\n    if (!glfwInit())\n        return -1;\n    //创建窗口以及上下文\n    GLFWwindow *window = glfwCreateWindow(800, 600, \"Bézier Curve\", NULL, NULL);\n    if (!window)\n        glfwTerminate();\n    //建立当前窗口的上下文\n    glfwMakeContextCurrent(window);\n    //循环绘制使其停留在屏幕上\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n        //背景颜色\n        glClearColor(0.2, 0.1, 0.2, 1);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        //绘制t0时每次迭代的控制点连线\n        glLineWidth(5);\n        for (int i = 0; i &lt; n; ++i)\n        {\n            //使每次迭代的控制点连线颜色不同\n            glColor3f(1.0 * (n - 1 - i) / (n - 1), 1.0 * i / (n - 1), 0);\n            glBegin(GL_LINE_STRIP);\n            for (auto &amp;p: control_points[i])\n                glVertex2f(p.x, p.y);\n            glEnd();\n        }\n        //绘制贝塞尔曲线\n        glColor3f(0, 0, 1);\n        glBegin(GL_LINE_STRIP);\n        for (auto &amp;p: middle_points[n])\n            glVertex2f(p.x, p.y);\n        glEnd();\n\n        //绘制出贝塞尔曲线上t0所对应的点\n        glColor3f(0, 0.7, 0.7);\n        glPointSize(20);\n        glEnable(GL_POINT_SMOOTH);\n        glBegin(GL_POINTS);\n        glVertex2f(control_points[n][0].x, control_points[n][0].y);\n        glEnd();\n\n        glfwSwapBuffers(window);\n    }\n    glfwTerminate();\n    return 0;\n}\n\n\n⚛︎ 5 order Bezier curve ()\n","slug":"Bezier-Curve","date":"2022-03-08T08:47:55.000Z","categories_index":"计算机图形学","tags_index":"走码观花,OpenGL","author_index":"Starlit Rover"},{"id":"df24c0ec65d9b0432ce3e888de12a2d4","title":"「Section 0」小记OpenGL","content":"\nglfwMakeContextCurrent(GLFWwindow *window)：将窗口window设为当前上下文\n\nOpenGL可以认为是一个巨大的状态机。所谓状态机，是一个包含了许多当前属性（背景颜色、渲染模式）的集合（状态），里面的属性值直到下次修改前都不会改变。那么当内部属性发生改变时状态也随之而变，类似编译原理里面的自动机。\n上下文可以认为是OpenGL当前的状态，即当前执行操作的窗口，可以认为选择window作为当前画布。\n\n\n\nglViewport(GLint x,GLint y,GLsizei width,GLsizei height)：在窗口上设置绘制区域\n\nx，y以像素为单位，指定了视口的左下角位置\nwidth，height 表示这个视口矩形的宽度和高度，根据窗口的实时变化重绘窗口\n在默认情况下，视口被设置为占据打开窗口的整个像素矩形，视口大小与窗口大小相同\n需要置于glfwMakeContextCurrent(GLFWwindow *window)函数后才会生效\n一个程序内可以使用多次在不同区域内进行绘制\n注册回调函数，即每次调整窗口时调用这个函数来调整视口\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    glViewport(0, 0, width, height);\n}\n\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\nOpenGL中的函数名：glColor3f,glVertex2f,glVertex3d, …\n\n开头gl表示OpenGL中的函数\n数字前的单词表示该函数的作用\n数字表示有几个参数，在glVertex中2表示二维坐标，3则表示三维坐标\n数字后面的字母表示参数类型\ns：16位整型\ni：32位整型\nf：32位符点数\nd：64位符点数\n\n\n\n\n3D坐标：glVertex3f(x,y,z)\n\n\n是二维平面的坐标，是窗口的中心，轴向右为正方向，轴向上为正方向\n为深度，可以认为是到屏幕的垂直距离\n\n\n绘制代码\nglBegin(TYPE);\n\t...\nglEnd()\n\n其中TYPE为绘图类型，常见的类型有：\n\nGL_POINTS：离散的点（⚠️画圆点：在glBegin前加glEnable(GL_POINT_SMOOTH);）\n\nGL_LINES：线\n\nGL_LINE_STRIP：折线图（多个点的连线）\n\nGL_LINE_LOOP：首尾相连的闭合线\n\nGL_TRIANGLES：三角形\n\nGL_TRIANGLE_STRIP：绘制同方向的三角形\n\n\n\n调节粗细大小：置于glBegin(TYPE)前\n\n线的粗细：void glLineWidth(GLfloat width)，\n点的大小：void glPointSize(GLfloat size) ，size的单位是像素（默认为正方形）\n\n\n\n","slug":"小记OpenGL","date":"2022-03-08T08:01:35.000Z","categories_index":"计算机图形学","tags_index":"OpenGL","author_index":"Starlit Rover"},{"id":"6e65b890459bfc2665ec0e0a14ed8ee7","title":"「Section 2」建立数据模型","content":"\n概念模型的基本概念\n\n实体：客观事物的映射，可以是实际存在的对象，也可以是某种概念\n\n属性：实体的特征，描述实体，使实体更为具体\n\n域：一个属性的取值范围\n\n实体集：所有具有相同属性的实体所构成的集合\n\n\n实体型：实体名称以及所有属性名构成的集合\n\n码：实体集中可以根据一个属性或多个属性唯一确定每一个实体，那么称该属性或属性组为码\n\n\n\n主要的数据模型\n\n层次模型\n网状模型\n关系模型\n面向对象模型\n\n\n数据模型的三大基本组成部分\n\n数据结构：实体间联系在信息世界的表示方法。描述了系统的静态特性。\n数据操作：对数据可以执行的操作（主要有数据维护、数据检索两大类）及操作规则。描述了系统的动态特性。\n完整性约束：只执行符合完整性约束条件的操作，从而保证数据的正确、有效、相容。\n\n\nE-R图的基本表示方法\n\n矩形表示实体集，椭圆表示实体集的属性，两者之间用无向边相连\n实体的码（e.g.学号，身份证号）用下划线标出\n菱形表示实体集之间的关系，菱形中写上关系名，与实体集的连线上则写上两个实体集之间的数量对应关系（联系的阶）\n一对一：1:1\n一对多：1:n\n多对多：m:n\n\n\n\n\n\n多元联系：两个以上实体集之间的联系\n\n\n联系的属性：有时一个属性从逻辑上不能单独分配给一个实体时，可以将属性分配给联系\n\n\n上图中一名学生有多门选课的成绩，而一门课程则有多个学生的成绩，因此两者都不能直接拥有成绩属性，而是将成绩属性分配给选课关系更为合适，一个选课一个成绩。\n\n强实体集：有码的实体集；弱实体集：无码的实体集，依赖于其余一个或多个实体集的码。\n\n\n","slug":"建立数据模型","date":"2022-03-06T06:27:50.000Z","categories_index":"数据库原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"cf7c04c438de034cff5412cfe4f52f34","title":"「Section 1」数据库系统概论","content":"\n数据库（DataBase）：存储在计算机系统内的有结构的数据结构。不仅包含数据，同时还有数据的含义、数据结构、约束的完整性定义\n\n文件系统的缺点\n\n数据冗余较大：数据文件无法共享\n\n数据和程序缺乏独立性：改变数据的逻辑结构就必须修改程序\n\n\n\n数据库管理系统（Database Management System）：DBMS是位于用户与操作系统之间的一层软件，它是一个大型的复杂的系统软件。领先的著名数据库管理系统DBMS有PostgreSQL、 IBM DB2、Oracle、 Microsoft SQL Server等。其最基本的功能就是允许用户逻辑地使用数据而无需关注这些数据在计算机中是如何存放、如何处理的。\n\n数据定义：方便用户定义数据的逻辑结构\n数据操控：方便用户对数据进行插入、删除、查询、修改等操作\n完整性约束检查：数据必须符合一些规定，如学号必须唯一、所属地区必须存在等\n访问机制：只有合法用户可以访问、操作数据\n并发控制：允许多个用户、应用并发访问数据库而不破坏数据的一致性\n数据库恢复\n\n\n数据库系统（Database System）：包括数据库、DBMS、应用系统、计算机硬件、数据库管理员（DBA）\n\n整体数据的结构化：数据库中的数据不属于任何应用而是公共的，结构是全面的。\n数据的共享度高：合法用户可以同时使用数据。\n数据的独立性高：数据和程序之间相互独立。\n高度的数据控制能力\n数据安全性高：在DBMS管理下，只有合法用户可以访问数据库。\n数据完整性好：DBMS自动检查数据的一致性、相容性。\n并发控制能力强：可以使多个用户同时对数据库中的数据进行操作而不破坏数据的完整性。\n数据恢复能力强：具备恢复数据库的功能。\n\n\n\n\n\n数据库的人员构成\n\n数据库管理员（DBA）\n在用户与数据库开发人员之间进行沟通协调\n参与数据库设计工作，熟悉数据库的整体布局\n决定数据库的完整性约束条件和不同用户的存取权限\n进行数据库的维护工作，保证数据库的正常运行\n\n\n数据库设计者：一般由DBA担任。需要分析用户需求，选取适当的存储结构。\n应用程序开发人员：开发程序来实现对数据库应用程序的各功能模块\n终端用户：利用应用程序访问、操作数据库，是数据库的主要面向对象\n\n\n三级模式结构：不同层次级别的用户看到的数据视图是不同的\n\n（逻辑）模式：唯一。数据在逻辑上的视图，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n外模式：不唯一。呈现给终端用户的视图，外模式根据终端用户的需求呈现特定部分的数据库。一个外模式可以被多个应用程序应用，一个应用程序只能应用一个外模式。外模式是模式的子集。\n内模式：唯一。定义了数据库存取的物理结构，与软件和硬件环境有关。\n\n\n二级映像：当其中一模式改变时只需修改相应的映像即可使另一模式不发生变化\n\n外模式/模式映像：逻辑独立性，模式发生改变时无需改变外模式与应用程序。\n模式/内模式映像：物理独立性，内模式改变时无需改变模式。\n\n\n应用程序读取数据的过程\n\n终端用户通过应用程序指定外模式名发出命令\nDBMS调取相应的外模式，同时检查用户的权限，只有通过检查可以继续\nDBMS根据外模式 /模式映像得到相应数据在模式上的信息\nDBMS根据模式 /内模式映像得到相应数据在内模式上的信息\nDBMS向操作系统发出读取该数据的请求\n操作系统将该数据从外存中调入系统缓存区中\nDBMS将数据按照外模式的形式送至用户工作区\n记载系统工作日志\n\n\n\n","slug":"数据库系统概论","date":"2022-03-06T05:11:11.000Z","categories_index":"数据库原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"916fffb6f0cf37494d0f7af19c9c80e4","title":"「Section 3」补码加减运算方法","content":"目前计算机中的数据普遍是用补码存储的，因为补码具有简单的加减法规则，运算简单，易于实现，而且符号位可以和数值位一起参与运算。\nα. 补码规则运算\nβ. 溢出检测\nγ. 机器数的移位运算\n\n\n\nα 补码运算规则补码的加减法运算公式为补补补\n补补补\n在「Section 1」数据格式中我们有提过补码的减法是用加法来实现的，这里其实就是被减数的补码+减数相反数的补码，而一个正数相反数的补码显然为其各位（包括符号位）取反+1。\n那么上述的公式又如何被证明呢？这里需要用数论中模（mod）的概念。我们知道正数的补码即为原码，而负数的补码则是各位取反+1，这两种情况是分开的，那是否有一种方式能将两者大一统呢？事实上，我们可以认为一个数的补码（算上符号位是位的补码）是该数模的结果：补这里的mod是取余的意思。我们规定余数必须为正，那么一个负数模的余数即为，就会发现补码的定义确实如此。\n那么，补补补\n根据上式，第二个等式由 补补 则显然成立。\n\nβ 溢出检测我们很高兴地发现了补码运算的简便，但算着算着就会发现一些神奇的情况，比如说怎么说呢，就是两个负数加起来变正了。想必，这就是物极必反吧（bushi\n这个式子的真面目应该是然而机器数的位数是有限制的，计算机难以容忍多出的一位，因此直接将最高位扔掉了，只是他不知道最高位有着特殊含义。这种现象我们称之为溢出（一般指上溢出）。\n溢出在所难免，因此计算机必须解决溢出的问题，需要检测并指示。\n\n\n❄︎ 单符号位判溢方法我们清楚事实上只有当绝对值变大，即同号相加、异号相减（两者本质相同）的情况才会发生溢出，我们设为溢出符号位，为两个运算数的最高符号位，为运算结果符号位，而则表示运算符，0为+，1为-，那么有\n❄︎ 进位判溢方法设为两数符号位相加的进位信号，则是两数最高有效位的进位信号。由于补码可以将减法转换为加法，而且只有同号相加时会发生溢出，因此这里只考虑同号加法。符号位在不受到影响之前为0，那么考虑后有。而的值则代表了两数的符号，0正1负。我们清楚运算结果的符号位若与两数符号位不同则表明溢出，即与不同。由于异号相加（不会发生溢出）时也有，因此可以将的表达式直接写为\n❄︎ 双符号位判溢方法运算数采用双符号位补码（变形补码）进行运算，正数的符号位变为00，负数的符号位变为11，其余位不变。当运算结果的符号位的两位不同时表明发生溢出 。正溢出；负溢出其实这是一种对进位判溢方法的应用，设两个运算数的符号位分别为，运算结果的符号位为，那么有当与不同时与也不同。而同号运算时显然，那么时说明两正数相加结果为负，为正溢出；时说明两负数相加结果为正，为负溢出。\n⚠️第一位是正确的符号位，第二位是保留溢出位。\n\nγ 机器数的移位运算\n逻辑移位：直接左右补0。将移位的数据视为无符号数据，各数据位在位置上发生了变化，导致无符号数据的数值（无正负）放大或缩小。(x86:SHL,SHR;RISC-V:sll,srl)\n算术移位：将移位的数据视为带符号机器数。算术移位的结果，在数值的绝对值上进行放大或缩小，同时，符号位必须要保持不变。(x86:SAL,SAR;RISC-V:sll,sra)\n补码的算数右移：高位补符号位\n补码的算术左移：数据最高有效位必须与符号位相同才能保证不会溢出，此时可以直接将最高有效位移入符号位并在左边补0\n\n\n循环移位：所有的数据位在自身范围内进行左移或者右移，左移时最高位移入最低位，右移时最低位移入最高位。(x86:ROL,ROR,RCL,RCR)\n\n","slug":"补码加减运算方法","date":"2022-03-04T09:46:00.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"481cf8b49191f67983b97c3d9fc63cfa","title":"OpenGL落脚CLion","content":"本篇文章将阐述在Mac os Monterey(12.2.1)的CLion(2021.3.3)上配置OpenGL的整体过程。虽然网上已有相关的文章，但有很多操作存在问题，可能是Mac系统变迁的原因，故作此文。\n原参考文章：Mac Clion OpenGL开发环境配置\n\n\n\n\n打开 terminal，用homebrew（默认已有）安装依赖项\nbrew install glew\nbrew install glfw3\n\n可以通过下述命令来查看上述两个依赖项的安装位置\nbrew list glew\nbrew list glfw\n\n配置Glad，通道在此\n①\n\n\n②\n\n\n③将glad.zip进行解压后里面就是上图中的include和src，将include/glad文件夹下的glad.h中的#include &lt;KHR/khrplatform.h&gt;更改为#include &lt;khrplatform.h&gt;\n\n\n④将include里面的两个文件夹glad与KHR拖入 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include（这与参考文章里的地址不同，那篇文章中的文件夹是真的没找到在哪），而src文件夹则直接拖入CLion中的项目文件夹（这个项目配置与普通C++项目配置相同）\n\n\n接下来配置CLion项目文件中的CMakeLists.txt文件\ncmake_minimum_required(VERSION 3.21)\nproject(OpenGLab)\n\nset(CMAKE_CXX_STANDARD 23)\n\n###############上面部分不用改，按自己原来的即可###############\n#设置一些OpenGL头文件所在目录的宏\nset(GLEW_H /opt/homebrew/Cellar/glew/2.2.0_1/include/GL)\nset(GLFW_H /opt/homebrew/Cellar/glfw/3.3.6/include/GLFW)\n#设置OpenGL库所在位置，并链接\nset(GLEW_LINK /opt/homebrew/Cellar/glew/2.2.0_1/lib/libGLEW.2.2.0.dylib)\nset(GLFW_LINK /opt/homebrew/Cellar/glfw/3.3.6/lib/libglfw.3.3.dylib)\nlink_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK})\n#########################################################\n\nset(GLAD_H /usr/local/include/)\nset(GLAD_H /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/glad)\nset(KH_H /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/KHR)\n#包含上述头文件所在目录\ninclude_directories(${GLEW_H} ${GLFW_H} ${GLAD_H} ${KH_H})\n\n#设置要编译的c/cpp文件到可执行文件中，该exe包含两个文件glad.c,main.cpp,生成OpenGLab\nset(SOURCE_FILES \"src/glad.c\" \"main.cpp\")\nadd_executable(OpenGLab ${SOURCE_FILES})\n\n# mac下这步很重要\nif (APPLE)\n    target_link_libraries(OpenGLab \"-framework OpenGL\")\n    target_link_libraries(OpenGLab \"-framework GLUT\")\nendif()\n\n⚠️将代码中我的项目名称OpenGLab换成你自己的项目名，另外#之间代码中的路径可能需要修改，请参考第一步中brew list的结果（主要是版本号可能不同的问题，我这里glew是2.2.0_1，glfw是3.3.6）\n\n\n测试代码——from 参考文章\n#include &lt;glew.h&gt;\n#include &lt;glfw3.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n{\n    //如果按下ESC，把windowShouldClose设置为True，外面的循环会关闭应用\n    if(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    std::cout&lt;&lt;\"ESC\"&lt;&lt;mode;\n}\n\nint main(void)\n{\n    //初始化GLFW库\n    if(!glfwInit())\n        return -1;\n    //创建窗口以及上下文\n    GLFWwindow* window = glfwCreateWindow(640, 480, \"hello world\", NULL, NULL);\n    if(!window)\n    {\n        //创建失败会返回NULL\n        glfwTerminate();\n    }\n    //建立当前窗口的上下文\n    glfwMakeContextCurrent(window);\n\n    glfwSetKeyCallback(window, key_callback); //注册回调函数\n    //循环，直到用户关闭窗口\n    while(!glfwWindowShouldClose(window))\n    {\n        /*******轮询事件*******/\n        glfwPollEvents();\n\n        /*******渲染*******/\n        //选择清空的颜色RGBA\n        glClearColor(0.2, 0.3, 0.3, 1);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        //开始画一个三角形\n        glBegin(GL_TRIANGLES);\n        glColor3f(1, 0, 0); //Red\n        glVertex3f(0, 1, 1);\n\n        glColor3f(0, 1, 0); //Green\n        glVertex3f(-1, -1, 0);\n\n        glColor3f(0, 0, 1); //Blue\n        glVertex3f(1, -1, 0);\n        //结束一个画图步骤\n        glEnd();\n\n        /******交换缓冲区，更新window上的内容******/\n        glfwSwapBuffers(window);\n    }\n    glfwTerminate();\n    return 0;\n}\n\n\n\n","slug":"OpenGL落脚CLion","date":"2022-03-03T11:45:51.000Z","categories_index":"血泪史","tags_index":"OpenGL","author_index":"Starlit Rover"},{"id":"e26b5ce0cae66dfe27a555c57255d754","title":"「1012」The Best Rank","content":"➳ENTRY\nTo evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.\nFor example, The grades of C, M, E and A - Average of 4 students are given as the following:\nStudentID  C  M  E  A\n310101     98 85 88 90\n310102     70 95 88 84\n310103     82 87 94 88\n310104     91 91 91 91\n\nThen the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID.\nOutput Specification:For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.\nThe priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.\nIf a student is not on the grading list, simply output N/A.\nSample Input:5 6\n310101 98 85 88\n310102 70 95 88\n310103 82 87 94\n310104 91 91 91\n310105 85 90 90\n310101\n310102\n310103\n310104\n310105\n999999\n\nSample Output:1 C\n1 M\n1 E\n1 A\n3 A\nN/A\n\n\nΩ有点类似那道奥运排行榜。众所周知，奥运奖牌榜有金牌榜、总牌榜，甚至还有人均奖牌榜，以灯塔国为首的许多国家都会选择自己国家排名靠前的榜单发布。这道题则换成了学生，一个学生有三门课的成绩，算上平均分就会有四个排名。为了让每位同学能开开心心地回家嗨皮，并免受麻麻的叨叨，学校决定对每位来查分数的同学都只告诉他最高的排名以及相对应的科目（即排名方式）。真是个好学校啊～\n\n\n那就先来个结构体，用来存储一位学生的学号以及各科分数\nclass info\n{\npublic:\n    string num;\n    int score[4];\n};\n\n大体思路呢，用一个map建立学号到最高排名以及排名方式的索引，然后按照优先级的顺序对四个分数依次进行sort，如果当前sort的结果比map中存储的最高排名要小的话就替换，同时更新排名方式。\nmap&lt;string, pair&lt;int, char&gt;&gt; outcome;\n//map&lt;num,pair&lt;best rank,ranking method&gt; &gt;\n\n这里需要特别注意排名的规则：\n\n相同分数的人名次相同\n当前面个人的分数与名次相同（均为）时，后一个人（其分数比前面个人的分数小）的名次不是而是，其中是比该人分数大的人数\n\n其实这些规则我们都是知道的，但coding的时候总会创造出一个新的排名规则……因此排名时只要和前一个人的分数进行比较即可，如果相同则名次不变，不同时则取其排序序号+1。\nr = (rank[i].score[idx] == pre ? r : i + 1);\n\n对了，平均分是一个四舍五入的整数，我们可以直接+0.5\nscore[0] = (c + m + e) / 3.0 + 0.5\n\nc,m,e都是整型，/3.0后变为double，+0.5后再（自动）强制类型转换成int赋值给score[0]完成四舍五入。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n//global: make sure lambda expression in sort can know \"idx\"\nint idx;\n\nclass info\n{\npublic:\n    string num;\n    int score[4];\n    //constructor\n    info(string n, int c, int m, int e) : num(move(n)), score{score[0] = (c + m + e) / 3.0 + 0.5, c, m, e} {}\n};\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    string num;\n    int c, m, e;\n  //used for sorting\n    vector&lt;info&gt; rank;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; num &gt;&gt; c &gt;&gt; m &gt;&gt; e;\n        rank.emplace_back(num, c, m, e);\n    }\n\n    map&lt;string, pair&lt;int, char&gt;&gt; outcome;\n  //initialize\n    for (auto &amp;s: rank)\n        outcome[s.num] = move(pair(n + 1, '-'));\n\n    char method[4] = {'A', 'C', 'M', 'E'};\n\n    for (idx = 0; idx &lt; 4; ++idx)\n    {\n        sort(rank.begin(), rank.end(), [](info &amp;a, info &amp;b) { return a.score[idx] &gt; b.score[idx]; });\n        int r = 1, pre = -1;\n        for (int i = 0; i &lt; n; ++i)\n        {\n            r = (rank[i].score[idx] == pre ? r : i + 1);\n            pre = rank[i].score[idx];\n            if (r &lt; outcome[rank[i].num].first)\n                outcome[rank[i].num] = move(pair(r, method[idx]));\n        }\n    }\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; num;\n        if (outcome.find(num) == outcome.end())\n            cout &lt;&lt; \"N/A\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; outcome[num].first &lt;&lt; \" \" &lt;&lt; outcome[num].second &lt;&lt; endl;\n    }\n}\n","slug":"1012-The-Best-Rank","date":"2022-03-03T07:03:15.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map,sort","author_index":"Starlit Rover"},{"id":"2aa32c1dad7cbbce692f6b1b0a062627","title":"「Section 2」浮点数表示","content":"\n浮点数：顾名思义，小数点的位置可以浮动，采用了科学记数法的思想\n\n任意一个二进制数都可以用阶码、尾数唯一地表示为⚠️正常情况下的尾数包括符号位\n\n阶码决定了数据的表示范围，尾数决定了数据的表示精度\n\n阶码与尾数可以采用不同的机器码进行表示\n\n\n当浮点数的绝对值超过最大正数时发生上溢，小于最小正数时发生下溢\n\n\n⚠️正溢出/负溢出指两正数/两负数相加时超出最大值/最小值，均属于上溢出的特例。\n\n机器数0：有两种情况\n\n若浮点数的尾数为零，无论阶码为何值；\n当阶码的值遇到比它能表示的最小值还要小时（阶码负溢出），无论其尾数为何值\n\n\n\n\n浮点数的规格化：上文中的浮点数表示方法随着阶码的变化会有多种表示方法，然而计算机中需要唯一性，因此我们需要对浮点数的尾数进行规格化处理。\n\n规格化处理：使尾数的最高有效位（⚠️尾数的第一位是符号位，因此最高有效位为符号位后一位）为1，即。\n\n那么对于非规格化尾数的处理也非常的明显，只需改变阶码值来使得尾数左移或右移\n\n另一种规格化数方法，是将符号位单独取出提至最前，然后隐藏最高有效位的1隐藏，那么就有：这便是IEEE754标准所采用的规格数，两种规格化数的方法没有本质区别，没有特殊说明的规格化数都是按照第一种的标准。\n\n\n\nIEEE754浮点数标准：到此为止，其实还是没给出浮点数唯一的标准，比如说尾数与阶码的机器码形式就还没确定。因此在20世纪70年底，美国电气及电子工程师协会（IEEE）于1985年提出了浮点数标准IEEE754，该标准至今仍被主流计算机所采用。\n\n该标准主要包括32位单精度浮点数float与64位双精度浮点数double\n\n规定所有二进制浮点数均由符号位、阶码与尾数三部分组成，不同精度的浮点数各部分位宽不同，下图为16位浮点数各部分位宽分布\n\n\n阶码用移码表示，⚠️其偏移量不是正常情况下的而是，之所以用移码表示阶码，其一是不需要符号位（移码可以认为将整体范围进行了一个平移）；其二可以直接使用阶码比较大小；其三更方便移位进行加减运算。而对于偏移量采用而非则众说纷纭，我提供一部分较为合理的解释：\n\n偏移量变小，表示的实际范围往右平移，即最大值更大，正数表示范围直接翻一倍，整体范围变大（负数范围变小只会使精度变低）\n使每一个规格化数的倒数能用另一个浮点数表示：阶码范围（00…0与11…1的阶码被保留用作特殊情况，因此范围较往常更小）。偏移量取时，阶码为的数取完倒数后阶码变为发生上溢，损失值较大；偏移量取 时，阶码为的数取完倒数后阶码变为发生下溢，但损失值极小。\n\n\n尾数为定点小数，将小数点左侧的1隐藏，完整的尾数形式应该为，实际只保存，节省下来的存储空间用于提高精度。可以认为尾数是以原码表示。\n⚠️尾数本身是包括符号位的，但IEEE754标准中将其分开并置于开头是特殊操作，如无特别说明符号位与尾数是连在一起的一个整体。\n\n特殊情况：\n\n\n当阶码与尾数均为0时表示机器数0。另外由于尾数采用原码表示，因此存在+0与-0。\n\n当时，浮点数为规格化数，其值为\n\n我们清楚规格化数无法表示绝对值在内的数，那么为了进一步提高浮点数的表示精度，于是引入非规格化数。当时，浮点数便为非规格化数，其值为\n\n\n\n\n","slug":"浮点数表示","date":"2022-03-01T08:43:17.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"ace59b7e8a5639360739593f39df1262","title":"「1010」Radix","content":"➳ENTRY\nGiven a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.\nNow for any pair of positive integers  and , your task is to find the radix of one number while that of the other is given.\n\n\nInput Specification:Each input file contains one test case. Each case occupies a line which contains 4 positive integers:\nN1 N2 tag radix\n\nHere N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2.\nOutput Specification:For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix.\nSample Input 1:6 110 1 10\n\nSample Output 1:2\n\nSample Input 2:1 ab 1 2\n\nSample Output 2:Impossible\n\n\nΩ这道题的测试点算是把我的认知给打穿了，不曾想，之前刷的题目都是那么的单纯可爱……\n\n\n咳咳，你说搞20个测试点也就算了，真就一个提示都不给？\n对的，计算机是一门追求严谨的学科，严谨的，严……\n好吧，肝就完事了。\n\n\n题目大意是，给你两个字符串数字，告诉你其中一个数是几进制，问你另一个数是几进制时可以使两数相等，如果不可能则输出Impossible。\n\n\n乍一看，so easy～ 一通枚举猛如虎，这不直接……但，题目没有给出进制数的范围，不讲武德呐。不过没有关系，我们清楚字符串数字的值随着进制数的增加是单调递增的（⚠️一种情况除外，那就是只有一位数字，其值不会随着进制的改变而改变。显然，我根本不可能掉进这种低级的坑），那么就可以先找出进制未知数中最大的字符，然后从最大的字符开始往上枚举，如果枚举到某个进制时超过了另一个已知数就说明两者不可能相等。比如说1ac3b中最大的字符是c=12，那就从13进制开始枚举直到其值≥另一个数。\n思路非常的清晰啊，小手一抖代码就写完了呢～\n\nC☹DE#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b;\n  //each has no more than 10 digits！\n  //a_d：decimal a；ra：radix of a\n    long long int t, ra, rb = 1, n, a_d = 0, b_d = 0;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; ra;\n  //make sure a's value is known\n    if (t == 2)\n        swap(a, b);\n  //calculate a's decimal value\n    for (auto &amp;c: a)\n    {\n        n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n        a_d = a_d * ra + n;\n    }\n  //mark if there is an answer\n    bool flag = false;\n  //find the max character of b\n    auto max_digit = *max_element(b.begin(), b.end());\n    rb = (isdigit(max_digit) ? max_digit - '0' : max_digit - 'a' + 10);\n\n  //start enumeration\n    while (b_d &lt; a_d)\n    {\n        b_d = 0;\n        ++rb;\n        for (auto &amp;c: b)\n        {\n            n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n            b_d = b_d * rb + n;\n        }\n        if (b_d == a_d)\n            flag = true;\n    }\n    if (flag)\n        cout &lt;&lt; rb;\n    else\n        cout &lt;&lt; \"Impossible\";\n}\n\n\n第一次提交的时候没有用long long int，有一个测试点炸了，改正后就【测试点7】显示运行超时。不错啊，20个里面已经消灭19个了，不过感觉这个运行超时不是很友好……毕竟枚举最怕的就是运行超时了。\n果然，经过一番测试（将rb的初始值不断提高看什么时候不超时），非常惊喜地发现【测试点7】的测试数据是10 2147483647 2 10。狗带，这用例完全就是专怼枚举的，因为这要从2进制枚举到最大的32位整型。也还好啦，再给我多一点时间……\n不枚举的话那咋办，突然想起来其值随着进制数的增大是单调递增的。单调的事物往往查找方便，因为还有一个叫二分法的东西。对啊，这不就是典型的二分法应用题嘛。\n一通代码猛如虎，修改方案的时候往往会捡了西瓜丢了芝麻。\n差点忘了题目里还有个要求，如果有多个符和要求的答案则输出最小的那个。我寻思着单调还能有多解？个位数们：你好。\n对了，“二进制数里没有132”。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b;\n    long long int t, ra, rb = 1, n, a_d = 0, b_d, cup = 1;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; ra;\n    if (t == 2)\n        swap(a, b);\n    for (auto &amp;c: a)\n    {\n        n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n        a_d = a_d * ra + n;\n    }\n  //consider one-digit\n    if (b.size() == 1 &amp;&amp; atoi(b.c_str()) == a_d)\n    {\n        cout &lt;&lt; atoi(b.c_str()) + 1;\n        exit(0);\n    }\n    bool flag = false;\n  //\"132 isn't binary number\"\n    auto max_digit = *max_element(b.begin(), b.end());\n    long long int rb_max = INT32_MAX, rb_min = (isdigit(max_digit) ? max_digit - '0' : max_digit - 'a' + 10);\n    while (rb_max &gt; rb_min)\n    {\n        b_d = 0;\n        rb = (rb_max + rb_min + 1) / 2;\n      // unchanged rb demonstrates impossibility\n        if (cup == rb)\n            break;\n        cup = rb;\n        for (auto &amp;c: b)\n        {\n            n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n            b_d = b_d * rb + n;\n          //break in time\n            if (b_d &gt; a_d)\n                break;\n        }\n        if (b_d == a_d)\n        {\n            flag = true;\n            break;\n        }\n        else if (b_d &lt; a_d)\n            rb_min = rb;\n        else\n            rb_max = rb;\n    }\n    if (flag)\n        cout &lt;&lt; rb;\n    else\n        cout &lt;&lt; \"Impossible\";\n}\n\n\nλ 一个小注在实施二分法的时候有一个问题需要关注，那就是边界能否取到。注意到，上文中那个让我大枚举法爆炸的测试数据的答案是2147483647，也就是最大的32位整数。而我在code里取的rb初始最大值就是INT32_MAX=2147483647,因此我需要让rb可以二分到这个最大边界，一种解决方案便是code里采用的二分时+1策略，这样的话rb下界就必须取一个不可能的值，因为达不到下界。\nrb = (rb_max + rb_min + 1) / 2;\n\n还有一种方法，就是rb_max与rb_min都取一个达不到的值，比如说\nlong long int rb_max = INT32_MAX + 1;\n\n然而一开始采用这个策略时，我发现rb_max被赋值为了-2147483648。有点懵，寻思着long long int不是64位的吗，怎么缩水溢出了？后来仔细想想是因为INT32_MAX是int类型的，因此+1的时候先是按int类型进行计算的，然后才将int的结果转换成long long int。所以一开始就需要对INT32_MAX进行强制类型转化。\n","slug":"1010-Radix","date":"2022-02-28T15:04:14.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,binary search","author_index":"Starlit Rover"},{"id":"2e1e3e282f89766b686da9305ae12c26","title":"「Section 0」计网专有名词","content":"\n独立模式：计算机未连接到网络，各自独立使用的方式（opp. 网络互连模式）\n\nWAN ( Wide Area Network，广域网）：指涵盖多个远距离区域的远程网络。比广域网再小一级的、连接整个城市的网络叫城域网(MAN, Metropolitan Area Network)。\n\nLAN ( Local Area Network, 局域网）：指一个楼层、一栋楼或一个校园等相对较小的区域内的网络。\n\n终端：由键盘、显示器等输入输出设备组成。最初还包括打字机。\n\n\n批处理（Batch Processing）：指事先将用户程序和数据装人卡带或磁带，并由计算机按照一定的顺序读取，使用户所要执行的这些程序和数据能够一并批量得到处理的方式。\n\n\n分时系统（Time Sharing System）：指多个终端与同一个计算机连接，允许多个用户同时使用一台计算机的系统。分时系统的重要特性包括多路性、独占性、交互性和及时性。\n\n\n分组交换：分组交换是指将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。\n\n\nOSI（Open Systems Interconnection）：开放式通信系统互联参考模型。\n\nOSI 参考模型中各个分层的作用\n\n\nMAC地址：称为物理地址或硬件地址，用来确认网络设备位置的地址，每个网卡都有一个唯一的MAC地址，且不能更改。采用 MAC 地址，目的是为了识别连接到同一个传输介质上的设备。\n\nIP地址：互联网协议地址，当设备连接网络时，设备将被分配一个IP地址（⚠️事实上是分配给设备中安装的网络硬件，即一台设备不一定只有一个IP地址），用作标识。通过IP地址，设备间可以互相通讯。共32位，由网络号和主机号组成，它们没有位数要求，而是由子网掩码来体现。若主机号部分全部为0则代表整个子网而不是子网中的某台设备。此外，主机号部分全部为1代表向子网上所有设备发送包，即广播。\n\n子网掩码：一串与IP地址长度相同的32比特数字。左边一部分全为1，相对应的IP地址部分表示网络号；右边剩余部分全为0，对应的IP地址部分表明主机号。\n\nDNS: Domain Namme System，域名服务系统。将服务器名称和 IP 地址进行关联是 DNS 最常见的用法，但 DNS 的功能并不仅限于此，它还可以将邮件地址和邮件服务器进行关联，以及为各种信息关联相应的名称。⚠️一个IP地址可以对应多个域名，一个域名也可以解析为多个IP地址。\n\n面向有连接型：面向有连接型中，在发送数据之前，需要在收发主机之间连接一条通信线路。（需要对方同意）\n\n面向无连接型：面向无连接型则不要求建立和断开连接。发送端可于任何时候自由发送数据。\n\n网卡：网络接口卡，NIC ( Network Interface Card)，是计算机连网时所使用的部件。\n\n带宽（Bandwidth）：单位时间内传输的数据量有多少，即传输速率，单位为bps ( Bits Per Second，每秒比特数）。带宽越大网络传输能力越强。从严格意义上讲，各种传输媒介中信号的流动速度是恒定的。因此，即使数据链路的传输速率不相同，也不会出现传输的速度忽快忽慢的情况，因为光和电流的传输速度是恒定的。\n\n吞吐量：指主机之间实际的传输速率，单位与带宽相同。\n\n中继器（Repeater）：物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。另外，中继器无法连接两个不同速度的网络，这需要网桥或路由器这样的设备来完成。\n\n\n网桥：数据链路层面上连接两个网络的设备。它能够识别数据链路层中的数据帧，并将这些数据帧临时存储于内存，再重新生成信号作为一个全新的帧转发给相连的另一个网段。由于能够存储这些数据帧，网桥可以连接传输速率完全不同的数据链路，并不限制连接网段的个数。\n\n\n路由器：提供路由与转送两种重要机制，可以决定数据包由来源端到目的端所经过的路径。网桥是根据物理地址（MAC 地址）进行处理，而路由器/3层交换机则是根据 IP 地址进行处理的。由此，TCP/IP 中网络层的地址就成为了 IP地址。\n\n\n网关：转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。网关能使通信线路上的服务器提供非 HTTP协议服务。\n\n\n报文：是HTTP通信中的基本单位，由8位组字节流 (octet sequence，其中 octet 为8个比特）组成，通过 HTTP 通信传输。\n\n代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。\n\n隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。隧道的目的是确保客户端能与服务器进行安全的通信。\n\n临时网络文件：客户端上的网页缓存。\n\n套接字：是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。\n\n\n端口号：明确指出某台具体计算机上某个具体的套接字。如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。\n\n负载均衡：其职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上，避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。\n\n虚拟主机（virtual hosting）：或称 共享主机（shared web hosting），又称虚拟服务器，是一种在单一主机或主机群上，实现多网域服务的方法，可以执行多个网站或服务的技术。虚拟主机之间完全独立，并可由用户自行管理，虚拟并非指不存在，而是指空间是由实体的服务器延伸而来，其硬件系统可以是基于服务器群，或者单个服务器。\n\nISP（Internet Service Provider）：互联网服务提供商。\n\nNAT（Network Address Translation）：网络地址翻译，它的提出也完全是为解决IPv4地址短缺的问题，为IPV6的开发争取足够时间。在计算机网络中是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问互联网的私有网络中。\n\n\n","slug":"计网专有名词","date":"2022-02-27T13:03:14.000Z","categories_index":"计算机网络","tags_index":"notes","author_index":"Starlit Rover"},{"id":"0891150107830e3ac5d4a54442d1eabc","title":"「1009」Product of Polynomials","content":"➳ENTRY\nThis time, you are supposed to find  where A and B are two polynomials.\n\n\nInput Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:where K is the number of nonzero terms in the polynomial， and   are the exponents and coefficients, respectively. It is given that ，.\nOutput Specification:For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.\nSample Input:2 1 2.4 0 3.2\n2 2 1.5 1 0.5\n\n\n\nSample Output:3 3 3.6 2 6.0 1 1.6\n\n\nΩ对于本题我只想说map大法好，废话不多说见Code~\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;int, double&gt; a, b, p;\n    int k, n;\n    double m;\n    cin &gt;&gt; k;\n    //A input\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; m;\n        a[n] = m;\n    }\n    //B input\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; m;\n        b[n] = m;\n    }\n    //product\n    for (auto &amp;x: a)\n        for (auto &amp;y: b)\n            p[x.first + y.first] += x.second * y.second;\n    //delete monomial with coefficient 0\n    for (auto z = p.begin(); z != p.end(); ++z)\n        if (z-&gt;second == 0)\n            p.erase(z);\n    cout &lt;&lt; p.size();\n    for (auto z = p.rbegin(); z != p.rend(); ++z)\n        printf(\" %d %.1f\", z-&gt;first, z-&gt;second);\n}\n\n\nAppendix 多项式加法 ➳ENTRY#include&lt;iostream&gt;\n#include&lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;int, double&gt; x, y, z;\n    int k, n;\n    double a;\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; a;\n        x[n] = a;\n    }\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; a;\n        y[n] = a;\n    }\n\n    for (auto &amp;p: x)\n        z[p.first] += p.second;\n    for (auto &amp;p: y)\n    {\n        z[p.first] += p.second;\n        if (z[p.first] == 0)\n            z.erase(p.first);\n    }\n\n    cout &lt;&lt; z.size();\n    for (auto s = z.rbegin(); s != z.rend(); ++s)\n        printf(\" %d %.1f\", s-&gt;first, s-&gt;second);\n}\n\n","slug":"1009-Product-of-Polynomials","date":"2022-02-27T11:45:51.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"C＋＋,map","author_index":"Starlit Rover"},{"id":"ac5b1c5b9bdf438ff9cc932e6cd1efaf","title":"「1007」 Maximum Subsequence Sum","content":"➳ENTRY\nGiven a sequence of K integers . A continuous subsequence is defined to be  where . The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence , its maximum subsequence is  with the largest sum being 20.\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\n\nInput Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.\nOutput Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\nSample Input:10\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:10 1 4\n\n\nΩ最大子序和，顾名思义，求出和最大的连续子序列。\n这是一道非常经典的动态规划问题，据说也是很多大厂的面试题，不过现在应该已经被做烂了，因为之前我就已经碰到过三四回了。对，不是这一类题目，是这一道题目。但我初看题目的时候还是有点懵，估计是之前没想透吧，那么今天就让它永久住在我的博客里，以加深印象。\n说实话一开始的思路必然是有的，第一个想法必然是枚举所有的子序和，野蛮又暴力。作为一个受过高等教育的科班大学生，我们要文明一点。当然不是说枚举不好，有时候枚举也会有意想不到的奇效，but not now.\n仔细分析一下最大子序列，我们不妨设最大子序列为，那么为什么能成为最大子序列呢？首先即的任意连续子序列和必然小于之和。另外的两端要么没有数要么就是负数，不然向两边扩张还可以变大，这与其定义“最大”矛盾。\n由此我们其实可以得到一个非常重要的推论——前n个数之和必然是的，否则丢弃前n个数得到新的子序列之和将会大于之和。那么我们便可以设置一个sum=0变量，依次读入每一个数并计入sum中，若sum&lt;0了根据之前的推论说明前面计入sum的序列不可能成为最大子序列的前置部分，因此直接令sum=0丢弃前面读入的序列和，直到再次读入一个正数后再开始计数。只要sum&gt;0就与最大值进行比较，记录下最大的sum。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, sum = 0, max_sum = -1, former = 0, latter, former_tmp = 0; \n  //former,latter记录最大子序列的首位index，\n  //max_sum=-1考虑0的存在，former_tmp必须赋初值(考虑第一个数是0的情况)\n    cin &gt;&gt; n;\n    latter = n - 1; //全为负数时输出序列的首位两个数\n    vector&lt;int&gt; seq(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;seq[i]);\n        sum += seq[i];\n        if (sum &lt; 0)\n        {\n            sum = 0;\n            former_tmp = i + 1; //former_tmp定位可能的最大子序列头index\n        }\n        else if (sum &gt; max_sum)\n        {\n            max_sum = sum;\n            former = former_tmp;\n            latter = i;\n        }\n    }\n    max_sum = (max_sum &lt; 0 ? 0 : max_sum);//考虑全为负数的情况\n    cout &lt;&lt; max_sum &lt;&lt; \" \" &lt;&lt; seq[former] &lt;&lt; \" \" &lt;&lt; seq[latter];\n}\n\n\nAppendix（无需输出最大子序列头尾版本）#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, sum = 0, max_sum = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        sum = ((sum += m) &gt; 0 ? sum : 0);\n        max_sum = (sum &gt; max_sum ? sum : max_sum);\n    }\n    cout &lt;&lt; max_sum;\n}\n\n\n\n","slug":"1007-Maximum-Subsequence-Sum","date":"2022-02-27T06:48:38.000Z","categories_index":"PAT（Advanced Level）Practice","tags_index":"动态规划,C＋＋","author_index":"Starlit Rover"},{"id":"b84d0f0ccbd1fa272bb501c55b437830","title":"「Section 1」数据格式","content":"\n机器数：数值数据在计算机中的表现形式称为机器数。\n\n表示范围受计算机字长的限制\n\n机器数的符号位必须被数值化为0和1\n\n机器数的小数点是用规定的隐含方式来表达的\n⚠️ 计算机硬件无法区分有符号（signed ）与无符号（unsigned ）数，只能由程序指令加以区分\n\n\n\n\n小数点的表示方法\n\n定点表示法：约定所有机器数的小数点位置都是固定不变的，可分为定点小数、定点整数两种。\n\n定点小数：用于表示纯小数，最高位是符号位，因此位定点小数能表示的最精确数为，即B（⨳为方便描述，定义表示n个k ）\n定点整数：用于表示纯整数，最高位也是符号位，因此位定点整数能表示的绝对值最大的整数为（不考虑补码，补码则是），即B\n\n⚠️然而计算机所处理的很多数据均是整数和小数都不为0的实数，因此在定点计算机中经常需要将实数乘以来移动小数点从而满足纯小数或纯整数的要求，处理完后再复原，\ne.g. \n\n浮点表示法：以科学记数法表示数值，其中表示阶数，数据的小数点位置由阶数决定，因此是浮动的。\n\n阶码的底一般取2的幂次2、8、16，在机器中规定隐含（不记录）\n尾数是一个定点小数，决定浮点数的精度\n阶数是一个定点整数，决定浮点数的表示范围\n\n\n\n\n定点机器数的表示方法：n位定点 [整数\\小数] 一般有位机器数，即符号位不包含在n位定点数中\n\n原码：最高位表示符号位（0正1负，下同 ），其余位与绝对值相同。\n\n对于n位定点整数，正数为其本身，而负数则先取其绝对值再加上最高符号位，因此其原码为\n原\n\n对于n位定点小数，正数为其本身，负数则将整数位变1，其余位不变，因此同定点整数可得\n原\n\n\n特点：0有两个原码，会造成歧义\n\n\n\n反码：最高位为符号位，正数的其余位为其原码，负数则按原码取反。\n\n对于n位定点整数，正数为其本身，而对负数来说，在不考虑符号位的情况下根据反码定义有反，再考虑符号位可得 反 ，因此其反码为\n\n 反\n \n\n对于n位定点小数，正数为其本身，而对负数来说，注意到二进制中有，那么同理有反，再考虑符号位1可得反，因此其反码为\n\n反\n \n\n特点：0依然有两个原码；通常作为补码转换的中间态\n\n\n\n★补码★：最高位为符号位，正数的其余位取原码，负数其余位取反码+1.\n\n对于n位定点整数，根据其定义以及前原码与反码的表达式，可得\n  补\n⚠️负数部分取不到0，但整体范围往负方向平移1\n\n对于n位定点小数，取反码后加1加的是最后一位，即，因此可得\n  补\n  ⚠️负数部分可以取到-1了，-1的补码为，这个编码在反码中为0，在补码中由于负数取值范围的整体平移，使得0将自己的一个编码让出来给了-1。\n\n特点：计算机中最广泛应用的一种机器数表示方法，能将减法用加法实现（补码干了什么：反码时帮你做了减法，补码+1抵消-1，而超过n位发生上溢，从而出色地完成了减法）\n补补\n\n\n\n移码：最高位为符号位，但是0负1正！其余位与补码相同移其中称为偏移量.\n\n\n\n\n","slug":"数据格式","date":"2022-02-24T09:03:45.000Z","categories_index":"计算机组成原理","tags_index":"notes","author_index":"Starlit Rover"},{"id":"8a97cd3a588257a772fc378d09ae2199","title":"「Section 1」计算机网络的概念","content":"\n计算机网络：一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。 总的来说，计算机网络是互连的、自治的（无主从关系 ）计算机集合。\n\n计算机网络的功能\n\n数据通信（连通性 ）\n资源共享\n分布式处理：多台计算机各自承担同一工作任务的不同部分\n提高可靠性\n负载均衡\n\n\n\n计算机网络的组成\n\n组成部分：硬件（主机、链路、通信设备 ）、软件、协议（保证安全可靠的传输 ）\n\n工作方式：\n\n边缘部分：主机存在的部分，用户直接使用\n核心部分：为边缘部分服务\n\n\n功能组成\n\n通信子网：实现数据通信\n资源子网：实现资源共享/数据处理 \n资源处理→通信传输\n\n\n\n\n计算机网络的分类\n\n分布范围：广域网WAN（交换技术 ），城域网MAN，局域网LAN（广播技术 ），个人区域网PAN\n使用者：公用网（e.g. 中国电信 ），专用网（e.g. 政府，军方 ）\n交换技术：电路交换，报文交换，分组交换\n拓扑结构 （通讯设备视为点，链路视为边 ）：星型，总线型，环型，网状型（常用于局域网 ）\n\n\n传输技术：广播式网络（共享公共通信信道 ），点对点网络（使用分组存储转发和路由选择机制 ）\n\nMindmap（from 王道考研 ）\n\n\n\n","slug":"计算机网络的概念","date":"2022-02-23T13:03:14.000Z","categories_index":"计算机网络","tags_index":"notes","author_index":"Starlit Rover"},{"id":"f036210e20161e9bc9972b673206da20","title":"博客着火事件","content":"\n\n浑浑，噩噩。\n\n首先，我只想对在座的各位说：\n一定要记得备份！！！\n\n鬼知道我昨天晚上经历了什么…\n\n\n我的博客是托管在Github上的，但Github也只是静态托管，上面只有已经生成的网页代码，而真正的源代码以及每篇文章的md文件都是存放在本地的一个大文件夹里面的。这么重要的文件夹，那必然得备份一波啊，万一遭遇个什么不测…（阅读理解：此处为后文埋下伏笔，暗示主人公命运的悲剧走向，使欧亨利式结尾出人意料又合乎情理 ）于是乎，我打开百度云，想把这个大文件夹拖到备份文件夹中。就是这轻轻的一拖，我寻思着魔法都没这么神奇——整个大文件夹直接消失了？？\n真的是离谱他妈给离谱开门，离谱到家了好吧\n我翻遍了整个电脑，废纸篓，iCloud（桌面备份竟然默认关闭）。不错不错，真正体会到什么叫做人间蒸发。后来我又用了些数据恢复软件，甚至还和苹果客服聊了半天，最终成功证明确实是找不回来了呢。没猜错的话，应该是我无意间触发了百度云的哪个魔法bug…\n让我觉得最讽刺的是，\n一个文件夹竟然在备份的过程中出现了意外\n\n幸好本地在下一次deploy至Github之前是不会影响静态托管的，也就是网页暂时不会有什么变化。但我要是不补全之前文章的md文件的话，下次deploy后之前的文章就会消失。当然在补文章之前还需要重建博客环境，所幸每次解决问题后我都会在第一篇文章的评论里留下解决日志，从而得以快速重搭环境。\n\nσ感觉，像是一场天降大火，一把就烧了个精光。\n浴火，要么死去，要么重生。\n是这样的。\n\n\n","slug":"博客着火事件","date":"2022-02-11T02:55:42.000Z","categories_index":"Daily","tags_index":"blog","author_index":"Starlit Rover"},{"id":"e48195bb952699bdcd7eaab2b29014de","title":"7-50 畅通工程之局部最小花费问题","content":"➳ENTRY某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全地区畅通需要的最低成本。\n输入格式:输入的第一行给出村庄数目N (1≤N≤100)；随后的行对应村庄间道路的成本及修建状态：每行给出4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态-1表示已建，0表示未建。\n\n\n输出格式:输出全省畅通需要的最低成本。\n输入样例:4\n1 2 1 1\n1 3 4 0\n1 4 1 1\n2 3 3 0\n2 4 2 1\n3 4 5 0\n\n输出样例:3\n\n\nΩ初看这题的分数时，我虎躯一震…竟然有35分。回想自己以往被虐的难题最多也只有30分，莫非是什么绝世难题。\n\n\n不过…看这题目长度并没有难题的气势。\n读完题目，常规之中透着一丝不羁。第一感觉是一道求最小生成树的题目，不过又有所不同，因为部分边已经选定了，我们需要在题目选定部分边的情况下选取成本（权值之和）最小并能使所有点连通的边。既然如此，那就把已经连通的点们看作一个大点，然后求大点们的最小生成树就完事了。参照处理最小生成树的Alg.Kruskal思想，我们可以每次选取一条两个顶点不在同一个连通集内且权值最小的边，直至所有点均连通。\n对于连通集的处理，那就不得不说一说并查集。下面简单介绍一下并查集。\nWikipedia：”并查集是一种用于处理一些不交集的合并及查询问题的数据结构。” 我们需要对一些元素进行划分，这里可以认为元素中有若干个帮派，帮派里的元素也有等级制度（诸如头头，大哥，小弟，etc）。那么事实上我们只要让每个元素记住自己上一级是谁即可，即父节点，而等级最高元素的父节点是他自己，把这种层次形象化后其实就是个树的数据结构。那么对任意一个小弟，通过不断访问父节点的父节点就能找到最大的头头。其最大的特点就是每个元素只存自己的父节点。对于两个帮派交汇，若想要元素较少的帮派归附于另一帮派，只要让该帮派头头的父节点指向（这里的指向并不是说父节点是指针，也可以是数组）另一帮派的头头即可。以上所说的这种呢是毫无优化最基础的并查集，因为很显然在特殊情况下可能会退化成链表。我们当然也可以直接让所有帮派成员的父节点都指向最大元素，有兴趣进一步了解可以移步至算法学习笔记(1) : 并查集。\n那么本题中的村庄很显然就是我们要划分的元素，因此我们可以先定义一个存储各村庄父节点的vector，一开始均初始化为自己:\nvector&lt;int&gt; belong(n);\niota(belong.begin(), belong.end(), 0);\n//belong-&gt;[0,1,2,...,n-1]\n\n同时我们需要一个size向量来存储每个帮派现有的元素个数，好在帮派交汇时决定谁并入谁，这是一种优化策略：\nvector&lt;int&gt; size(n, 1);\n\n对于已经建成的公路，公路两端的村庄是连通的，需要将这两个帮派合并，那么就根据少数并入多数的策略进行合并：\nint max_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[x] : belong[y],\n    min_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[y] : belong[x];\nbelong[min_idx] = max_idx;\nsize[max_idx] += size[min_idx];\n\n由于我想要知道初始情况下连通集的个数，因此我必须让所有成员均指向其帮派头目，才能得知有几个帮派头目。但是上述代码会发生一个帮派头头的父节点指向了另一个帮派头头，但其手下成员的父节点并未更新，因此结束上述操作后还需找到每个元素真正的头头：\nfor (auto &amp;v: belong)\n    while (v != belong[v])\n        v = belong[v];\n\n此时belong中都是头头的编号了，我们只需将其放入set容器中即可得知连通集的个数。显然，每次找一条边只能使连通集个数-1，那么我们需要找的边数即是连通集的个数-1。\n\n话说回来，每条公路的成本该怎么存呢？其实初看题目的时候我就纳闷已经修通的公路为啥还要告诉我成本。如果不给的话，数据倒是不规整了…估计是程序员那该死的强迫症作祟吧。也就是说，其实需要的数据也不是很多…本来最大也就的成本矩阵，现在没这个念头了。本来想用map和pair结合的，不过由于后面需要对成本进行排序…sort和map天性不搭，全剧终。那就找map他爸pair:\nvector&lt;pair&lt;pair&lt;int, int&gt;, int&gt; cost;\n/*pair&lt;pair&lt;village1,village2&gt;,cost&gt;*/\n\n最后，只要将cost按从小到大的顺序进行sort，然后按顺序判断每个公路的两个村庄是否位于两个连通集，若是则计入其成本直至有（连通集的个数-1）条符合条件的公路为止。另外这个过程需要动态更新连通集的关系，因为连通集的个数一直在变少。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;pair&lt;int, int&gt;, int&gt; info;\n\nint main()\n{\n    int n, x, y, c;\n    bool flag;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; belong(n), size(n, 1);\n    vector&lt;info&gt; cost;\n    iota(belong.begin(), belong.end(), 0);\n    for (int i = 0; i &lt; n * (n - 1) / 2; ++i)\n    {\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c &gt;&gt; flag;\n        x -= 1; y -= 1;\n        if (!flag)\n            cost.push_back({ {x, y}, c});\n        else\n        {\n            int max_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[x] : belong[y],\n                min_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[y] : belong[x];\n            belong[min_idx] = max_idx;\n            size[max_idx] += size[min_idx];\n        }\n    }\n    for (auto &amp;v: belong)\n        while (v != belong[v])\n            v = belong[v];\n    set&lt;int&gt; div(belong.begin(), belong.end());\n    int all_cost = 0, idx = 0;\n    sort(cost.begin(), cost.end(), [](info &amp;a, info &amp;b) { return a.second &lt; b.second; });\n    for (int i = 1; i &lt; div.size(); ++i)\n    {\n        int v1, v2;\n        // 优化版\n        do\n        {\n            v1 = cost[idx].first.first, v2 = cost[idx].first.second;\n            while (belong[v1] != belong[belong[v1]])\n                belong[v1] = belong[belong[v1]];\n            while (belong[v2] != belong[belong[v2]])\n                belong[v2] = belong[belong[v2]];\n            ++idx;\n        } while (belong[v1] == belong[v2]);\n        int max_idx = (size[belong[v1]] &gt; size[belong[v2]]) ? belong[v1] : belong[v2],\n            min_idx = (size[belong[v1]] &gt; size[belong[v2]]) ? belong[v2] : belong[v1];\n        belong[min_idx] = max_idx;\n        size[max_idx] += size[min_idx];\n        /* 简化版\n        do\n        {\n            v1 = cost[idx].first.first, v2 = cost[idx].first.second;\n            ++idx;\n        } while (belong[v1] == belong[v2]);\n        belong[belong[v1]] = belong[v2];\n         */\n        all_cost += cost[idx - 1].second;\n    }\n    cout &lt;&lt; all_cost;\n}\n\nΣ 几点说明\nmap的本质是pair，但pair的两部分是平等的，不能通过其一访问另一个\n\niota函数在指定初值后可以使vector按增序排列：\n#include &lt;numeric&gt;\n vector&lt;int&gt; v(num); //需要先确定向量大小\n iota(v.begin(),v.end(),start_num);\n//v=[start_num , start_num+1 , … , start_num+num-1]\n\n经过几次实验，读入bool变量，只能输入0和1.若输入其他数字可能不会影响bool变量的读入，但会影响后面变量的读入.\n\n优化版代码在查找符合条件的公路时顺便更新父节点，并依旧按照小并大原则进行合并，这在数据较大时较有优势；而简化版则简短精炼，合并时不管三七二十一均将v1并入v2，也不更新父节点. 以下是两者的时间比较：\n☜优化版简化版☞\n❣\n❣\n❣\n❣\n❣\n❣\n\n\nδ 彩蛋然鹅简化版真的是对的吗？哈哈哈哈，虽然简化版确实通过了所有测试点，但我一直觉的简化版不够严谨，因此尝试着枚举一个反例出来。随便构造了一个：\n\n\n简化版真的是对的吗？哈哈哈哈，虽然简化版确实通过了所有测试点，但我一直觉的简化版不够严谨，因此尝试着枚举一个反例出来。随便构造了一个：\n5\n1 2 2 0\n1 3 10 1\n1 4 10 0\n1 5 3 0\n2 3 1 0\n2 4 10 1\n2 5 10 0\n3 4 10 0\n3 5 10 0\n4 5 10 0\n\n这个测试用例优化版的结果是4，而简化版的结果是3。显然，简化版中枪了，我构造的思路就是着眼于简化版不动态更新各个元素的父节点，不更新也就算了，在检查的时候还不访问元素父节点的父节点，这样在一定的条件下就必然会导致选中的一条公路，其端点两个村庄的父节点不同，然而在之前的选取过程中这两个父节点已经合并了，也就是说，选取了一条处于一个连通集中的公路，花了没必要的造路成本。\n哈哈哈哈哈哈，说的简化版不是我写的一样，其实简化版是我在提交完优化版后乱删而成的。当时就想着能不能简化代码，但自己改改太累了，不妨先试着删亿点然后提交看看，如果通过了那就再思考思考为什么可以删掉，于是乎，有了这个彩蛋！我已经将这个问题以邮件的形式发给PTA了，但我没留名字，或许以后能在这道题下面看到感谢一位不知名的同学补充数据！那么怎么改正简化版呢，其实不改do-while部分就好了：\ndo\n{\n    v1 = cost[idx].first.first, v2 = cost[idx].first.second;\n    while (belong[v1] != belong[belong[v1]])\n        belong[v1] = belong[belong[v1]];\n    while (belong[v2] != belong[belong[v2]])\n        belong[v2] = belong[belong[v2]];\n    ++idx;\n} while (belong[v1] == belong[v2]);\nbelong[belong[v1]] = belong[v2];\n","slug":"7-50-畅通工程之局部最小花费问题","date":"2022-02-09T14:37:31.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"C＋＋,Graph,pair,并查集,numeric","author_index":"Starlit Rover"},{"id":"b06eec1520de8e94623ad87c71416a11","title":"7-48 银行排队问题之单窗口“夹塞”版","content":"➳ENTRY排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第i位顾客与排在后面的第j位顾客是好朋友，并且愿意替朋友办理事务的话，那么第i位顾客的事务处理时间就是自己的事务加朋友的事务所耗时间的总和。在这种情况下，顾客的等待时间就可能被影响。假设所有人到达银行时，若没有空窗口，都会请求排在最前面的朋友帮忙（包括正在窗口接受服务的朋友）；当有不止一位朋友请求某位顾客帮忙时，该顾客会根据自己朋友请求的顺序来依次处理事务。试编写程序模拟这种现象，并计算顾客的平均等待时间。\n\n输入格式:输入的第一行是两个整数：1≤N≤10000，为顾客总数；0≤M≤100，为彼此不相交的朋友圈子个数。若M非0，则此后M行，每行先给出正整数2≤L≤100，代表该圈子里朋友的总数，随后给出该朋友圈里的L位朋友的名字。名字由3个大写英文字母组成，名字间用1个空格分隔。最后N行给出N位顾客的姓名、到达时间T和事务处理时间P（以分钟为单位），之间用1个空格分隔。简单起见，这里假设顾客信息是按照到达时间先后顺序给出的（有并列时间的按照给出顺序排队），并且假设每个事务最多占用窗口服务60分钟（如果超过则按60分钟计算）。\n输出格式:按顾客接受服务的顺序输出顾客名字，每个名字占1行。最后一行输出所有顾客的平均等待时间，保留到小数点后1位。\n输入样例:6 2\n3 ANN BOB JOE\n2 JIM ZOE\nJIM 0 20\nBOB 0 15\nANN 0 30\nAMY 0 2\nZOE 1 61\nJOE 3 10\n输出样例:JIM\nZOE\nBOB\nANN\nJOE\nAMY\n75.2\n\nΩ终于不再是一道处理字符串的题目了，这道题较前面几题都略难一些，也更有意思一点。初看这道题的时候没有什么特别好的思路，愣了半天，不知道这跟什么数据结构有关，那就依感觉写吧。\n第一个问题是如何存储他们之间的朋友关系，最先想到的是无向图，建立一个关系矩阵，最大的情况是，很可能会是个稀疏矩阵，感觉这道题没有必要用图。或者只要每个顾客存一下自己所在朋友圈的编号也是可以直接判断两人是否为朋友。观察这道题的要求，其实每个人只会找前一个离自己最近的朋友帮忙，因此我们只要知道每个顾客后面最近的朋友位置即可。由此可以建一个client类：\nclass client\n{\npublic:\n    string name;\n    int T, P, nxt = -1;\n    //T-&gt;Arrival Time,P-&gt;Processing Time\n    //nxt-&gt;number in line of next friend,-1 means no friend in line behind himself\n}\n那么当每位顾客都办完事后都看看队伍后面有没有自己的朋友，有的话帮他也办了，以此类推。注意如果办完事朋友还没到则不能帮忙。整条队伍的顺序可以用一个vector存储。对于帮忙办完事的朋友，可以选择从队伍中删除，也可以设置一个isProcessed的布尔变量来标记，若已处理则continue。前者可能会导致循环出现问题，因此这里我选择的是后者。由于还需要计算平均等待时间(⚠️等待时间不包括自己事情处理的时间)，因此要设置一个time变量来记录当前的时间，time减去当前顾客到达时间即为其等待时间。\n当我以为可能会有测试点超时的时候，竟然一次性全部通过了。真是很难体会到这种feeling了，且行且珍惜吧。\n\nC☺DE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nclass client\n{\npublic:\n    string name;\n    bool isProcessed = false;\n    int T, P, nxt = -1;\n\n    client(string _name, int t, int p):\n    name(move(_name)), T(t), P(p) {};\n};\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m;\n    map&lt;string, int&gt; circle;\n    //pre_loc[i]表示朋友圈i此时最后一个读入的顾客在队伍中的序号\n    vector&lt;int&gt; pre_loc(m, -1);\n    string name;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; k;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; name;\n            circle[name] = i + 1;\n            //对没有朋友圈的name，circle[name]会初始化为0，因此+1使有朋友圈的name不会为0\n        }\n    }\n    vector&lt;client&gt; queue;\n    int t, p;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; t &gt;&gt; p;\n        queue.emplace_back(client(name, t, p &gt; 60 ? 60 : p));\n        if (circle[name])\n        {\n            if (pre_loc[circle[name] - 1] != -1)\n                queue[pre_loc[circle[name] - 1]].nxt = i;\n            pre_loc[circle[name] - 1] = i;\n        }\n    }\n    int time = 0, all_waiting_time = 0;\n    vector&lt;string&gt; final_list;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (queue[i].isProcessed)\n            continue;\n        //考虑窗口存在闲置的时间\n        time = time &lt; queue[i].T ? queue[i].T : time;\n        int clt = i;\n        while (clt != -1 &amp;&amp; time &gt;= queue[clt].T)\n        {\n            all_waiting_time += (time - queue[clt].T);\n            time += queue[clt].P;\n            final_list.push_back(queue[clt].name);\n            queue[clt].isProcessed = true;\n            clt = queue[clt].nxt;\n        }\n    }\n    for (auto &amp;s: final_list)\n        cout &lt;&lt; s &lt;&lt; endl;\n    cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; 1.0 * all_waiting_time / n &lt;&lt; endl;\n}","slug":"7-48-银行排队问题之单窗口“夹塞”版","date":"2022-02-08T14:22:42.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"C＋＋,vector","author_index":"Starlit Rover"},{"id":"0c577028a09af77ed6d5c0870f900894","title":"7-47 打印选课学生名单","content":"➳ENTRY假设全校有最多40000名学生和最多2500门课程。现给出每个学生的选课清单，要求输出每门课的选课学生名单。\n输入格式:输入的第一行是两个正整数：N（≤40000），为全校学生总数；K（≤2500），为总课程数。此后N行，每行包括一个学生姓名（3个大写英文字母+1位数字）、一个正整数C（≤20）代表该生所选的课程门数、随后是C个课程编号。简单起见，课程从1到K编号。\n\n\n输出格式:顺序输出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号和选课学生总数（之间用空格分隔），之后在第二行按字典序输出学生名单，每个学生名字占一行。\n输入样例:10 5\nZOE1 2 4 5\nANN0 3 5 2 1\nBOB5 5 3 4 2 1 5\nJOE4 1 2\nJAY9 4 1 2 5 4\nFRA8 3 4 2 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 5 4 2\nLOR6 4 2 4 1 5\n\n输出样例:1 4\nANN0\nBOB5\nJAY9\nLOR6\n2 7\nANN0\nBOB5\nFRA8\nJAY9\nJOE4\nKAT3\nLOR6\n3 1\nBOB5\n4 7\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n5 9\nAMY7\nANN0\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n\n\nΩ其实这道题我不是很想写，感觉自己将背负着水文章的嫌疑，因为确实不是一般的水，但debug还是卡了半天，其中一些坎坷也可以拿出来聊一聊。由于每一门课程的学生是不会重复的，而且最后需要按字母序输出学生名单，那么自然而然就想到了set容器。码呢，也非常简单，三下五除二，就三十来行。内心感觉非常良好，小手一点\n运行超时老熟人了，内心狂喜cout，cin拜拜吧(参见7-45 航空公司VIP客户查询)…不过这里有一个问题：C中的printf和scanf要如何与C++的string类兼容？\nstring 类提供了c_str()方法可供printf：\nprintf(\"%s\",str.c_str());\n\n另外对于scanf，我们需要用resize方法先给 str分配空间，然后再将str的头指针传给scanf，这与我们认识的scanf相同：\nstr.resize(n);\nscanf(\"%s\",&amp;str[0]);\n\n小手一点，【运行超时】变成了【答案错误】？\n注意到前面5个测试点都通过了，最后一个测试点的数据量拉满🤔，估计是容器的问题。于是我将set换成vector，最后对每门课程的vector进行sort后输出，bingo！嗯，看来用set也要节制，毕竟set的底层是用红黑树实现的，复杂度必然是要比线性容器高许多的。\n\n🐎#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, c, m;\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    string name;\n    name.resize(5);\n    vector&lt;vector&lt;string&gt;&gt; info(k, vector&lt;string&gt;());\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;name[0], &amp;c);\n        for (int j = 0; j &lt; c; ++j)\n        {\n            scanf(\"%d\", &amp;m);\n            info[m - 1].push_back(name);\n        }\n    }\n    for (int i = 0; i &lt; k; ++i)\n    {\n        printf(\"%d %d\\n\", i + 1, info[i].size());\n        sort(info[i].begin(), info[i].end());\n        for (auto &amp;w: info[i])\n            puts(w.c_str());\n    }\n}","slug":"7-47-打印选课学生名单","date":"2022-02-06T14:08:04.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"C＋＋,vector","author_index":"Starlit Rover"},{"id":"44dec690db2bddd5b1d02e910fef2f3a","title":"7-46 新浪微博热门话题","content":"➳ENTRY新浪微博可以在发言中嵌入“话题”，即将发言中的话题文字写在一对“#”之间，就可以生成话题链接，点击链接可以看到有多少人在跟自己讨论相同或者相似的话题。新浪微博还会随时更新热门话题列表，并将最热门的话题放在醒目的位置推荐大家关注。\n本题目要求实现一个简化的热门话题推荐功能，从大量英文（因为中文分词处理比较麻烦）微博中解析出话题，找出被最多条微博提到的话题。\n输入格式:输入说明：输入首先给出一个正整数N（≤），随后N行，每行给出一条英文微博，其长度不超过140个字符。任何包含在一对最近的#中的内容均被认为是一个话题，输入保证#成对出现。\n\n\n输出格式:第一行输出被最多条微博提到的话题，第二行输出其被提到的微博条数。如果这样的话题不唯一，则输出按字母序最小的话题，并在第三行输出And k more …，其中k是另外几条热门话题的条数。输入保证至少存在一条话题。\n\n注意：两条话题被认为是相同的，如果在去掉所有非英文字母和数字的符号、并忽略大小写区别后，它们是相同的字符串；同时它们有完全相同的分词。输出时除首字母大写外，只保留小写英文字母和数字，并用 一 个 空 格 分隔原文中的单词。\n\n输入样例:4\nThis is a #test of topic#.\nAnother #Test of topic.#\nThis is a #Hot# #Hot# topic\nAnother #hot!# #Hot# topic\n\n输出样例:Hot\n2\nAnd 1 more ...\n\n\nΩ第一次提交…\n可以接受的啦，毕竟\nAC只是coding中的冰淇淋，debug才是coding的正餐。\n——沃滋基硕德 \n本题满分30分，我已经拿到了20分，看来 大势已去，让我们看下一题 又是一些非常微小的细节所导致的错误。\n通过仔细阅读题目，不难发现【注意】里面有一句非常显眼的话说要用 **一 个 空 格** 分隔单词。\nSo easy的啦～读到空格的时候把后面的分隔符全部读掉就完事了。\n\n哦对，空格可能在开头哦对，非英文字母和数字的符号也会分隔哦对，空格后面还可能是结束符’#’哦对，会不会’#’之间只有空格呢😅\n[小手一点]\n可以接受的啦，就差4分了呢~。。。Ten minutes later…\n\n不科学啊，一个话题的情况怎么会出错呢，我试了∞个输入了\n最后，我在网上找到别人AC的码来自己测试，刚输完一个人就傻了😅 通过更加仔细地阅读题目，不难发现 “如果这样的话题不唯一，则输出按字母序最小的话题，并在第三行输出And k more …” 也就是说，不存在”And 0 more …”的输出。\n人老了，希望眼睛还健在。\n\nCodeee#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;string, int&gt; tc;\n\nint main()\n{\n    set&lt;string&gt; topics;\n    map&lt;string, int&gt; topics_cnt;\n    int n;\n    cin &gt;&gt; n;\n    getchar();\n    string str, topic;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        getline(cin, str);\n        for (int j = 0; j &lt; str.size(); ++j)\n            if (str[j] == '#')\n            {\n                j += 1;\n                while (str[j] != '#')\n                {\n                    if (isalnum(str[j]))\n                        topic += str[j];\n                    else //测试点2：非英文字母和数字符号也具有分词作用\n                    {\n                        while (!isalnum(str[++j]) &amp;&amp; str[j] != '#');\n                        if (str[j] != '#' &amp;&amp; !topic.empty())\n                            topic += ' ';\n                        j -= 1;\n                    }\n                    ++j;\n                }\n                transform(topic.begin(), topic.end(), topic.begin(), ::tolower);\n                topics.insert(topic);\n                topic = \"\";\n            }\n        for (auto &amp;t: topics)\n            topics_cnt[t] += 1;\n        topics.clear();\n    }\n    vector&lt;tc&gt; cup(topics_cnt.begin(), topics_cnt.end());\n    sort(cup.begin(), cup.end(), [](tc &amp;a, tc &amp;b) { return a.second &gt; b.second; });\n    int index = 0;\n    string hottest_topic = cup[0].first;\n    while (++index &lt; cup.size() &amp;&amp; cup[index].second == cup[0].second)\n        if (cup[index].first &lt; hottest_topic)\n            hottest_topic = cup[index].first;\n    hottest_topic[0] = toupper(hottest_topic[0]);\n    cout &lt;&lt; hottest_topic &lt;&lt; endl &lt;&lt; cup[0].second &lt;&lt; endl;\n    if (index &gt; 1) //测试点3\n        cout &lt;&lt; \"And \" &lt;&lt; index - 1 &lt;&lt; \" more ...\";\n}\n\n\n∑ 几点说明\n基本思路：一条微博中的话题用set存储可以避免重复计算，读完一条微博后将set中的话题计数至map中\n\nsort不能对map进行排序，因此先将原map放置于同类型pair的vector中，再进行排序，排序完找最小话题\n\n依然用transform函数将所有英文字母转换为小写，最后将首字母转换为大写\n\n这里用到的isalnum函数用来判断字符是否为字母或数字\n\n\n\n函数\n 作用\n\n\n\nislower(char c)\n是否为小写字母\n\n\nisupper(char c)\n是否为大写字母\n\n\nisdigit(char c)\n是否为数字\n\n\nisalpha(char c)\n是否为字母\n\n\nisalnum(char c)\n是否为字母或者数字\n\n\ntoupper(char c)\n字母小写转大写\n\n\ntolower(char c)\n字母大写转小写\n\n\n\n\n","slug":"7-46-新浪微博热门话题","date":"2022-02-06T13:21:31.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"C＋＋,map,set","author_index":"Starlit Rover"},{"id":"bd9129163f952044453adc76640f4d91","title":"7-45 航空公司VIP客户查询","content":"➳ENTRY不少航空公司都会提供优惠的会员服务，当某顾客飞行里程累积达到一定数量后，可以使用里程积分直接兑换奖励机票或奖励升舱等服务。现给定某航空公司全体会员的飞行记录，要求实现根据身份证号码快速查询会员里程积分的功能。\n输入格式:输入首先给出两个正整数N（≤）和K（≤500）。其中K是最低里程，即为照顾乘坐短程航班的会员,航空公司还会将航程低于K公里的航班也按K公里累积。随后N行，每行给出一条飞行记录。飞行记录的输入格式为：18位身份证号码（空格）飞行里程。其中身份证号码由17位数字加最后一位校验码组成，校验码的取值范围为0~9和x共11个符号；飞行里程单位为公里，是(0, 15000]区间内的整数。然后给出一个正整数M（≤），随后给出M行查询人的身份证号码。\n\n输出格式:对每个查询人，给出其当前的里程累积值。如果该人不是会员，则输出No Info。每个查询结果占一行。\n输入样例:4 500\n330106199010080419 499\n110108198403100012 15000\n120104195510156021 800\n330106199010080419 1\n4\n120104195510156021\n110108198403100012\n330106199010080419\n33010619901008041x\n输出样例:800\n15000\n1000\nNo Info\n\nCedo#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, int&gt; fly;\n    int m, n, k, d;\n    string id;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; d;\n        fly[id] += (d &lt; k ? k : d);\n    }\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id;\n        if (fly.find(id) == fly.end())\n            cout &lt;&lt; \"No Info\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; fly[id] &lt;&lt; endl;\n    }\n}\nΩ乍看这道题也太简单了吧，直接用map容器乱杀，但是提交上述代码后却得到下面的结果：\n开始纳闷了，map容器优化的不够好？循着往昔惨痛经历，突然想起cout是个费时的输出函数，那就把所有的cout改成printf试试（满怀期待.jpg)�怎么还是一样的结果…cin和cout是一伙的，一起干了吧。\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, int&gt; fly;\n    int m, n, k, d;\n    char id[19];\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;id, &amp;d);\n        fly[id] += (d &lt; k ? k : d);\n    }\n    scanf(\"%d\", &amp;m);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%s\", &amp;id);\n        if (fly[id])\n            printf(\"%d\\n\", fly[id]);\n        else\n            printf(\"No Info\\n\");\n        // 若id不存在，则fly[id]自动初始化为0\n    }\n}\n[小手一点]\n嗯？(省略一千字脏话…\n由于运行超时的代码看不了运行时间，因此我又顺带把printf改回cout也是可以通过的：\n嗯，在危险的边缘疯狂试探…(限时400ms)\n\nΣ 结语事实上已经有很多人做过关于cin、cout 与scanf、printf的效率比较实验了，测试结果显示后者比前者快了将近10倍. 有一种解释认为前者需要缓存而后者直接调用系统的IO函数，是非缓存的. 另外流输入输出依赖于函数重载，也会造成效率的低下.\n","slug":"7-45-航空公司VIP客户查询","date":"2022-02-02T12:48:48.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"C＋＋,map","author_index":"Starlit Rover"},{"id":"c1bb0c3958152b806f4d44bad6ebbf7f","title":"7-44 基于词频的文件相似度","content":"➳ENTRY实现一种简单原始的文件相似度计算，即以两文件的公共词汇占总词汇的比例来定义相似度。为简化问题，这里不考虑中文（因为分词太难了），只考虑长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。\n输入格式:输入首先给出正整数N（≤100），为文件总数。随后按以下格式给出每个文件的内容：首先给出文件正文，最后在一行中只给出一个字符#，表示文件结束。在N个文件内容结束之后，给出查询总数M（≤），随后M行，每行给出一对文件编号，其间以空格分隔。这里假设文件按给出的顺序从1到N编号。\n\n\n输出格式:针对每一条查询，在一行中输出两文件的相似度，即两文件的公共词汇量占两文件总词汇量的百分比，精确到小数点后1位。注意这里的一个“单词”只包括仅由英文字母组成的、长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。单词间以任何非英文字母隔开。另外，大小写不同的同一单词被认为是相同的单词，例如“You”和“you”是同一个单词。\n输入样例:3\nAaa Bbb Ccc\n#\nBbb Ccc Ddd\n#\nAaa2 ccc Eee\nis at Ddd@Fff\n#\n2\n1 2\n1 3\n\n输出样例:50.0%\n33.3%\n\n\nCode～#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, a, b;\n    cin &gt;&gt; n;\n    vector&lt;set&lt;string&gt;&gt; files(n, set&lt;string&gt;());\n    char c = getchar();\n    for (size_t i = 0; i &lt; n; ++i)\n    {\n        string s = \"\";\n        while ((c = getchar()) != '#')\n        {\n            if (isalpha(c))\n                s += c;\n            else\n            {\n                if (s.size() &lt; 3)\n                {\n                    s = \"\";\n                    continue;\n                } else if (s.size() &gt; 10)\n                    s = s.substr(0, 10);\n                transform(s.begin(), s.end(), s.begin(), ::tolower);\n                files[i].insert(s);\n                s = \"\";\n            }\n        }\n    }\n    cin &gt;&gt; m;\n    for (size_t i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        set&lt;string&gt; inter;\n        set_intersection(files[a - 1].begin(), files[a - 1].end(), files[b - 1].begin(), files[b - 1].end(),\n                         inserter(inter, inter.begin()));\n        printf(\"%.1f%%\\n\", inter.size() * 100.0 / (files[a - 1].size() + files[b - 1].size() - inter.size()));\n        inter.clear();\n    }\n}\n\nΩ 一些说明：1.基本思想：一个文件中所有的有效单词用set进行存储，各个文件的set用一个vector进行存储。对于任意两个文件公共词汇个数的求取，是直接求两个文件set的交集(set_intersection,from &lt; algorithm &gt;)的个数。\n2.由于不分大小写，因此存入的单词统一转为相应的小写单词存入。这里采用的是transform(s.begin(), s.end(), s.begin(), ::tolower)方法，将tolower函数应用于s的每个字符。\n3.tolower函数之前有“::”是因为这个函数既有C版本的，又有STL模板的，二者存在冲突。这里用定界符强制指定为C版本的。\n4.set_intersect函数可以求取两个set的交集，另外还有set_union（取并集）、set_difference（取差集）、set_symmetric_difference（取对称差集）等函数。\n","slug":"7-44-基于词频的文件相似度","date":"2022-01-27T16:37:22.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"C＋＋,set","author_index":"Starlit Rover"},{"id":"4d044ba098bb35996b72630bc962fb79","title":"README","content":"\n\n\n\n\n\n\n\n✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦ Github仓库导航   ✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦✦\n\n\n\n","slug":"README","date":"2022-01-27T08:50:38.000Z","categories_index":"PTA-数据结构与算法题目集","tags_index":"","author_index":"Starlit Rover"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Hello, nice to meet you! I’m Starlit Rover, Jammy Zeta. \nWelcome to my Blog, which is powered by Hexo. This is my very first post . \nActually, the thought of creating a blog for myself originated long long time ago. Through blog, I want to record some studying process and outcomes or write something about my emotional ups and downs. In my belief, it is bound to be a brilliant journey!\nBuilding this blog mainly referred to this webpage, to which my much appreciation goes. What’s more, I  encountered many obstacles in the process. But fortunately, they all have already been tackled by seniors, which sharply diminished my bug-killing time.\n\nprintf(\"Hello, World!\");\nprint(\" 哈啰！\")\ncout &lt;&lt; \"Hola!\";\ndisp('Morning!');\nSystem.out.println(\"Go for it!\");\necho \"Life is not about how to live through storms but how to dance in the rain.\"\n\n\n\n\n\n","slug":"hello-world","date":"2022-01-16T08:08:38.000Z","categories_index":"Daily","tags_index":"blog","author_index":"Starlit Rover"}]