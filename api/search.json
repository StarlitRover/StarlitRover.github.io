[{"id":"9cc2213cd21176f4b7bef7f9e55191e3","title":"ã€ŒChapter 1ã€åˆè¯†MySQL","content":"å…³äºæ•°æ®åº“è¿™é—¨è¯¾ç€å®æ²¡å­¦å¤ªæ˜ç™½ï¼Œè€å¸ˆæ˜¯ä¸€ä½åˆšä»å“ˆå·¥å¤§æ¯•ä¸šçš„ç¾å¥³æ•™å¸ˆï¼Œä¸è¿‡è®²è¯¾ç¡®å®ä¸æ•¢æ­ç»´ï¼Œç”Ÿç¡¬çš„PPTï¼Œä¹¦é¢åŒ–çš„è®²è¿°ï¼Œå¤§æ¦‚ç‡æ˜¯æ•™å­¦ç»éªŒçš„ç¼ºå¤±ã€‚æœ€åè€ƒå‰è‡ªå·±æŠŠä¹¦æœ¬å•ƒäº†ä¸€éï¼Œç›¸ä¿¡è€å¸ˆä¸ä¼šå¤ªåˆéš¾æˆ‘ä»¬ï¼Œæ‰€ä»¥è€ƒå‰ä¹Ÿå°±çœ‹äº†çœ‹ä¹¦ï¼Œç»“æœè€ƒè¯•ç›´æ¥éš¾å‡ºå¤©é™…ï¼Œåˆ—æ–‡è™å…‹å¼å‡ºé¢˜ï¼Œè¦†ç›–äº†å¾ˆå¤šçŸ¥è¯†ç‚¹ï¼Œäºæ˜¯å°±ä¸å‡ºæ„æ–™åœ°è€ƒç‚¸äº†ï¼Œå¯ä»¥çœ‹å¾—å‡ºè€å¸ˆå‡ºé¢˜çš„ç”¨å¿ƒè‰¯è‹¦ã€‚\nå½“ç„¶å·²ç»è¿‡å»è®¸ä¹…ï¼Œè‡³ä»Šæˆ‘å¯¹æ•°æ®åº“ç¡®å®è¿˜æ²¡æœ‰ä¸€ä¸ªæ¸…æ™°çš„ä½“ç³»æ¡†æ¶ï¼Œæ‰€ä»¥ä¹°äº†ä¸€æœ¬ã€ŠMySQLæ˜¯æ€æ ·è¿è¡Œçš„ã€‹ï¼Œè±†ç“£ä¸Šè¯„ä»·æŒºé«˜ï¼Œå¾ˆæ—©å°±æƒ³ä¹°äº†ã€‚çœ‹äº†ä½œè€…å‰è¨€ï¼Œå†…å¿ƒä¸€é˜µé…¸æºœï¼Œä½œè€…æœ¬æ˜¯ç¨‹åºå‘˜ï¼Œä¸­é€”è¾èŒå†™ä¹¦ï¼Œå‡ºç‰ˆæ—¶å´å‘ç°è‡ªå·±æ²¡æœ‰åæ°”éš¾ä»¥å‡ºç‰ˆï¼Œæœ€åå¹¸æœ‰å¥½å¿ƒäººç›¸åŠ©æ‰å¾—ä»¥å‡ºç‰ˆã€‚å¸Œæœ›è¿™æœ¬å°é¢çœ‹èµ·æ¥åƒå¹¼å„¿å¯è’™è¯»æœ¬çš„ä¹¦èƒ½æˆä¸ºæˆ‘æ•°æ®åº“åŸç†çš„å¯è’™è¯»æœ¬ã€‚\nè¿™ä¸ªç³»åˆ—æ˜¯å…³äºè¿™æœ¬ä¹¦çš„ç¬”è®°ï¼Œä¸å®šæœŸæ›´æ–°ï¼Œæˆ‘ä¸ä¼šè®°å¾—å¤ªè¯¦ç»†ï¼Œå°½é‡å¤šå†™è‡ªå·±çš„ç†è§£å’Œæ„Ÿæ‚Ÿï¼Œæœ‰å…´è¶£å¯ä»¥è´­ä¹¦æ”¯æŒä¸€ä¸‹ï¼Œä½œè€…ä¹Ÿæ˜¯ç¨‹åºå‘˜ä¸­çš„ä¸€è‚¡æ¸…æµã€‚\n\nMySQLæ˜¯Oracleæ——ä¸‹çš„ä¸€ä¸ªå…³ç³»å‹æ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼Œæ•´ä½“åˆ†ä¸ºæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¸¤éƒ¨åˆ†ï¼ŒæœåŠ¡å™¨è´Ÿè´£å¤„ç†å“åº”å®¢æˆ·ç«¯å‘æ¥çš„å‘½ä»¤ï¼Œå¹¶å°†å‘½ä»¤ç»“æœå‘å›å®¢æˆ·ç«¯ã€‚\nåœ¨ä¸ªäººç”µè„‘ä¸Šä¸‹è½½MySQLåï¼ŒæœåŠ¡å™¨ç¨‹åºå’Œå®¢æˆ·ç«¯ç¨‹åºéƒ½å®‰è£…åœ¨äº†ç”µè„‘ä¸Šã€‚\n","slug":"ã€ŒChapter-1ã€åˆè¯†MySQL","date":"2023-01-27T12:09:36.000Z","categories_index":"æ•°æ®åº“åŸç†","tags_index":"notes,MySQLæ˜¯æ€æ ·è¿è¡Œçš„","author_index":"Starlit Rover"},{"id":"fec11be8fe74efb46e38390fb6e3547a","title":"ã€1167ã€Cartesian Tree","content":"AÂ Cartesian treeÂ is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.\n\nYour job is to output the level-order traversal sequence of the min-heap Cartesian tree.\n\n\nInput Specification:Each input file contains one test case. Each case starts from giving a positive integerÂ NÂ (â‰¤30), and thenÂ NÂ distinct numbers in the next line, separated by a space. All the numbers are in the range ofÂ int.\nOutput Specification:For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.\nSample Input:10\n8 15 3 4 1 5 12 10 18 6\n\nSample Output:1 3 5 8 4 6 15 10 12 18\n\n\nÎ©ç¬›å¡å°”æ ‘æ˜¯é€šè¿‡ä¸€ä¸²åºåˆ—è¿›è¡Œæ„é€ çš„ï¼Œå®ƒæ»¡è¶³æœ€å°å †çš„ç‰¹å¾ï¼ˆçˆ¶èŠ‚ç‚¹&lt;å­èŠ‚ç‚¹ï¼‰ï¼ŒåŒæ—¶å®ƒçš„ä¸­åºéå†ç»“æœå°±æ˜¯æ„é€ åºåˆ—ã€‚\nç”±äºæ„é€ åºåˆ—ä¸ä¸­åºéå†æ˜¯ä¸€è‡´çš„ï¼Œé‚£ä¹ˆåœ¨é€ä¸€æ’å…¥èŠ‚ç‚¹çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬åªèƒ½å°†æ–°èŠ‚ç‚¹æ’å…¥åˆ°ç°æœ‰èŠ‚ç‚¹çš„å³è¾¹ï¼ˆåŸæœ‰èŠ‚ç‚¹æ˜¯æ–°èŠ‚ç‚¹çš„å·¦å­æ ‘/æ–°èŠ‚ç‚¹æ˜¯åŸæœ‰èŠ‚ç‚¹çš„å³å­æ ‘ï¼‰ï¼Œæ‰èƒ½ä¿è¯ä¸­åºéå†ä¸­æ–°èŠ‚ç‚¹åœ¨ç°æœ‰èŠ‚ç‚¹çš„åé¢ã€‚ç„¶åæœ€å°å †çš„ç‰¹å¾çº¦æŸäº†å°èŠ‚ç‚¹å¿…é¡»åœ¨å¤§èŠ‚ç‚¹çš„ä¸Šæ–¹ï¼Œå¯ä»¥è®¤ä¸ºä¸€ä¸ªçº¦æŸäº†å·¦å³ï¼Œå¦ä¸€ä¸ªçº¦æŸäº†ä¸Šä¸‹ï¼Œé‚£ä¹ˆå°±å¯ä»¥åˆ¶å®šå¦‚ä¸‹æ’å…¥æ–¹æ¡ˆï¼š\n\næ–°èŠ‚ç‚¹&gt;å½“å‰èŠ‚ç‚¹ï¼šå‘å³å­æ ‘æ’å…¥\n\næ–°èŠ‚ç‚¹&lt;å½“å‰èŠ‚ç‚¹ï¼šå°†å½“å‰èŠ‚ç‚¹ä½œä¸ºæ–°èŠ‚ç‚¹çš„å·¦å­æ ‘\n\n\næ¯æ¬¡éƒ½ä»æ ¹èŠ‚ç‚¹å¼€å§‹æ’å…¥ï¼Œé€’å½’æ’å…¥å‡½æ•°è¿”å›æ’å…¥åå­æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚å¦å¤–ç”±äºèŠ‚ç‚¹é”®å€¼æ˜¯æ•´å‹èŒƒå›´ï¼Œå› æ­¤è¿˜éœ€è¦ä¸€ä¸ªboolæ•°ç»„æ ‡è®°å„ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ã€‚\nå®Œç»“æ’’èŠ±ï¼Œç¥æˆ‘æ˜å¤©è€ƒè¯•é¡ºåˆ©ï½\n\n\n\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nmap&lt;int, pair&lt;bool, bool&gt;&gt; has;\n\nint insert(int r, int k)\n{\n    if (r &lt; k &amp;&amp; has[r].second)\n        sons[r].second = insert(sons[r].second, k);\n    else if (r &lt; k)\n        sons[r].second = k, has[r].second = true;\n    else if (r &gt; k)\n    {\n        sons[k].first = r, has[k].first = true;\n        return k;\n    }\n    return r;\n}\n\nint main()\n{\n    int n, r, k;\n    cin &gt;&gt; n &gt;&gt; r;\n    for (int i = 1; i &lt; n; ++i)\n        cin &gt;&gt; k, r = insert(r, k);\n    vector&lt;int&gt; crt{r}, nxt;\n    bool space = false;\n    while (!crt.empty())\n    {\n        for (auto &amp;t: crt)\n        {\n            printf(\"%s%d\", space ? \" \" : (space = true, \"\"), t);\n            if (has[t].first) nxt.push_back(sons[t].first);\n            if (has[t].second) nxt.push_back(sons[t].second);\n        }\n        crt = std::move(nxt), nxt = vector&lt;int&gt;();\n    }\n}\n","slug":"ã€1167ã€Cartesian-Tree","date":"2022-12-02T06:37:46.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Tree","author_index":"Starlit Rover"},{"id":"198f2c49e9910efe18930d8f84735116","title":"ã€Œ1166ã€Summit","content":"AÂ summitÂ (å³°ä¼š) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangement of one area is to invite those heads so that everyone is a direct friend of everyone.\nNow given a set of tentative arrangements, your job is to tell the organizers whether or not each area is all set.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (â‰¤Â 200), the number of heads in the summit, and M, the number of friendship relations. Then M lines follow, each gives a pair of indices of the heads who are friends to each other. The heads are indexed from 1 to N.\nThen there is another positive integer K (â‰¤Â 100), and K lines of tentative arrangement of rest areas follow, each first gives a positive number L (â‰¤Â N), then followed by a sequence of L distinct indices of the heads. All the numbers in a line are separated by a space.\nOutput Specification:For each of the K areas, print in a line your advice in the following format:\n\nif in this area everyone is a direct friend of everyone, and no friend is missing (that is, no one else is a direct friend of everyone in this area), printÂ Area X is OK..\n\nif in this area everyone is a direct friend of everyone, yet there are some other heads who may also be invited without breaking the ideal arrangement, printÂ Area X may invite more people, such as H.Â whereÂ HÂ is the smallest index of the head who may be invited.\n\nif in this area the arrangement is not an ideal one, then printÂ Area X needs help.Â so the host can provide some special service to help the heads get to know each other.\n\n\nHereÂ XÂ is the index of an area, starting from 1 toÂ K.\nSample Input:8 10\n5 6\n7 8\n6 4\n3 6\n4 5\n2 3\n8 2\n2 7\n5 3\n3 4\n6\n4 5 4 3 6\n3 2 8 7\n2 2 3\n1 1\n2 4 6\n3 3 2 1\n\nSample Output:Area 1 is OK.\nArea 2 is OK.\nArea 3 is OK.\nArea 4 is OK.\nArea 5 may invite more people, such as 3.\nArea 6 needs help.\n\n\nÎ©ä¸€ç¾¤äººå‚åŠ å³°ä¼šï¼Œç»™å‡ºæ‰€æœ‰çš„æœ‹å‹å¯¹å’Œè‹¥å¹²ä¸ªå°ç¾¤ä½“ï¼Œåˆ†åˆ«åˆ¤æ–­æ¯ä¸ªå°å›¢ä½“æ˜¯å¦ä¸ºæœ€å¤§çš„æœ‹å‹åœˆï¼Œè¿™é‡Œçš„æœ‹å‹åœˆæŒ‡çš„æ˜¯å†…éƒ¨ä»»æ„ä¸¤ä¸ªäººéƒ½æ˜¯æœ‹å‹ã€‚å¦‚æœæ˜¯æœ‹å‹åœˆï¼Œä½†ä¸æ˜¯æœ€å¤§çš„ï¼Œåˆ™è¿˜éœ€è¾“å‡ºå¯ä»¥åŠ å…¥çš„æœ€å°ç¼–å·ã€‚\nç”¨bitset&lt;201&gt;æ ‡è®°æ¯ä¸ªäººçš„æœ‹å‹ï¼Œåœ¨è¯»å…¥ä¸€ä¸ªå›¢ä½“çš„è¿‡ç¨‹ä¸­ï¼Œå•ç‹¬ç”¨ä¸€ä¸ªbitset&lt;201&gt; flagæ ‡è®°å·²ç»è¯»å…¥çš„äººï¼Œæ¯è¯»å…¥ä¸€ä¸ªäººå°±ç”¨ä»–çš„bitsetå’Œflagè¿›è¡Œäº¤è¿ç®—ï¼Œå¦‚æœå¾—åˆ°çš„ç»“æœä¸ç­‰äºflagè¯´æ˜æœ‰äººå’Œä»–ä¸æ˜¯æœ‹å‹ï¼Œæœ€ååœ¨flagé‡Œæ ‡è®°è¿™ä¸ªäººã€‚è¯»å®Œåå¦‚æœè¿™ä¸ªå›¢ä½“æ˜¯æœ‹å‹åœˆå°±å†åˆ¤æ–­æ˜¯å¦æœ€å¤§ï¼ŒæŒ‰ç¼–å·é¡ºåºéå†ä¸åœ¨è¿™ä¸ªå›¢ä½“ä¸­çš„äººï¼Œç”¨ä»–ä»¬çš„bitsetä¸æœ€ç»ˆçš„flagï¼ˆæ ‡è®°äº†æ‰€æœ‰å›¢é˜Ÿä¸­çš„äººï¼‰è¿›è¡Œäº¤è¿ç®—ï¼Œå¦‚æœå­˜åœ¨æœ€ç»ˆç»“æœç­‰äºflagçš„äººå°±è¯´æ˜ä¸æ˜¯æœ€å¤§çš„æœ‹å‹åœˆã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b, k, x = -1;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;bitset&lt;201&gt;&gt; edge(n + 1);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a][b] = edge[b][a] = true;\n    }\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i, x = -1)\n    {\n        cin &gt;&gt; m;\n        bitset&lt;201&gt; flag;\n        bool ans = true;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; a;\n            if (!ans) continue;\n            if ((flag &amp; edge[a]) != flag) ans = false;\n            flag[a] = true;\n        }\n        for (int j = 1; j &lt;= n; ++j)\n            if (!flag[j] &amp;&amp; ((edge[j] &amp; flag) == flag))\n            {\n                x = j;\n                break;\n            }\n        if (ans &amp;&amp; x == -1) printf(\"Area %d is OK.\\n\", i + 1);\n        else if (ans) printf(\"Area %d may invite more people, such as %d.\\n\", i + 1, x);\n        else printf(\"Area %d needs help.\\n\", i + 1);\n    }\n}\n","slug":"ã€Œ1166ã€Summit","date":"2022-12-02T06:16:17.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,bitset","author_index":"Starlit Rover"},{"id":"9e4aa382d8b2ad0e7867e42c221eb9e6","title":"ã€Œ1165ã€Block Reversing","content":"Given a singly linked listÂ L. Let us consider everyÂ KÂ nodes as aÂ blockÂ (if there are less thanÂ KÂ nodes at the end of the list, the rest of the nodes are still considered as a block). Your job is to reverse all the blocks inÂ L. For example, givenÂ LÂ as 1â†’2â†’3â†’4â†’5â†’6â†’7â†’8 andÂ KÂ as 3, your output must be 7â†’8â†’4â†’5â†’6â†’1â†’2â†’3.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positiveÂ  which is the total number of nodes, and a positiveÂ  which is the size of a block. The address of a node is a 5-digit nonnegative integer, and NULL is represented byÂ âˆ’1.\nThenÂ NÂ lines follow, each describes a node in the format:\nAddress Data Next\n\nwhereÂ AddressÂ is the position of the node,Â DataÂ is an integer, andÂ NextÂ is the position of the next node.\nOutput Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 8 3\n71120 7 88666\n00000 4 99999\n00100 1 12309\n68237 6 71120\n33218 3 00000\n99999 5 68237\n88666 8 -1\n12309 2 33218\n\nSample Output:71120 7 88666\n88666 8 00000\n00000 4 99999\n99999 5 68237\n68237 6 00100\n00100 1 12309\n12309 2 33218\n33218 3 -1\n\n\nÎ©å¸¸è§„é“¾è¡¨æ”¾æ¾é¢˜ã€‚ç»™å‡ºå¤´èŠ‚ç‚¹ä¸é“¾è¡¨åœ°å€ã€å€¼ã€ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åœ°å€ã€‚éœ€è¦å°†è¿™ä¸ªé“¾è¡¨æ¯ä¸ªèŠ‚ç‚¹åˆ†ä¸ºä¸€å—ï¼ˆæœ€åä¸è¶³ä¸ªèŠ‚ç‚¹ä¹Ÿç®—ä¸€å—ï¼‰ï¼Œç„¶åå°†è¿™äº›å—é€†åºè¿æ¥ï¼ˆå—å†…éƒ¨æ— éœ€é€†åºï¼‰è¾“å‡ºã€‚\nå…ˆå°†é“¾è¡¨ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„åœ°å€ã€å€¼å­˜å‚¨åˆ°ä¸€ä¸ªvectorä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦ç¡®å®šæœ€åä¸€ä¸ªå—çš„èµ·å§‹ç´¢å¼•ï¼Œç„¶åæ¯æ¬¡å¾€åè¾“å‡ºä¸ªèŠ‚ç‚¹ï¼Œæœ€åæŠŠèµ·å§‹ç´¢å¼•é‡å¤å¾ªç¯å³å¯ã€‚\né‚£ä¹ˆæœ€åå—çš„èµ·å§‹ç´¢å¼•åº”è¯¥æ˜¯ï¼Œæ³¨æ„å½“å¯ä»¥æ•´é™¤æ—¶å°±éœ€è¦å‡å»ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥-1å¹³ç§»ä¹‹åå†å–ä½™å¾—åˆ°æœ€åé‚£å—çš„èµ·å§‹ç´¢å¼•ä¸º\n\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int h, n, k, a;\n    cin &gt;&gt; h &gt;&gt; n &gt;&gt; k;\n    map&lt;int, pair&lt;int, int&gt;&gt; node;\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; a &gt;&gt; node[a].first &gt;&gt; node[a].second;\n    vector&lt;pair&lt;int, int&gt;&gt; list;\n    while (h != -1) list.emplace_back(h, node[h].first), h = node[h].second;\n    bool first = true;\n    for (int i = list.size() - (list.size() - 1) % k - 1; i &gt;= 0; i -= k)\n        for (int j = i; j &lt; min(i + k, int(list.size())); ++j)\n        {\n            if (!first) printf(\" %05d\\n\", list[j].first);\n            else first = false;\n            printf(\"%05d %d\", list[j].first, list[j].second);\n        }\n    printf(\" -1\");\n}\n","slug":"ã€Œ1165ã€Block-Reversing","date":"2022-12-02T06:03:29.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,list","author_index":"Starlit Rover"},{"id":"e7fe1381af6f1b05a70d02f02d73c22d","title":"ã€Œ1164ã€Good in C","content":"When your interviewer asks you to write â€œHello Worldâ€ using C, can you do as the following figure shows?\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first part gives the 26 capital English letters A-Z, each in aÂ 7Ã—5Â matrix ofÂ Câ€˜s andÂ .â€˜s. Then a sentence is given in a line, ended by a return. The sentence is formed by several words (no more than 10 continuous capital English letters each), and the words are separated by any characters other than capital English letters.\nIt is guaranteed that there is at least one word given.\nOutput Specification:For each word, print the matrix form of each of its letters in a line, and the letters must be separated by exactly one column of space. There must be no extra space at the beginning or the end of the word.\nBetween two adjacent words, there must be a single empty line to separate them. There must be no extra line at the beginning or the end of the output.\nSample Input:..C..\n.C.C.\nC...C\nCCCCC\nC...C\nC...C\nC...C\nCCCC.\nC...C\nC...C\nCCCC.\nC...C\nC...C\nCCCC.\n.CCC.\nC...C\nC....\nC....\nC....\nC...C\n.CCC.\nCCCC.\nC...C\nC...C\nC...C\nC...C\nC...C\nCCCC.\nCCCCC\nC....\nC....\nCCCC.\nC....\nC....\nCCCCC\nCCCCC\nC....\nC....\nCCCC.\nC....\nC....\nC....\nCCCC.\nC...C\nC....\nC.CCC\nC...C\nC...C\nCCCC.\nC...C\nC...C\nC...C\nCCCCC\nC...C\nC...C\nC...C\nCCCCC\n..C..\n..C..\n..C..\n..C..\n..C..\nCCCCC\nCCCCC\n....C\n....C\n....C\n....C\nC...C\n.CCC.\nC...C\nC..C.\nC.C..\nCC...\nC.C..\nC..C.\nC...C\nC....\nC....\nC....\nC....\nC....\nC....\nCCCCC\nC...C\nC...C\nCC.CC\nC.C.C\nC...C\nC...C\nC...C\nC...C\nC...C\nCC..C\nC.C.C\nC..CC\nC...C\nC...C\n.CCC.\nC...C\nC...C\nC...C\nC...C\nC...C\n.CCC.\nCCCC.\nC...C\nC...C\nCCCC.\nC....\nC....\nC....\n.CCC.\nC...C\nC...C\nC...C\nC.C.C\nC..CC\n.CCC.\nCCCC.\nC...C\nCCCC.\nCC...\nC.C..\nC..C.\nC...C\n.CCC.\nC...C\nC....\n.CCC.\n....C\nC...C\n.CCC.\nCCCCC\n..C..\n..C..\n..C..\n..C..\n..C..\n..C..\nC...C\nC...C\nC...C\nC...C\nC...C\nC...C\n.CCC.\nC...C\nC...C\nC...C\nC...C\nC...C\n.C.C.\n..C..\nC...C\nC...C\nC...C\nC.C.C\nCC.CC\nC...C\nC...C\nC...C\nC...C\n.C.C.\n..C..\n.C.C.\nC...C\nC...C\nC...C\nC...C\n.C.C.\n..C..\n..C..\n..C..\n..C..\nCCCCC\n....C\n...C.\n..C..\n.C...\nC....\nCCCCC\nHELLO~WORLD!\n\nSample Output:C...C CCCCC C.... C.... .CCC.\nC...C C.... C.... C.... C...C\nC...C C.... C.... C.... C...C\nCCCCC CCCC. C.... C.... C...C\nC...C C.... C.... C.... C...C\nC...C C.... C.... C.... C...C\nC...C CCCCC CCCCC CCCCC .CCC.\n\nC...C .CCC. CCCC. C.... CCCC.\nC...C C...C C...C C.... C...C\nC...C C...C CCCC. C.... C...C\nC.C.C C...C CC... C.... C...C\nCC.CC C...C C.C.. C.... C...C\nC...C C...C C..C. C.... C...C\nC...C .CCC. C...C CCCCC CCCC.\n\n\nÎ©ç»™å‡ºæ‰€æœ‰å¤§å†™å­—æ¯çš„ç‚¹é˜µè¡¨ç¤ºï¼Œæœ€åä¸€è¡Œæ˜¯éœ€è¦ç”¨ç‚¹é˜µè¾“å‡ºçš„è¯­å¥ï¼Œå•è¯ä¹‹é—´ç”¨éå¤§å†™å­—æ¯çš„å­—ç¬¦ï¼ˆä¸²ï¼‰éš”å¼€ï¼Œä¿è¯è‡³å°‘æœ‰ä¸€ä¸ªå•è¯ã€‚å•è¯ä¸­å­—æ¯ä¹‹é—´éœ€è¦ç©ºä¸€åˆ—ï¼Œå•è¯ä¸å•è¯ä¹‹é—´éœ€è¦ç©ºä¸€è¡Œã€‚\nç”±äºåªèƒ½æ¨ªå‘è¾“å‡ºï¼Œå› æ­¤ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„å­˜å‚¨æ¯ä¸ªå­—æ¯ç‚¹é˜µçš„æ¯ä¸€è¡Œè¡¨ç¤ºã€‚ç„¶åè¯»å…¥éœ€è¦è¾“å‡ºçš„å­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯å¤§å†™å­—æ¯å°±å…ˆå­˜å…¥å¾…è¾“å‡ºå­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯éå¤§å†™å­—æ¯å­—ç¬¦ï¼Œå°±æ£€æŸ¥å¾…è¾“å‡ºå­—ç¬¦ä¸²æ˜¯å¦ä¸ºç©ºï¼Œä¸ç©ºå°±åˆ†ä¸ƒè¡Œè¾“å‡ºã€‚ç”±äºå­—ç¬¦ä¸²ç»“å°¾ä¸ä¸€å®šä¼šæœ‰éå¤§å†™å­—æ¯å­—ç¬¦ï¼Œå› æ­¤åœ¨è¯»å…¥åç›´æ¥ç»“å°¾åŠ ä¸€ä¸ªç©ºæ ¼ã€‚å¦å¤–å•è¯ä¹‹é—´çš„ç©ºè¡Œåªè¦åˆ¤æ–­ä¸€ä¸‹æ˜¯ä¸æ˜¯ç¬¬ä¸€ä¸ªè¾“å‡ºçš„å•è¯å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;vector&lt;string&gt;&gt; matrix(26, vector(7, string()));\n    for (int i = 0; i &lt; 26; ++i)\n        for (int j = 0; j &lt; 7; ++j)\n            getline(cin, matrix[i][j]);\n    string s, w;\n    getline(cin, s);\n    s += \" \";\n    bool line = false;\n    for (auto &amp;c: s)\n    {\n        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')\n            w += c;\n        else if (!w.empty())\n        {\n            if (line) printf(\"\\n\");\n            else line = true;\n            for (int i = 0; i &lt; 7; ++i)\n                for (int j = 0; j &lt; w.size(); ++j)\n                    printf(\"%s%s\", matrix[w[j] - 'A'][i].c_str(), j == w.size() - 1 ? \"\\n\" : \" \");\n            w.clear();\n        }\n    }\n}\n","slug":"ã€Œ1164ã€Good-in-C","date":"2022-12-02T05:51:06.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"ed0b23be5de3068df8822b7f089d6673","title":"ã€1163ã€Dijkstra Sequence","content":"Dijkstraâ€™s algorithm is one of the very famous greedy algorithms.It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.\nIn this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, letâ€™s call itÂ Dijkstra sequence, is generated by Dijkstraâ€™s algorithm.\nOn the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive integersÂ  andÂ , which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 toÂ â€‹.\nThenÂ Neâ€‹Â lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (â‰¤100) of the edge. It is guaranteed that the given graph is connected.\nFinally the number of queries,Â K, is given as a positive integer no larger thanÂ 100, followed byÂ KÂ lines of sequences, each contains a permutationof theÂ Nvâ€‹Â vertices. It is assumed that the first vertex is the source for each sequence.\nAll the inputs in a line are separated by a space.\nOutput Specification:For each of theÂ KÂ sequences, print in a lineÂ YesÂ if it is a Dijkstra sequence, orÂ NoÂ if not.\nSample Input:5 7\n1 2 2\n1 5 1\n2 3 1\n2 4 1\n2 5 2\n3 5 1\n3 4 1\n4\n5 1 3 4 2\n5 3 1 2 4\n2 3 4 5 1\n3 2 1 5 4\n\nSample Output:Yes\nYes\nYes\nNo\n\n\nÎ©è€ƒå¯Ÿå¯¹Dijkstraç®—æ³•çš„æœ¬è´¨ç†è§£ï¼Œä¸éš¾ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œç»™å®šèµ·ç‚¹ï¼ŒDijkstraç®—æ³•ä¼šé€ä¸€æŠŠè·ç¦»èµ·ç‚¹ç”±è¿‘åˆ°è¿œçš„é¡¶ç‚¹åŠ å…¥åˆ°ä¸€ä¸ªé›†åˆä¸­ï¼Œä¹Ÿå°±æ˜¯å·²ç»ç¡®å®šåˆ°èµ·ç‚¹æœ€çŸ­è·ç¦»çš„é¡¶ç‚¹ä»¬ï¼Œé‚£ä¹ˆå°†é¡¶ç‚¹çš„åŠ å…¥é¡ºåºç§°ä¸ºDijkstra Sequenceã€‚ç°åœ¨ç»™å®šä¸€ä¸ªæ— å‘å›¾å’Œè‹¥å¹²åºåˆ—ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦ä¸ºè¿™å¼ å›¾çš„Dijkstra Sequenceã€‚æ³¨æ„åˆ°ï¼Œç”±äºéƒ¨åˆ†é¡¶ç‚¹åˆ°èµ·ç‚¹çš„æœ€çŸ­è·ç¦»ç›¸åŒï¼Œå› æ­¤ä¸€å¼ å›¾å­˜åœ¨å¤šä¸ªDijkstra Sequenceã€‚\nå¾ˆæ˜¾ç„¶ï¼Œç›´æ¥ä¸ŠDijkstraç®—æ³•ï¼Œç”±äºæ˜¯æ£€æŸ¥ï¼Œå› æ­¤æˆ‘ä»¬ä¸ç”¨å®Œå…¨æŒ‰æµç¨‹èµ°ã€‚æŒ‰ç…§é¡ºåºéå†ç»™å‡ºçš„åºåˆ—ï¼Œæˆ‘ä»¬åªè¦ä¿è¯å½“å‰æœªåŠ å…¥é›†åˆä¸­æ²¡æœ‰æ¯”è·ç¦»èµ·ç‚¹æ›´è¿‘çš„é¡¶ç‚¹å³å¯ï¼Œå¦‚æœæœ‰æ›´è¿‘çš„é¡¶ç‚¹è¯´æ˜ä¸æ˜¯Dijkstra Sequenceé€€å‡ºå¾ªç¯ï¼Œå¦åˆ™æ›´æ–°ä¸å…³è”é¡¶ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»ï¼Œå¹¶å°†åˆ°èµ·ç‚¹çš„è·ç¦»æ”¹ä¸ºINT32_MAXï¼ˆåé¢å°±æ— éœ€è€ƒè™‘æ˜¯å¦å·²åœ¨é›†åˆä¸­ï¼‰ç„¶åé‡å¤å¾ªç¯ã€‚\nâš ï¸ ä¸è¦æ›´æ–°é‚£äº›å·²ç»åœ¨é›†åˆä¸­çš„é¡¶ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»ï¼Œå› æ­¤è¿˜æ˜¯éœ€è¦æ ‡è®°ä½äºé›†åˆä¸­çš„é¡¶ç‚¹ã€‚ \n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int v, e, a, b, d, k;\n    cin &gt;&gt; v &gt;&gt; e;\n    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; edge(v + 1);\n    for (int i = 0; i &lt; e; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;\n        edge[a].emplace_back(b, d);\n        edge[b].emplace_back(a, d);\n    }\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        vector&lt;int&gt; dj(v), dist(v + 1, INT32_MAX);\n        vector&lt;bool&gt; visited(v + 1, false);\n        bool ans = true;\n        for (auto &amp;t: dj) cin &gt;&gt; t;\n        for (auto &amp;t: edge[dj[0]])\n            dist[t.first] = t.second;\n        visited[dj[0]] = true;\n        for (int j = 1; j &lt; v; dist[dj[j]] = INT32_MAX, visited[dj[j]] = true, ++j)\n        {\n            if (!(ans = *min_element(dist.begin(), dist.end()) == dist[dj[j]]))\n                break;\n            for (auto &amp;t: edge[dj[j]])\n            {\n                if (visited[t.first]) continue;\n                dist[t.first] = min(dist[dj[j]] + t.second, dist[t.first]);\n            }\n        }\n        printf(ans ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n","slug":"ã€1163ã€Dijkstra-Sequence","date":"2022-12-01T16:57:57.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Dijkstra","author_index":"Starlit Rover"},{"id":"7d33432dbf79dd8f70b2b1b9bfcc3dbc","title":"ã€Œ1162ã€Postfix Expression","content":"Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences of the operators.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤Â 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (theÂ i-th line corresponds to theÂ i-th node) in the format:\ndata left_child right_child\n\nwhereÂ dataÂ is a string of no more than 10 characters,Â left_childÂ andÂ right_childÂ are the indices of this nodeâ€™s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented byÂ âˆ’1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\n\n\nOutput Specification:For each case, print in a line the postfix expression, with parentheses reflecting the precedences of the operators.There must be no space between any symbols.\nSample Input 1:8\n* 8 7\na -1 -1\n* 4 1\n+ 2 5\nb -1 -1\nd -1 -1\n- -1 6\nc -1 -1\n\nSample Output 1:(((a)(b)+)((c)(-(d))*)*)\n\nSample Input 2:8\n2.35 -1 -1\n* 6 1\n- -1 4\n% 7 8\n+ 2 3\na -1 -1\nstr -1 -1\n871 -1 -1\n\nSample Output 2:(((a)(2.35)*)(-((str)(871)%))+)\n\n\nÎ©ç»™å‡ºä¸€ä¸ªè¿ç®—å¼çš„è¯­æ³•æ ‘ï¼Œè¾“å‡ºå®ƒçš„åç¼€è¡¨è¾¾å¼ã€‚æœ¬è´¨ä¸Šå°±æ˜¯è€ƒå¯Ÿæ ‘çš„ååºéå†ï¼Œå”¯ä¸€ä¸åŒçš„åœ°æ–¹åœ¨äºï¼Œéœ€è¦æ³¨æ„å•ç›®è¿ç®—ç¬¦ã€-ã€‘ï¼Œå¦‚æœè¯´å­˜åœ¨å³å­æ ‘ä½†ä¸å­˜åœ¨å·¦å­æ ‘å°±è¯´æ˜æ˜¯å•ç›®è¿ç®—ç¬¦ï¼Œéœ€è¦å…ˆè¾“å‡ºèŠ‚ç‚¹çš„å€¼ï¼Œç„¶åå†è¾“å‡ºå³å­æ ‘çš„åç¼€è¡¨è¾¾å¼ã€‚\nâš ï¸æ ¹èŠ‚ç‚¹éœ€è¦è‡ªå·±è®¡ç®—ï¼Œåˆå§‹åŒ–æ ¹èŠ‚ç‚¹åºå·ä¸º1-Nä¹‹å’Œï¼Œç„¶åå‡å»æ‰€æœ‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹åºå·ï¼Œæœ€åå‰©ä¸‹çš„å°±æ˜¯æ ¹èŠ‚ç‚¹ç¼–å·ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;string&gt; value;\nvector&lt;pair&lt;int, int&gt;&gt; sons;\n\nstring postfix(int i)\n{\n    if (i == -1) return \"\";\n    else if (sons[i].first == -1) return \"(\" + value[i] + postfix(sons[i].second) + \")\";\n    else return \"(\" + postfix(sons[i].first) + postfix(sons[i].second) + value[i] + \")\";\n}\n\nint main()\n{\n    int n, h;\n    cin &gt;&gt; n;\n    h = n * (n + 1) / 2;\n    value.resize(n + 1), sons.resize(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        cin &gt;&gt; value[i] &gt;&gt; sons[i].first &gt;&gt; sons[i].second;\n        h -= max(0, sons[i].first) + max(0, sons[i].second);\n    }\n    cout &lt;&lt; postfix(h);\n}\n","slug":"ã€Œ1162ã€Postfix-Expression","date":"2022-12-01T16:02:39.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"37353806131bb7be8e2475ba5c533abf","title":"ã€Œ1161ã€Merging Linked Lists","content":"Given two singly linked listsÂ â€‹Â andÂ â€‹. IfÂ , you are supposed to reverse and merge the shorter one into the longer one to obtain a list likeÂ â€‹â‹¯. For example, given one list being 6â†’7 and the other one 1â†’2â†’3â†’4â†’5, you must output 1â†’2â†’7â†’3â†’4â†’6â†’5.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the two addresses of the first nodes ofÂ L1â€‹Â andÂ L2â€‹, plus a positiveÂ  which is the total number of nodes given. The address of a node is a 5-digit nonnegative integer, and NULL is represented byÂ -1.\nThenÂ NÂ lines follow, each describes a node in the format:\nAddress Data Next\n\nwhereÂ AddressÂ is the position of the node,Â DataÂ is a positive integer no more thanÂ , andÂ NextÂ is the position of the next node. It is guaranteed that no list is empty, and the longer list is at least twice as long as the shorter one.\nOutput Specification:For each case, output in order the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 01000 7\n02233 2 34891\n00100 6 00001\n34891 3 10086\n01000 1 02233\n00033 5 -1\n10086 4 00033\n00001 7 -1\n\nSample Output:01000 1 02233\n02233 2 00001\n00001 7 34891\n34891 3 10086\n10086 4 00100\n00100 6 00033\n00033 5 -1\n\n\nÎ©é“¾è¡¨æ°´é¢˜æ”¾æ¾ã€‚ç»™å‡ºä¸¤ä¸ªé“¾è¡¨ï¼Œé•¿åº¦åˆ†åˆ«ä¸ºï¼Œéœ€è¦ä½ å°†çŸ­é“¾è¡¨åå‘éš”2æ’å…¥åˆ°é•¿é“¾è¡¨ä¸­ã€‚\né¦–å…ˆè¯»å…¥æ‰€æœ‰èŠ‚ç‚¹ï¼Œç”¨mapå»ºç«‹åœ°å€åˆ°èŠ‚ç‚¹å€¼ä»¥åŠä¸‹ä¸€ä¸ªèŠ‚ç‚¹åœ°å€çš„æ˜ å°„ã€‚ç„¶åé€šè¿‡å¤´èŠ‚ç‚¹éå†é“¾è¡¨ï¼Œå°†æ¯ä¸ªèŠ‚ç‚¹çš„åœ°å€åŠå€¼å­˜å‚¨åˆ°vector&lt;pair&lt;int,int&gt;&gt;ä¸­ã€‚æœ€åæ¯è¾“å‡ºä¸¤ä¸ªé•¿é“¾è¡¨èŠ‚ç‚¹ï¼Œå°±åå‘è¾“å‡ºä¸€ä¸ªçŸ­é“¾è¡¨èŠ‚ç‚¹ã€‚çŸ­é“¾è¡¨è¾“å®Œåéœ€è¦æŠŠé•¿é“¾è¡¨å‰©ä½™èŠ‚ç‚¹ä¸€æ¬¡æ€§è¾“å‡ºã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\ninline void output(pair&lt;int, int&gt; &amp;p)\n{\n    static bool flag = false;\n    if (flag) printf(\" %05d\\n\", p.first);\n    printf(\"%05d %d\", p.first, p.second);\n    flag = true;\n}\n\nint main()\n{\n    int sa, sb, n, a, v, nxt, j;\n    cin &gt;&gt; sa &gt;&gt; sb &gt;&gt; n;\n    map&lt;int, pair&lt;int, int&gt;&gt; node;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; v &gt;&gt; nxt;\n        node[a] = make_pair(v, nxt);\n    }\n    vector&lt;pair&lt;int, int&gt;&gt; l1, l2;\n    while (sa != -1)\n        l1.emplace_back(sa, node[sa].first), sa = node[sa].second;\n    while (sb != -1)\n        l2.emplace_back(sb, node[sb].first), sb = node[sb].second;\n    if (l1.size() &lt; l2.size()) swap(l1, l2);\n    for (j = 0; j &lt; 2 * l2.size(); j += 2)\n        output(l1[j]), output(l1[j + 1]), output(l2[l2.size() - j / 2 - 1]);\n    for (; j &lt; l1.size(); ++j) output(l1[j]);\n    printf(\" -1\");\n}\n","slug":"ã€Œ1161ã€Merging-Linked-Lists","date":"2022-12-01T15:33:32.000Z","categories_index":"","tags_index":"","author_index":"Starlit Rover"},{"id":"75be25fcd9a5cd2b923517296b55a3e7","title":"ã€Œ1160ã€Forever","content":"â€œForever numberâ€ is a positive integerÂ AÂ withÂ KÂ digits, satisfying the following constrains:\n\nthe sum of all the digits ofÂ AÂ isÂ m;\nthe sum of all the digits ofÂ A+1Â isÂ n; and\nthe greatest common divisor ofÂ mÂ andÂ nÂ is a prime number which is greater than 2.\n\nNow you are supposed to find these forever numbers.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains a positive integerÂ NÂ (â‰¤5). ThenÂ NÂ lines follow, each gives a pair ofÂ KÂ (3&lt;K&lt;10) andÂ mÂ (1&lt;m&lt;90), of which the meanings are given in the problem description.\nOutput Specification:For each pair ofÂ KÂ andÂ m, first print in a lineÂ Case X, whereÂ XÂ is the case index (starts from 1). Then printÂ nÂ andÂ AÂ in the following line. The numbers must be separated by a space. If the solution is not unique, output in the ascending order ofÂ n. If still not unique, output in the ascending order ofÂ A. If there is no solution, outputÂ No Solution.\nSample Input:2\n6 45\n7 80\n\nSample Output:Case 1\n10 189999\n10 279999\n10 369999\n10 459999\n10 549999\n10 639999\n10 729999\n10 819999\n10 909999\nCase 2\nNo Solution\n\n\nÎ©é•¿ä¹…æ•°Aï¼Œæ»¡è¶³ä¸ºå¤§äº2çš„è´¨æ•°ï¼Œå…¶ä¸­æŒ‡çš„æ˜¯çš„å„ä½ä¹‹å’Œï¼ŒæŒ‡çš„æ˜¯çš„å„ä½ä¹‹å’Œï¼Œgcdæ˜¯æœ€å¤§å…¬å› æ•°ã€‚\nä¸€å¼€å§‹çœ‹æ˜¯äºŒååˆ†çš„é¢˜ï¼Œè€Œä¸”é™æ—¶3000msï¼Œå°±æƒ³ç€ç›´æ¥æšä¸¾ï¼Œç»“æœå‰ä¸¤ä¸ªæµ‹è¯•ç‚¹éƒ½æ²¡è¶…1000msï¼Œåé¢ä¸¤ä¸ªæµ‹è¯•ç‚¹ç‚¸äº†ã€‚ä¸è¿‡æ¯åŠ 1æ—¶é—´ç¡®å®ä¼šç¿»åå€ã€‚æˆ‘å¾ˆç»æœ›åœ°è¦å¼€å§‹å°è¯•DFSæœç´¢äº†ï¼Œä¸è¿‡æ³¨æ„åˆ°Sampleä¸­çš„ç»“æœéƒ½æ˜¯ä»¥99ç»“å°¾çš„ï¼Œå¯»æ€ç€ä¼šä¸ä¼šæœ‰ä»€ä¹ˆè§„å¾‹ï¼Œæ²¡æƒ³åˆ°è¿˜çœŸæœ‰ã€‚\nä»æœ€ä½ä½å¼€å§‹ï¼Œå¦‚æœçš„æœ€ä½ä½ä¸æ˜¯9çš„è¯ï¼Œé‚£ä¹ˆå°±ä¸ä¼šäº§ç”Ÿè¿›ä½ï¼Œä»è€Œï¼Œè€Œæ˜¾ç„¶ï¼Œå¿…ç„¶ä¸æ˜¯è´¨æ•°ã€‚Amazingï¼Œæ¥ç€çœ‹å¦‚æœçš„å€’æ•°ç¬¬äºŒä½ä¸æ˜¯9ï¼Œè¿™æ—¶æˆ‘ä»¬å·²ç»ç¡®å®šçš„æœ€åä¸€ä½ä¸€å®šæ˜¯9ï¼Œé‚£ä¹ˆæ„å‘³ç€åªä¼šåœ¨åä½äº§ç”Ÿä¸€æ¬¡è¿›ä½ï¼Œä»è€Œï¼Œæ³¨æ„åˆ°ä¸€å®šæ˜¯8çš„å› å­ï¼Œæ•´é™¤8çš„ç´ æ•°åªæœ‰2ï¼Œè€Œé¢˜ç›®è¦æ±‚æ˜¯&gt;2çš„ç´ æ•°ï¼Œå› æ­¤ä¹Ÿä¸€å®šä¸ç¬¦åˆé¢˜æ„ã€‚åˆ°ç¬¬ä¸‰ä½çš„æ—¶å€™ï¼Œï¼Œï¼Œé‚£ä¹ˆæœ€å¤§å…¬å› å­åªå¯èƒ½æ˜¯1æˆ–è€…17ï¼Œæ˜¯æœ‰å¯èƒ½ç¬¦åˆé¢˜æ„çš„ã€‚ç»¼ä¸Šå¯ä»¥ç¡®å®šé•¿ä¹…æ•°çš„æœ€åä¸¤ä½ä¸€å®šæ˜¯99ã€‚\nåœ¨ç¡®å®šæœ€åä¸¤ä½åï¼Œæšä¸¾çš„å·¥ä½œé‡ç›´æ¥é™ä¸¤ä¸ªé‡çº§ï¼Œæšä»–ä¸«çš„ã€‚\nå½“ç„¶è¦æ˜¯æˆ‘æ²¡æ³¨æ„åˆ°è¿™ä¸ªç‰¹æ€§ï¼Œå°±å¿…é¡»æƒ³åŠæ³•é™ä½æšä¸¾é‡ã€‚é¦–å…ˆå¯ä»¥ç›´æ¥æ„é€ æ‰€æœ‰å„ä½æ•°ä¹‹å’Œä¸ºçš„ä½æ•°ï¼Œä»æœ€é«˜ä½å¼€å§‹æšä¸¾æ„é€ ï¼Œå¦‚æœåé¢æ‰€æœ‰ä½éƒ½å–9éƒ½è¾¾ä¸åˆ°çš„è¯ï¼Œè¯´æ˜å‰é¢æ•°å­—å–å°äº†ï¼Œå¯ä»¥ç›´æ¥è·³è¿‡ï¼Œè¿™æ ·èƒ½èŠ‚çœå¤§é‡å¼€é”€ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nbool isPrime(int r)\n{\n    if (r &lt; 4) return r &gt; 2;\n    for (int i = 2; i &lt;= sqrt(r); i += (i == 2) + 1)\n        if (r % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int n, k, m, u = 1, v = 1, vv = 0;\n    bool flag = true;\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i, u = 1, v = 19, vv = 0, flag = true)\n    {\n        vector&lt;pair&lt;int, int&gt;&gt; ans;\n        printf(\"Case %d\\n\", i + 1);\n        scanf(\"%d %d\", &amp;k, &amp;m);\n        for (int j = 1; j &lt; k - 2; ++j) u *= 10;\n        for (int j = u; j &lt; 10 * u; ++j, v = vv + 18, vv = 0)\n        {\n            string s = to_string(j + 1);\n            for (auto &amp;c: s)\n                vv += c - '0';\n            if (v == m &amp;&amp; isPrime(gcd(v, vv)))\n                ans.emplace_back(vv, j * 100 + 99), flag = false;\n        }\n        if (flag) printf(\"No Solution\\n\");\n        else\n        {\n            sort(ans.begin(), ans.end());\n            for (auto &amp;t: ans) printf(\"%d %d\\n\", t.first, t.second);\n        }\n    }\n}\n","slug":"ã€Œ1160ã€Forever","date":"2022-12-01T12:15:21.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,prime","author_index":"Starlit Rover"},{"id":"23a26d9dbfb7f35f39b098e97db54754","title":"ã€1159ã€Structure of a Binary Tree","content":"Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, a binary tree can be uniquely determined.\nNow given a sequence of statements about the structure of the resulting tree, you are supposed to tell if they are correct or not. A statment is one of the following:\n\nA is the root\nA and B are siblings\nA is the parent of B\nA is the left child of B\nA is the right child of B\nA and B are on the same level\nIt is a full tree\n\nNote:\n\nTwo nodes areÂ on the same level, means that they have the same depth.\nAÂ full binary treeÂ is a tree in which every node other than the leaves has two children.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are no more thanÂ Â and are separated by a space.\nThen another positive integerÂ MÂ (â‰¤30) is given, followed byÂ MÂ lines of statements. It is guaranteed that bothÂ AÂ andÂ BÂ in the statements are in the tree.\nOutput Specification:For each statement, print in a lineÂ YesÂ if it is correct, orÂ NoÂ if not.\nSample Input:9\n16 7 11 32 28 2 23 8 15\n16 23 7 32 11 2 28 15 8\n7\n15 is the root\n8 and 2 are siblings\n32 is the parent of 11\n23 is the left child of 16\n28 is the right child of 2\n7 and 11 are on the same level\nIt is a full tree\n\nSample Output:Yes\nNo\nYes\nNo\nYes\nYes\nYes\n\n\nÎ©ç»™å‡ºä¸€æ£µäºŒå‰æ ‘çš„ååºã€ä¸­åºéå†ï¼Œç„¶ååˆ¤æ–­ä¸ƒç§é™ˆè¿°æ¨¡å¼çš„å¯¹é”™ã€‚\næ ‘çš„èŠ‚ç‚¹ä¸è¶…è¿‡30ä¸ªï¼Œå› æ­¤ç›´æ¥æä¸ªç»“æ„ä½“å­˜å‚¨æ‰€æœ‰ä¿¡æ¯â€”â€”çˆ¶èŠ‚ç‚¹ã€å­èŠ‚ç‚¹ã€æ·±åº¦ã€‚è€Œä¸”èŠ‚ç‚¹ç¼–å·ä¸ä¼šè¶…è¿‡1000ï¼Œå› æ­¤ç›´æ¥å¼€ä¸ªæ•°ç»„å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹çš„ç»“æ„ä½“ã€‚åœ¨é€’å½’å»ºæ ‘çš„è¿‡ç¨‹ä¸­ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯ï¼ŒåŒæ—¶å¦‚æœå½“å‰èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­åˆ™æ ‡è®°notFullä¸ºtrueã€‚\nå¦ä¸€ä¸ªéš¾ç‚¹æ˜¯åˆ¤æ–­é™ˆè¿°æ¨¡å¼ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå°†æ•´è¡Œè¯»å…¥ï¼ˆâš ï¸ä¸è¦å¿˜è®°è¯»å®Œågetchar()ï¼‰ï¼Œç„¶åæŒ‰ç…§ç©ºæ ¼å°†å•è¯å‹å…¥æ•°ç»„ä¸­ï¼Œæ ¹æ®è¯­å¥ä¸­çš„å…³é”®è¯è¿›è¡Œåˆ¤æ–­ã€‚âš ï¸åˆ¤æ–­é¡ºåºå°½é‡æŒ‰ç…§å•è¯æ•°å°‘çš„æ¨¡å¼åˆ°å•è¯æ•°å¤šçš„æ¨¡å¼ï¼Œå¦‚æœå…ˆåˆ¤æ–­å•è¯æ•°å¤šæ¨¡å¼ååçš„å…³é”®è¯å¯èƒ½ä¼šå¯¼è‡´å•è¯æ•°å°‘æ¨¡å¼çš„è¶Šç•Œè®¿é—®ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; post, in;\nbool notFull = false, ans;\n\nstruct node\n{\n    int parent = -1, depth = 0;\n    pair&lt;int, int&gt; sons{-1, -1};\n};\n\nvector&lt;node&gt; tree(1001);\n\nvoid build(int ps, int pe, int is, int ie)\n{\n    int bias = find(in.begin() + is, in.begin() + ie, post[pe]) - in.begin() - is;\n    if (bias &gt; 0)\n    {\n        tree[post[pe]].sons.first = post[ps + bias - 1];\n        tree[post[ps + bias - 1]].parent = post[pe];\n        tree[post[ps + bias - 1]].depth = tree[post[pe]].depth + 1;\n        build(ps, ps + bias - 1, is, is + bias);\n    }\n    if (is + bias &lt; ie - 1)\n    {\n        tree[post[pe]].sons.second = post[pe - 1];\n        tree[post[pe - 1]].parent = post[pe];\n        tree[post[pe - 1]].depth = tree[post[pe]].depth + 1;\n        build(ps + bias, pe - 1, is + bias + 1, ie);\n    }\n    notFull |= (bias &lt; ie - is - 1) ^ (bias &gt; 0);\n}\n\nint main()\n{\n    int n, m, p = 0;\n    cin &gt;&gt; n;\n    post.resize(n), in.resize(n);\n    for (auto &amp;k: post) cin &gt;&gt; k;\n    for (auto &amp;k: in) cin &gt;&gt; k;\n    build(0, n - 1, 0, n);\n    cin &gt;&gt; m;\n    getchar();\n    string st;\n    for (int i = 0; i &lt; m; ++i, p = 0)\n    {\n        vector&lt;string&gt; jdg;\n        getline(cin, st);\n        st.push_back(' ');\n        for (int j = 0; j &lt; st.size(); ++j)\n            if (st[j] == ' ')\n            {\n                jdg.push_back(st.substr(p, j - p));\n                p = j + 1;\n            }\n        if (jdg[3] == \"root\") ans = stoi(jdg[0]) == post.back();\n        else if (jdg[0] == \"It\") ans = !notFull;\n        else if (jdg[1] == \"and\")\n        {\n            auto &amp;a = tree[stoi(jdg[0])], &amp;b = tree[stoi(jdg[2])];\n            ans = (jdg[4] == \"on\" ? a.depth == b.depth : a.parent == b.parent);\n        }\n        else if (jdg[3] == \"parent\") ans = stoi(jdg[0]) == tree[stoi(jdg[5])].parent;\n        else\n            ans = (jdg[3] == \"left\" ? tree[stoi(jdg.back())].sons.first == stoi(jdg[0]) :\n                   tree[stoi(jdg.back())].sons.second == stoi(jdg[0]));\n        printf(\"%s\\n\", ans ? \"Yes\" : \"No\");\n    }\n}\n","slug":"ã€1159ã€Structure-of-a-Binary-Tree","date":"2022-12-01T09:44:36.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"7369aa2af707a2b4122dd8865d50ba11","title":"ã€Œ1158ã€Telefraud Detection","content":"Telefraudï¼ˆç”µä¿¡è¯ˆéª—ï¼‰ remains a common and persistent problem in our society. In some cases, unsuspecting victims lose their entire life savings. To stop this crime, you are supposed to write a program to detect those suspects from a huge amount of phone call records.\nA person must be detected as a suspect if he/she makes more thanÂ KÂ short phone calls toÂ differentÂ people everyday, but no more than 20% of these people would call back. And more, if two suspects are calling each other, we say they might belong to the same gang.Â AÂ makes aÂ shortÂ phone call toÂ BÂ means that the total duration of the calls fromÂ AÂ toÂ BÂ is no more than 5 minutes.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives 3 positive integersÂ , the thresholdï¼ˆé˜ˆå€¼ï¼‰ of the amount of short phone calls),Â , the number of different phone numbers), andÂ , the number of phone call records). ThenÂ MÂ lines of one dayâ€™s records are given, each in the format:\ncaller receiver duration\n\nwhereÂ callerÂ andÂ receiverÂ are numbered from 1 toÂ N, andÂ durationÂ is no more than 1440 minutes in a day.\nOutput Specification:Print in each line all the detected suspects in a gang, in ascending order of their numbers. The gangs are printed in ascending order of their first members. The numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.\nIf no one is detected, outputÂ NoneÂ instead.\nSample Input 1:5 15 31\n1 4 2\n1 5 2\n1 5 4\n1 7 5\n1 8 3\n1 9 1\n1 6 5\n1 15 2\n1 15 5\n3 2 2\n3 5 15\n3 13 1\n3 12 1\n3 14 1\n3 10 2\n3 11 5\n5 2 1\n5 3 10\n5 1 1\n5 7 2\n5 6 1\n5 13 4\n5 15 1\n11 10 5\n12 14 1\n6 1 1\n6 9 2\n6 10 5\n6 11 2\n6 12 1\n6 13 1\n\nSample Output 1:3 5\n6\n\nNote:Â In sample 1, althoughÂ 1Â had 9 records, but there were 7 distinct receivers, among whichÂ 5Â andÂ 15Â both had conversations lasted more than 5 minutes in total. HenceÂ 1Â had made 5 short phone calls and didnâ€™t exceed the threshold 5, and therefore is not a suspect.\nSample Input 2:5 7 8\n1 2 1\n1 3 1\n1 4 1\n1 5 1\n1 6 1\n1 7 1\n2 1 1\n3 1 1\n\nSample Output 2:None\n\n\nÎ©é¢˜ç›®æ¯”è¾ƒå¤æ‚ï¼Œæ‰æ‚äº†å¾ˆå¤šè€ƒç‚¹ï¼Œä½†åªè¦æŠŠé¢˜ç›®è¯»æ‡‚ï¼Œç†æ¸…æ¡ä»¶å°±è¿˜å¥½ã€‚ç»™å‡ºè‹¥å¹²é€šç”µè¯è®°å½•ï¼ŒåŒ…æ‹¬æ‹¨æ‰“è€…ã€æ¥å¬è€…å’Œé€šè¯æ—¶é•¿ï¼Œå¦‚æœä¸€ä¸ªäººç»™ä¸ªã€ä¸åŒã€‘çš„äººæ‰“äº†ã€çŸ­ã€‘é€šè¯ï¼ˆä½œä¸ºã€æ‹¨æ‰“è€…ã€‘é€šè¯ã€æ€»ã€‘æ—¶é•¿â‰¤ 5 minï¼‰ç”µè¯ï¼Œè€Œä¸”ã€è¿™äº›äººã€‘ä¸­åªæœ‰â‰¤ 20%çš„äººå›æ‹¨ï¼Œå°±è®¤å®šè¿™æ˜¯ä¸€ä¸ªç”µä¿¡è¯ˆéª—å«Œç–‘çŠ¯ã€‚å¦å¤–å¦‚æœä¸¤ä¸ªå«Œç–‘äººä¹‹é—´ã€äº’é€šã€‘ç”µè¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¤ä¸ºä»–ä»¬å¯èƒ½å±äºåŒä¸€ä¸ªå›¢ä¼™ã€‚æœ€åè¾“å‡ºæ‰€æœ‰å«Œç–‘çŠ¯ï¼Œä¸€è¡Œä¸€ä¸ªå›¢ä¼™ï¼ŒæŒ‰ç…§å‡åºè¾“å‡ºã€‚\néœ€è¦æ³¨æ„çš„ç‚¹éƒ½ç”¨ã€ã€‘æ ‡æ³¨å‡ºæ¥äº†ï¼Œå¯ä»¥çœ‹åˆ°åªè¦æœ‰ä¸€ä¸ªåœ°æ–¹æ²¡ç†è§£é€å½»å°±ç¿»è½¦ã€‚æ³¨æ„åˆ°äººæ•°ä¸ä¼šè¶…è¿‡1000ï¼Œæ‰€ä»¥æˆ‘æ‰“ç®—ç”¨bitsetæ¥åˆ†åˆ«æ ‡è®°æ‰“å‡ºè®°å½•å’Œæ¥å¬è®°å½•ï¼šbitset&lt;1000&gt; call(n),rec(n)ã€‚ç”±äºéœ€è¦è®°å½•çŸ­é€šè¯çš„æ¬¡æ•°ï¼Œå› æ­¤ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„å­˜å‚¨å•å‘æ‹¨æ‰“é€šè¯æ€»æ—¶é•¿ã€‚æ³¨æ„åˆ°callå’Œrecçš„ä¿¡æ¯å…¶å®æ˜¯ç­‰ä»·çš„ï¼Œå› æ­¤æˆ‘ä»¬ç”¨callæ¥æ ‡è®°çŸ­é€šè¯ã€‚å½“ä¸¤ä¸ªäººä¹‹é—´å­˜åœ¨é€šè¯è®°å½•å°±åœ¨æ‹¨æ‰“è€…çš„callé‡Œè¿›è¡Œæ ‡è®°ï¼Œå¦‚æœå•å‘é€šè¯æ—¶é•¿è¶…è¿‡5minï¼Œå°±å–æ¶ˆæ ‡è®°ã€‚recåªè¦æœ‰é€šè¯è®°å½•éƒ½æ ‡è®°ã€‚\né‚£ä¹ˆæ‹¨æ‰“çŸ­é€šè¯çš„ä¸åŒäººæ•°å°±æ˜¯call[i]ä¸­1çš„æ•°é‡call[i].count()ï¼Œè€Œå›æ‹¨çš„äººæ•°æˆ‘ä»¬åªè€ƒè™‘é‚£äº›æœ‰æ¥å¬çš„çŸ­é€šè¯çš„äººç¾¤ï¼Œå³call[i][j]&amp;&amp;rec[i][j]ã€‚æœ€ç»ˆæˆ‘ä»¬å°†è¿™éƒ¨åˆ†äººæ•°ï¼ˆéœ€è¦ä¿è¯æ•´å‹ä¸ä¼šæº¢å‡ºï¼‰å†å’Œcall[i].count()è¿›è¡Œæ¯”è¾ƒï¼Œå°†å«Œç–‘äººå­˜å…¥vector&lt;int&gt; susã€‚æœ€åå†å¯¹susè¿›è¡ŒDFSæˆ–BFSæˆ–å¹¶æŸ¥é›†æ¥æ±‚å–è¿é€šåˆ†å›¾ï¼Œæˆ‘è¿™é‡Œç”¨äº†DFSã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; edge;\nvector&lt;bool&gt; flag;\n\nvoid dfs(int n, vector&lt;int&gt; &amp;gang)\n{\n    flag[n] = true, gang.push_back(n);\n    for (auto &amp;k: edge[n])\n    {\n        if (flag[k]) continue;\n        dfs(k, gang);\n    }\n}\n\nint main()\n{\n    int k, n, m, c, r, d, cnt = 0;\n    cin &gt;&gt; k &gt;&gt; n &gt;&gt; m;\n    vector&lt;bitset&lt;1000&gt;&gt; call(n), rec(n);\n    vector&lt;vector&lt;int&gt;&gt; dur(n, vector(n, 0));\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; c &gt;&gt; r &gt;&gt; d;\n        call[c - 1][r - 1] = (dur[c - 1][r - 1] += d) &lt;= 5;\n        rec[r - 1][c - 1] = true;\n    }\n    vector&lt;int&gt; sus, gang;\n    for (int i = 0; i &lt; n; ++i, cnt = 0)\n    {\n        for (int j = 0; j &lt; n; ++j) cnt += (call[i][j] &amp;&amp; rec[i][j]);\n        if (call[i].count() &gt; k &amp;&amp; 5 * cnt &lt;= call[i].count())\n            sus.push_back(i);\n    }\n    if (sus.empty()) printf(\"None\");\n    else\n    {\n        edge.resize(sus.size()), flag.resize(sus.size(), false);\n        for (int i = 0; i &lt; sus.size(); ++i)\n            for (int j = i + 1; j &lt; sus.size(); ++j)\n                if (rec[sus[i]][sus[j]] &amp;&amp; rec[sus[j]][sus[i]])\n                    edge[i].push_back(j), edge[j].push_back(i);\n        for (int i = 0; i &lt; sus.size(); ++i, gang.clear())\n        {\n            if (flag[i]) continue;\n            dfs(i, gang);\n            sort(gang.begin(), gang.end(), [&amp;sus](int a, int b) { return sus[a] &lt; sus[b]; });\n            for (int j = 0; j &lt; gang.size(); ++j)\n                printf(\"%d%s\", sus[gang[j]] + 1, j == gang.size() - 1 ? \"\\n\" : \" \");\n        }\n    }\n}\n","slug":"ã€Œ1158ã€Telefraud-Detection","date":"2022-12-01T06:53:52.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,DFS,bitset","author_index":"Starlit Rover"},{"id":"11dc3c2912f3e8bbbeebc80b6943eb66","title":"ã€1157ã€Anniversary","content":"Zhejiang University is about to celebrate her 122th anniversary in 2019. To prepare for the celebration, the alumni association ï¼ˆæ ¡å‹ä¼šï¼‰ has gathered the IDâ€™s of all her alumni. Now your job is to write a program to count the number of alumni among all the people who come to the celebration.\n\n\nInput Specification:Each input file contains one test case. For each case, the first part is about the information of all the alumni. Given in the first line is a positive integerÂ . ThenÂ NÂ lines follow, each contains an ID number of an alumnus. An ID number is a string of 18 digits or the letterÂ X. It is guaranteed that all the IDâ€™s are distinct.\nThe next part gives the information of all the people who come to the celebration. Again given in the first line is a positive integerÂ . ThenÂ MÂ lines follow, each contains an ID number of a guest. It is guaranteed that all the IDâ€™s are distinct.\nOutput Specification:First print in a line the number of alumni among all the people who come to the celebration. Then in the second line, print the ID of the oldest alumnus â€“ notice that the 7th - 14th digits of the ID gives oneâ€™s birth date. If no alumnus comes, output the ID of the oldest guest instead. It is guaranteed that such an alumnus or guest is unique.\nSample Input:5\n372928196906118710\n610481197806202213\n440684198612150417\n13072819571002001X\n150702193604190912\n6\n530125197901260019\n150702193604190912\n220221196701020034\n610481197806202213\n440684198612150417\n370205198709275042\n\nSample Output:3\n150702193604190912\n\n\nÎ©ç»™å‡ºæ ¡å‹èº«ä»½IDï¼Œç„¶åç»Ÿè®¡å‚åŠ æ ¡åº†äººç¾¤ä¸­çš„æ ¡å‹ä¸ªæ•°ï¼Œå¹¶è¾“å‡ºæœ€å¹´é•¿çš„æ ¡å‹IDã€‚å¦‚æœæ²¡æœ‰æ ¡å‹å‚åŠ ï¼Œåˆ™è¾“å‡ºæ‰€æœ‰å®¾å®¢ä¸­æœ€å¹´é•¿çš„IDã€‚\næœ€å¹´é•¿IDå…·æœ‰æ˜æ˜¾çš„ä¼˜å…ˆçº§ï¼Œä¸pairæ¯”è¾ƒçš„æ€æƒ³ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨pairå¯¹çš„æ¯”è¾ƒæ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æ›¿æ¢æœ€å¹´é•¿IDã€‚æ¯”å¦‚è¯´ä¸€ä¸ªæ ¡å‹{false,\"19991229\"}å’Œä¸€ä¸ªéæ ¡å‹{true,\"18900101\"}ï¼Œç”±äºå‰è€…çš„pairè¾ƒå°ï¼ˆï¼‰ï¼Œé€‰æ‹©å‰è€…ä¸ºæœ€å¹´é•¿IDã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    set&lt;string&gt; alu;\n    int n, m, cnt = 0;\n    cin &gt;&gt; n;\n    string id, oldest;\n    pair&lt;bool, string&gt; cmp{true, string(8, '9')};\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; id, alu.insert(id);\n    cin &gt;&gt; m;\n    bool notAlu;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id;\n        (notAlu = alu.find(id) == alu.end()) ?: ++cnt;\n        if (make_pair(notAlu, id.substr(6, 8)) &lt; cmp)\n            cmp = make_pair(notAlu, id.substr(6, 8)), oldest = id;\n    }\n    printf(\"%d\\n%s\", cnt, oldest.c_str());\n}\n","slug":"ã€1157ã€Anniversary","date":"2022-11-29T14:27:33.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"8ed7bca38adabdf721bda6f764633180","title":"ã€1156ã€Sexy Primes","content":"Sexy primes are pairs of primes of the form , so-named since â€œsexâ€ is the Latin word for â€œsixâ€. (Quoted from http://mathworld.wolfram.com/SexyPrimes.html)\nNow given an integer, you are supposed to tell if it is a sexy prime.\n\n\nInput Specification:Each input file contains one test case. Each case gives a positive integerÂ .\nOutput Specification:For each case, print in a lineÂ YesÂ ifÂ NÂ is a sexy prime, then print in the next line the other sexy prime paired withÂ NÂ (if the answer is not unique, output the smaller number). Or ifÂ NÂ is not a sexy prime, printÂ NoÂ instead, then print in the next line the smallest sexy prime which is larger thanÂ N.\nSample Input 1:47\n\nSample Output 1:Yes\n41\n\nSample Input 2:21\n\nSample Output 2:No\n23\n\n\nÎ©æ€§æ„Ÿï¼ˆsexyï¼Œä¸sixå‘éŸ³ç›¸è¿‘ï¼‰ç´ æ•°æŒ‡åŒä¸ºç´ æ•°çš„ç´ æ•°ã€‚ç°åœ¨ç»™å‡ºä¸€ä¸ªæ•°ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºæ€§æ„Ÿç´ æ•°ï¼Œå¦‚æœæ˜¯å°±è¾“å‡ºå¦ä¸€ä¸ªæœ€å°çš„ç´ æ•°ä¼™ä¼´ï¼Œå¦åˆ™è¾“å‡ºæœ€å°ä¸”çš„æ€§æ„Ÿç´ æ•°ã€‚\nç›´æ¥ä»å¼€å§‹åˆ¤æ–­æ˜¯å¦ä¸ºæ€§æ„Ÿç´ æ•°ï¼Œä¸æ˜¯å°±+1ï¼Œæœ€åæ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªæ€§æ„Ÿç´ æ•°å¦‚æœå’Œç›¸ç­‰å°±è¾“å‡ºâ€œYesâ€å’Œå®ƒçš„ç´ æ•°ä¼™ä¼´ï¼Œå¦åˆ™è¾“å‡ºâ€œNoâ€å’Œæœ€å°çš„æ€§æ„Ÿç´ æ•°ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    if (n &lt; 4) return n &gt; 1;\n    for (int i = 2; i &lt;= sqrt(n); i += (i != 2) + 1)\n        if (n % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n, m = n - 1;\n    while (!isPrime(++m) || (!isPrime(k = m - 6) &amp;&amp; !isPrime(k = m + 6)));\n    printf(\"%s\\n%d\", m == n ? \"Yes\" : \"No\", m == n ? k : m);\n}\n","slug":"ã€1156ã€Sexy-Primes","date":"2022-11-29T12:59:44.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,prime","author_index":"Starlit Rover"},{"id":"af9a9a9068aea13525f268c88dd33420","title":"ã€1155ã€Heap Paths","content":"In computer science, aÂ heapÂ is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))\nOne thing for sure is that all the keys along any path from the root to a leaf in a max/min heap must be in non-increasing/non-decreasing order.\nYour job is to check every path in a given complete binary tree, in order to tell if it is a heap or not.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (1&lt;Nâ‰¤1,000), the number of keys in the tree. Then the next line containsÂ NÂ distinct integer keys (all in the range ofÂ int), which gives the level order traversal sequence of a complete binary tree.\nOutput Specification:For each given tree, first print all the paths from the root to the leaves. Each path occupies a line, with all the numbers separated by a space, and no extra space at the beginning or the end of the line. The paths must be printed in the following order: for each node in the tree, all the paths in its right subtree must be printed before those in its left subtree.\nFinally print in a lineÂ Max HeapÂ if it is a max heap, orÂ Min HeapÂ for a min heap, orÂ Not HeapÂ if it is not a heap at all.\nSample Input 1:8\n98 72 86 60 65 12 23 50\n\nSample Output 1:98 86 23\n98 86 12\n98 72 65\n98 72 60 50\nMax Heap\n\nSample Input 2:8\n8 38 25 58 52 82 70 60\n\nSample Output 2:8 25 70\n8 25 82\n8 38 52\n8 38 58 60\nMin Heap\n\nSample Input 3:8\n10 28 15 12 34 9 8 56\n\nSample Output 3:10 15 8\n10 15 9\n10 28 34\n10 28 12 56\nNot Heap\n\n\nÎ©æŒ‰ç…§å¶å­èŠ‚ç‚¹ä»å³è‡³å·¦çš„é¡ºåºè¾“å‡ºæ‰€æœ‰æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œå¹¶åˆ¤æ–­æ˜¯å°é¡¶å †è¿˜æ˜¯å¤§é¡¶å †ã€‚è¾“å…¥å †çš„å±‚æ¬¡éå†ï¼Œç”±äºå †æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œå› æ­¤å¯ä»¥æ ¹æ®èŠ‚ç‚¹ç´¢å¼•åˆ¤æ–­æ˜¯å¦å­˜åœ¨ã€‚\næœ¬è´¨ä¸Šå°±æ˜¯æ ‘çš„DFSï¼Œä¼˜å…ˆéå†å³å­æ ‘ï¼Œå†éå†å·¦å­æ ‘ã€‚ç”¨ä¸€ä¸ªvectorå­˜å‚¨ä»æ ¹èŠ‚ç‚¹åˆ°å½“å‰å‡½æ•°æ‰€åœ¨èŠ‚ç‚¹çš„è·¯å¾„ï¼ˆè¿›å…¥å‡½æ•°æ—¶å‹å…¥å½“å‰èŠ‚ç‚¹ç¼–å·ï¼Œé€€å‡ºæ—¶æŠŠæœ€åä¸€ä¸ªå…ƒç´ æ¨å‡ºï¼‰ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå°±å°†è·¯å¾„è¾“å‡ºã€‚é€’å½’è¿‡ç¨‹ä¸­é¡ºä¾¿è®°å½•æ¯ä¸ªèŠ‚ç‚¹ä¸çˆ¶èŠ‚ç‚¹ä¹‹é—´çš„å¤§å°å…³ç³»ï¼Œå¦‚æœæœ‰ä¸åŒçš„å¤§å°å…³ç³»è¯´æ˜ä¸æ˜¯å †ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define sign(x, y) (x==y?0:(x&gt;y)+1)\n\nusing namespace std;\nint n, jdg = 0;\nvector&lt;int&gt; level, path;\n\nvoid traverse(int r)\n{\n    if (r &gt; n) return;\n    path.push_back(level[r]);\n    jdg |= sign(level[r], level[r / 2]);\n    if (2 * r &gt; n &amp;&amp; 2 * r + 1 &gt; n)\n        for (int i = 0; i &lt; path.size(); ++i)\n            printf(\"%d%s\", path[i], i &lt; path.size() - 1 ? \" \" : \"\\n\");\n    traverse(2 * r + 1);\n    traverse(2 * r);\n    path.pop_back();\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    level.resize(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n        cin &gt;&gt; level[i];\n    level[0] = level[1];\n    traverse(1);\n    printf(\"%s\", jdg == 3 ? \"Not Heap\" : jdg == 2 ? \"Min Heap\" : \"Max Heap\");\n}\n","slug":"ã€1155ã€Heap-Paths","date":"2022-11-29T12:12:08.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,heap","author_index":"Starlit Rover"},{"id":"09fcb22b7551ea744c57f07b69e5a972","title":"ã€Œ1154ã€Vertex Coloring","content":"AÂ proper vertex coloringÂ is a labeling of the graphâ€™s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at mostÂ kÂ colors is called a (proper)Â k-coloring.\nNow you are supposed to tell if a given coloring is a properÂ k-coloring.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integersÂ NÂ andÂ MÂ (both no more thanÂ ), being the total numbers of vertices and edges, respectively. ThenÂ MÂ lines follow, each describes an edge by giving the indices (from 0 toÂ Nâˆ’1) of the two ends of the edge.\nAfter the graph, a positive integerÂ  is given, which is the number of colorings you are supposed to check. ThenÂ KÂ lines follow, each containsÂ NÂ colors which are represented by non-negative integers in the range ofÂ int. TheÂ i-th color is the color of theÂ i-th vertex.\nOutput Specification:For each coloring, print in a lineÂ k-coloringÂ if it is a properÂ k-coloring for some positiveÂ k, orÂ NoÂ if not.\nSample Input:10 11\n8 7\n6 8\n4 5\n8 4\n8 1\n1 2\n1 4\n9 8\n9 1\n1 0\n2 4\n4\n0 1 0 1 4 1 0 1 3 0\n0 1 0 1 4 1 0 1 0 0\n8 1 0 1 4 1 0 5 3 0\n1 2 3 4 5 6 7 8 8 9\n\nSample Output:4-coloring\nNo\n6-coloring\nNo\n\n\nÎ©ç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œåˆ¤æ–­é¡¶ç‚¹æŸ“è‰²æ–¹æ¡ˆæ˜¯å¦æ»¡è¶³ä»»æ„è¾¹çš„ä¸¤ä¸ªç«¯ç‚¹ä¸åŒè‰²ï¼Œè‹¥æ»¡è¶³åˆ™åŒæ—¶è¾“å‡ºé¢œè‰²æ•°é‡ã€‚\nåœ¨è¯»å–æŸ“è‰²æ–¹æ¡ˆæ—¶ï¼Œç”¨setå­˜å‚¨å„ä¸ªç‚¹ä¸èƒ½æŸ“çš„é¢œè‰²ç¼–å·ã€‚è¯»å…¥é¡¶ç‚¹çš„é¢œè‰²ä¹‹åï¼Œå…ˆåœ¨çš„setä¸­find(c)Â ï¼Œå¦‚æœæ‰¾åˆ°äº†è¯´æ˜ä¸æ»¡è¶³è¦æ±‚ï¼Œæ»¡è¶³çš„è¯å†å°†æ‰€æœ‰ä¸å…³è”çš„é¡¶ç‚¹setä¸­æ’å…¥é¢œè‰²ï¼Œè¡¨æ˜å®ƒä¸èƒ½æŸ“æˆé¢œè‰²ã€‚åŒæ—¶å•ç‹¬ç”¨ä¸€ä¸ªsetå­˜å‚¨æ‰€æœ‰å‡ºç°è¿‡çš„é¢œè‰²æ¥è®°å½•ä¸åŒé¢œè‰²æ•°é‡ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b, k;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;vector&lt;int&gt;&gt; edge(n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        edge[a].push_back(b), edge[b].push_back(a);\n    }\n    scanf(\"%d\", &amp;k);\n    for (int i = 0; i &lt; k; ++i)\n    {\n        vector&lt;set&lt;int&gt;&gt; no(n);\n        set&lt;int&gt; color;\n        bool ans = true;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            scanf(\"%d\", &amp;a);\n            if (!ans) continue;\n            ans = (no[j].find(a) == no[j].end());\n            for (auto &amp;t: edge[j])\n                no[t].insert(a);\n            color.insert(a);\n        }\n        if (ans) printf(\"%zu-coloring\\n\", color.size());\n        else printf(\"No\\n\");\n    }\n}\n","slug":"ã€Œ1154ã€Vertex-Coloring","date":"2022-11-29T10:43:33.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph","author_index":"Starlit Rover"},{"id":"1dc52340625e6d898b967d568951e86c","title":"ã€Œ1153ã€Decode Registration Card of PAT","content":"A registration card number of PAT consists of 4 parts:\n\nthe 1st letter represents the test level, namely,Â TÂ for the top level,Â AÂ for advance andÂ BÂ for basic;\nthe 2nd - 4th digits are the test site number, ranged from 101 to 999;\nthe 5th - 10th digits give the test date, in the form ofÂ yymmdd;\nfinally the 11th - 13th digits are the testeeâ€™s number, ranged from 000 to 999.\n\nNow given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integersÂ NÂ (â‰¤104) andÂ MÂ (â‰¤100), the numbers of cards and the queries, respectively.\nThenÂ NÂ lines follow, each gives a card number and the ownerâ€™s score (integer inÂ [0,100]), separated by a space.\nAfter the info of testees, there areÂ MÂ lines, each gives a query in the formatÂ Type Term, where\n\nTypeÂ being 1 means to output all the testees on a given level, in non-increasing order of their scores. The correspondingÂ TermÂ will be the letter which specifies the level;\nTypeÂ being 2 means to output the total number of testees together with their total scores in a given site. The correspondingÂ TermÂ will then be the site number;\nTypeÂ being 3 means to output the total number of testees of every site for a given test date. The correspondingÂ TermÂ will then be the date, given in the same format as in the registration card.\n\nOutput Specification:For each query, first print in a lineÂ Case #: input, whereÂ #Â is the index of the query case, starting from 1; andÂ inputÂ is a copy of the corresponding input query. Then output as requested:\n\nfor a type 1 query, the output format is the same as in input, that is,Â CardNumber Score. If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed);\nfor a type 2 query, output in the formatÂ Nt NsÂ whereÂ NtÂ is the total number of testees andÂ NsÂ is their total score;\nfor a type 3 query, output in the formatÂ Site NtÂ whereÂ SiteÂ is the site number andÂ NtÂ is the total number of testees atÂ Site. The output must be in non-increasing order ofÂ Ntâ€˜s, or in increasing order of site numbers if there is a tie ofÂ Nt.\n\nIf the result of a query is empty, simply printÂ NA.\nSample Input:8 4\nB123180908127 99\nB102180908003 86\nA112180318002 98\nT107150310127 62\nA107180908108 100\nT123180908010 78\nB112160918035 88\nA107180908021 98\n1 A\n2 107\n3 180908\n2 999\n\nSample Output:Case 1: 1 A\nA107180908108 100\nA107180908021 98\nA112180318002 98\nCase 2: 2 107\n3 260\nCase 3: 3 180908\n107 2\n123 2\n102 1\nCase 4: 2 999\nNA\n\n\nÎ©åšè¿™ç§é¢˜ç›®çš„æ—¶å€™æ€»æ˜¯å¿ƒæƒŠèƒ†æˆ˜ï¼Œç”Ÿæ€•å“ªä¸ªåœ°æ–¹ä¼˜åŒ–æ²¡åšå¥½ï¼Œæ•°æ®ç»“æ„æ²¡æå¥½å°±TLEã€‚\nç»™å‡ºè‹¥å¹²ä¸ªPATè€ƒè¯•ç™»è®°ç ï¼šï¼Œæ¥ä¸‹æ¥ä¼šæœ‰å¤šä¸ªæŸ¥è¯¢ï¼Œæœ‰ä¸‰ç§æŸ¥è¯¢æ¨¡å¼ï¼š\n\nType 1ï¼šè¾“å…¥levelï¼ˆBã€Aã€Tï¼‰ï¼ŒæŒ‰ç…§æˆç»©é™åºè¾“å‡ºæ‰€æœ‰å‚åŠ è¿™ä¸ªç­‰çº§è€ƒçš„å­¦ç”Ÿç™»è®°ç å’Œæˆç»©ï¼Œæˆç»©ä¸€æ ·æŒ‰ç™»è®°ç å‡åºæ’åˆ—\n\nType 2ï¼šè¾“å…¥è€ƒåœºå·ï¼Œè¾“å‡ºåœ¨è¯¥è€ƒåœºå‚åŠ è€ƒè¯•çš„æ€»äººæ•°ä»¥åŠæ€»æˆç»©\n\nType 3ï¼šè¾“å…¥æ—¥æœŸï¼ŒæŒ‰ç…§å½“æ—¥è€ƒè¯•äººæ•°é™åºè¾“å‡ºæ‰€æœ‰æœ‰äººè€ƒè¯•çš„è€ƒåœºå·ï¼Œä»¥åŠç›¸åº”çš„è€ƒè¯•äººæ•°ï¼Œå¦‚æœè€ƒè¯•äººæ•°ä¸€è‡´åˆ™æŒ‰è€ƒåœºå·å‡åºæ’åˆ—\n\n\næŸ¥è¯¢ç»“æœä¸ºç©ºå°±è¾“å‡ºNAã€‚\nå‰ä¸¤ç§æŸ¥è¯¢æ–¹å¼éƒ½æŒºå¥½å¤„ç†ã€‚è¯»å–å®Œæ‰€æœ‰ç™»è®°ç å’Œæˆç»©ï¼Œå¯¹ä¸‰ä¸ªlevelçš„ä¿¡æ¯åˆ†åˆ«è¿›è¡Œæ’åºï¼›æ³¨æ„åˆ°è€ƒåœºå·åªæœ‰ä¸‰ä½æ•°ï¼Œé‚£ä¹ˆç›´æ¥å¼€ä¸€ä¸ªvector&lt;pair&lt;int,int&gt;&gt; site(1000)ï¼Œè€ƒåœºå·å³ä¸ºç´¢å¼•ï¼Œæ¥å­˜å‚¨äººæ•°å’Œæ€»æˆç»©ã€‚ç¬¬ä¸‰ä¸ªæŸ¥è¯¢æ¨¡å¼å°±æ¯”è¾ƒæ£˜æ‰‹äº†ï¼Œæˆ‘çš„æ€è·¯æ˜¯ç›´æ¥å¼€ä¸€ä¸ªmap&lt;int,map&lt;int,int&gt;&gt;æ¥å­˜å‚¨å•ä¸ªæ—¥æœŸä¸‹å•ä¸ªè€ƒåœºçš„äººæ•°ï¼Œåœ¨æŸ¥è¯¢æ—¶æŠŠå­mapæ‹·è´åˆ°ä¸€ä¸ªvectorä¸­ï¼Œç„¶åå†è¿›è¡Œæ’åºè¾“å‡ºã€‚\nç¬¬ä¸€æ¬¡æäº¤ï¼Œåä¸‰ä¸ªæµ‹è¯•ç‚¹å…¨æ˜¯TLEï¼ŒæŠŠæˆ‘çœ‹å‚»äº†ï¼Œå¿ƒæ€ç›´æ¥å´©ã€‚ä¸çŸ¥é“è¿˜æœ‰ä»€ä¹ˆä¼˜åŒ–æ‰‹æ®µï¼Œäºæ˜¯å»ç½‘ä¸Šçœ‹äº†äº›é¢˜è§£ï¼Œå‘ç°æš´åŠ›å¾ªç¯éå†éƒ½èƒ½è¿‡ï¼Œç™¾æ€ä¸å¾—å…¶è§£ã€‚æˆ‘è¯•ç€æŠŠä¸‰ä¸ªlevelçš„æ’åºéƒ¨åˆ†ç»™æ³¨é‡Šæ‰ï¼Œç«Ÿç„¶å‘ç°æ—¶é—´éª¤å‡ã€‚ä»”ç»†ç ”ç©¶ä¸€ç•ªï¼Œå‘ç°é—®é¢˜å‡ºåœ¨lambdaè¡¨è¾¾å¼ä¸­çš„ä¼ å‚ã€‚ç”±äºæˆ‘æŠŠç™»è®°ç å’Œæˆç»©å•ç‹¬å­˜å‚¨åœ¨ä¸€ä¸ªvector&lt;pair&lt;int,int&gt;&gt; infoä¸­ï¼Œè€Œä¸‰ä¸ªleveléƒ½åªå­˜infoçš„ç´¢å¼•ï¼Œå› æ­¤åœ¨sortçš„lambdaå‡½æ•°ä¸­éœ€è¦å°†infoä¼ å…¥ï¼š\n[info](int a, int b) {return info[a].second == info[b].second ? info[a].first &lt; info[b].first : info[a].second &gt; info[b].second;}\n\né‚£ä¹ˆå°±æ„å‘³ç€æ¯æ¬¡è°ƒç”¨lambdaå‡½æ•°æ—¶éƒ½ä¼šæ‹·è´ä¸€éinfoï¼Œä»è€Œé€ æˆäº†å¤§é‡çš„æ—¶é—´å¼€é”€ã€‚å…¶å®lambdaå‡½æ•°æ˜¯å¯ä»¥ä¼ å…¥å¼•ç”¨çš„ï¼Œåªè¦åœ¨å˜é‡åå‰åŠ ä¸Š&amp;å³å¯ï¼š\n[&amp;info](int a, int b)\n\nä¼ å…¥æ‰€æœ‰å‚æ•°æ˜¯[=]ï¼Œâš ï¸è¿™ä¹Ÿæ˜¯æ‹·è´ä¼ å‚ã€‚å¦‚æœéœ€è¦ä¼ å…¥å¤šä¸ªå‚æ•°å°±ç”¨ã€,ã€‘åˆ†éš”ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\n\n#define idx(x) (x=='B'?0:x=='A'?1:2)\n\nusing namespace std;\ntypedef const pair&lt;int, int&gt; cpii;\n\nint main()\n{\n    int n, m, tp, s, d;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;pair&lt;string, int&gt;&gt; info(n, {string(13, 0), 0});\n    vector&lt;pair&lt;int, int&gt;&gt; site(1000);\n    vector&lt;int&gt; level[3];\n    unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; date;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;info[i].first[0], &amp;info[i].second);\n        s = stoi(info[i].first.substr(1, 3)), d = stoi(info[i].first.substr(4, 6));\n        level[idx(info[i].first[0])].push_back(i);\n        ++site[s].first; site[s].second += info[i].second;\n        ++date[d][s];\n    }\n    for (auto &amp;k: level)\n        sort(k.begin(), k.end(), [&amp;info](int a, int b) \n        {return info[a].second == info[b].second ? info[a].first &lt; info[b].first : info[a].second &gt; info[b].second;});\n    string st;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; tp &gt;&gt; st;\n        printf(\"Case %d: %d %s\\n\", i + 1, tp, st.c_str());\n        switch (tp)\n        {\n            case 1:\n                if (level[idx(st[0])].empty()) printf(\"NA\\n\");\n                else\n                    for (auto &amp;k: level[idx(st[0])])\n                        printf(\"%s %d\\n\", info[k].first.c_str(), info[k].second);\n                break;\n            case 2:\n                if (!site[stoi(st)].first) printf(\"NA\\n\");\n                else printf(\"%d %d\\n\", site[stoi(st)].first, site[stoi(st)].second);\n                break;\n            case 3:\n                if (date[stoi(st)].empty()) printf(\"NA\\n\");\n                else\n                {\n                    vector&lt;pair&lt;int, int&gt;&gt; tmp(date[stoi(st)].begin(), date[stoi(st)].end());\n                    sort(tmp.begin(), tmp.end(), [](cpii &amp;a, cpii &amp;b) \n                    {return a.second == b.second ? a.first &lt; b.first : a.second &gt; b.second;});\n                    for (auto &amp;k: tmp)\n                        printf(\"%03d %d\\n\", k.first, k.second);\n                }\n                break;\n        }\n    }\n}\n","slug":"ã€Œ1153ã€Decode-Registration-Card-of-PAT","date":"2022-11-29T08:35:11.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"1c996a2205f7f5bbcbe287507d181067","title":"ã€Œ1152ã€Google Recruitment","content":"In July 2004, Google posted on a giant billboard along Highway 101 in Silicon Valley (shown in the picture below) for recruitment. The content is super-simple, a URL consisting of the first 10-digit prime found in consecutive digits of the natural constantÂ e. The person who could find this prime number could go to the next step in Googleâ€™s hiring process by visiting this website.\n\nThe natural constantÂ eÂ is a well known transcendental numberï¼ˆè¶…è¶Šæ•°ï¼‰. The first several digits are:Â eÂ = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921â€¦ where the 10 digits in bold are the answer to Googleâ€™s question.\nNow you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number.\n\n\nInput Specification:Each input file contains one test case. Each case first gives in a line two positive integers: L (â‰¤Â 1,000) and K (&lt;Â 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line.\nOutput Specification:For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, outputÂ 404Â instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number.\nSample Input 1:20 5\n23654987725541023819\n\nSample Output 1:49877\n\nSample Input 2:10 3\n2468024680\n\nSample Output 2:404\n\n\nÎ©å¥½è€çš„æ¢—å•Šï¼Œå‡ ç™¾å¹´å‰å°±çœ‹åˆ°è¿‡äº†ã€‚ç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºLçš„å­—ç¬¦ä¸²ï¼Œä»ä¸­æ‰¾å‡ºæœ€å‰é¢é•¿åº¦ä¸ºKçš„è¿ç»­ç´ å­ä¸²ã€‚ç›´æ¥ä»ï½ä¾æ¬¡éå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªç´ æ•°ååœæ­¢ã€‚\nâš ï¸æ—¶ç›´æ¥è¾“å‡º404ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    if (n &lt; 3) return n == 2;\n    for (int i = 2; i &lt;= sqrt(n); i += i == 2 ? 1 : 2)\n        if (n % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int l, k;\n    string s;\n    cin &gt;&gt; l &gt;&gt; k &gt;&gt; s;\n    if (l &lt; k)\n    {\n        printf(\"404\");\n        return 0;\n    }\n    for (int i = 0; i &lt; l - k + 1; ++i)\n        if (isPrime(stoi(s.substr(i, k))))\n        {\n            printf(\"%s\", s.substr(i, k).c_str());\n            return 0;\n        }\n    printf(\"404\");\n}\n","slug":"ã€Œ1152ã€Google-Recruitment","date":"2022-11-28T15:31:17.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,prime,string","author_index":"Starlit Rover"},{"id":"1e6798c1367bb43a43c504bc91548d12","title":"ã€Œ1151ã€LCA in a Binary Tree","content":"The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.\nGiven any two nodes in a binary tree, you are supposed to find their LCA.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (â‰¤Â 1,000), the number of pairs of nodes to be tested; and N (â‰¤Â 10,000), the number of keys in the binary tree, respectively. In each of the following two lines, N distinct integers are given as the inorder and preorder traversal sequences of the binary tree, respectively. It is guaranteed that the binary tree can be uniquely determined by the input sequences. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range ofÂ int.\nOutput Specification:For each given pair of U and V, print in a lineÂ LCA of U and V is A.Â if the LCA is found andÂ AÂ is the key. But ifÂ AÂ is one of U and V, printÂ X is an ancestor of Y.Â whereÂ XÂ isÂ AÂ andÂ YÂ is the other node. If U or V is not found in the binary tree, print in a lineÂ ERROR: U is not found.Â orÂ ERROR: V is not found.Â orÂ ERROR: U and V are not found..\nSample Input:6 8\n7 2 3 4 6 5 1 8\n5 3 7 2 6 4 8 1\n2 6\n8 1\n7 9\n12 -3\n0 8\n99 99\n\nSample Output:LCA of 2 and 6 is 3.\n8 is an ancestor of 1.\nERROR: 9 is not found.\nERROR: 12 and -3 are not found.\nERROR: 0 is not found.\nERROR: 99 and 99 are not found.\n\n\nÎ©å¥½çœ¼ç†Ÿçš„é¢˜ç›®å•Šï¼Œæ„Ÿè§‰è¿æµ‹è¯•æ ·ä¾‹ç”šè‡³éƒ½æ˜¯ä¸€æ ·çš„â€”â€”ã€1143ã€Lowest Common Ancestorã€‚åŒæ ·æ˜¯è¾“å‡ºä¸¤ä¸ªèŠ‚ç‚¹å…±åŒçš„æœ€ä½ç¥–å®—èŠ‚ç‚¹ï¼Œä¸Šä¸€é—®ä¸­æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œè€Œè¿™ä¸€é—®åªæ˜¯äºŒå‰æ ‘ï¼Œä½†ç»™å‡ºäº†ä¸­åºéå†å’Œå…ˆåºéå†ã€‚\nçœŸæ˜¯æ¢æ±¤ä¸æ¢è¯å•Šï¼Œæˆ‘å¯»æ€ç€ä¸Šä¸€é—®ä¹‹æ‰€ä»¥å¯ä»¥æŠŠä¸­åºéå†çœå»æ˜¯å› ä¸ºæ‰€æœ‰èŠ‚ç‚¹çš„å‡åºæ’åˆ—å°±æ˜¯äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ã€‚æ‰€ä»¥ä¸¤è€…æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œæˆ‘ä»¬åªè¦ç»™æ¯ä¸€ä¸ªèŠ‚ç‚¹é‡æ–°ç¼–å·ä½¿å¾—å®ƒä»¬çš„ä¸­åºéå†ç»“æœå³ä¸ºå‡åºæ’åˆ—ï¼Œé€šè¿‡mapå»ºç«‹èµ·è€ç¼–å·å’Œæ–°ç¼–å·ä¹‹é—´çš„æ˜ å°„ã€‚é‚£ä¹ˆå¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬åªéœ€è¦æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„æ–°ç¼–å·è®¾ç½®ä¸ºä¸­åºéå†ä¸­çš„ç´¢å¼•å³å¯ã€‚æ¥ä¸‹æ¥å°±åœ¨å…ˆåºéå†ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ–°ç¼–å·ä»‹äºä¸¤ä¸ªèŠ‚ç‚¹æ–°ç¼–å·ä¹‹é—´çš„èŠ‚ç‚¹å³å¯ï¼Œè¯æ˜è¿‡ç¨‹è§1143ã€‚\nå…¶å®æ ¹æ®æ¨å¯¼è¿‡ç¨‹ï¼Œå¯ä»¥çœ‹å‡ºä¸€èˆ¬çš„æ ‘ï¼ˆéäºŒå‰æ ‘ï¼‰ä¹Ÿé€‚ç”¨è¿™ç§åšæ³•ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k, a, b, u, v, ans;\n    scanf(\"%d %d\", &amp;m, &amp;n);\n    vector&lt;int&gt; pre(n);\n    map&lt;int, int&gt; in;\n    for (int i = 0; i &lt; n; ++i)\n        scanf(\"%d\", &amp;k), in[k] = i;\n    for (auto &amp;p: pre) cin &gt;&gt; p;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        bool fa = in.find(a) == in.end(), fb = in.find(b) == in.end();\n        switch (fa + (fb &lt;&lt; 1))\n        {\n            case 1:\n                printf(\"ERROR: %d is not found.\\n\", a); continue;\n            case 2:\n                printf(\"ERROR: %d is not found.\\n\", b); continue;\n            case 3:\n                printf(\"ERROR: %d and %d are not found.\\n\", a, b); continue;\n        }\n        u = min(in[a], in[b]), v = max(in[a], in[b]);\n        for (auto &amp;p: pre)\n            if (in[p] &gt;= u &amp;&amp; in[p] &lt;= v)\n            {\n                ans = p;\n                break;\n            }\n        if (in[ans] == v || in[ans] == u)\n            printf(\"%d is an ancestor of %d.\\n\", in[ans] == in[a] ? a : b, in[ans] == in[a] ? b : a);\n        else\n            printf(\"LCA of %d and %d is %d.\\n\", a, b, ans);\n    }\n}\n\n\n","slug":"ã€Œ1151ã€LCA-in-a-Binary-Tree","date":"2022-11-28T14:12:07.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"a4815f6ae46beab8c783f42705d05394","title":"ã€1150ã€Travelling Salesman Problem","content":"The â€œtravelling salesman problemâ€ asks the following question: â€œGiven a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city and returns to the origin city?â€ It is an NP-hard problem in combinatorial optimization, important in operations research and theoretical computer science. (Quoted from â€œhttps://en.wikipedia.org/wiki/Travelling_salesman_problemâ€œ.)\nIn this problem, you are supposed to find, from a given list of cycles, the one that is the closest to the solution of a travelling salesman problem.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integersÂ NÂ (2&lt;Nâ‰¤200), the number of cities, andÂ M, the number of edges in an undirected graph. ThenÂ MÂ lines follow, each describes an edge in the formatÂ City1 City2 Dist, where the cities are numbered from 1 toÂ NÂ and the distanceÂ DistÂ is positive and is no more than 100. The next line gives a positive integerÂ KÂ which is the number of paths, followed byÂ KÂ lines of paths, each in the format:\nnÂ C1â€‹Â C2â€‹Â â€¦Â Cnâ€‹\nwhereÂ nÂ is the number of cities in the list, andÂ Ciâ€‹â€™s are the cities on a path.\nOutput Specification:For each path, print in a lineÂ Path X: TotalDist (Description)Â whereÂ XÂ is the index (starting from 1) of that path,Â TotalDistÂ its total distance (if this distance does not exist, outputÂ NAÂ instead), andÂ DescriptionÂ is one of the following:\n\nTS simple cycleÂ if it is a simple cycle that visits every city;\nTS cycleÂ if it is a cycle that visits every city, but not a simple cycle;\nNot a TS cycleÂ if it is NOT a cycle that visits every city.\n\nFinally print in a lineÂ Shortest Dist(X) = TotalDistÂ whereÂ XÂ is the index of the cycle that is the closest to the solution of a travelling salesman problem, andÂ TotalDistÂ is its total distance. It is guaranteed that such a solution is unique.\nSample Input:6 10\n6 2 1\n3 4 1\n1 5 1\n2 5 1\n3 1 8\n4 1 6\n1 6 1\n6 3 1\n1 2 1\n4 5 1\n7\n7 5 1 4 3 6 2 5\n7 6 1 3 4 5 2 6\n6 5 1 4 3 6 2\n9 6 2 1 6 3 4 5 2 6\n4 1 2 5 1\n7 6 1 2 5 4 3 1\n7 6 3 2 5 4 1 6\n\nSample Output:Path 1: 11 (TS simple cycle)\nPath 2: 13 (TS simple cycle)\nPath 3: 10 (Not a TS cycle)\nPath 4: 8 (TS cycle)\nPath 5: 3 (Not a TS cycle)\nPath 6: 13 (Not a TS cycle)\nPath 7: NA (Not a TS cycle)\nShortest Dist(4) = 8\n\n\nÎ©TSPæ˜¯ä¸€ä¸ªNPéš¾é—®é¢˜ï¼Œè¿™ä¸€é¢˜éœ€è¦ä½ åˆ¤æ–­ç»™å®šæ— å‘å›¾ä¸­çš„ä¸€äº›è·¯å¾„æ˜¯ä»¥ä¸‹ä¸‰ç§ä¸­çš„å“ªç§ï¼š\n\nTS ç®€å•ç¯ï¼šæ¯åº§åŸå¸‚è®¿é—®è¿‡ä¸”ä»…è®¿é—®è¿‡ä¸€æ¬¡\n\nTS ç¯ï¼šæ¯åº§åŸå¸‚éƒ½è®¿é—®è¿‡ï¼Œä½†éƒ¨åˆ†åŸå¸‚å¤šæ¬¡è®¿é—®\n\néTSç¯ï¼šéƒ¨åˆ†åŸå¸‚æ²¡æœ‰è®¿é—®ï¼Œæˆ–æ ¹æœ¬ä¸æ˜¯ç¯ï¼Œæˆ–è·¯çº¿ä¸å­˜åœ¨\n\n\næ³¨æ„å¦‚æœä¸æ˜¯è·¯çº¿ä¸å­˜åœ¨ï¼Œæ‰€æœ‰çš„è·¯çº¿éƒ½éœ€è¦è¾“å‡ºæ€»é•¿åº¦ï¼Œè€Œæœ€ä¼˜è·¯çº¿åªèƒ½ä»TS simple cycleå’ŒTS cycleä¸­é€‰ã€‚ç”¨ä¸€ä¸ªbitset&lt;201&gt;æ¥æ ‡è®°åŸå¸‚æ˜¯å¦è®¿é—®è¿‡ï¼Œç”¨æ•´å‹å˜é‡jdgçš„ä½ä¸¤ä½åˆ†åˆ«æ¥è¡¨ç¤ºå…·å¤‡TS cycleï¼ˆé‡å¤è®¿é—®åŸå¸‚ï¼‰å’ŒNot a TS cycleçš„ç‰¹å¾ï¼ˆæœ‰åŸå¸‚æ²¡è®¿é—®ã€ä¸æ˜¯ç¯è·¯ã€è·¯çº¿ä¸å­˜åœ¨ï¼‰ï¼Œæ˜¾ç„¶å½“æ—¶è¯´æ˜æ˜¯å‰è€…çš„æƒ…å†µï¼Œè€Œéƒ½æ˜¯åè€…ã€‚è¯»å…¥è·¯çº¿çš„è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­æ˜¯å¦é‡å¤è®¿é—®ï¼ŒåŒæ—¶æ£€æŸ¥è·¯çº¿æ˜¯å¦å­˜åœ¨ã€‚è¯»å®Œä¹‹ååˆ¤æ–­èµ·ç‚¹å’Œç»ˆç‚¹æ˜¯å¦ç›¸åŒï¼Œæ˜¯å¦æ‰€æœ‰åŸå¸‚éƒ½å·²è®¿é—®ã€‚æœ€åæ ¹æ®jdgçš„å€¼è¾“å‡ºç›¸åº”çš„ä¿¡æ¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, a, b, p, d = 0, jdg = 0, opt = -1, min_d = INT32_MAX;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt; dist(n + 1, vector(n + 1, 0));\n    for (int i = 0; i &lt; m; ++i)\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; dist[b][a], dist[a][b] = dist[b][a];\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i, d = 0, jdg = 0)\n    {\n        bitset&lt;201&gt; flag(string(n, '1'));\n        cin &gt;&gt; k &gt;&gt; a, p = a;\n        for (int j = 1; j &lt; k; ++j, p = b)\n        {\n            cin &gt;&gt; b;\n            // if revisit city and visit non-existent road\n            jdg |= !flag[b - 1] + (dist[p][b] ? 0 : (d = -1, 2));\n            d += (d &gt; -1) * dist[p][b], flag[b - 1] = false;\n        }\n        // if starting city is same as ending city and all the cities have been visited\n        jdg |= (a == b &amp;&amp; flag == 0 ? 0 : 2);\n        switch (jdg)\n        {\n            case 0:\n                printf(\"Path %d: %d (TS simple cycle)\\n\", i + 1, d);\n                if (d &lt; min_d) min_d = d, opt = i + 1;\n                break;\n            case 1:\n                printf(\"Path %d: %d (TS cycle)\\n\", i + 1, d);\n                if (d &lt; min_d) min_d = d, opt = i + 1;\n                break;\n            default:\n                if (d &gt; 0) printf(\"Path %d: %d (Not a TS cycle)\\n\", i + 1, d);\n                else printf(\"Path %d: NA (Not a TS cycle)\\n\", i + 1);\n                break;\n        }\n    }\n    printf(\"Shortest Dist(%d) = %d\", opt, min_d);\n}\n","slug":"ã€1150ã€Travelling-Salesman-Problem","date":"2022-11-28T12:44:21.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,TSP","author_index":"Starlit Rover"},{"id":"ff3134335de30a822a5e1c46f95fdfc6","title":"ã€1149ã€Dangerous Goods Packaging","content":"When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent ï¼ˆæ°§åŒ–å‰‚ï¼‰ must not be packed with flammable liquid ï¼ˆæ˜“ç‡ƒæ¶²ä½“ï¼‰, or it can cause explosion.\nNow you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers:Â , the number of pairs of incompatible goods, andÂ , the number of lists of goods to be shipped.\nThen two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format:\nK G[1] G[2] ... G[K]\n\nwhereÂ KÂ (â‰¤1,000) is the number of goods andÂ G[i]â€˜s are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces.\nOutput Specification:For each shipping list, print in a lineÂ YesÂ if there are no incompatible goods in the list, orÂ NoÂ if not.\nSample Input:6 3\n20001 20002\n20003 20004\n20005 20006\n20003 20001\n20005 20004\n20004 20006\n4 00001 20004 00002 20003\n5 98823 20002 20003 20006 10010\n3 12345 67890 23333\n\nSample Output:No\nYes\nYes\n\n\nÎ©ä»Šå¤©çœŸçš„æ˜¯æ°´é€†ï¼Œä¸€ä¼šTLEï¼Œä¸€ä¼šMLEï¼Œæ€»ä¹‹æ¯æ¬¡ç¬¬ä¸€ä¸ªæ€è·¯æ€»æ˜¯é”™çš„ï¼Œå¯æ¶ã€‚\nç»™å‡ºå¯¹ä¸èƒ½ä¸€èµ·è¿è¾“çš„ç‰©å“IDï¼Œéšåè¾“å…¥ä¸ªè¿è¾“æ¸…å•ï¼Œè¾“å‡ºèƒ½å¦è¿è¾“ã€‚å°±è¿è¿™ç§é¢˜ç›®éƒ½ä¸èƒ½ä¸€è¾¹è¿‡ï¼Œæœäº†ã€‚\nä¸€å¼€å§‹æˆ‘æ‰“ç®—ç”¨ä¸€ä¸ªset&lt;long long&gt;å­˜å‚¨ä¸èƒ½ä¸€èµ·è¿è¾“çš„ç‰©å“IDï¼Œå‡è®¾æ˜¯ä¸€å¯¹ä¸èƒ½ä¸€èµ·è¿è¾“çš„ç‰©å“ï¼Œé‚£ä¹ˆå°±å°†æŸ¥è¯¢ç´¢å¼•å­˜å…¥setã€‚åœ¨è¯»å…¥ä¸€ä¸ªè¿è¾“æ¸…å•æ—¶ï¼Œå°†æ¯ä¸€ä¸ªè¯»å…¥ç‰©å“ä¸ä¹‹å‰è¯»å…¥ç‰©å“ç»„æˆæŸ¥è¯¢ç´¢å¼•åœ¨setä¸­æŸ¥æ‰¾ï¼Œå¦‚æœæ‰¾åˆ°äº†å°±è¯´æ˜ä¸èƒ½ä¸€èµ·è¿è¾“ã€‚ç»“æœåé¢ä¸¤ä¸ªæµ‹è¯•ç‚¹TLEäº†ã€‚åæ¥æˆ‘æƒ³ç›´æ¥ç»™æ¯ä¸ªç‰©å“å¼€ä¸€ä¸ªbitset&lt;100000&gt;æ¥è®°å½•ä¸èƒ½ä¸€èµ·å­˜å‚¨çš„ç‰©å“ï¼Œç»“æœMEï¼ˆMemory Limit Exceededï¼‰ã€‚\næœ€åé‡‡å–å¸¸è§„åšæ³•ï¼Œç”¨map&lt;int,vector&lt;int&gt;&gt;å»ºç«‹IDåˆ°ä¸èƒ½ä¸€èµ·è¿è¾“ç‰©å“é›†çš„æ˜ å°„ï¼Œç„¶åæ¯è¯»å…¥ä¸€ä¸ªç‰©å“å°±å°†ä¸èƒ½å’Œå…¶ä¸€èµ·è¿è¾“çš„ç‰©å“IDè¿›è¡Œæ ‡è®°ï¼Œå¦‚æœåé¢å‡ºç°äº†æ ‡è®°è¿‡çš„ç‰©å“ï¼Œåˆ™è¯´æ˜è¿™å•ä¸èƒ½è¿è¾“ã€‚äº‹å®è¯æ˜ï¼Œä¸­åº¸æ‰æ˜¯ç‹é“ï¼Œæˆ‘ä¹‹å‰çš„ä¸¤ä¸ªåšæ³•åˆ†åˆ«åœ¨æ—¶é—´å’Œç©ºé—´ä¸Šè¿‡äºæç«¯ï¼ˆå½“ç„¶é¢˜ç›®é™çš„å¤ªç‹ ä¹Ÿæ˜¯ä¸€ä¸ªå› ç´ \nåæ€äº†ä¸€ä¸‹ï¼Œæœ€å¼€å§‹å»ºç«‹çš„é‚£ä¸ªæŸ¥è¯¢ç´¢å¼•ä¼šè®©ç´¢å¼•é‡å¢é•¿åˆ°ï¼Œsetå’Œmapå†…éƒ¨çš„æ•°æ®ç»“æ„éƒ½æ˜¯çº¢é»‘æ ‘ï¼ŒæŸ¥æ‰¾æ•ˆç‡åœ¨ï¼Œé‚£ä¹ˆä¼šè®©æ—¶é—´å¢é•¿ä¸€å€ï¼Œè¿™ç¡®å®æ˜¯ä¸€ç¬”ä¸å°çš„å¼€é”€ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;bitset&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    map&lt;int, vector&lt;int&gt;&gt; incap;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        incap[a].push_back(b), incap[b].push_back(a);\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d\", &amp;n);\n        bitset&lt;size_t(1e5)&gt; tmp;\n        bool ans = true;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            scanf(\"%d\", &amp;a);\n            if (!ans) continue;\n            if (tmp[a]) ans = false;\n            for (auto &amp;k: incap[a]) tmp[k] = true;\n        }\n        printf(ans ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n","slug":"ã€1149ã€Dangerous-Goods-Packaging","date":"2022-11-28T10:26:29.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,bitset","author_index":"Starlit Rover"},{"id":"00adf0accb1aad7e13f310feb201ca0a","title":"ã€Œ1148ã€Werewolf - Simple Version","content":"Werewolfï¼ˆç‹¼äººæ€ï¼‰ is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game,\n\nplayer #1 said: â€œPlayer #2 is a werewolf.â€;\nplayer #2 said: â€œPlayer #3 is a human.â€;\nplayer #3 said: â€œPlayer #4 is a werewolf.â€;\nplayer #4 said: â€œPlayer #5 is a human.â€; and\nplayer #5 said: â€œPlayer #4 is a human.â€.\n\nGiven that there were 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. Can you point out the werewolves?\nNow you are asked to solve a harder version of this problem: given that there wereÂ NÂ players, with 2 werewolves among them, at least one but not all the werewolves were lying, and there were exactly 2 liars. You are supposed to point out the werewolves.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ . ThenÂ NÂ lines follow and theÂ i-th line gives the statement of theÂ i-th player , which is represented by the index of the player with a positive sign for a human and a negative sign for a werewolf.\nOutput Specification:If a solution exists, print in a line in ascending order the indices of the two werewolves. The numbers must be separated by exactly one space with no extra spaces at the beginning or the end of the line. If there are more than one solution, you must output the smallest solution sequence â€“ that is, for two sequencesÂ Â andÂ , if there existsÂ 0â‰¤k&lt;MÂ such thatÂ  andÂ , thenÂ AÂ is said to be smaller thanÂ B. In case there is no solution, simply printÂ No Solution.\nSample Input 1:5\n-2\n+3\n-4\n+5\n+4\n\nSample Output 1:1 4\n\nSample Input 2:6\n+6\n+3\n+1\n-5\n-2\n+4\n\nSample Output 2 (the solution is not unique):1 5\n\nSample Input 3:5\n-2\n-3\n-4\n-5\n-1\n\nSample Output 3:No Solution\n\n\nÎ©åšäº†å¥½ä¹…ï¼Œæœ€è¿‘è„‘å­éå¸¸æ··ä¹±ï¼Œæ„Ÿè§‰çŠ¶æ€è¶Šåšè¶Šå·®ï¼Œå¯èƒ½ç¡çœ è´¨é‡ä¸ä½³ã€‚\nç‹¼äººæ€æ¨¡æ‹Ÿï¼Œä¸ªç©å®¶åˆ†åˆ«ä½œå‡ºè°æ˜¯ç‹¼äºº/å¹³æ°‘çš„é™ˆè¿°ï¼Œå·²çŸ¥å…¶ä¸­æœ‰ä¸¤ä¸ªç‹¼äººï¼Œä¸”æœ‰ä¸€ä¸ªç‹¼äººå’Œä¸€ä¸ªå¹³æ°‘è¯´è°ï¼Œè¯·åˆ¤æ–­è°æ˜¯ç‹¼äººã€‚\n20åˆ†ä¸€çœ‹å°±æ˜¯æšä¸¾é¢˜ï¼Œç»“æœæˆ‘ä¸€å¼€å§‹ç«Ÿç„¶åœ¨æšä¸¾è°è¯´è°ï¼Œæšäº†åŠå¤©å·®ç‚¹ç–¯äº†ã€‚å› ä¸ºå°±ç®—ç¡®å®šäº†å“ªä¸¤ä¸ªäººè¯´è°ä¹Ÿä¸ä¸€å®šèƒ½æ¨æ–­å‡ºç‹¼äººæ˜¯è°ï¼Œæœ‰äº›äººçš„é™ˆè¿°å¯èƒ½ä¼šé’ˆå¯¹åŒä¸€ä¸ªäººï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€éƒ¨åˆ†äººä¼šæ²¡æœ‰ä»»ä½•èº«ä»½ä¿¡æ¯ã€‚äº‹å®è¯æ˜ï¼Œä¸è¦æŠŠ20åˆ†çš„é—®é¢˜æƒ³çš„å¤ªå¤æ‚ï¼Œæ±‚å•¥æšå•¥ï¼Œç›´æ¥æšä¸¾ä¸¤ä¸ªç‹¼äººï¼Œç„¶åè®¡æ•°æœ‰å‡ ä¸ªé”™çš„é™ˆè¿°ï¼Œæ¥ç€åˆ¤æ–­æ˜¯å¦ä¸¤äººæ’’è°ï¼Œæ˜¯ä¸æ˜¯ä¸€ä¸ªç‹¼äººä¸€ä¸ªå¹³æ°‘ã€‚\nå¯¹äºæ˜¯å¦æ’’è°æˆ‘ä»¬å¯ä»¥é€šè¿‡ã€æ˜¯å¦ä¸ºç‹¼äººã€‘ä¸ã€æ¨æµ‹æ˜¯ç‹¼äººã€‘çš„å¼‚æˆ–è¿ç®—å¾—å‡ºï¼Œä¸€ç‹¼ä¸€å¹³æ°‘çš„åˆ¤æ–­ä¹Ÿå¯ä»¥é€šè¿‡å¼‚æˆ–è¿›è¡Œåˆ¤æ–­ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define isWolf(x) (abs(x)==i||abs(x)==j)\n\nusing namespace std;\n\nint main()\n{\n    int n, r = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; st(n), liar;\n    for (auto &amp;s: st) cin &gt;&gt; s;\n    for (int i = 1; i &lt; n; ++i)\n        for (int j = i + 1; j &lt;= n; ++j, r = 0, liar.clear())\n        {\n            for (int k = 0; k &lt; n; ++k)\n                if (isWolf(st[k]) ^ (st[k] &lt; 0))\n                    liar.push_back(k + 1);\n            if (liar.size() == 2 &amp;&amp; (isWolf(liar[0]) ^ isWolf(liar[1])))\n            {\n                printf(\"%d %d\\n\", i, j);\n                return 0;\n            }\n        }\n    printf(\"No Solution\\n\");\n}\n","slug":"ã€Œ1148ã€Werewolf-Simple-Version","date":"2022-11-28T08:38:29.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"26c8e58b47c0447a364ca71b586839ff","title":"ã€Œ1147ã€Heaps","content":"In computer science, aÂ heapÂ is a specialized tree-based data structure that satisfies the heap property: if P is a parent node of C, then the key (the value) of P is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the key of C. A common implementation of a heap is the binary heap, in which the tree is a complete binary tree. (Quoted from Wikipedia at https://en.wikipedia.org/wiki/Heap_(data_structure))\nYour job is to tell if a given complete binary tree is a heap.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (â‰¤Â 100), the number of trees to be tested; and N (1Â &lt;Â NÂ â‰¤Â 1,000), the number of keys in each tree, respectively. Then M lines follow, each contains N distinct integer keys (all in the range ofÂ int), which gives the level order traversal sequence of a complete binary tree.\nOutput Specification:For each given tree, print in a lineÂ Max HeapÂ if it is a max heap, orÂ Min HeapÂ for a min heap, orÂ Not HeapÂ if it is not a heap at all. Then in the next line print the treeâ€™s postorder traversal sequence. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line.\nSample Input:3 8\n98 72 86 60 65 12 23 50\n8 38 25 58 52 82 70 60\n10 28 15 12 34 9 8 56\n\nSample Output:Max Heap\n50 60 65 72 12 23 86 98\nMin Heap\n60 58 52 38 82 70 25 8\nNot Heap\n56 12 34 28 9 8 15 10\n\n\nÎ©æ ¹æ®ä¸€æ£µå®Œå…¨äºŒå‰æ ‘çš„å±‚æ¬¡éå†åˆ¤æ–­æ˜¯æœ€å¤§å †è¿˜æ˜¯æœ€å°å †ï¼Œæœ€åè¾“å‡ºè¯¥æ ‘çš„ååºéå†ã€‚\né‚£ä¹ˆå°±å°†æ¯ä¸ªèŠ‚ç‚¹ä¸å…¶æ ¹èŠ‚ç‚¹è¿›è¡Œå¤§å°æ¯”è¾ƒï¼Œç”¨ä¸€ä¸ªintçš„ä½ä¸¤ä½ï¼ˆbitï¼‰æ ‡è®°å’Œï¼Œæœ€åå¦‚æœä½ä¸¤ä½éƒ½è¢«æ ‡è®°äº†å°±è¯´æ˜ä¸æ˜¯å †ï¼Œæœ€ä½ä½è¢«æ ‡è®°å°±æ˜¯æœ€å°å †ï¼Œæ¬¡ä½ä½è¢«æ ‡è®°å°±æ˜¯æœ€å¤§å †ï¼Œæœ€åé€’å½’è¾“å‡ºååºéå†å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define sign(x, y) (x==y?0:x&gt;y?2:1)\n\nusing namespace std;\nvector&lt;int&gt; level;\n\nvoid printPost(int n)\n{\n    if (n &gt;= level.size()) return;\n    printPost(2 * n + 1);\n    printPost(2 * n + 2);\n    printf(\"%d%s\", level[n], n == 0 ? \"\\n\" : \" \");\n}\n\nint main()\n{\n    int m, n, jdg = 0;\n    cin &gt;&gt; m &gt;&gt; n;\n    level.resize(n);\n    bool flag = false;\n    for (int i = 0; i &lt; m; ++i, flag = false, jdg = 0)\n    {\n        cin &gt;&gt; level[0];\n        for (int j = 1; j &lt; n; ++j, flag = !flag)\n        {\n            cin &gt;&gt; level[j];\n            jdg |= sign(level[j / 2 - flag], level[j]);\n        }\n        printf(jdg == 3 ? \"Not Heap\\n\" : jdg == 2 ? \"Max Heap\\n\" : \"Min Heap\\n\");\n        printPost(0);\n    }\n}\n","slug":"ã€Œ1147ã€Heaps","date":"2022-11-28T03:50:32.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,heap","author_index":"Starlit Rover"},{"id":"58b13f5d3514e42a82f269de71ed64e3","title":"ã€1146ã€Topological Order","content":"This is a problem given in the Graduate Entrance Exam in 2018: Which of the following is NOT a topological order obtained from the given directed graph? Now you are supposed to write a program to test each of the options.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (â‰¤Â 1,000), the number of vertices in the graph, and M (â‰¤Â 10,000), the number of directed edges. Then M lines follow, each gives the start and the end vertices of an edge. The vertices are numbered from 1 to N. After the graph, there is another positive integer K (â‰¤Â 100). Then K lines of query follow, each gives a permutation of all the vertices. All the numbers in a line are separated by a space.\nOutput Specification:Print in a line all the indices of queries which correspond to â€œNOT a topological orderâ€. The indices start from zero. All the numbers are separated by a space, and there must no extra space at the beginning or the end of the line. It is graranteed that there is at least one answer.\nSample Input:6 8\n1 2\n1 3\n5 2\n5 4\n2 3\n2 6\n3 4\n6 4\n6\n5 2 3 6 4 1\n1 5 2 3 6 4\n5 1 2 6 3 4\n5 1 2 3 6 4\n5 2 1 6 3 4\n1 2 3 4 5 6\n\nSample Output:0 4 5\n\n\nÎ©ç»™å®šæœ‰å‘å›¾ï¼Œåˆ¤æ–­å‡ ä¸ªé¡¶ç‚¹å…¨æ’åˆ—æ˜¯å¦æ»¡è¶³æ‹“æ‰‘æ’åºï¼Œè¾“å‡ºä¸æ˜¯æ‹“æ‰‘æ’åºçš„åºåˆ—ç¼–å·ã€‚\nå¦‚æœæŠŠæ¯ä¸ªé¡¶ç‚¹çœ‹ä½œä»»åŠ¡ï¼Œæ¯æ¡æœ‰å‘è¾¹è¡¨ç¤ºå¼€å§‹ä»»åŠ¡Bä¹‹å‰éœ€è¦å…ˆå®ŒæˆAä»»åŠ¡ï¼Œé‚£ä¹ˆå¦‚æœä¸€ç»„é¡¶ç‚¹çš„å…¨æ’åˆ—æ»¡è¶³æ‰€æœ‰ä»»åŠ¡å¯ä»¥æŒ‰ç…§é¡ºåºåšå®Œï¼Œå°±ç§°å…¶ä¸ºè¯¥å›¾çš„æ‹“æ‰‘æ’åºã€‚é‚£ä¹ˆæˆ‘ä»¬åªè¦æŒ‰é¡ºåºæ£€æŸ¥æ¯ä¸ªé¡¶ç‚¹çš„å…¥è¾¹èµ·ç‚¹æ˜¯å¦éƒ½å·²ç»å®Œæˆå³å¯ã€‚\nè¿™ç§æ£€æŸ¥é¢˜éƒ½æ²¡å•¥éš¾åº¦ï¼Œå¯¹æ¯ä¸ªå…¨æ’åˆ—ï¼Œæ ‡è®°å·²ç»å‡ºç°çš„èŠ‚ç‚¹ï¼Œç„¶ååˆ¤æ–­å½“å‰èŠ‚ç‚¹æ‰€æœ‰å…¥è¾¹çš„èµ·ç‚¹æ˜¯å¦è¢«æ ‡è®°ï¼Œè‹¥å­˜åœ¨å…¥è¾¹èµ·ç‚¹æœªè¢«æ ‡è®°è¯´æ˜ä¸æ»¡è¶³æ‹“æ‰‘æ’åºã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt; edge(n + 1);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[b].push_back(a);\n    }\n    cin &gt;&gt; m;\n    vector&lt;int&gt; ans;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        bool isTPG = true;\n        vector&lt;bool&gt; flag(n + 1, false);\n        for (int j = 0; j &lt; n; ++j)\n        {\n            cin &gt;&gt; a, flag[a] = true;\n            if (!isTPG) continue;\n            for (auto &amp;k: edge[a])\n                if (!flag[k])\n                {\n                    isTPG = false;\n                    break;\n                }\n        }\n        if (!isTPG) ans.push_back(i);\n    }\n    cout &lt;&lt; ans[0];\n    for (int i = 1; i &lt; ans.size(); ++i)\n        cout &lt;&lt; \" \" &lt;&lt; ans[i];\n}\n","slug":"ã€1146ã€Topological-Order","date":"2022-11-27T15:31:10.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,æ‹“æ‰‘æ’åº","author_index":"Starlit Rover"},{"id":"83b3a4468e6241cb8f0d55c9d71c268b","title":"ã€1145ã€Hashing - Average Search Time","content":"The task of this problem is simple: insert a sequence of distinct positive integers into a hash table first. Then try to find another sequence of integer keys from the table and output the average search time (the number of comparisons made to find whether or not the key is in the table). The hash function is defined to beÂ Â whereÂ TSizeÂ is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.\nNote that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 3 positive numbers: MSize, N, and M, which are the user-defined table size, the number of input numbers, and the number of keys to be found, respectively. All the three numbers are no more thanÂ . Then N distinct positive integers are given in the next line, followed by M positive integer keys in the next line. All the numbers in a line are separated by a space and are no more thanÂ .\nOutput Specification:For each test case, in case it is impossible to insert some number, print in a lineÂ X cannot be inserted.Â whereÂ XÂ is the input number. Finally print in a line the average search time for all the M keys, accurate up to 1 decimal place.\nSample Input:4 5 4\n10 6 4 15 11\n11 4 15 2\n\nSample Output:15 cannot be inserted.\n2.8\n\n\nÎ©æ•‘å‘½ï¼Œå“ˆå¸Œé¢˜å¥½éš¾å•Šã€‚ç»™å‡ºè¡¨å¤§å°ï¼ˆå¦‚æœä¸ä¸ºç´ æ•°éœ€è¦æ‰¾åˆ°çš„æœ€å°ç´ æ•°ï¼‰ï¼Œä¸ªå¾…æ’å…¥çš„æ•°ï¼Œä¸ªéœ€è¦æŸ¥è¯¢çš„æ•°ã€‚å¯¹ä¸èƒ½æ’å…¥çš„æ•°è¿›è¡Œè¾“å‡ºï¼Œæœ€åè¾“å‡ºå¹³å‡æœç´¢æ—¶é—´ã€‚\nå¦‚æœæ’å…¥æ—¶å­˜åœ¨å†²çªé‡‡å–äºŒæ¬¡æ¢æµ‹æ³•ï¼Œè¯¦è§ä¸Šä¸€é“hashé¢˜ã€Œ1078ã€Hashingã€‚å¯¹äºæ— æ³•æ’å…¥çš„é”®å€¼æœ€å¤šåªéœ€æ¬¡ï¼Œå…³é”®æ˜¯å¹³å‡æœç´¢æ—¶é—´çš„è®¡ç®—ã€‚\næ¯ä¸€æ¬¡é”®å€¼çš„æ¯”è¾ƒéƒ½ç®—æ˜¯ä¸€ä¸ªå•ä½çš„æœç´¢æ—¶é—´ï¼Œä½†é—®é¢˜æ˜¯ä¸å­˜åœ¨é”®å€¼çš„æœç´¢æ—¶é—´æ˜¯å¦æ˜¯ä¸€ä¸ªå›ºå®šæ—¶é—´ï¼Œç­”æ¡ˆæ˜¯å¦å®šçš„ã€‚å› ä¸ºä¸å­˜åœ¨çš„é”®å€¼æœ‰ä¸¤ç§æƒ…å†µï¼š1. æœªæ›¾å°è¯•æ’å…¥è¿‡ï¼Œ2. å°è¯•æ’å…¥è¿‡ä½†å¤±è´¥äº†ã€‚å¯¹äºcase 2ï¼Œä½ éœ€è¦æ¬¡æœç´¢ï¼ˆæœ€åä¸€æ¬¡å‘ç°å›åˆ°èµ·ç‚¹ä¹Ÿç®—ï¼Œè™½ç„¶æˆ‘è§‰çš„æ²¡ä»€ä¹ˆå¿…è¦ï¼‰ï¼›è€Œå¯¹äºcase 1ï¼Œåœ¨ä½ é‡‡å–äºŒæ¬¡æ¢æµ‹æ³•æŸ¥æ‰¾é”®å€¼æ—¶å¦‚æœå‘ç°æŸä¸ªä½ç½®ä¸ºç©ºï¼Œå°±è¯´æ˜å®ƒä¹‹å‰æ²¡æœ‰æ’å…¥è¿‡ï¼Œåº”è¯¥ç›´æ¥åœæ­¢æœç´¢ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    if (n == 1) return false;\n    if (n == 2) return true;\n    for (int i = 2; i &lt;= sqrt(n); i += (i == 2 ? 1 : 2))\n        if (n % i == 0) return false;\n    return true;\n}\n\nint main()\n{\n    int t, n, m, k, bias = -1, cnt = 0;\n    cin &gt;&gt; t &gt;&gt; n &gt;&gt; m;\n    while (!isPrime(t)) ++t;\n    vector&lt;int&gt; hash(t, 0);\n    for (int i = 0; i &lt; n; ++i, bias = -1)\n    {\n        cin &gt;&gt; k;\n        while (++bias &lt; t &amp;&amp; hash[(k + bias * bias) % t]);\n        if (bias == t) printf(\"%d cannot be inserted.\\n\", k);\n        else hash[(k + bias * bias) % t] = k;\n    }\n    for (int i = 0; i &lt; m; ++i, bias = -1)\n    {\n        cin &gt;&gt; k;\n        while (++cnt, ++bias &lt; t &amp;&amp; hash[(k + bias * bias) % t] != k &amp;&amp; hash[(k + bias * bias) % t] != 0);\n    }\n    printf(\"%.1f\", 1.0 * cnt / m);\n}\n","slug":"ã€1145ã€Hashing-Average-Search-Time","date":"2022-11-27T14:35:53.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,hash","author_index":"Starlit Rover"},{"id":"16253d2f98c7585dcb9c2bd2f1f7d451","title":"ã€Œ1144ã€The Missing Number","content":"Given N integers, you are supposed to find the smallest positive integer that is NOT in the given list.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer . Then N integers are given in the next line, separated by spaces. All the numbers are in the range ofÂ int.\nOutput Specification:Print in a line the smallest positive integer that is missing from the input list.\nSample Input:10\n5 -25 9 6 1 3 4 2 5 17\n\nSample Output:7\n\n\nÎ©ç»™å‡ºä¸€ä¸ªæ•´æ•°åºåˆ—ï¼Œè¾“å‡ºåºåˆ—ä¸­ä¸å­˜åœ¨çš„æœ€å°æ­£æ•´æ•°ã€‚\næ³¨æ„åˆ°æœ€å¤§ä¹Ÿæ‰ï¼Œå› æ­¤ç­”æ¡ˆä¸€å®šåœ¨ï½ä¸­ã€‚æˆ‘ä»¬å¼€ä¸€ä¸ªå¤§å°ï¼ˆæœ€åä¸€ä¸ªç´¢å¼•æ˜¯ï¼‰çš„boolæ•°ç»„ï¼Œå¹¶åˆå§‹åŒ–ç´¢å¼•æŒ‡é’ˆä¸º1ã€‚æ¯æ¬¡è¯»å…¥ä¸€ä¸ªæ•°ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªçš„ã€æ­£ã€‘æ•´æ•°ï¼Œé‚£ä¹ˆå°†å…¶ç´¢å¼•çš„boolå€¼ç½®trueï¼ŒåŒæ—¶å¾€åç§»åŠ¨ï¼ˆä¹Ÿå¯èƒ½ä¸ç§»åŠ¨ï¼‰ç´¢å¼•æŒ‡é’ˆåˆ°ç¬¬ä¸€ä¸ªå€¼ä¸ºfalseçš„ç´¢å¼•ã€‚æœ€åç›´æ¥è¾“å‡ºç´¢å¼•æŒ‡é’ˆã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, ans = 1;\n    scanf(\"%d\", &amp;n);\n    vector&lt;bool&gt; pos(1e5 + 2, false);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        if (k &lt;= 1e5 &amp;&amp; k &gt; 0) pos[k] = true;\n        while (pos[ans]) ++ans;\n    }\n    printf(\"%d\", ans);\n}\n","slug":"ã€Œ1144ã€The-Missing-Number","date":"2022-11-27T12:33:03.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"f27d92d50d5edef0b562aa3325cde9aa","title":"ã€1143ã€Lowest Common Ancestor","content":"The lowest common ancestor (LCA) of two nodes U and V in a tree is the deepest node that has both U and V as descendants.\nA binary search tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the nodeâ€™s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.\nBoth the left and right subtrees must also be binary search trees.\n\nGiven any two nodes in a BST, you are supposed to find their LCA.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers: M (â‰¤Â 1,000), the number of pairs of nodes to be tested; and N (â‰¤Â 10,000), the number of keys in the BST, respectively. In the second line, N distinct integers are given as the preorder traversal sequence of the BST. Then M lines follow, each contains a pair of integer keys U and V. All the keys are in the range ofÂ int.\nOutput Specification:For each given pair of U and V, print in a lineÂ LCA of U and V is A.Â if the LCA is found andÂ AÂ is the key. But ifÂ AÂ is one of U and V, printÂ X is an ancestor of Y.Â whereÂ XÂ isÂ AÂ andÂ YÂ is the other node. If U or V is not found in the BST, print in a lineÂ ERROR: U is not found.Â orÂ ERROR: V is not found.Â orÂ ERROR: U and V are not found..\nSample Input:6 8\n6 3 1 2 5 4 8 7\n2 5\n8 7\n1 9\n12 -3\n0 8\n99 99\n\nSample Output:LCA of 2 and 5 is 3.\n8 is an ancestor of 7.\nERROR: 9 is not found.\nERROR: 12 and -3 are not found.\nERROR: 0 is not found.\nERROR: 99 and 99 are not found.\n\n\nÎ©ç»™å‡ºä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„å…ˆåºéå†ï¼Œè¾“å‡ºä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€ä½ç¥–å®—èŠ‚ç‚¹ï¼Œå¦‚æœæ ‘ä¸­ä¸å­˜åœ¨èŠ‚ç‚¹ï¼Œå°±è¾“å‡ºç›¸åº”çš„æŠ¥é”™ä¿¡æ¯ã€‚\nè¢«è‡ªå·±è ¢å“­äº†ï¼Œæœ€è¿‘é¢˜ç›®åˆ·å¤šåè€Œåˆ·å‚»äº†ã€‚ä¸€çœ‹åˆ°å…ˆåºéå†å’ŒäºŒå‰æœç´¢æ ‘ï¼Œå°±æ€¥ç€è¦æ„å»ºå‡ºæ•´æ£µæ ‘æ¥ï¼Œè€Œä¸”åœ¨æ„å»ºè¿‡ç¨‹ä¸­è®°å½•äº†æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ã€‚è¯»å…¥éœ€è¦æŸ¥æ‰¾çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœæ ‘ä¸­å­˜åœ¨è¿™ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå°±å…ˆè®©æ·±åº¦æ›´å¤§çš„èŠ‚ç‚¹å¾€ä¸Šå›æº¯çˆ¶èŠ‚ç‚¹ç›´åˆ°ä¸å¦ä¸€ä¸ªèŠ‚ç‚¹æ·±åº¦ç›¸åŒï¼Œå¦‚æœå…¶çˆ¶èŠ‚ç‚¹å°±æ˜¯å¦ä¸€ä¸ªèŠ‚ç‚¹åˆ™è¾“å‡ºâ€œX is an ancestor of Y.â€ï¼Œå¦åˆ™ä¸€èµ·å¾€ä¸Šå›æº¯ç›´åˆ°ä¸¤è€…çˆ¶èŠ‚ç‚¹ç›¸åŒã€‚\nå…¶å®æäº¤å‰è‡ªæˆ‘æ„Ÿè§‰è‰¯å¥½ï¼Œè§‰å¾—èƒ½ä¸€éè¿‡ï¼Œç»“æœæœ€åä¸¤ä¸ªæµ‹è¯•ç‚¹è¶…æ—¶äº†ã€‚æˆ‘å°±è½»è½¦ç†Ÿè·¯åœ°æŠŠæ‰€æœ‰cinã€coutæ¢æˆscanfã€printfï¼Œè¿™æ¬¡ç«Ÿç„¶æ²¡ç”¨ï¼Œäºæ˜¯æˆ‘åˆæŠŠmapæ¢æˆäº†unordered_mapï¼Œi.e. å“ˆå¸Œè¡¨ï¼Œç»“æœæœ€åä¸€ä¸ªæµ‹è¯•ç‚¹è¿˜æ˜¯è¶…æ—¶ã€‚æˆ‘æ·±æ„Ÿä¸å¦™ï¼Œåˆ°è¿™ä¸€æ­¥å°±å·²ç»è¯´æ˜æ˜¯æˆ‘çš„ç®—æ³•å‡ºäº†é—®é¢˜ã€‚æˆ‘å¯»æ€ç€ï¼Œéš¾åˆ°è¿˜æœ‰ä»€ä¹ˆå¥‡æŠ€æ·«å·§å—ã€‚ã€‚ã€‚\nè¿™æ—¶å€™å°±éœ€è¦å›å½’æœ¬è´¨äº†ï¼Œæœ€ä½ç¥–å®—èŠ‚ç‚¹å…¶å®æ˜¯ä¸¤ä¸ªèŠ‚ç‚¹åˆ†æµçš„åœ°æ–¹ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆä¼šåˆ†æµå‘¢ï¼Ÿå› ä¸ºä¸¤ä¸ªèŠ‚ç‚¹ä¸æœ€ä½ç¥–å®—èŠ‚ç‚¹çš„å¤§å°å…³ç³»ä¸åŒã€‚bingoï¼Œæ³¨æ„åˆ°å…ˆåºéå†çš„ç‰¹å¾æ˜¯æ ¹èŠ‚ç‚¹åœ¨æ‰€æœ‰å­èŠ‚ç‚¹å‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦é¡ºåºéå†å…ˆåºéå†åºåˆ—ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä½¿å¾—ï¼Œå…¶ä¸­æ˜¯éœ€è¦æŸ¥æ‰¾çš„ä¸¤ä¸ªèŠ‚ç‚¹ã€‚è¿™é‡Œä¹‹æ‰€ä»¥ä¸¤è¾¹éƒ½è¦åŠ ä¸Šã€=ã€‘æ˜¯å› ä¸ºæœ‰å¯èƒ½å°±æ˜¯ã€‚é‚£ä¸ºä»€ä¹ˆç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å°±æ˜¯ç­”æ¡ˆå‘¢ï¼Ÿå› ä¸ºå½“ä½ æŠŠä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å»æ‰åå°±ä¼šå‘ç°å‰©ä½™èŠ‚ç‚¹ä¸çš„å¤§å°å…³ç³»éƒ½æ˜¯ä¸€è‡´çš„ï¼Œè€Œå…ˆåºéå†ä¸­å‰é¢çš„èŠ‚ç‚¹ä¸€å®šæ¥è‡ªäºè¿™äº›å‰©ä½™èŠ‚ç‚¹ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, a, b, u, v, ans;\n    cin &gt;&gt; m &gt;&gt; n;\n    vector&lt;int&gt; pre(n);\n    map&lt;int, bool&gt; flag;\n    for (auto &amp;k: pre)\n        cin &gt;&gt; k, flag[k] = true;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        bool skip = true;\n        switch ((flag[a] &lt;&lt; 1) + flag[b])\n        {\n            case 2: printf(\"ERROR: %d is not found.\\n\", b); break;\n            case 1: printf(\"ERROR: %d is not found.\\n\", a); break;\n            case 0: printf(\"ERROR: %d and %d are not found.\\n\", a, b); break;\n            default: skip = false;\n        }\n        if (skip) continue;\n        u = min(a, b), v = max(a, b);\n        for (auto &amp;k: pre)\n            if (k &gt;= u &amp;&amp; k &lt;= v)\n            {\n                ans = k;\n                break;\n            }\n        (ans == v || ans == u) ? printf(\"%d is an ancestor of %d.\\n\", ans == v ? v : u, ans == v ? u : v)\n                               : printf(\"LCA of %d and %d is %d.\\n\", a, b, ans);\n    }\n}\n\nğŸğŸï¼ˆcase 5: Time Limit Exceededï¼‰#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre;\nunordered_map&lt;int, pair&lt;int, int&gt;&gt; dad;\n\nvoid build(int s, int e)\n{\n    int r = upper_bound(pre.begin() + s, pre.begin() + e, pre[s]) - pre.begin();\n    if (r &gt; s + 1)\n    {\n        dad[pre[s + 1]] = make_pair(pre[s], dad[pre[s]].second + 1);\n        build(s + 1, e);\n    }\n    if (r &lt; e)\n    {\n        dad[pre[r]] = make_pair(pre[s], dad[pre[s]].second + 1);\n        build(r, e);\n    }\n}\n\nint main()\n{\n    int m, n, a, b, u, v;\n    scanf(\"%d %d\", &amp;m, &amp;n);\n    pre.resize(n);\n    for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;pre[i]);\n    dad[pre[0]] = make_pair(pre[0], 0);\n    build(0, n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        bool fa = dad.find(a) == dad.end(), fb = dad.find(b) == dad.end(), flag = true;\n        switch ((fa &lt;&lt; 1) + fb)\n        {\n            case 1: printf(\"ERROR: %d is not found.\\n\", b); break;\n            case 2: printf(\"ERROR: %d is not found.\\n\", a); break;\n            case 3: printf(\"ERROR: %d and %d are not found.\\n\", a, b); break;\n            default: flag = false;\n        }\n        if (flag) continue;\n        u = (dad[a].second &gt; dad[b].second) ? a : b, v = (dad[a].second &gt; dad[b].second) ? b : a;\n        while (dad[u].second &gt; dad[v].second) u = dad[u].first;\n        if (u == v) printf(\"%d is an ancestor of %d.\\n\", v, v == a ? b : a);\n        else\n        {\n            while (u != v)\n                u = dad[u].first, v = dad[v].first;\n            printf(\"LCA of %d and %d is %d.\\n\", a, b, u);\n        }\n    }\n}\n","slug":"ã€1143ã€Lowest-Common-Ancestor","date":"2022-11-27T11:26:11.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search,traversal order,Tree","author_index":"Starlit Rover"},{"id":"fd7ce911047e09d73f8229b416cde491","title":"ã€Œ1142ã€Maximal Clique","content":"AÂ cliqueÂ is a subset of vertices of an undirected graph such that every two distinct vertices in the clique are adjacent. AÂ maximal cliqueÂ is a clique that cannot be extended by including one more adjacent vertex. (Quoted from https://en.wikipedia.org/wiki/Clique_(graph_theory))\nNow it is your job to judge if a given subset of vertices can form a maximal clique.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers Nv (â‰¤Â 200), the number of vertices in the graph, and Ne, the number of undirected edges. Then Ne lines follow, each gives a pair of vertices of an edge. The vertices are numbered from 1 to Nv.\nAfter the graph, there is another positive integer M (â‰¤Â 100). Then M lines of query follow, each first gives a positive number K (â‰¤Â Nv), then followed by a sequence of K distinct vertices. All the numbers in a line are separated by a space.\nOutput Specification:For each of the M queries, print in a lineÂ YesÂ if the given subset of vertices can form a maximal clique; or if it is a clique but not aÂ maximal clique, printÂ Not Maximal; or if it is not a clique at all, printÂ Not a Clique.\nSample Input:8 10\n5 6\n7 8\n6 4\n3 6\n4 5\n2 3\n8 2\n2 7\n5 3\n3 4\n6\n4 5 4 3 6\n3 2 8 7\n2 2 3\n1 1\n3 4 3 6\n3 3 2 1\n\nSample Output:Yes\nYes\nYes\nYes\nNot Maximal\nNot a Clique\n\n\nÎ©ç»™å‡ºä¸€ä¸ªæ— å‘å›¾ï¼Œåˆ¤æ–­å…¶ä¸­çš„é¡¶ç‚¹å­é›†æ˜¯å¦ä¸ºæœ€å¤§å®Œå…¨å›¾ï¼Œå®Œå…¨å›¾æŒ‡å†…éƒ¨ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´å‡æœ‰è¾¹ç›¸è¿ï¼Œè€Œæœ€å¤§åˆ™æŒ‡å›¾ä¸­å…¶ä½™ä»»æ„ç‚¹çš„åŠ å…¥éƒ½ä¸èƒ½å†æ„æˆä¸€ä¸ªæ›´å¤§çš„å®Œå…¨å›¾ã€‚\nå®Œå…¨å›¾åªè¦éå†æ‰€æœ‰é¡¶ç‚¹å¯¹æ£€æŸ¥æ˜¯å¦æœ‰è¾¹å³å¯ï¼Œè€Œæœ€å¤§åˆ™æ£€æŸ¥å‰©ä½™å›¾ä¸­æ˜¯å¦å­˜åœ¨ä¸å­é›†ä¸­æ‰€æœ‰é¡¶ç‚¹å‡æœ‰è¾¹çš„é¡¶ç‚¹ï¼Œè‹¥å­˜åœ¨è¯´æ˜ä¸æ˜¯æœ€å¤§ã€‚\nè¿™ç§é¢˜ç”¨bitsetå°±å¾ˆçˆ½ï¼Œæ³¨æ„åˆ°é¡¶ç‚¹æ•°ä¸è¶…è¿‡200ä¸ªï¼Œå› æ­¤æˆ‘ä»¬ç»™æ¯ä¸€ä¸ªé¡¶ç‚¹éƒ½å¼€ä¸€ä¸ªbitset&lt;201&gt;ï¼Œç¬¬ä½ä¸º1ä»£è¡¨ä¸ç¬¬ä¸ªé¡¶ç‚¹ä¹‹é—´æœ‰è¾¹ç›¸è¿ï¼Œé‚£ä¹ˆ201ä½å°±èƒ½ä»£è¡¨ä¸€ä¸ªé¡¶ç‚¹çš„è¿è¾¹æƒ…å†µã€‚åœ¨è¯»å…¥ä¸€ä¸ªé¡¶ç‚¹å­é›†çš„è¿‡ç¨‹ä¸­ï¼Œæ¯è¯»å…¥ä¸€ä¸ªé¡¶ç‚¹ï¼Œå°±å°†å…¶è¿è¾¹æƒ…å†µä¸ä¹‹å‰è¯»å…¥çš„é¡¶ç‚¹ï¼ˆä¹Ÿç”¨bitset&lt;201&gt;è¡¨ç¤ºï¼‰è¿›è¡Œå¹¶è¿ç®—ï¼Œå¦‚æœç»“æœä¸ä¹‹å‰è¯»å…¥çš„é¡¶ç‚¹ä¸€è‡´å°±ä»£è¡¨è¯¥é¡¶ç‚¹ä¸å‰é¢æ‰€æœ‰é¡¶ç‚¹ä¹‹é—´å‡æœ‰è¾¹ç›¸è¿ï¼Œå¦åˆ™è¯´æ˜ä¸æ˜¯å®Œå…¨å›¾ã€‚æœ€åå°†å‰©ä½™é¡¶ç‚¹çš„è¿è¾¹æƒ…å†µä¸è¯¥é¡¶ç‚¹é›†çš„é¡¶ç‚¹è¿›è¡Œå¹¶è¿ç®—ï¼Œå¦‚æœç»“æœç­‰äºé¡¶ç‚¹é›†ä¸­çš„é¡¶ç‚¹å°±è¯´æ˜ä¸æ˜¯æœ€å¤§çš„cliqueã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int v, e, a, b;\n    cin &gt;&gt; v &gt;&gt; e;\n    bitset&lt;201&gt; edge[v + 1];\n    for (int i = 0; i &lt; e; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a][b] = edge[b][a] = true;\n    }\n    int n, m;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        bool ans = true;\n        vector&lt;bool&gt; flag(v + 1, false);\n        bitset&lt;201&gt; r(0);\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; a;\n            if (!ans) continue;\n            if ((edge[a] &amp; r) != r) ans = false;\n            r[a] = true, flag[a] = true;\n        }\n        if (!ans) printf(\"Not a Clique\\n\");\n        else\n        {\n            for (int j = 1; j &lt;= v; ++j)\n            {\n                if (flag[j]) continue;\n                if ((edge[j] &amp; r) == r)\n                {\n                    ans = false;\n                    break;\n                }\n            }\n            printf(ans ? \"Yes\\n\" : \"Not Maximal\\n\");\n        }\n    }\n}\n","slug":"ã€Œ1142ã€Maximal-Clique","date":"2022-11-27T07:38:11.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph","author_index":"Starlit Rover"},{"id":"324ab5351ee7cff7d5b7ed1cb7ec626b","title":"ã€1141ã€PAT Ranking of Institutions","content":"After each PAT, the PAT Center will announce the ranking of institutions based on their studentsâ€™ performances. Now you are asked to generate the ranklist.\n\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤105), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format:\nID Score School\n\nwhereÂ IDÂ is a string of 6 characters with the first one representing the test level:Â BÂ stands for the basic level,Â AÂ the advanced level andÂ TÂ the top level;Â ScoreÂ is an integer in [0, 100]; andÂ SchoolÂ is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed thatÂ IDÂ is unique for each testee.\nOutput Specification:For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format:\nRank School TWS Ns\n\nwhereÂ RankÂ is the rank (start from 1) of the institution;Â SchoolÂ is the institution code (all in lower case); ;Â TWSÂ is theÂ total weighted scoreÂ which is defined to be the integer part ofÂ ScoreB/1.5 + ScoreA + ScoreT*1.5, whereÂ ScoreXÂ is the total score of the testees belong to this institution on levelÂ X; andÂ NsÂ is the total number of testees who belong to this institution.\nThe institutions are ranked according to theirÂ TWS. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order ofÂ Ns. If there is still a tie, they shall be printed in alphabetical order of their codes.\nSample Input:10\nA57908 85 Au\nB57908 54 LanX\nA37487 60 au\nT28374 67 CMU\nT32486 24 hypu\nA66734 92 cmu\nB76378 71 AU\nA47780 45 lanx\nA72809 100 pku\nA03274 45 hypu\n\nSample Output:5\n1 cmu 192 2\n1 au 192 3\n3 pku 100 1\n4 hypu 81 2\n4 lanx 81 2\n\n\nÎ©ä¸ºPATçš„å›¢ä½“æˆç»©è¿›è¡Œæ’åºï¼Œç»™å‡ºæ¯ä¸ªè€ƒç”Ÿçš„å‡†è€ƒè¯å·ã€æˆç»©ã€å­¦æ ¡ä»£å·ï¼Œæœ€ç»ˆå­¦æ ¡å›¢ä½“æˆç»©æŒ‰ç…§ï¼ŒABTä»£è¡¨ä¸‰ä¸ªä¸åŒçš„è€ƒè¯•ç­‰çº§ï¼Œè¡¨ç¤ºè¿™ä¸ªå­¦æ ¡å‚åŠ Xç­‰çº§è€ƒè¯•çš„è€ƒç”Ÿæˆç»©æ€»å’Œã€‚æœ€ç»ˆç»“æœæŒ‰å›¢ä½“æˆç»©é™åºæ’åˆ—ï¼Œå¹¶ç»™å‡ºç›¸åº”åæ¬¡ï¼Œå¦‚æœæ€»æˆç»©ç›¸åŒå°±æŒ‰ç…§å‚ä¸äººæ•°çš„å‡åºæ’åˆ—ï¼Œå¦‚æœäººæ•°ä¹Ÿä¸€è‡´å°±æŒ‰ç…§å­¦æ ¡ä»£ç å‡åºæ’åˆ—ã€‚\nå…ˆç”¨ä¸€ä¸ªmap&lt;string, tuple&lt;int, int, int, int&gt;&gt;å»ºç«‹å­¦æ ¡ä»£ç åˆ°BATè€ƒè¯•æˆç»©æ€»å’Œä»¥åŠè€ƒç”Ÿäººæ•°çš„æ˜ å°„ã€‚ç„¶åè®¡ç®—æ¯ä¸ªå­¦æ ¡çš„å›¢ä½“æˆç»©ï¼Œå¹¶å°†å­¦æ ¡ä»£ç ã€è€ƒç”Ÿäººæ•°ä¸€å¹¶å­˜å…¥vector&lt;tuple&lt;string, int, int&gt;&gt;ï¼Œç„¶åæ ¹æ®æ’åºè¦æ±‚ç»™å®šcmpå‡½æ•°è¿›è¡Œsortã€‚æœ€åä¾æ¬¡è¾“å‡ºç›¸å…³ä¿¡æ¯ã€‚å¦‚æœå›¢ä½“æˆç»©ä¸ä¸Šä¸€ä¸ªå­¦æ ¡ä¸€æ ·ï¼Œé‚£ä¹ˆåæ¬¡ä¸å˜ï¼Œå¦åˆ™=ä¸‹æ ‡+1ã€‚\n\nÎ©#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;string, int, int&gt; tsii;\n\nint main()\n{\n    string id, school;\n    int n, s, r = 0, p = -1;\n    cin &gt;&gt; n;\n    map&lt;string, tuple&lt;int, int, int, int&gt;&gt; score;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s &gt;&gt; school;\n        transform(school.begin(), school.end(), school.begin(), ::tolower);\n        switch (id[0])\n        {\n            case 'B':\n                get&lt;0&gt;(score[school]) += s;\n                break;\n            case 'A':\n                get&lt;1&gt;(score[school]) += s;\n                break;\n            case 'T':\n                get&lt;2&gt;(score[school]) += s;\n                break;\n        }\n        ++get&lt;3&gt;(score[school]);\n    }\n    vector&lt;tsii&gt; tws;\n    for (auto &amp;t: score)\n        tws.emplace_back(t.first, get&lt;0&gt;(t.second) / 1.5 + get&lt;1&gt;(t.second) + get&lt;2&gt;(t.second) * 1.5, get&lt;3&gt;(t.second));\n    sort(tws.begin(), tws.end(), [](tsii &amp;a, tsii &amp;b) {return get&lt;1&gt;(a) == get&lt;1&gt;(b) ?\n          make_pair(get&lt;2&gt;(a), get&lt;0&gt;(a)) &lt; make_pair(get&lt;2&gt;(b), get&lt;0&gt;(b)) : get&lt;1&gt;(a) &gt; get&lt;1&gt;(b);});\n    printf(\"%zu\\n\", tws.size());\n    for (int i = 0; i &lt; tws.size(); ++i)\n    {\n        r = (get&lt;1&gt;(tws[i]) == p) ? r : (p = get&lt;1&gt;(tws[i]), i + 1);\n        printf(\"%d %s %d %d\\n\", r, get&lt;0&gt;(tws[i]).c_str(), get&lt;1&gt;(tws[i]), get&lt;2&gt;(tws[i]));\n    }\n}\n","slug":"ã€1141ã€PAT-Ranking-of-Institutions","date":"2022-11-26T07:20:45.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,sort,tuple","author_index":"Starlit Rover"},{"id":"7df29c755cdde6fc07511e582be256da","title":"ã€Œ1140ã€Look-and-say Sequence","content":"Look-and-say sequence is a sequence of integers as the following:\nD, D1, D111, D113, D11231, D112213111, ...\n\nwhereÂ DÂ is in [0, 9] except 1. The (n+1)st number is a kind of description of the nth number. For example, the 2nd number means that there is oneÂ DÂ in the 1st number, and hence it isÂ D1; the 2nd number consists of oneÂ DÂ (corresponding toÂ D1) and one 1 (corresponding to 11), therefore the 3rd number isÂ D111; or since the 4th number isÂ D113, it consists of oneÂ D, two 1â€™s, and one 3, so the next number must beÂ D11231. This definition works forÂ DÂ = 1 as well. Now you are supposed to calculate the Nth number in a look-and-say sequence of a given digitÂ D.\n\n\n\n\nInput Specification:Each input file contains one test case, which givesÂ DÂ (in [0, 9]) and a positive integer N (â‰¤Â 40), separated by a space.\nOutput Specification:Print in a line the Nth number in a look-and-say sequence ofÂ D.\nSample Input:1 8\n\nSample Output:1123123111\n\n\nÎ©å­—ç¬¦ä¸²è¿­ä»£ï¼Œæ¯æ¬¡è¿­ä»£çš„è§„åˆ™ï¼Œæ˜¯å°†åŸå­—ç¬¦ä¸²ä¸­çš„è¿ç»­å­ä¸²â€œxxâ€¦xâ€æ›¿æ¢ä¸ºâ€œxnâ€ï¼Œnè¡¨ç¤ºæœ€é•¿è¿ç»­å­ä¸²ä¸­xçš„ä¸ªæ•°ã€‚é‚£ä¹ˆåªéœ€éå†å­—ç¬¦ä¸²ï¼Œè‹¥å½“å‰å­—ç¬¦ä¸å‰ä¸€ä¸ªå­—ç¬¦ä¸åŒï¼Œå°±æŠŠå‰ä¸€ä¸ªå­—ç¬¦ä¸cntåŠ åˆ°ç»“æœå­—ç¬¦ä¸²ä¸­ï¼ŒåŒæ—¶å°†è®¡æ•°å™¨cntå½’1ï¼Œè‹¥ç›¸åŒåˆ™++cntã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string ans, nxt;\n    int n, cnt = 1;\n    cin &gt;&gt; ans &gt;&gt; n;\n    for (int i = 1; i &lt; n; ++i, cnt = 1)\n    {\n        for (int j = 1; j &lt; ans.size(); ++j)\n        {\n            if (ans[j] != ans[j - 1])\n                nxt += string(1, ans[j - 1]) + to_string(cnt), cnt = 1;\n            else ++cnt;\n        }\n        nxt += string(1, ans.back()) + to_string(cnt);\n        ans = std::move(nxt), nxt = \"\";\n    }\n    cout &lt;&lt; ans;\n}\n","slug":"ã€Œ1140ã€Look-and-say-Sequence","date":"2022-11-26T05:03:10.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"8e874153b53000d75be72bb73b703255","title":"ã€Œ1139ã€First Contact","content":"Unlike in nowadays, the way that boys and girls expressing their feelings of love was quite subtle in the early years. When a boy A had a crush on a girl B, he would usually not contact her directly in the first place. Instead, he might ask another boy C, one of his close friends, to ask another girl D, who was a friend of both B and C, to send a message to B â€“ quite a long shot, isnâ€™t it? Girls would do analogously.\nHere given a network of friendship relations, you are supposed to help a boy or a girl to list all their friends who can possibly help them making the first contact.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (1Â &lt;Â NÂ â‰¤Â 300) and M, being the total number of people and the number of friendship relations, respectively. Then M lines follow, each gives a pair of friends. Here a person is represented by a 4-digit ID. To tell their genders, we use a negative sign to represent girls.\nAfter the relations, a positive integer K (â‰¤Â 100) is given, which is the number of queries. Then K lines of queries follow, each gives a pair of lovers, separated by a space. It is assumed that the first one is having a crush on the second one.\nOutput Specification:For each query, first print in a line the number of different pairs of friends they can find to help them, then in each line print the IDs of a pair of friends.\nIf the lovers A and B are of opposite genders, you must first print the friend of A who is of the same gender of A, then the friend of B, who is of the same gender of B. If they are of the same gender, then both friends must be in the same gender as theirs. It is guaranteed that each person has only one gender.\nThe friends must be printed in non-decreasing order of the first IDs, and for the same first ones, in increasing order of the seconds ones.\nSample Input:10 18\n-2001 1001\n-2002 -2001\n1004 1001\n-2004 -2001\n-2003 1005\n1005 -2001\n1001 -2003\n1002 1001\n1002 -2004\n-2004 1001\n1003 -2002\n-2003 1003\n1004 -2002\n-2001 -2003\n1001 1003\n1003 -2001\n1002 -2001\n-2002 -2003\n5\n1001 -2001\n-2003 1001\n1005 -2001\n-2002 -2004\n1111 -2003\n\nSample Output:4\n1002 2004\n1003 2002\n1003 2003\n1004 2002\n4\n2001 1002\n2001 1003\n2002 1003\n2002 1004\n0\n1\n2003 2001\n0\n\n\nÎ©åˆæ˜¯å•èº«ç‹—æ— æ³•ç†è§£çš„ä¸€é“é¢˜ç›®ï¼Œæˆ‘ç”±è¡·åœ°å¸Œæœ›ï¼Œå¤§å®¶èƒ½å¤Ÿç›´çƒåœ°é¢å¯¹è‡ªå·±çš„å¿ƒä¸Šäººï¼ŒçœŸè¯šæ‰æ˜¯å¿…æ€æŠ€ï¼Œè°¢è°¢ã€‚\nç´¯äº†ï¼Œç®€å•çš„å¤–è¡¨ä¸‹ï¼Œè—ç€ä¸€é¢—æœˆçƒçš„å¿ƒï¼Œä¸è¦é—®æˆ‘åœ¨å“ªï¼Œæœ‰å‘çš„åœ°æ–¹å°±æœ‰æˆ‘â€¦â€¦. ä»€ä¹ˆå«åšä¸€æ­¥ä¸€ä¸ªè„šå°ï¼Œå°±æ˜¯æ¯å½“ä½ æäº¤å‰è§‰å¾—è¦acçš„æ—¶å€™ï¼Œç»“æœåªå¤šçº¢äº†ä¸€ä¸ªæµ‹è¯•ç‚¹ï¼Œç”šè‡³æ¯«æ— å˜åŒ–ã€‚\nAå–œæ¬¢Bï¼Œæ€‚çš„1bï¼Œå¸Œæœ›é€šè¿‡å¥½åŸºå‹Cæ‰¾åˆ°Bçš„å¥½é—ºèœœDå»è¯•æ¢Bï¼ˆä½ è¿™ç§äººèƒ½è„±å•æ‰æ€ªå“¦ï¼‰âš ï¸ACï¼ŒBDå¿…é¡»åŒæ€§åˆ«ã€‚æƒ³æ³•éå¸¸ç®€å•ï¼Œç”¨setå­˜å‚¨æ¯ä¸ªäººçš„åŒæ€§æœ‹å‹ï¼Œç„¶åç”¨ä¸€ä¸ªmap&lt;int,bool&gt; r æ‰€æœ‰æœ‹å‹å¯¹ï¼Œæ¥è¡¨ç¤ºä¹‹é—´æ˜¯å¦ä¸ºæœ‹å‹ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±ç›´æ¥æšä¸¾Aå’ŒBçš„æ‰€æœ‰åŒæ€§æœ‹å‹ï¼Œç„¶åç”¨ræ¥åˆ¤æ–­æ˜¯å¦ä¸ºæœ‹å‹ã€‚ç”±äºsetä¼šè‡ªåŠ¨æŒ‰ç…§ç¼–å·å‡åºæ’åºï¼Œå› æ­¤æŒ‰ä¾æ¬¡éå†å¾—åˆ°çš„ç»“æœé¡ºåºå³ä¸ºé¢˜æ„è¦æ±‚ã€‚\næ€è·¯å°±æ˜¯è¿™ä¹ˆç®€å•ï¼Œæ¥ä¸‹æ¥æ˜¯ç¯å½¢å‘æšä¸¾é˜¶æ®µï¼š\n\nå››ä½ç¼–å·è¾“å…¥å¯èƒ½å­˜åœ¨â€œ0000â€å’Œâ€œ-0000â€ï¼Œå¦‚æœæ˜¯ç”¨intè¯»å–å°±æ— æ³•åŒºåˆ†æ€§åˆ«ï¼Œå› æ­¤éœ€è¦ç”¨å­—ç¬¦ä¸²è¯»å–ååˆ¤æ–­é•¿åº¦å¾—å‡ºæ€§åˆ«\n\nAå’ŒBå¯èƒ½æœ¬èº«å°±æ˜¯åŒæ€§æœ‹å‹ï¼ˆä¸ºè¿™é“é¢˜çš„æ ¼å±€ç‚¹èµï¼‰ï¼Œå› æ­¤æšä¸¾Açš„åŒæ€§æœ‹å‹æ—¶éœ€è¦è·³è¿‡B\n\nåŒæ ·çš„ï¼Œæšä¸¾Bçš„åŒæ€§æœ‹å‹æ—¶è·³è¿‡Aï¼ˆå¾ˆé‡è¦ï¼Œæœ‰æ—¶å€™æƒ³åˆ°2ä¹Ÿä¸è§å¾—ä¼šè®°å¾—3ï¼‰\n\nCå’ŒDä¸èƒ½æ˜¯åŒä¸€ä¸ªäººï¼Œä½†ä½ åªè¦æœ‰åˆ¤æ–­Cå’ŒDæ˜¯å¦æ˜¯æœ‹å‹å°±ä¸éœ€è¦å…³æ³¨è¿™ç‚¹\n\nå¦‚æœæ˜¯ä»¥intå­˜å‚¨ç¼–å·çš„ï¼Œæœ€åè¾“å‡ºåˆ«å¿˜è®°æ ¼å¼åŒ–%04d\n\n\nè¿™è¿˜ä¸æ˜¯æœ€å¼€å¿ƒçš„ï¼Œæœ€è®©äººæ¿€åŠ¨çš„æ˜¯å”¯ä¸€çš„æµ‹è¯•æ ·ä¾‹æ²¡æœ‰å‡ºç°ä¸Šé¢çš„ä»»ä½•ä¸€ä¸ªå‘: ) å¯è°“åŸ‹çš„ä¸€æ‰‹å¥½é›·ã€‚å¤–åŠ è¿™ç§é¢˜ç›®ä¸å¥½è‡ªå·±æ„é€ æµ‹è¯•æ ·ä¾‹ï¼Œæœ‰æ—¶åªèƒ½ç«™åœ¨å‡ºé¢˜äººçš„è§’åº¦å»æ‰¾æ´æ”»å‡»è‡ªå·±ä»£ç ã€‚é“é«˜ä¸€å°ºï¼Œé­”é«˜ä¸€ä¸ˆï¼Œåªæ˜¯æœªæ›¾æƒ³è¿‡è·¯é€”å¦‚æ­¤é™©æ¶ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    map&lt;int, set&lt;int&gt;&gt; f;\n    map&lt;int, bool&gt; r;\n    string sa, sb;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; sa &gt;&gt; sb;\n        a = stoi(sa), b = stoi(sb);\n        if (sa.size() == sb.size())\n            f[abs(a)].insert(abs(b)), f[abs(b)].insert(abs(a));\n        r[abs(a) * 10000 + abs(b)] = r[abs(b) * 10000 + abs(a)] = true;\n    }\n    scanf(\"%d\", &amp;m);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        vector&lt;int&gt; ans;\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        a = abs(a), b = abs(b);\n        for (auto &amp;u: f[a])\n        {\n            if (u == b) continue;\n            for (auto &amp;v: f[b])\n            {\n                if (v == a) continue;\n                if (r[u * 10000 + v])\n                    ans.push_back(u * 10000 + v);\n            }\n        }\n        printf(\"%zu\\n\", ans.size());\n        for (auto &amp;t: ans)\n            printf(\"%04d %04d\\n\", t / 10000, t % 10000);\n    }\n}\n","slug":"ã€Œ1139ã€First-Contact","date":"2022-11-25T17:09:15.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph","author_index":"Starlit Rover"},{"id":"568e7e4ef7b87e91d83cab23742c4094","title":"ã€Œ1138ã€Postorder Traversal","content":"Suppose that all the keys in a binary tree are distinct positive integers. Given the preorder and inorder traversal sequences, you are supposed to output the first number of the postorder traversal sequence of the corresponding binary tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤Â 50,000), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the first number of the postorder traversal sequence of the corresponding binary tree.\nSample Input:7\n1 2 3 4 5 6 7\n2 3 1 5 4 7 6\n\nSample Output:3\n\n\nÎ©ç»™å‡ºå‰åºã€ä¸­åºéå†ï¼Œè¾“å‡ºååºéå†ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚æ ¹æ®ååºéå†çš„å®šä¹‰ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ•´æ£µæ ‘æœ€å·¦è¾¹é‚£ä¸ªæ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚é‚£ä¹ˆé€’å½’é¡ºåºå°±å¾ˆæ˜¾ç„¶äº†ï¼Œå¦‚æœå­˜åœ¨å·¦å­æ ‘å°±é€’å½’å·¦å­æ ‘ï¼Œæ²¡æœ‰å°±é€’å½’å³å­æ ‘ï¼Œç›´åˆ°æ²¡æœ‰å­æ ‘çš„èŠ‚ç‚¹ä¸ºæ­¢ã€‚å­æ ‘çš„åˆ’åˆ†å°±ä¸å¤šè¯´äº†ï¼Œè¯¦æƒ…çœ‹traversal orderçš„tagã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre, in;\n\nint first_post(int ps, int pe, int is, int ie)\n{\n    if (ps == pe) return pre[ps];\n    int bias = find(in.begin() + is, in.begin() + ie, pre[ps]) - in.begin() - is;\n    if (bias &gt; 0) return first_post(ps + 1, ps + bias, is, is + bias - 1);\n    else return first_post(ps + bias + 1, pe, is + bias + 1, ie);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    pre.resize(n), in.resize(n);\n    for (auto &amp;k: pre) cin &gt;&gt; k;\n    for (auto &amp;k: in) cin &gt;&gt; k;\n    cout &lt;&lt; first_post(0, n - 1, 0, n - 1);\n}\n","slug":"ã€Œ1138ã€Postorder-Traversal","date":"2022-11-25T14:28:08.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"b068c193355ec83faa12b088a84c2501","title":"ã€1137ã€Final Grading","content":"For a student taking the online course â€œData Structuresâ€ on China University MOOC (http://www.icourse163.org/), to be qualified for a certificate, he/she must first obtain no less than 200 points from the online programming assignments, and then receive a final grade no less than 60 out of 100. The final grade is calculated byÂ Â ifÂ â€‹, orÂ â€‹Â will be taken as the final gradeÂ G. HereÂ â€‹Â andÂ â€‹Â are the studentâ€™s scores of the mid-term and the final exams, respectively.\nThe problem is that different exams have different grading sheets. Your job is to write a program to merge all the grading sheets into one.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives three positive integers: P , the number of students having done the online programming assignments; M, the number of students on the mid-term list; and N, the number of students on the final exam list. All the numbers are no more than 10,000.\nThen three blocks follow. The first block contains P online programming scoresÂ â€‹â€™s; the second one contains M mid-term scoresÂ â€™s; and the last one contains N final exam scoresÂ â€‹â€™s. Each score occupies a line with the format:Â StudentID Score, whereÂ StudentIDÂ is a string of no more than 20 English letters and digits, andÂ ScoreÂ is a nonnegative integer (the maximum score of the online programming is 900, and that of the mid-term and final exams is 100).\nOutput Specification:For each case, print the list of students who are qualified for certificates. Each student occupies a line with the format:\nStudentIDÂ \n$$If some score does not exist, output â€œâˆ’1â€ instead. The output must be sorted in descending order of their final grades (GÂ must be rounded up to an integer). If there is a tie, output in ascending order of theirÂ StudentIDâ€˜s. It is guaranteed that theÂ StudentIDâ€˜s are all distinct, and there is at least one qullified student.\nSample Input:6 6 7\n01234 880\na1903 199\nydjh2 200\nwehu8 300\ndx86w 220\nmissing 400\nydhfu77 99\nwehu8 55\nydjh2 98\ndx86w 88\na1903 86\n01234 39\nydhfu77 88\na1903 66\n01234 58\nwehu8 84\nydjh2 82\nmissing 99\ndx86w 81\n\nSample Output:missing 400 -1 99 99\nydjh2 200 98 82 88\ndx86w 220 88 81 84\nwehu8 300 55 84 84\n\n\nÎ©  åˆ†ä¸‰å—ç»™å‡º ä¸Šæœºã€æœŸä¸­å’ŒæœŸæœ« æˆç»©åå•ï¼Œä¸€ä¸ªå­¦ç”Ÿçš„æœ€ç»ˆæˆç»©è®¡ç®—æ–¹å¼å¦‚ä¸‹ï¼š\n\næœŸæœ«æˆç»©â‰¥æœŸä¸­æˆç»©ï¼šå–æœŸæœ«æˆç»©ä¸ºæ€»æˆç»©\n\næœŸæœ«æˆç»©&lt;æœŸä¸­æˆç»©ï¼š\n\nå¦‚æœä¸Šæœºåˆ†æ•°æ²¡æœ‰åˆ°200åˆ†ï¼ˆåŒ…æ‹¬æ²¡å‚åŠ ï¼‰ï¼Œæˆ–è€…æ€»æˆç»©Gæ²¡åˆ°60åˆ†ï¼Œåˆ™è®¤å®šè¯¥å­¦ç”Ÿæˆç»©æ— æ•ˆ\n\n\né‚£ä¹ˆæœ€ç»ˆéœ€è¦è¾“å‡ºæ‰€æœ‰æˆç»©æœ‰æ•ˆå­¦ç”Ÿçš„å„é—¨åˆ†æ•°+æ€»æˆç»©ï¼ŒæŒ‰ç…§æ€»æˆç»©é™åºæ’åˆ—ï¼Œæ€»æˆç»©ç›¸åŒåˆ™æŒ‰ç…§IDå‡åºæ’åˆ—ã€‚\næˆ‘ä»¬å…ˆç”¨ä¸€ä¸ªmap&lt;string,tuple&lt;int,int,int&gt;&gt;å»ºç«‹IDåˆ°ä¸‰é—¨æˆç»©çš„æ˜ å°„ï¼Œç¬¬ä¸€è½®è¯»å…¥ä¸Šæœºåˆ†æ•°ï¼Œå¦‚æœæˆç»©æ²¡åˆ°200å°±ä¸å­˜å…¥ã€‚æ¥ç€è¯»å…¥æœŸä¸­å’ŒæœŸæœ«æˆç»©ï¼Œè¿™é‡Œæˆ‘ä»¬åªå°†ä¸Šæœºåˆ†æ•°æœ‰æ•ˆçš„åŒå­¦æˆç»©å½•å…¥ï¼ˆå°±æ˜¯mapä¸­èƒ½æ‰¾åˆ°IDçš„ï¼‰ã€‚ç„¶åæŒ‰ç…§ä¸Šè¿°è§„åˆ™è®¡ç®—è¿™äº›åŒå­¦çš„æ€»æˆç»©ï¼Œå°†æ€»æˆç»©ä¹Ÿæœ‰æ•ˆï¼ˆGâ‰¥60ï¼‰çš„å­¦ç”ŸIDå’ŒGå­˜å…¥ä¸€ä¸ªvector&lt;pair&lt;int,string&gt;&gt;ï¼Œä»¥ä¾¿åç»­çš„sortã€‚æŒ‡å®šcmpå‡½æ•°åç›´æ¥sortï¼Œç„¶åæŒ‰ç…§é¡ºåºè¾“å‡ºå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;int, string&gt; pis;\n\nint main()\n{\n    int p, m, n, s, f;\n    cin &gt;&gt; p &gt;&gt; m &gt;&gt; n;\n    string id;\n    map&lt;string, tuple&lt;int, int, int&gt;&gt; score;\n    vector&lt;pair&lt;int, string&gt;&gt; final;\n    for (int i = 0; i &lt; p; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s;\n        if (s &gt;= 200) score[id] = make_tuple(s, -1, -1);\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s;\n        auto it = score.end();\n        if ((it = score.find(id)) != score.end())\n            get&lt;1&gt;(it-&gt;second) = s;\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; s;\n        auto it = score.end();\n        if ((it = score.find(id)) != score.end())\n            get&lt;2&gt;(it-&gt;second) = s;\n    }\n    for (auto &amp;t: score)\n    {\n        f = get&lt;1&gt;(t.second) &gt; get&lt;2&gt;(t.second) ? round(0.4 * get&lt;1&gt;(t.second) + 0.6 * get&lt;2&gt;(t.second))\n                                                : get&lt;2&gt;(t.second);\n        if (f &gt;= 60) final.emplace_back(f, t.first);\n    }\n    sort(final.begin(), final.end(),\n         [](pis &amp;a, pis &amp;b) { return a.first != b.first ? a.first &gt; b.first : a.second &lt; b.second; });\n    for (auto &amp;t: final)\n        printf(\"%s %d %d %d %d\\n\", t.second.c_str(), get&lt;0&gt;(score[t.second]), get&lt;1&gt;(score[t.second]),\n               get&lt;2&gt;(score[t.second]), t.first);\n}\n\nè¿™é‡Œæˆ‘å¯¹æœŸä¸­ã€æœŸæœ«æˆç»©çš„åˆå§‹åŒ–æ˜¯-1ï¼Œä¸»è¦ä¸ºäº†æœ€åè¾“å‡ºçš„æ–¹ä¾¿ï¼Œè‡³äºåœ¨è®¡ç®—æ€»æˆç»©çš„æ—¶å€™ï¼Œå¦‚æœæœŸæœ«æˆç»©ä¸º-1ï¼ˆæ²¡å‚åŠ è€ƒè¯•ï¼‰æ ¹æœ¬ä¸å¯èƒ½è®©æ€»æˆç»©è¾¾åˆ°60ï¼›å¦‚æœæœŸä¸­æ²¡è€ƒï¼Œé‚£ä¹ˆå°±ä¼šé€‰æ‹©æœŸæœ«æˆç»©ä¸ºæ€»æˆç»©ï¼Œå› æ­¤-1å¯¹æ€»æˆç»©è®¡ç®—æ²¡æœ‰å½±å“ã€‚\n","slug":"ã€1137ã€Final-Grading","date":"2022-11-25T09:13:34.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"53c2472eec1fb780c12dac8c28c45b29","title":"ã€1136ã€A Delayed Palindrome","content":"Consider a positive integerÂ NÂ written in standard notation withÂ k+1Â digitsÂ aiâ€‹Â asÂ Â withÂ Â for allÂ Â andÂ . ThenÂ NÂ isÂ palindromicÂ if and only ifÂ  for allÂ . Zero is written 0 and is also palindromic by definition.\nNon-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. Such number is calledÂ a delayed palindrome. (Quoted from https://en.wikipedia.org/wiki/Palindromic_number )\nGiven any positive integer, you are supposed to find its paired palindromic number.\n\n\nInput Specification:Each input file contains one test case which gives a positive integer no more than 1000 digits.\nOutput Specification:For each test case, print line by line the process of finding the palindromic number. The format of each line is the following:\nA + B = C\n\nwhereÂ AÂ is the original number,Â BÂ is the reversedÂ A, andÂ CÂ is their sum.Â AÂ starts being the input number, and this process ends untilÂ CÂ becomes a palindromic number â€“ in this case we print in the last lineÂ C is a palindromic number.; or if a palindromic number cannot be found in 10 iterations, printÂ Not found in 10 iterations.Â instead.\nSample Input 1:97152\n\nSample Output 1:97152 + 25179 = 122331\n122331 + 133221 = 255552\n255552 is a palindromic number.\n\nSample Input 2:196\n\nSample Output 2:196 + 691 = 887\n887 + 788 = 1675\n1675 + 5761 = 7436\n7436 + 6347 = 13783\n13783 + 38731 = 52514\n52514 + 41525 = 94039\n94039 + 93049 = 187088\n187088 + 880781 = 1067869\n1067869 + 9687601 = 10755470\n10755470 + 07455701 = 18211171\nNot found in 10 iterations.\n\n\nÎ©ç»™å®šä¸€ä¸ªä¸è¶…è¿‡1000ä½çš„æ•°å­—ï¼Œåˆ¤æ–­å…¶æ˜¯å¦ä¸ºå›æ–‡æ•°ï¼Œå¦‚æœä¸æ˜¯åˆ™å°†å…¶ä¸è‡ªèº«çš„é€†åºæ•°ç›¸åŠ ï¼Œå¦‚æœä¾æ—§ä¸æ˜¯å›æ–‡æ•°åˆ™é‡å¤è¿­ä»£ï¼Œè¿­ä»£åæ¬¡åä¾æ—§ä¸æ˜¯åˆ™è¾“å‡ºâ€œNot found in 10 iterations.â€ã€‚\nåˆæ˜¯reverseå‡½æ•°å¤§æ˜¾èº«æ‰‹çš„æ—¶å€™äº†ã€‚1000ä½çš„æ•°æ˜¾ç„¶ä¸èƒ½ç”¨intï¼Œè€Œä¸”éœ€è¦è‡ªå·±å®ç°å¤§æ•°çš„åŠ æ³•è¿ç®—ï¼Œè€æ ·å­ï¼Œè®¾ç½®ä¸ªè¿›ä½ï¼Œæ¯ä½å•ç‹¬è¿ç®—ï¼Œç„¶åå°†ç»“æœå’Œå…¶é€†åºæ¯”è¾ƒï¼Œå¦‚æœç›¸ç­‰è¯´æ˜æ˜¯å›æ–‡æ•°ç»ˆæ­¢è¿­ä»£ï¼Œå¦åˆ™ç»§ç»­ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s, t, r;\n    cin &gt;&gt; s, t = s;\n    reverse(t.begin(), t.end());\n    int c = 0, d, i;\n    // ATTENTION: c=0 !!!\n    for (i = 0; i &lt; 10 &amp;&amp; s != t; ++i, c = 0, r.clear())\n    {\n        for (int j = s.size() - 1; j &gt;= 0; --j)\n        {\n            d = s[j] + t[j] - 2 * '0' + c;\n            r.push_back(d % 10 + '0'), c = d / 10;\n        }\n        if (c) r.push_back('1');\n        reverse(r.begin(), r.end());\n        printf(\"%s + %s = %s\\n\", s.c_str(), t.c_str(), r.c_str());\n        s = t = r;\n        reverse(t.begin(), t.end());\n    }\n    if (i == 10) printf(\"Not found in 10 iterations.\\n\");\n    else printf(\"%s is a palindromic number.\\n\", s.c_str());\n}\n","slug":"ã€1136ã€A-Delayed-Palindrome","date":"2022-11-25T09:05:29.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,reverse,string","author_index":"Starlit Rover"},{"id":"23124d9c52676e982f8ad5a9c32feebd","title":"ã€1135ã€Is It A Red-Black Tree","content":"There is a kind of balanced binary search tree namedÂ red-black treeÂ in the data structure. It has the following 5 properties:\n\n(1) Every node is either red or black.\n(2) The root is black.\n(3) Every leaf (NULL) is black.\n(4) If a node is red, then both its children are black.\n(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\n\nFor example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.\n\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\nFigure 3\n\n\nFor each given binary search tree, you are supposed to tell if it is a legal red-black tree.\n\n\nInput Specification:Each input file contains several test cases. The first line gives a positive integer K (â‰¤30) which is the total number of cases. For each case, the first line gives a positive integer N (â‰¤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3.\nOutput Specification:For each test case, print in a line â€œYesâ€ if the given tree is a red-black tree, or â€œNoâ€ if not.\nSample Input:3\n9\n7 -2 1 5 -4 -11 8 14 -15\n9\n11 -2 1 -7 5 -4 8 14 -15\n8\n10 -7 5 -6 8 15 -11 17\n\nSample Output:Yes\nNo\nNo\n\n\nÎ©ç»™å‡ºäºŒå‰æœç´¢æ ‘çš„å…ˆåºéå†ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦ä¸ºçº¢é»‘æ ‘ã€‚çº¢é»‘æ ‘æ˜¯ä¸€ç§é«˜æ•ˆçš„äºŒå‰æœç´¢æ ‘ï¼ŒæŸ¥æ‰¾æ•ˆç‡å¯ä»¥è¾¾åˆ°ï¼Œä¸»è¦å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š\n\næ ¹èŠ‚ç‚¹å’Œæ‰€æœ‰å¶å­èŠ‚ç‚¹ï¼ˆè¿™é‡Œå°†NULLçœ‹ä½œå¶èŠ‚ç‚¹ï¼Œå› æ­¤è¿™ä¸ªç‰¹å¾ä¸å…·æœ‰ä»€ä¹ˆçº¦æŸï¼‰éƒ½æ˜¯é»‘è‰²\n\nå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²ï¼Œé‚£ä¹ˆå®ƒçš„ä¸¤ä¸ªå­èŠ‚ç‚¹å¿…é¡»å‡ä¸ºé»‘è‰²\n\næ¯ä¸ªèŠ‚ç‚¹åˆ°å®ƒæ‰€æœ‰å­ä»£å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸Šæœ‰ç›¸åŒä¸ªæ•°çš„é»‘è‰²èŠ‚ç‚¹\n\n\nç”±äºæ˜¯äºŒå‰æœç´ æ ‘ï¼Œå› æ­¤é€šè¿‡å’Œæ ¹èŠ‚ç‚¹ä¹‹é—´çš„æ¯”è¾ƒï¼Œå¯ä»¥å°†å…ˆåºéå†åˆ’åˆ†ä¸ºã€æ ¹èŠ‚ç‚¹ï½œå·¦å­æ ‘èŠ‚ç‚¹ï½œå³å­æ ‘èŠ‚ç‚¹ã€‘ï¼Œç„¶åé€’å½’åˆ’åˆ†æ‰¾å‡ºæ‰€æœ‰çˆ¶å­å…³ç³»ã€‚ç„¶åé€šè¿‡DFSé€’å½’éªŒè¯2ã€3ç‰¹å¾ï¼Œ2æ¯”è¾ƒç®€å•åªè¦æ£€æŸ¥çº¢èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å³å¯ï¼›éªŒè¯3çš„è¯å°±è®©dfså‡½æ•°è¿”å›ä»å½“å‰èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ä¸­çš„é»‘èŠ‚ç‚¹ä¸ªæ•°ï¼Œå¦‚æœå‘ç°å·¦å³å­èŠ‚ç‚¹è¿”å›ä¸ªæ•°ä¸åŒæˆ–è€…å…¶ä¸€è¿”å›-1ï¼Œåˆ™è¯´æ˜ä¸ç¬¦åˆç‰¹å¾3ç›´æ¥è¿”å›-1ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nvector&lt;int&gt; pre;\n\nvoid build(int s, int e)\n{\n    int idx = upper_bound(pre.begin() + s, pre.begin() + e, abs(pre[s]),\n                          [](const int &amp;a, const int &amp;b) { return abs(a) &lt; abs(b); }) - pre.begin();\n    if (idx &gt; s + 1)\n    {\n        sons[pre[s]].first = pre[s + 1];\n        build(s + 1, idx);\n    }\n    if (idx &lt; e)\n    {\n        sons[pre[s]].second = pre[idx];\n        build(idx, e);\n    }\n}\n\nint check(int n)\n{\n    if (n == 0) return 0;\n    // feature 2\n    if (n &lt; 0 &amp;&amp; (sons[n].first &lt; 0 || sons[n].second &lt; 0))\n        return -1;\n    int l, r;\n    // feature 3\n    if ((l = check(sons[n].first)) &lt; 0) return -1;\n    else if ((r = check(sons[n].second)) &lt; 0) return -1;\n    else if (l != r) return -1;\n    else return l + (n &gt; 0);\n}\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        pre.resize(m);\n        for (int j = 0; j &lt; m; ++j)\n            cin &gt;&gt; pre[j];\n        if (pre[0] &lt; 0)\n        {\n            printf(\"No\\n\");\n            continue;\n        }\n        build(0, m);\n        printf(check(pre[0]) &gt; 0 ? \"Yes\\n\" : \"No\\n\");\n        sons.clear(), pre.clear();\n    }\n}\n\nè¿™é‡Œç”¨äº†upper_boundå‡½æ•°æ‰¾åˆ°å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ä½ç½®ï¼Œè¯¥å‡½æ•°è¿”å›ç¬¬ä¸€ä¸ª&gt;ç»™å®šå€¼çš„å…ƒç´ è¿­ä»£å™¨ï¼Œå®ƒçš„å…„å¼Ÿå‡½æ•°lower_boundåˆ™è¿”å›ç¬¬ä¸€ä¸ªâ‰¥ç»™å®šå€¼çš„å…ƒç´ è¿­ä»£å™¨ã€‚\n","slug":"ã€1135ã€Is-It-A-Red-Black-Tree","date":"2022-11-25T06:06:31.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree,DFS,RBT","author_index":"Starlit Rover"},{"id":"1e867ab5e03f286a58fad122534ef050","title":"ã€Œ1134ã€Vertex Cover","content":"AÂ vertex coverÂ of a graph is a set of vertices such that each edge of the graph is incident to at least one vertex of the set. Now given a graph with several vertex sets, you are supposed to tell if each of them is a vertex cover or not.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integersÂ NÂ andÂ MÂ (both no more thanÂ ), being the total numbers of vertices and the edges, respectively. ThenÂ MÂ lines follow, each describes an edge by giving the indices (from 0 toÂ Nâˆ’1) of the two ends of the edge.\nAfter the graph, a positive integerÂ KÂ (â‰¤Â 100) is given, which is the number of queries. ThenÂ KÂ lines of queries follow, each in the format:\n\nwhereÂ Nvâ€‹Â is the number of vertices in the set, andÂ â€™s are the indices of the vertices.\nOutput Specification:For each query, print in a lineÂ YesÂ if the set is a vertex cover, orÂ NoÂ if not.\nSample Input:10 11\n8 7\n6 8\n4 5\n8 4\n8 1\n1 2\n1 4\n9 8\n9 1\n1 0\n2 4\n5\n4 0 3 8 4\n6 6 1 7 5 4 9\n3 1 8 4\n2 2 8\n7 9 8 7 6 5 4 2\n\nSample Output:No\nYes\nYes\nNo\nNo\n\n\nÎ©é¡¶ç‚¹è¦†ç›–æ˜¯ä¸€ä¸ªé¡¶ç‚¹çš„é›†åˆï¼Œå…¶å®šä¹‰æ˜¯ï¼Œå¦‚æœå›¾ä¸­ä»»ä½•ä¸€æ¡è¾¹è‡³å°‘ä¸€ä¸ªç«¯ç‚¹ä½äºé¡¶ç‚¹é›†å†…åˆ™ç§°è¯¥é¡¶ç‚¹é›†ä¸ºä¸€ä¸ªé¡¶ç‚¹è¦†ç›–ã€‚ç»™å®šå›¾å’Œå‡ ä¸ªé¡¶ç‚¹é›†ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦ä¸ºé¡¶ç‚¹è¦†ç›–ã€‚\næœ¬è´¨ä¸Šæ˜¯çœ‹é¡¶ç‚¹é›†ä¸­æ‰€æœ‰é¡¶ç‚¹å…³è”è¾¹é›†çš„å¹¶é›†æ˜¯å¦åŒ…å«å›¾ä¸­æ‰€æœ‰è¾¹ã€‚å¯ä»¥ç”¨ä¸€ä¸ªvector&lt;bool&gt;è¿›è¡Œæ ‡è®°ï¼Œä½†è¿™é‡Œæˆ‘èŒç”Ÿäº†bitsetçš„æƒ³æ³•ï¼Œç”¨äºŒè¿›åˆ¶ä½è¡¨ç¤ºæ¯ä¸ªé¡¶ç‚¹å…³è”çš„è¾¹é›†ï¼Œç„¶åå¯¹é¡¶ç‚¹é›†ä¸­æ‰€æœ‰é¡¶ç‚¹çš„è¾¹é›†äºŒè¿›åˆ¶æ•°å–æˆ–è¿ç®—ï¼Œçœ‹æœ€ç»ˆäºŒè¿›åˆ¶æ ‘ä¸­æ˜¯å¦æ‰€æœ‰è¾¹ä½éƒ½ä¸º1ï¼Œè¿™ä¹Ÿæ˜¯æ±‚å¹¶é›†çš„ä¸€ç§æ–¹æ³•ã€‚bitsetæ˜¯1ä½1bitï¼Œå’Œboolä¸åŒçš„æ˜¯å¯ä»¥ç›´æ¥è¿›è¡Œä½è¿ç®—ï¼Œä¸è¿‡bitsetå¿…é¡»åœ¨ç¼–è¯‘æœŸé—´å°±ç¡®å®šä½æ•°å¤§å°ï¼Œå› æ­¤ä¸èƒ½ç”¨å˜é‡åˆå§‹åŒ–ä½æ•°ã€‚ç”±äºï¼Œå› æ­¤ç›´æ¥å¼€bitset&lt;10000&gt;ï¼Œæˆ–è¿ç®—ç»“æŸåæˆ‘ä»¬å°†å…¶è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå–æœ€åçš„mä½æ£€æŸ¥æ˜¯å¦å…¨ä¸º1ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, v, k, t, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;bitset&lt;10000&gt;&gt; flag(n, 0);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        flag[a][i] = flag[b][i] = 1;\n    }\n    cin &gt;&gt; v;\n    for (int i = 0; i &lt; v; ++i)\n    {\n        cin &gt;&gt; k;\n        bitset&lt;10000&gt; otc(0);\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; t;\n            otc |= flag[t];\n        }\n        printf(otc.to_string().substr(10000 - m) == string(m, '1') ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n","slug":"ã€Œ1134ã€Vertex-Cover","date":"2022-11-25T02:50:33.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,bitset","author_index":"Starlit Rover"},{"id":"25908c90d75c97f6d5f5af144716999a","title":"ã€1133ã€Splitting A Linked List","content":"Given a singly linked list, you are supposed to rearrange its elements so that all the negative values appear before all of the non-negatives, and all the values in [0, K] appear before all those greater than K. The order of the elements inside each class must not be changed. For example, given the list being 18â†’7â†’-4â†’0â†’5â†’-6â†’10â†’11â†’-2 and K being 10, you must output -4â†’-6â†’-2â†’7â†’0â†’5â†’10â†’18â†’11.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positive  which is the total number of nodes, and a positive . The address of a node is a 5-digit nonnegative integer, and NULL is represented byÂ âˆ’1.\nThen N lines follow, each describes a node in the format:\nAddress Data Next\n\nwhereÂ AddressÂ is the position of the node,Â DataÂ is an integer inÂ , andÂ NextÂ is the position of the next node. It is guaranteed that the list is not empty.\nOutput Specification:For each case, output in order (from beginning to the end of the list) the resulting linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 9 10\n23333 10 27777\n00000 0 99999\n00100 18 12309\n68237 -6 23333\n33218 -4 00000\n48652 -2 -1\n99999 5 68237\n27777 11 48652\n12309 7 33218\n\nSample Output:33218 -4 68237\n68237 -6 48652\n48652 -2 12309\n12309 7 00000\n00000 0 99999\n99999 5 23333\n23333 10 00100\n00100 18 27777\n27777 11 -1\n\n\nÎ©é“¾è¡¨é¢˜ï¼Œç»™å‡ºä¸€ä¸ªé“¾è¡¨ï¼Œå°†æ‰€æœ‰èŠ‚ç‚¹æŒ‰å€¼åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼ŒåŒæ—¶æ¯ä¸€éƒ¨åˆ†å†…çš„èŠ‚ç‚¹é¡ºåºå¿…é¡»æŒ‰ç…§åŸå…ˆé“¾è¡¨å†…çš„é¡ºåºã€‚\næœ€ç›´æ¥çš„åšæ³•ï¼Œå°±æ˜¯ç”¨ä¸‰ä¸ªvectoråˆ†åˆ«å­˜å‚¨ï¼Œæœ€åæŒ‰é¡ºåºè¾“å‡ºï¼Œä¸è¿‡æˆ‘æƒ³è¯•è¯•stable_sortï¼Œå³ç¨³å®šæ’åºå‡½æ•°ï¼Œä¿è¯å€¼ç›¸ç­‰çš„å…ƒç´ æŒ‰ç…§åŸå…ˆé¡ºåºæ’åˆ—ã€‚ç”¨æ³•ä¸sortå‡½æ•°ç±»ä¼¼ï¼Œâš ï¸ä¸è¿‡åœ¨ç”¨lambdaå‡½æ•°æ—¶æ³¨æ„ä¼ å…¥å‚æ•°ç±»å‹éœ€è¦constä¿è¯ï¼\næ³¨æ„é¢˜ç›®ç»™å‡ºçš„èŠ‚ç‚¹ä¸ä¸€å®šå…¨éƒ¨ç”¨ä¸Šï¼Œå…ˆæ ¹æ®å¤´èŠ‚ç‚¹åœ°å€æ‰¾å‡ºé“¾è¡¨ï¼Œç„¶åæ ¹æ®èŠ‚ç‚¹çš„å€¼åœ¨å“ªä¸ªåŒºé—´èŒƒå›´å†…åˆ†åˆ«èµ‹å€¼-1ï¼Œ0ï¼Œ1ï¼Œæœ€åè°ƒç”¨stable_sortå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef const pair&lt;string, int&gt; psi;\n\nint main()\n{\n    map&lt;string, pair&lt;int, string&gt;&gt; info;\n    string start, addr;\n    int n, k;\n    cin &gt;&gt; start &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; addr &gt;&gt; info[addr].first &gt;&gt; info[addr].second;\n    vector&lt;pair&lt;string, int&gt;&gt; node;\n    while (start != \"-1\")\n    {\n        node.emplace_back(start, info[start].first &gt; k ? 1 : info[start].first &lt; 0 ? -1 : 0);\n        start = info[start].second;\n    }\n    stable_sort(node.begin(), node.end(), [](psi &amp;a, psi &amp;b) { return a.second &lt; b.second; });\n    for (int i = 0; i &lt; node.size(); ++i)\n    {\n        if (i) printf(\" %s\\n\", node[i].first.c_str());\n        printf(\"%s %d\", node[i].first.c_str(), info[node[i].first].first);\n    }\n    printf(\" -1\\n\");\n}\n\nè¿˜å‘ç°ä¸€ä»¶æ¯”è¾ƒç¥å¥‡çš„äº‹æƒ…ï¼š\n    cin &gt;&gt; addr &gt;&gt; info[addr].first &gt;&gt; info[addr].second;\n\nå¼ºè¿«ç—‡é‡åº¦æ‚£è€…è¡¨ç¤ºä¸ç”¨åˆ†ä¸¤è¡Œå†™å¾ˆèµğŸ‘ğŸ¼\n","slug":"ã€1133ã€Splitting-A-Linked-List","date":"2022-11-24T17:28:48.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,list","author_index":"Starlit Rover"},{"id":"358e1bd298e98daf2cbd6662a57fb65a","title":"ã€1132ã€Cut Integer","content":"Cutting an integer means to cut a K digits lone integer Z into two integers of (K/2) digits long integers A and B. For example, after cutting Z = 167334, we have A = 167 and B = 334. It is interesting to see that Z can be devided by the product of A and B, as 167334 / (167Â Ã—Â 334) = 3. Given an integer Z, you are supposed to test if it is such an integer.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤Â 20). Then N lines follow, each gives an integer . It is guaranteed that the number of digits of Z is an even number.\nOutput Specification:For each case, print a single lineÂ YesÂ if it is such a number, orÂ NoÂ if not.\nSample Input:3\n167334\n2333\n12345678\n\nSample Output:Yes\nNo\nNo\n\n\nÎ©ç»™å‡ºä¸€ä¸ªå…·æœ‰å¶æ•°ä½æ•°çš„æ•´æ•°Pï¼Œå°†Pæ‹†æˆä½æ•°ç›¸åŒçš„å‰åä¸¤åŠAã€Bï¼Œå¦‚æœPèƒ½å¤Ÿè¢«Aã€Bçš„ä¹˜ç§¯æ•´é™¤å°±è¾“å‡ºYesï¼Œåä¹‹è¾“å‡ºNoã€‚\nç”¨å­—ç¬¦ä¸²å­˜å‚¨Pï¼Œå†ç”¨substrè®¡ç®—å‡ºABã€‚âš ï¸A or Bä¸º0æ—¶ç›´æ¥è¾“å‡ºNoï¼Œå–ä½™ä¼šå‘ç”Ÿâ€œFloat Point Exceptionâ€œã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    string k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        if (!stoi(k.substr(0, k.size() / 2)) || !stoi(k.substr(k.size() / 2)))\n            printf(\"No\\n\");\n        else\n            printf(stoi(k) % (stoi(k.substr(0, k.size() / 2)) * stoi(k.substr(k.size() / 2))) ? \"No\\n\" : \"Yes\\n\");\n    }\n}\n","slug":"ã€1132ã€Cut-Integer","date":"2022-11-24T16:28:21.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"841d996290522367bb59c54f717d9310","title":"ã€Œ1131ã€Subway Map","content":"In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ NÂ (â‰¤Â 100), the number of subway lines. ThenÂ NÂ lines follow, with theÂ i-th (i=1,â‹¯,N) line describes theÂ i-th subway line in the format:\nMÂ S[1] S[2] â€¦ S[M]\nwhereÂ MÂ (â‰¤Â 100) is the number of stops, and S[i]â€™s (i=1,â‹¯,M) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order â€“ that is, the train travels between S[i] and S[i+1] (i=1,â‹¯,Mâˆ’1) without any stop.\nNote: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station). Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called â€œtransfer stationsâ€), no station can be the conjunction of more than 5 lines.\nAfter the description of the subway, another positive integerÂ KÂ (â‰¤Â 10) is given. ThenÂ KÂ lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively.\nThe following figure shows the sample map.\n\nNote: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.\nOutput Specification:For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:\nTake Line#X1 from S1 to S2.\nTake Line#X2 from S2 to S3.\n......\n\nwhereÂ Xiâ€™s are the line numbers andÂ Siâ€™s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.\nIf the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.\nSample Input:4\n7 1001 3212 1003 1204 1005 1306 7797\n9 9988 2333 1204 2006 2005 2004 2003 2302 2001\n13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011\n4 6666 8432 4011 1306\n3\n3011 3013\n6666 2001\n2004 3001\n\nSample Output:2\nTake Line#3 from 3011 to 3013.\n10\nTake Line#4 from 6666 to 1306.\nTake Line#3 from 1306 to 2302.\nTake Line#2 from 2302 to 2001.\n6\nTake Line#2 from 2004 to 1204.\nTake Line#1 from 1204 to 1306.\nTake Line#3 from 1306 to 3001.\n\n\nÎ©å‹¾å…«é¢˜ç›®ï¼Œæ­»ç»™ä½ çœ‹å“¦ã€‚å…¶å®ä¸æ˜¯å¾ˆéš¾ï¼Œä½†æˆ‘ä¸€ç›´é™·åœ¨BFSï¼Œç™¾æ€ä¸å¾—å…¶è§£ã€‚\nç»™å‡ºåœ°é“ç«™å›¾ä¸­æ‰€æœ‰çº¿è·¯çš„ç«™å°ç¼–å·ï¼Œè¦æ±‚ä½ è¾“å‡ºç»™å®šèµ·ç‚¹å’Œç»ˆç‚¹ç«™å°çš„è·¯çº¿ã€‚å¦‚éœ€æ¢ä¹˜åˆ™è¿˜éœ€è¾“å‡ºæ¢ä¹˜ç«™å°ã€‚ä¼˜å…ˆè¾“å‡ºè¿‡ç«™æœ€å°‘çš„è·¯çº¿ï¼Œå¦‚æœæœ‰å¤šæ¡è·¯çº¿åˆ™è¾“å‡ºæ¢ä¹˜æ•°æœ€å°‘çš„è·¯çº¿ã€‚\nä¸€å¼€å§‹ï¼Œæˆ‘è¿˜å°è¯•äº†Dijkstraï¼Œä¸ç¦è¶…æ—¶è€Œä¸”åªacäº†ä¸¤ä¸ªæµ‹è¯•ç‚¹ã€‚äºæ˜¯ä¹ï¼Œæˆ‘æ”¹ç”¨BFSç»“æœè¿˜æ˜¯åªacäº†ä¸¤ä¸ªã€‚å¦‚æœPATè€ƒè¯•é‡Œé‡åˆ°è¿™é¢˜ï¼Œæˆ‘æ€•ä¸æ˜¯å·²ç»åƒç–®ç™¾å­”äº†ã€‚ç»è¿‡å‡ ç™¾æ¬¡æŠ“ç‹‚ä¹‹åï¼Œä»”ç»†åˆ†æäº†ä¸€æ³¢ï¼Œæˆ‘åœ¨BFSä¸­ç”¨preæ•°ç»„å­˜å‚¨æœ€ä¼˜è·¯çº¿çš„å‰ç½®èŠ‚ç‚¹ï¼Œä½†äº‹å®ä¸Šä½ ä¸å¾€åèµ°æ˜¯æ— æ³•ç¡®å®šåˆ°æŸä¸ªèŠ‚ç‚¹çš„è·¯çº¿æ˜¯æœ€ä¼˜çš„ï¼Œå› ä¸ºä½ è¿˜ä¸çŸ¥é“ç»ˆç‚¹åœ¨å“ªä¸ªæ–¹å‘ï¼Œæ‰€ä»¥ä½ ä¸çŸ¥é“åœ¨è¿™ä¸ªèŠ‚ç‚¹ä¸Šæ˜¯å¦éœ€è¦æ¢ä¹˜ï¼Œä¸åŒè·¯çº¿åˆ°è¾¾è¿™ä¸ªç«™å°çš„æ¢ä¹˜æ¬¡æ•°å°±ä¼šä¸åŒã€‚å½“ç„¶ä½ å¯ä»¥æ‰¾åˆ°æ‰€æœ‰èµ·ç‚¹åˆ°ç»ˆç‚¹ç«™å°æ•°æœ€å°‘çš„è·¯çº¿ï¼Œç„¶åå†é€ä¸€è®¡ç®—æ¢ä¹˜æ•°ï¼Œå–æœ€å°è€…ã€‚\næœ€åå‘ç°æ‰€æœ‰çš„æ–¹æ³•éƒ½ä¼šå›åˆ°DFSï¼Œåªæœ‰DFSèƒ½ç›´æ¥è®¡ç®—å‡ºåˆ°ç»ˆç‚¹ç«™å…±æ¢ä¹˜äº†å¤šå°‘æ¬¡ã€‚è®¾ç½®ä¸€ä¸ªå…¨å±€æœ€ä¼˜pairå¯¹optï¼Œå¦‚æœåˆ°ç»ˆç‚¹çš„è·¯çº¿æ¯”optä¼˜åˆ™è®°å½•è·¯çº¿å¹¶æ›´æ–°optï¼ŒåŒæ—¶ç”¨posè¡¨ç¤ºè¿™æ¡è·¯åŸæœ¬åœ¨å‡ å·çº¿ä¸Šï¼Œå¦‚æœæ¥ä¸‹å»å°†è¦dfsçš„ç«™å°çº¿å·ä¸å½“å‰è·¯çº¿çº¿å·ä¸åŒåˆ™ç»™trans+1ã€‚oå¯¹ï¼Œæ³¨æ„åˆ°æ¯ä¸ªç«™å°å¯èƒ½å±äºå¤šä¸ªçº¿è·¯ï¼Œè€Œé‚»ç«™ä¹‹é—´çš„è·¯çº¿åˆ™å±äºå”¯ä¸€çº¿è·¯ï¼Œå› æ­¤ç”¨map&lt;pair&lt;int,int&gt;,int&gt;è¡¨ç¤ºç›¸é‚»ç«™å°ä¹‹é—´çš„è·¯çº¿å±äºå“ªä¸€çº¿è·¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\nmap&lt;pair&lt;int, int&gt;, int&gt; line;\nvector&lt;vector&lt;int&gt;&gt; edge(10000);\nvector&lt;bool&gt; flag(10000, false);\nvector&lt;int&gt; path, ans;\npair&lt;int, int&gt; opt{INT32_MAX, INT32_MAX};\n\nvoid dfs(int s, int e, int trans, int pos)\n{\n    static int depth = 0;\n    flag[s] = true, path.push_back(s);\n    if (s == e)\n    {\n        if (make_pair(depth, trans) &lt; opt)\n        {\n            opt = make_pair(depth, trans);\n            ans = path;\n        }\n    }\n    else\n    {\n        for (auto &amp;k: edge[s])\n        {\n            if (flag[k]) continue;\n            depth += 1;\n            dfs(k, e, trans + (pos != line[{k, s}] &amp;&amp; depth &gt; 1), line[{k, s}]);\n            depth -= 1;\n        }\n    }\n    flag[s] = false, path.pop_back();\n}\n\nint main()\n{\n    int n, m, k, a, b, p;\n    scanf(\"%d\", &amp;n);\n    edge.resize(10000);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d %d\", &amp;m, &amp;p);\n        for (int j = 1; j &lt; m; ++j)\n        {\n            scanf(\"%d\", &amp;k);\n            line[make_pair(k, p)] = line[make_pair(p, k)] = i + 1;\n            edge[k].push_back(p), edge[p].push_back(k);\n            p = k;\n        }\n    }\n    scanf(\"%d\", &amp;m);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d\", &amp;a, &amp;b);\n        dfs(a, b, 0, 0);\n        printf(\"%d\\n\", opt.first);\n        int l = line[{ans[0], ans[1]}], p = a;\n        for (int j = 1; j &lt; ans.size(); ++j)\n        {\n            if (line[{ans[j - 1], ans[j]}] != l)\n            {\n                printf(\"Take Line#%d from %04d to %04d.\\n\", l, p, ans[j - 1]);\n                l = line[{ans[j - 1], ans[j]}], p = ans[j - 1];\n            }\n        }\n        printf(\"Take Line#%d from %04d to %04d.\\n\", l, p, ans.back());\n        path.clear(), ans.clear();\n        opt = {INT32_MAX, INT32_MAX};\n    }\n}\n","slug":"ã€Œ1131ã€Subway-Map","date":"2022-11-24T14:20:00.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,DFS","author_index":"Starlit Rover"},{"id":"0def5409a91f0fbcec7f6cf9896df886","title":"ã€1130ã€Infix Expression","content":"Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of the operators.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤Â 20) which is the total number of nodes in the syntax tree. Then N lines follow, each gives the information of a node (theÂ i-th line corresponds to theÂ i-th node) in the format:\ndata left_child right_child\n\nwhereÂ dataÂ is a string of no more than 10 characters,Â left_childÂ andÂ right_childÂ are the indices of this nodeâ€™s left and right children, respectively. The nodes are indexed from 1 to N. The NULL link is represented byÂ âˆ’1. The figures 1 and 2 correspond to the samples 1 and 2, respectively.\n\n\n\n\n\n\n\n\nFigure 1\nFigure 2\n\n\nOutput Specification:For each case, print in a line the infix expression, with parentheses reflecting the precedences of the operators. Note that there must be no extra parentheses for the final expression, as is shown by the samples. There must be no space between any symbols.\nSample Input 1:8\n* 8 7\na -1 -1\n* 4 1\n+ 2 5\nb -1 -1\nd -1 -1\n- -1 6\nc -1 -1\n\nSample Output 1:(a+b)*(c*(-d))\n\nSample Input 2:8\n2.35 -1 -1\n* 6 1\n- -1 4\n% 7 8\n+ 2 3\na -1 -1\nstr -1 -1\n871 -1 -1\n\nSample Output 2:(a*2.35)+(-(str%871))\n\n\nÎ©ç»™å‡ºä¸€æ£µè¡¨è¾¾å¼è¯­æ³•äºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ä»¥åŠå·¦å³å­èŠ‚ç‚¹ç¼–å·ï¼Œè¾“å‡ºæœ€ç»ˆçš„è¡¨è¾¾å¼ï¼Œæ‹¬å·ç”¨äºè¡¨è¾¾è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ï¼Œâš ï¸æœ€ç»ˆè¡¨è¾¾å¼çš„å¤–é¢ä¸è¦åŠ æ‹¬å·ã€‚\næœ¬è´¨ä¸Šå°±æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œéå†åŒæ—¶è¿ç”¨å­—ç¬¦ä¸²çš„åŠ æ³•ï¼Œä½†é—®é¢˜åœ¨äºä½•æ—¶åŠ æ‹¬å·ï¼šå¾ˆæ˜¾ç„¶å°±æ˜¯æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹è¡¨è¾¾å¼ä¸éœ€è¦æ‹¬å·ï¼Œå› ä¸ºèŠ‚ç‚¹æœ¬èº«æ˜¯ä¸ªå¶å­èŠ‚ç‚¹ï¼Œè¡¨ç¤ºä¸€ä¸ªå•ç‹¬çš„å€¼ã€‚å¯¹äºå…¶ä»–æƒ…å†µçš„èŠ‚ç‚¹è¡¨è¾¾å¼éƒ½éœ€è¦åŠ ä¸Šã€(ã€‘ã€)ã€‘ã€‚ç”±äºæœ€ç»ˆè¾“å‡ºçš„ç»“æœä¸éœ€è¦å¤§æ‹¬å·ï¼Œäºæ˜¯ä¹æˆ‘ä»¬å°±å–ä¸­é—´ä¸å«å­ä¸²çš„éƒ¨åˆ†ã€‚\nâš ï¸æœ‰ä¸€ç§æƒ…å†µéœ€è¦å•ç‹¬è€ƒè™‘ï¼Œé‚£å°±æ˜¯åªæœ‰æ ¹èŠ‚ç‚¹çš„æƒ…å†µï¼ŒåŸºäºä¸Šè¿°è§„åˆ™æˆ‘ä»¬ä¸ä¼šç»™æ ¹èŠ‚ç‚¹è¡¨è¾¾å¼æ·»åŠ æ‹¬å·ï¼Œé‚£ä¹ˆæœ€åç›´æ¥è¾“å‡ºå¾—åˆ°çš„å­—ç¬¦ä¸²å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; sons;\nvector&lt;string&gt; value;\n\nstring infix(int node)\n{\n    if (node == -1) return \"\";\n    else if (sons[node] == make_pair(-1,-1)) return value[node];\n    return \"(\" + infix(sons[node].first) + value[node] + infix(sons[node].second) + \")\";\n}\n\nint main()\n{\n    int n, root;\n    cin &gt;&gt; n;\n    root = n * (n + 1) / 2;\n    sons.resize(n + 1), value.resize(n + 1);\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        cin &gt;&gt; value[i] &gt;&gt; sons[i].first &gt;&gt; sons[i].second;\n        root -= (sons[i].first == -1 ? 0 : sons[i].first) + (sons[i].second == -1 ? 0 : sons[i].second);\n    }\n    string ans = infix(root);\n    if (n == 1) cout &lt;&lt; ans;\n    else cout &lt;&lt; ans.substr(1, ans.size() - 2);\n}\n","slug":"ã€1130ã€Infix-Expression","date":"2022-11-23T17:27:42.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"f1ff96299aac15c031753a8c21bad439","title":"ã€1129ã€Recommendation System","content":"Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the userâ€™s preference by the number of times that an item has been accessed by this user.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains two positive integers: N (â‰¤Â 50,000), the total number of queries, and K (â‰¤Â 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing â€“ for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space.\nOutput Specification:For each case, process the queries one by one. Output the recommendations for each query in a line in the format:\nquery: rec[1] rec[2] ... rec[K]\n\nwhereÂ queryÂ is the item that the user is accessing, andÂ rec[i]Â (i=1, â€¦ K) is theÂ i-th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order.\nNote: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query.\nSample Input:12 3\n3 5 7 5 5 3 2 1 8 3 8 12\n\nSample Output:5: 3\n7: 3 5\n5: 3 5 7\n5: 5 3 7\n3: 5 3 7\n2: 5 3 7\n1: 5 3 2\n8: 5 3 1\n3: 5 3 1\n8: 3 5 1\n12: 3 5 8\n\n\nÎ©å†™ä¸€ä¸ªæ¨èç³»ç»Ÿï¼Œå‡è®¾è®¿é—®å¯¹è±¡çš„ç¼–å·ä»1-Nï¼Œç»™å‡ºç”¨æˆ·æŒ‰æ—¶é—´é¡ºåºè®¿é—®çš„å¯¹è±¡åºåˆ—ï¼Œä»¥åŠæ¯æ¬¡æœ€å¤šæ¨èçš„å¯¹è±¡ä¸ªæ•°ï¼Œåœ¨æ¯æ¬¡ç”¨æˆ·è®¿é—®å¯¹è±¡å‰ï¼ˆé™¤ç¬¬ä¸€æ¬¡ï¼‰ç»™å‡ºæ¨èåºåˆ—ï¼ŒæŒ‰ç…§å…ˆå‰è®¿é—®æ¬¡æ•°é™åºæ’åˆ—ï¼Œå¦‚æœè®¿é—®æ¬¡æ•°ä¸€è‡´ï¼ŒæŒ‰ç…§åºå·å‡åºæ’åˆ—ã€‚\nè¿™å‹¾å…«é¢˜ç›®æˆ‘è¯»äº†åŠå¤©ï¼Œè°æ¥æ•‘æ•‘æˆ‘çš„è‹±è“ç“œå“¥ã€‚æ²¡æœ‰æƒ³å¤ªå¤šï¼ŒåªçŸ¥é“æ¯æ¬¡éƒ½éœ€è¦é€‰å‡ºè®¿é—®æ¬¡æ•°æœ€é«˜çš„ä¸ªå¯¹è±¡ï¼Œæ¯æ¬¡æ’åºä¼°è®¡æ—¶é—´å¼€é”€å¤ªå¤§ã€‚äºæ˜¯ä¹æˆ‘æ‰“ç®—ç”¨setå’Œvectorè®¾è®¡ä¸€ä¸ªæ¡¶vector&lt;set&lt;int&gt;&gt; item(n+1)ï¼Œé‚£ä¹ˆitem[i]å°±è¡¨ç¤ºè®¿é—®æ¬¡æ•°ä¸ºçš„å¯¹è±¡é›†åˆï¼Œsetä¼šè‡ªåŠ¨æŒ‰ç…§åºå·å‡åºæ’åˆ—ã€‚æ¥ç€å†ç”¨ä¸€ä¸ªvector&lt;int&gt; cnt(n+1,0)å­˜å‚¨æ¯ä¸ªç‰©ä½“çš„è®¿é—®æ¬¡æ•°ã€‚é‚£ä¹ˆæ¯å½“ä¸€ä¸ªå¯¹è±¡çš„è®¿é—®æ¬¡æ•°å¢åŠ æ—¶ï¼Œæˆ‘ä»¬éƒ½éœ€è¦å°†åŸå…ˆæ¡¶ä¸­ï¼ˆï¼‰çš„å¯¹è±¡eraseï¼Œåœ¨æ–°æ¡¶ä¸­ï¼ˆï¼‰æ’å…¥ã€‚ç„¶åå†ç”¨ä¸€ä¸ªmostå˜é‡è®°å½•å½“å‰çš„æœ€é«˜è®¿é—®æ¬¡æ•°ï¼Œé‚£ä¹ˆæ¯æ¬¡é€‰æ‹©æ¨èå¯¹è±¡æ—¶éƒ½ä»å¼€å§‹æ‰¾ä¸ªå³å¯ã€‚\nâš ï¸å¦‚æœè®¿é—®è¿‡çš„å¯¹è±¡ä¸è¶³ä¸ªå°±ä¸éœ€è¦æ¨èè¿™ä¹ˆå¤šï¼Œæœ‰å¤šå°‘å°±æ¨èå¤šå°‘ã€‚\nå¬ä¸Šå»è™½ç„¶æœ‰ç‚¹éº»çƒ¦ï¼Œä½†å®ç°èµ·æ¥è¿˜æ˜¯å¾ˆå¿«çš„ã€‚ç„¶é¹…ä¸€å¼€å§‹æœ€åä¸€ä¸ªæµ‹è¯•ç‚¹ä¸€ç›´SFï¼Œæˆ‘ä¸€è„¸èŒ«ç„¶ï¼Œä¸¤çœ¼æ‡µé€¼ã€‚æœ€åå‘ç°å‰é¢çš„è®¿é—®å¯¹è±¡å¯èƒ½éƒ½æ˜¯åŒä¸€ä¸ªï¼Œé‚£ä¹ˆé¢„æµ‹å¯¹è±¡åªéœ€è¦è¾“å‡ºä¸€ä¸ªå³å¯ï¼Œè€Œä¸èƒ½å–å†³äºè®¿é—®æ¬¡æ•°ï¼ï¼ï¼\nè¿˜æœ‰ä¸€ç§åšæ³•ï¼Œæ„Ÿè§‰ç›¸å¯¹easyç‚¹ï¼Œå°±æ˜¯å…¨éƒ¨è£…åœ¨ä¸€ä¸ªsetä¸­ï¼Œç„¶åç»™å‡ºsetçš„compareå‡½æ•°ï¼Œé‚£ä¹ˆæ¯æ¬¡éƒ½ç›´æ¥ä»å‰ä¸ªé€‰æ‹©ï¼Œæ„Ÿè§‰å®æ“æ€§æ›´å¼ºä¸€ç‚¹ã€‚\noè¿˜æ— æ„ä¸­å‘ç°ï¼Œmultisetä¸­å¦‚æœeraseå‡½æ•°çš„å‚æ•°ç»™çš„æ˜¯ç‰¹å®šå€¼çš„è¯å°±ä¼šæŠŠæ‰€æœ‰ç‰¹å®šå€¼éƒ½åˆ æ‰ï¼Œå¦‚æœæƒ³åªåˆ å…¶ä¸­ä¸€ä¸ªï¼Œå°±æ­é…findç»™å‡ºè¿­ä»£å™¨ï¼šmultiset.erase(multiset.find(value))ã€‚ä¼°è®¡å†…éƒ¨å®ç°å°±æ˜¯set&lt;pair&lt;...,int&gt;&gt;ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, m, most = 1, j, p, distinct = 1;\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;\n    vector&lt;set&lt;int&gt;&gt; item(n + 1);\n    vector&lt;int&gt; cnt(n + 1, 0);\n    item[1].insert(m), cnt[m] = 1;\n    for (int i = 1; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        j = min(distinct, k), p = most;\n        printf(\"%d:\", m);\n        while (j &gt; 0)\n            for (auto &amp;t: item[p--])\n            {\n                printf(\" %d\", t);\n                if (--j &lt;= 0) break;\n            }\n        printf(\"\\n\");\n        if (++cnt[m] &gt; 1) item[cnt[m] - 1].erase(m);\n        else ++distinct;\n        item[cnt[m]].insert(m);\n        most = max(most, cnt[m]);\n    }\n}\n","slug":"ã€1129ã€Recommendation-System","date":"2022-11-23T16:22:12.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,set","author_index":"Starlit Rover"},{"id":"988044046878bff1b1dd82dbd324dde7","title":"ã€Œ1128ã€N Queens Puzzle","content":"The â€œeight queens puzzleâ€ is the problem of placing eight chess queens on anÂ 8Ã—8Â chessboard so that no two queens threaten each other. Thus, a solution requires that no two queens share the same row, column, or diagonal. The eight queens puzzle is an example of the more generalÂ NÂ queens problem of placingÂ NÂ non-attacking queens on anÂ NÃ—NÂ chessboard. (From Wikipedia - â€œEight queens puzzleâ€.)\nHere you are NOT asked to solve the puzzles. Instead, you are supposed to judge whether or not a given configuration of the chessboard is a solution. To simplify the representation of a chessboard, let us assume that no two queens will be placed in the same column. Then a configuration can be represented by a simple integer sequenceÂ , whereÂ â€‹Â is the row number of the queen in theÂ i-th column. For example, Figure 1 can be represented by (4, 6, 8, 2, 7, 1, 3, 5) and it is indeed a solution to the 8 queens puzzle; while Figure 2 can be represented by (4, 6, 7, 2, 8, 1, 9, 5, 3) and is NOT a 9 queensâ€™ solution.\n\n\n\n\n\n\n\n\n\nFigure 1\n\nFigure 2\n\n\n\n\nInput Specification:Each input file contains several test cases. The first line gives an integerÂ . ThenÂ KÂ lines follow, each gives a configuration in the format â€œâ€‹â€, whereÂ 4â‰¤Nâ‰¤1000Â and it is guaranteed thatÂ Â for allÂ . The numbers are separated by spaces.\nOutput Specification:For each configuration, if it is a solution to theÂ NÂ queens problem, printÂ YESÂ in a line; orÂ NOÂ if not.\nSample Input:4\n8 4 6 8 2 7 1 3 5\n9 4 6 7 2 8 1 9 5 3\n6 1 5 2 6 4 3\n5 1 3 5 2 4\n\nSample Output:YES\nNO\nNO\nYES\n\n\nÎ©ç»™å‡ºå‡ ä¸ªæ£‹ç›˜å¸ƒå±€ï¼Œåˆ¤æ–­æ˜¯å¦æ»¡è¶³â€œå…«çš‡åé—®é¢˜â€çš„è¦æ±‚ï¼Œå³è¡Œåˆ—ä»¥åŠå¯¹è§’çº¿ä¸Šæœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªçš‡åã€‚æ£‹ç›˜å¸ƒå±€çš„è¡¨ç¤ºæ–¹æ³•æ˜¯ç»™å‡ºæ¯ä¸€åˆ—çš‡åæ‰€åœ¨çš„ï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰è¡Œæ•°ã€‚\né¢˜ç›®ä¿è¯äº†æ£‹ç›˜ä¸Šçš„æ¯ä¸€åˆ—å‡æœ‰ä¸€ä¸ªçš‡åï¼Œå› æ­¤æˆ‘ä»¬åªè¦æ£€æŸ¥è¡Œä¸å¯¹è§’çº¿ä¹‹é—´æ˜¯å¦æ»¡è¶³ã€‚è¡Œæ£€æŸ¥æ¯”è¾ƒæ˜¾ç„¶ï¼Œåªè¦æ‰€æœ‰çš‡åçš„è¡Œæ•°ä¸åŒï¼›è€Œå¯¹äºå¯¹è§’çº¿çš„æ¡ä»¶ï¼Œåˆ™éœ€è¦æ»¡è¶³ï¼Œå…¶ä¸­æ˜¯åˆ—æ•°ï¼Œè¡¨ç¤ºåˆ—çš‡åæ‰€åœ¨çš„è¡Œæ•°ã€‚æ¯ä¸€åˆ—çš„çš‡ååªéœ€å’Œå‰é¢å‡ åˆ—çš„çš‡åæ¯”è¾ƒå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        vector&lt;int&gt; seq(m);\n        bool ans = true;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; seq[j];\n            if (!ans) continue;\n            for (int k = 0; k &lt; j; ++k)\n                ans = ans &amp;&amp; (j - k != abs(seq[j] - seq[k])) &amp;&amp; seq[j] != seq[k];\n        }\n        printf(ans ? \"YES\\n\" : \"NO\\n\");\n    }\n}\n","slug":"ã€Œ1128ã€N-Queens-Puzzle","date":"2022-11-23T09:22:37.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"dec46595a39d6d567d60096de34e1f5b","title":"ã€1127ã€ZigZagging on a Tree","content":"Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in â€œzigzagging orderâ€ â€“ that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer , the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:8\n12 11 20 17 1 15 8 5\n12 20 17 11 15 8 5 1\n\nSample Output:1 11 5 8 17 12 20 15\n\n\nÎ©ç»™å‡ºä¸€æ£µäºŒå‰æ ‘çš„ä¸­åºéå†å’Œåç»­éå†ï¼Œè¾“å‡ºå…¶ZigZagéå†ç»“æœã€‚èŠ±æ ·çœŸå¤šå•Šï¼Œå°±æ˜¯Så½¢çš„å±‚æ¬¡éå†ï¼Œå…ˆä»å·¦åˆ°å³ï¼Œå†ä»å³åˆ°å·¦ã€‚\næ ‘çš„æ ¹èŠ‚ç‚¹éƒ½åœ¨åç»­éå†ä¸­çš„æœ€åä¸€ä½ï¼Œç„¶åå†é€šè¿‡ä¸­åºéå†ä¸­æ ¹èŠ‚ç‚¹çš„ä½ç½®å¾—çŸ¥å·¦å³å­æ ‘çš„èŠ‚ç‚¹ï¼Œåœ¨åç»­éå†ä¸­åˆ’åˆ†å®Œé€’å½’åˆ’åˆ†å­æ ‘ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹ã€‚æœ€åè®¾ç½®ä¸€ä¸ªflagå¸ƒå°”å˜é‡è¡¨ç¤ºé¡ºåºï¼Œæ¯æ¬¡éƒ½å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nvector&lt;int&gt; post, in;\n\nvoid build(int is, int ie, int ps, int pe)\n{\n    int bias = (find(in.begin(), in.end(), post[pe]) - in.begin()) - is;\n    if (bias &gt; 0)\n    {\n        sons[post[pe]].first = post[ps + bias - 1];\n        build(is, is + bias - 1, ps, ps + bias - 1);\n    }\n    if (bias + is &lt; ie)\n    {\n        sons[post[pe]].second = post[pe - 1];\n        build(is + bias + 1, ie, ps + bias, pe - 1);\n    }\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    post.resize(n), in.resize(n);\n    for (auto &amp;k: in) cin &gt;&gt; k;\n    for (auto &amp;k: post) cin &gt;&gt; k;\n    build(0, n - 1, 0, n - 1);\n    vector&lt;int&gt; crt{post.back()}, nxt;\n    bool flag = false, space = false;\n    while (!crt.empty())\n    {\n        for (auto &amp;k: crt)\n        {\n            if (sons[k].first) nxt.push_back(sons[k].first);\n            if (sons[k].second) nxt.push_back(sons[k].second);\n        }\n        if (flag)\n            for (auto &amp;k: crt) \n                printf(\"%s%d\", space ? \" \" : (space = true, \"\"), k);\n        else\n            for (auto it = crt.rbegin(); it != crt.rend(); ++it)\n                printf(\"%s%d\", space ? \" \" : (space = true, \"\"), *it);\n        crt = std::move(nxt), nxt = vector&lt;int&gt;(), flag = !flag;\n    }\n}\n","slug":"ã€1127ã€ZigZagging-on-a-Tree","date":"2022-11-23T08:27:59.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"9c2a27d777225ad7770aaf3f1ce46c04","title":"ã€Œ1126ã€Eulerian Path","content":"In graph theory, an Eulerian path is a path in a graph which visits every edge exactly once. Similarly, an Eulerian circuit is an Eulerian path which starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the famous Seven Bridges of Konigsberg problem in 1736. It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are calledÂ Eulerian. If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other. A graph that has an Eulerian path but not an Eulerian circuit is calledÂ semi-Eulerian. (Cited from https://en.wikipedia.org/wiki/Eulerian_path)\nGiven an undirected graph, you are supposed to tell if it is Eulerian, semi-Eulerian, or non-Eulerian.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 2 numbers N (â‰¤Â 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by giving the two ends of the edge (the vertices are numbered from 1 to N).\nOutput Specification:For each test case, first print in a line the degrees of the vertices in ascending order of their indices. Then in the next line print your conclusion about the graph â€“ eitherÂ Eulerian,Â Semi-Eulerian, orÂ Non-Eulerian. Note that all the numbers in the first line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.\nSample Input 1:7 12\n5 7\n1 2\n1 3\n2 3\n2 4\n3 4\n5 2\n7 6\n6 3\n4 5\n6 4\n5 6\n\nSample Output 1:2 4 4 4 4 4 2\nEulerian\n\nSample Input 2:6 10\n1 2\n1 3\n2 3\n2 4\n3 4\n5 2\n6 3\n4 5\n6 4\n5 6\n\nSample Output 2:2 4 4 4 3 3\nSemi-Eulerian\n\nSample Input 3:5 8\n1 2\n2 5\n5 4\n4 1\n1 3\n3 2\n3 4\n5 3\n\nSample Output 3:3 3 4 3 3\nNon-Eulerian\n\n\nÎ©åˆ¤æ–­å›¾ä¸ºæ¬§æ‹‰å›¾ï¼ˆæ‰€æœ‰èŠ‚ç‚¹çš„åº¦ä¸ºå¶æ•°ï¼‰ã€åŠæ¬§æ‹‰å›¾ï¼ˆé™¤äº†ä¸¤ä¸ªèŠ‚ç‚¹åº¦ä¸ºå¥‡æ•°ï¼Œå…¶ä½™ç‚¹åº¦å‡ä¸ºå¶æ•°ï¼‰ or éæ¬§æ‹‰å›¾ã€‚é¢˜ç›®éƒ½æŠŠåˆ¤æ–­æ–¹å¼å†™å‡ºæ¥äº†ï¼Œå‰©ä¸‹çš„å°±è€ƒå¯Ÿè‹±è¯­é˜…è¯»ç†è§£äº†ã€‚\nå½“ç„¶è¿™ä¸€åˆ‡æˆç«‹è¿˜å­˜åœ¨ä¸€ä¸ªå‰ææ¡ä»¶ï¼Œä¹Ÿæ˜¯æµ‹è¯•ç‚¹3æš—è—çš„å¤§å‘â€”â€”è¿™ä¸ªå›¾å¿…é¡»æ˜¯è¿é€šå›¾ã€‚è¿™ä¸ªç‚¹å…¶å®ä¸éš¾æƒ³åˆ°ï¼Œå› ä¸ºè®¡ç®—æœºä¸­å°†0ä¹Ÿè§†ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆå¦‚æœä¸€æ¡è¾¹ä¹Ÿæ²¡æœ‰ï¼Œæ‰€æœ‰ç‚¹åº¦éƒ½ä¸ºå¶æ•°ï¼ŒæŒ‰ç…§ä¸Šè¿°ç†è®ºåº”ä¸ºæ¬§æ‹‰å›¾ï¼ˆç¤¼è²Œçš„å¾®ç¬‘.jpgï¼‰ã€‚æ‰€ä»¥åˆ¤æ–­å‰åˆ«å¿˜äº†æ¥ä¸ªã€DFS/BFS/å¹¶æŸ¥é›†ã€‘æ£€æŸ¥ä¸€ä¸‹è¿é€šæ€§ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; edge;\nvector&lt;bool&gt; flag;\n\nint dfs(int n)\n{\n    flag[n] = true;\n    int sum = 0;\n    for (auto &amp;k: edge[n])\n    {\n        if (flag[k]) continue;\n        sum += dfs(k);\n    }\n    return sum + 1;\n}\n\nint main()\n{\n    int n, m, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    edge.resize(n + 1), flag.resize(n + 1, false);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a].push_back(b), edge[b].push_back(a);\n    }\n    int odd = edge[1].size() % 2, even = 1 - edge[1].size() % 2;\n    cout &lt;&lt; edge[1].size();\n    for (int i = 2; i &lt;= n; ++i)\n    {\n        cout &lt;&lt; \" \" &lt;&lt; edge[i].size();\n        edge[i].size() % 2 ? ++odd : ++even;\n    }\n    cout &lt;&lt; endl;\n    if (dfs(1) &lt; n) printf(\"Non-Eulerian\");\n    else printf(even == n ? \"Eulerian\" : (odd == 2 ? \"Semi-Eulerian\" : \"Non-Eulerian\"));\n}\n","slug":"ã€Œ1126ã€Eulerian-Path","date":"2022-11-23T07:17:49.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,DFS","author_index":"Starlit Rover"},{"id":"e21aa88525fef8dbccd8e7f69148bf51","title":"ã€Œ1125ã€Chain the Ropes","content":"Given some segments of rope, you are supposed to chain them into one rope. Each time you may only fold two segments into loops and chain them into one piece, as shown by the figure. The resulting chain will be treated as another segment of rope and can be folded again. After each chaining, the lengths of the original two segments will be halved.\n\nYour job is to make the longest possible rope out ofÂ NÂ given segments.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ . ThenÂ NÂ positive integer lengths of the segments are given in the next line, separated by spaces. All the integers are no more thanÂ .\nOutput Specification:For each case, print in a line the length of the longest possible rope that can be made by the given segments. The result must be rounded to the nearest integer that is no greater than the maximum length.\nSample Input:8\n10 15 12 3 4 13 1 15\n\nSample Output:14\n\n\nÎ©ç»™å‡ºå‡ æ®µç»³å­çš„é•¿åº¦ï¼Œå½“æˆ‘ä»¬æŠŠä¸¤æ®µç»³å­æ‰“ç»“åå°±ä¼šæˆä¸ºä¸€æ®µæ–°çš„ç»³å­ï¼Œä¸”é•¿åº¦ä¸ºä¸¤è€…ä¹‹å’Œçš„ä¸€åŠï¼Œè¾“å‡ºè¿™äº›ç»³å­æœ€åæ‰“æˆä¸€æ®µçš„æœ€å¤§é•¿åº¦ã€‚\nä¹çœ‹ä¸€è„¸èŒ«ç„¶ï¼Œä»”ç»†æƒ³æƒ³å°±ä¼šå‘ç°æ¯æ¬¡æ‰“ç»“åç»³å­çš„é•¿åº¦å°±ä¼šæŸå¤±ä¸€åŠï¼Œè€Œä¸”é•¿ç»³å­çš„ä¸€åŠä¸çŸ­ç»³å­çš„ä¸€åŠæ˜¾ç„¶ä¸åŒã€‚åŸºäºæŸå¤±æœ€å°åŸåˆ™ï¼Œæˆ‘ä»¬åº”è¯¥å°½åŠ›è®©é•¿ç»³å­æŠ˜åŠæ¬¡æ•°æœ€å°‘ï¼ŒçŸ­ç»³å­æŠ˜åŠæ¬¡æ•°å°½å¯èƒ½å¤šã€‚äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥å¯¹ç»³å­é•¿åº¦è¿›è¡Œä¸€ä¸ªæ’åºï¼Œæ¯æ¬¡éƒ½å–æœ€çŸ­çš„ä¸¤æ®µç»³å­æ‰“ç»“ï¼Œç”±äºæ‰“ç»“åçš„ç»³å­é•¿åº¦å¿…ç„¶ä»‹äºåŸç»³é•¿åº¦çš„ä¸¤è€…ä¹‹é—´ï¼Œå› æ­¤æ¥ä¸‹æ¥åªè¦æ‹¿æ‰“ç»“çš„ç»³å­å’Œå‰©ä½™æœ€çŸ­çš„ç»³å­ç»§ç»­æ‰“ç»“å³å¯ã€‚è¿™æœ¬è´¨ä¸Šæ˜¯ä¸€ç§è´ªå¿ƒç­–ç•¥ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    int a[n];\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; a[i];\n    sort(a, a + n);\n    int ans = a[0];\n    for (int i = 1; i &lt; n; ++i)\n        ans = (ans + a[i]) / 2;\n    cout &lt;&lt; ans;\n}\n","slug":"ã€Œ1125ã€Chain-the-Ropes","date":"2022-11-22T16:47:47.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,è´ªå¿ƒ","author_index":"Starlit Rover"},{"id":"0e44f9fb7cc06322096d65164057b9ec","title":"ã€Œ1124ã€Raffle for Weibo Followers","content":"John got a full mark on PAT. He was so happy that he decided to hold a raffleï¼ˆæŠ½å¥–ï¼‰ for his followers on Weibo â€“ that is, he would select winners from every N followers who forwarded his post, and give away gifts. Now you are supposed to help him generate the list of winners.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives three positive integers M (â‰¤Â 1000), N and S, being the total number of forwards, the skip number of winners, and the index of the first winner (the indices start from 1). Then M lines follow, each gives the nickname (a nonempty string of no more than 20 characters, with no white space or return) of a follower who has forwarded Johnâ€™s post.\nNote: it is possible that someone would forward more than once, but no one can win more than once. Hence if the current candidate of a winner has won before, we must skip him/her and consider the next one.\nOutput Specification:For each case, print the list of winners in the same order as in the input, each nickname occupies a line. If there is no winner yet, printÂ Keep going...Â instead.\nSample Input 1:9 3 2\nImgonnawin!\nPickMe\nPickMeMeMeee\nLookHere\nImgonnawin!\nTryAgainAgain\nTryAgainAgain\nImgonnawin!\nTryAgainAgain\n\nSample Output 1:PickMe\nImgonnawin!\nTryAgainAgain\n\nSample Input 2:2 3 5\nImgonnawin!\nPickMe\n\nSample Output 2:Keep going...\n\n\nÎ©ä»è½¬å‘è€…ä¸­ç¡®å®šè·å¥–åå•ã€‚ç»™å®šè½¬å‘åå•ï¼Œèµ·å§‹åºå·ï¼Œä»¥åŠç¡®å®šä¸€ä¸ªè·å¥–è€…ä¹‹åçš„è·³è¿‡äººæ•°ã€‚ç”±äºè½¬å‘ä¸é™æ¬¡æ•°ï¼Œä½†åªèƒ½è·ä¸€æ¬¡å¥–ï¼Œå› æ­¤é‡åˆ°å·²ç»è·å¥–çš„äººå°±æŸ¥çœ‹ä¸‹ä¸€ä¸ªã€‚æŠ½å¥–ç³»ç»Ÿè¦çœŸè¿™ä¹ˆå†™ï¼Œæˆ‘å°±è½¬ä»–ä¸ªåƒç™¾æ¥æ¬¡â€¦..\nå…ˆç”¨ä¸€ä¸ªvectorå­˜å‚¨è½¬å‘åå•ï¼Œç„¶åä»èµ·å§‹åºå·å¼€å§‹ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªéè·å¥–è€…ï¼ŒåŠ å…¥è·å¥–è€…seté›†ï¼Œå°†è¯¥è·å¥–è€…åºå·+Né‡å¤ä¸Šè¿°æ­¥éª¤ã€‚\næ²¡æœ‰è·å¥–è€…ï¼ˆm&lt;sï¼‰æ—¶å°±â€œKeep goingâ€¦â€\n\nğŸ#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, s;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;\n    vector&lt;string&gt; nick(m);\n    for (auto &amp;t: nick)\n        cin &gt;&gt; t;\n    set&lt;string&gt; winner;\n    for (int i = s - 1; i &lt; m; i += n)\n    {\n        while (i &lt; m &amp;&amp; winner.find(nick[i]) != winner.end()) ++i;\n        if (i != m)\n        {\n            winner.insert(nick[i]);\n            cout &lt;&lt; nick[i] &lt;&lt; endl;\n        }\n    }\n    if (m &lt; s) cout &lt;&lt; \"Keep going...\";\n}\n","slug":"ã€Œ1124ã€Raffle-for-Weibo-Followers","date":"2022-11-22T16:27:16.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"84f574e4cfc0fc23647f1cff6dfd2d15","title":"ã€Œ1123ã€Is It a Complete AVL Tree","content":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.\n\n\n\n\n\n\n\n\n\n\n\n\nNow given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤Â 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, printÂ YESÂ if the tree is complete, orÂ NOÂ if not.\nSample Input 1:5\n88 70 61 63 65\n\nSample Output 1:70 63 88 61 65\nYES\n\nSample Input 2:8\n88 70 61 96 120 90 65 68\n\nSample Output 2:88 65 96 61 70 90 120 68\nNO\n\n\nÎ©åˆè§AVLï¼ç¬¬äºŒæ¬¡çœ‹å®ƒæ¯”ç¬¬ä¸€æ¬¡äº²åˆ‡å¤šäº†ï¼Œä½†è¿˜æ˜¯èŠ±äº†ä¸å°‘æ—¶é—´ï¼Œè€Œä¸”æ˜¯çœ‹ç€ä¹‹å‰çš„åšå®¢ç çš„ã€‚å…³äºAVLæ—‹è½¬çš„è¯¦ç»†ä»‹ç»è¯·è§ã€Œ1066ã€Root of AVL Treeã€‚\nè¿™æ¬¡éœ€è¦æˆ‘ä»¬è¾“å‡ºAVLçš„å±‚æ¬¡éå†ï¼ŒåŒæ—¶åˆ¤æ–­æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼ˆç¼–å·ä¸æ»¡äºŒå‰æ ‘ç›¸åŒï¼‰ã€‚As beforeï¼Œç”¨pairå¯¹å­˜å‚¨å·¦å³å­èŠ‚ç‚¹ï¼ŒåŒæ—¶å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘é«˜åº¦ï¼Œéƒ½é€šè¿‡mapè¿›è¡Œç´¢å¼•ã€‚\nå¯¹æ¯ä¸€ä¸ªæ–°èŠ‚ç‚¹çš„æ’å…¥ï¼Œå…ˆé€šè¿‡é€’å½’æ‰¾åˆ°æ’å…¥ä½ç½®ï¼Œç„¶ååœ¨é€’å½’å›é€€çš„è¿‡ç¨‹ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªå·¦å³å­æ ‘é«˜åº¦å·®&gt;1çš„èŠ‚ç‚¹ï¼Œè¿›è¡ŒAVLæ—‹è½¬è°ƒæ•´åŒæ—¶æ›´æ–°ç›¸åº”çš„é«˜åº¦ã€‚æœ€åBFSå‡ºå±‚æ¬¡éå†ï¼Œé¡ºä¾¿è®°å½•æ¯ä¸ªèŠ‚ç‚¹ç¼–å·ï¼ˆ=çˆ¶èŠ‚ç‚¹ç¼–å·*2ã€å·¦å­èŠ‚ç‚¹ã€‘/çˆ¶èŠ‚ç‚¹ç¼–å·*2+1ã€å³å­èŠ‚ç‚¹ã€‘ï¼‰ï¼Œçœ‹æœ€åä¸€ä¸ªèŠ‚ç‚¹ç¼–å·æ˜¯å¦=Nï¼Œä¸ç­‰äºè¯´æ˜ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\n#define diff(root) (depth[sons[root].first]-depth[sons[root].second])\n#define depth(root) (max(depth[sons[root].first],depth[sons[root].second])+1)\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; sons;\nmap&lt;int, int&gt; depth;\n\nvoid insert(int &amp;root, int num)\n{\n    if (root == 0)\n    {\n        root = num, depth[num] = 1;\n        return;\n    }\n    if (root &gt; num) insert(sons[root].first, num);\n    else insert(sons[root].second, num);\n    depth[root] = depth(root);\n    if (abs(diff(root)) &lt; 2) return;\n    bool isLeft = diff(root) &gt; 0;\n    int &amp;so = isLeft ? sons[root].first : sons[root].second,\n        &amp;si = isLeft ? sons[root].second : sons[root].first,\n        &amp;sso = isLeft ? sons[so].first : sons[so].second,\n        &amp;ssi = isLeft ? sons[so].second : sons[so].first,\n        tmp = so;\n    // åˆ¤æ–­æ’å…¥èŠ‚ç‚¹æ˜¯å¦ä½äºå­æ ‘çš„åŒä¾§\n    if ((diff(root) ^ diff(so)) &gt; 0)\n    {\n        so = ssi, ssi = root, root = tmp;\n        depth[ssi] = depth(ssi);\n        depth[root] = depth(root);\n    }\n    else\n    {\n        int &amp;ssso = isLeft ? sons[ssi].first : sons[ssi].second,\n            &amp;sssi = isLeft ? sons[ssi].second : sons[ssi].first,\n            t1 = ssso, t2 = sssi;\n        ssso = so, sssi = root, so = t2, root = ssi, ssi = t1;\n        // æ³¨æ„é«˜åº¦æ›´æ–°é¡ºåºè‡ªä¸‹å¾€ä¸Š\n        depth[ssso] = depth(ssso);\n        depth[sssi] = depth(sssi);\n        depth[root] = depth(root);\n    }\n}\n\nint main()\n{\n    int n, m, r;\n    cin &gt;&gt; n &gt;&gt; r;\n    for (int i = 1; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        insert(r, m);\n    }\n    bool flag = false;\n    vector&lt;pair&lt;int, int&gt;&gt; crt{{r, 1}}, nxt;\n    int end = -1;\n    while (!crt.empty())\n    {\n        for (auto &amp;k: crt)\n        {\n            printf(\"%s%d\", flag ? \" \" : (flag = true, \"\"), k.first);\n            if (sons[k.first].first)\n                nxt.emplace_back(sons[k.first].first, 2 * k.second);\n            if (sons[k.first].second)\n                nxt.emplace_back(sons[k.first].second, 2 * k.second + 1);\n            end = k.second;\n        }\n        crt = std::move(nxt);\n        nxt = vector&lt;pair&lt;int, int&gt;&gt;();\n    }\n    printf(end == n ? \"\\nYES\" : \"\\nNO\");\n}\n\n","slug":"ã€Œ1123ã€Is-It-a-Complete-AVL-Tree","date":"2022-11-22T15:46:11.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,BFS,Tree,AVL","author_index":"Starlit Rover"},{"id":"033ed2c7a1bcdb67e313290ff8557d56","title":"ã€Œ1122ã€Hamiltonian Cycle","content":"The â€œHamilton cycle problemâ€ is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a â€œHamiltonian cycleâ€.\nIn this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integersÂ , the number of vertices, andÂ M, the number of edges in an undirected graph. ThenÂ MÂ lines follow, each describes an edge in the formatÂ Vertex1 Vertex2, where the vertices are numbered from 1 toÂ N. The next line gives a positive integerÂ KÂ which is the number of queries, followed byÂ KÂ lines of queries, each in the format:\n\nwhereÂ nÂ is the number of vertices in the list, andÂ â€‹â€™s are the vertices on a path.\nOutput Specification:For each query, print in a lineÂ YESÂ if the path does form a Hamiltonian cycle, orÂ NOÂ if not.\nSample Input:6 10\n6 2\n3 4\n1 5\n2 5\n3 1\n4 1\n1 6\n6 3\n1 2\n4 5\n6\n7 5 1 4 3 6 2 5\n6 5 1 4 3 6 2\n9 6 2 1 6 3 4 5 2 6\n4 1 2 5 1\n7 6 1 3 4 5 2 6\n7 6 1 2 5 4 3 1\n\nSample Output:YES\nNO\nNO\nNO\nYES\nNO\n\n\nÎ©ç»™å‡ºä¸€ä¸ªæ— å‘å›¾ï¼Œå†ç»™å‡ºå‡ ä¸ªé¡¶ç‚¹åºåˆ—ï¼Œåˆ¤æ–­æ˜¯å¦æ„æˆå“ˆå¯†å°”é¡¿å›è·¯ã€‚\nå“ˆå¯†å°”é¡¿å›è·¯æŒ‡ï¼Œæ¯ä¸ªé¡¶ç‚¹éƒ½å‡ºç°ä¸”ä»…å‡ºç°ä¸€æ¬¡ï¼Œé‚£ä¹ˆè¿™ä¸ªé¡¶ç‚¹åºåˆ—éœ€è¦æ»¡è¶³ï¼š\n\nèµ·ç‚¹å’Œç»ˆç‚¹ç›¸åŒ\n\né™¤äº†ç»ˆç‚¹ï¼Œå…¶ä»–èŠ‚ç‚¹å¿…é¡»äº’ä¸ç›¸åŒ\n\né¡¶ç‚¹æ€»æ•°åº”ä¸ºN+1ï¼ˆç»“åˆ2â‡’æ¯ä¸ªé¡¶ç‚¹å‡ºç°ä¸”ä»…å‡ºç°ä¸€æ¬¡ï¼‰\n\nä»»æ„ç›¸é‚»èŠ‚ç‚¹ä¹‹é—´å¿…é¡»å­˜åœ¨è¾¹\n\n\næ ¹æ®ä»¥ä¸Šåˆ¤æ®è®¾ç½®ä¸€ä¸ªboolå‘é‡ï¼Œå¦‚æœæœ‰é‡å¤å‡ºç°çš„é¡¶ç‚¹å°±å°†flagç½®falseï¼Œå¦‚æœå°šæœªå‡ºç°å°±å°†å…¶æ ‡è®°ä¸ºtrueï¼ŒåŒæ—¶++cntã€‚æœ€åæ ¹æ® flag&amp;&amp;èµ·ç‚¹==ç»ˆç‚¹&amp;&amp;cnt==n æ¥æ–­å®šæ˜¯å¦ä¸ºå“ˆå¯†å°”é¡¿å›è·¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, s, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;bool&gt;&gt; edge(n + 1, vector&lt;bool&gt;(n + 1, false));\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        edge[a][b] = edge[b][a] = true;\n    }\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        bool flag = true;\n        int cnt = 0, pre;\n        vector&lt;bool&gt; show(n + 1, false);\n        cin &gt;&gt; a &gt;&gt; s, pre = s;\n        for (int j = 1; j &lt; a; ++j)\n        {\n            cin &gt;&gt; k;\n            if (show[k] || !edge[pre][k]) flag = false;\n            else show[k] = true, ++cnt;\n            pre = k;\n        }\n        if (flag &amp;&amp; s == k &amp;&amp; cnt == n) printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n}\n","slug":"ã€Œ1122ã€Hamiltonian-Cycle","date":"2022-11-22T07:14:15.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph","author_index":"Starlit Rover"},{"id":"682e37dc1f7927fd1308b08627948fb9","title":"ã€Œ1121ã€Damn Single","content":"â€œDamn Single (å•èº«ç‹—)â€ is the Chinese nickname for someone who is being single. You are supposed to find those who are alone in a big party, so they can be taken care of.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤Â 50,000), the total number of couples. Then N lines of the couples follow, each gives a couple of IDâ€™s which are 5-digit numbers (i.e. from 00000 to 99999). After the list of couples, there is a positive integer M (â‰¤Â 10,000) followed by M IDâ€™s of the party guests. The numbers are separated by spaces. It is guaranteed that nobody is having bigamous marriage (é‡å©š) or dangling with more than one companion.\nOutput Specification:First print in a line the total number of lonely guests. Then in the next line, print their IDâ€™s in increasing order. The numbers must be separated by exactly 1 space, and there must be no extra space at the end of the line.\nSample Input:3\n11111 22222\n33333 44444\n55555 66666\n7\n55555 44444 10000 88888 22222 11111 23333\n\nSample Output:5\n10000 23333 44444 55555 88888\n\n\nÎ©Damn Single!\næ ¹æ®ç»™å‡ºçš„coupleä¿¡æ¯ï¼Œåˆ—ä¸¾å‡ºæ‰€æœ‰å‚åŠ partyçš„å•èº«äººå£«ï¼ŒåŒ…æ‹¬æ²¡æœ‰å’Œä¼´ä¾£ä¸€èµ·æ¥çš„ï¼Œä»¥ä¾¿ç»™ä»–ä»¬æä¾›ç‰¹æ®Šå…³ç…§ï¼š)\nåƒè¿™ç§ç¼–å·ä¸å¤ªå¤§çš„é¢˜ç›®ï¼Œç›´æ¥å¼€æ»¡æ•°ç»„ï¼Œç”¨æ¡¶çš„æ€æƒ³å»è§£å†³ã€‚é¦–å…ˆç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨æ‰€æœ‰çš„coupleä¿¡æ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸º-1ï¼›ç„¶åç”¨ä¸€ä¸ªå¸ƒå°”å‘é‡æ ‡è®°éœ€è¦ç‰¹æ®Šå…³ç…§çš„å¯¹è±¡ï¼Œå¦‚æœå‘ç°ä¼´ä¾£å·²åœ¨careå¯¹è±¡ä¸­ï¼Œåˆ™å°†å…¶ä¼´ä¾£ç½®falseã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;int&gt; mate(int(1e5), -1);\n    vector&lt;bool&gt; care(int(1e5), false);\n    int n, u, v, cnt = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; u &gt;&gt; v;\n        mate[u] = v;\n        mate[v] = u;\n    }\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; u;\n        if (mate[u] == -1 || !care[mate[u]])\n            care[u] = true, ++cnt;\n        else care[mate[u]] = false, --cnt;\n    }\n    printf(\"%d\\n\", cnt);\n    bool flag = false;\n    for (int i = 0; i &lt; int(1e5); ++i)\n        if (care[i])\n        {\n            if (flag) printf(\" \");\n            else flag = true;\n            printf(\"%05d\", i);\n        }\n}\n","slug":"ã€Œ1121ã€Damn-Single","date":"2022-11-22T05:57:31.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"8e095d3dd038417b28cb9cd069dbad37","title":"ã€1120ã€Friend Numbers","content":"Two integers are called â€œfriend numbersâ€ if they share the same sum of their digits, and the sum is their â€œfriend IDâ€. For example, 123 and 51 are friend numbers since 1+2+3 = 5+1 = 6, and 6 is their friend ID. Given some numbers, you are supposed to count the number of different friend IDâ€™s among them.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N. Then N positive integers are given in the next line, separated by spaces. All the numbers are less thanÂ .\nOutput Specification:For each case, print in the first line the number of different friend IDâ€™s among the given integers. Then in the second line, output the friend IDâ€™s in increasing order. The numbers must be separated by exactly one space and there must be no extra space at the end of the line.\nSample Input:8\n123 899 51 998 27 33 36 12\n\nSample Output:4\n3 6 9 26\n\n\nÎ©å¤œæ·±äººé™ä¹‹æ—¶ï¼Œé…åˆä¸€é“æ°´é¢˜æ”¾æ¾å¿ƒæƒ…æ˜¯ä½•ç­‰çš„äº«å—ï½ğŸ•‘æ‰“å¡\nä¸€ä¸ªæ•°æ‰€æœ‰ä½ä¸Šçš„æ•°å­—ä¹‹å’Œå³ä¸ºå…¶friend idï¼Œç»™å‡ºä¸€ç»„æ•°ï¼ŒæŒ‰ç…§å‡åºè¾“å‡ºæ‰€æœ‰çš„friend idsã€‚æä¸€ä¸ªsetï¼Œé€ä¸€æ’å…¥å†é€ä¸€è¾“å‡ºå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    set&lt;int&gt; id;\n    int n;\n    cin &gt;&gt; n;\n    string s;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; s;\n        int sum = 0;\n        for (auto &amp;c: s)\n            sum += c - '0';\n        id.insert(sum);\n    }\n    cout &lt;&lt; id.size() &lt;&lt; endl &lt;&lt; *id.begin();\n    for (auto it = ++id.begin(); it != id.end(); ++it)\n        cout &lt;&lt; \" \" &lt;&lt; *it;\n}\n","slug":"ã€1120ã€Friend-Numbers","date":"2022-11-21T17:53:46.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,set","author_index":"Starlit Rover"},{"id":"b5bfa4c818f558091af57c67af0a1746","title":"ã€Œ1119ã€Pre- and Post-order Traversals","content":"Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences, or preorder and inorder traversal sequences. However, if only the postorder and preorder traversal sequences are given, the corresponding tree may no longer be unique.\nNow given a pair of postorder and preorder traversal sequences, you are supposed to output the corresponding inorder traversal sequence of the tree. If the tree is not unique, simply output any one of them.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤Â 30), the total number of nodes in the binary tree. The second line gives the preorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, first printf in a lineÂ YesÂ if the tree is unique, orÂ NoÂ if not. Then print in the next line the inorder traversal sequence of the corresponding binary tree. If the solution is not unique, any answer would do. It is guaranteed that at least one solution exists. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input 1:7\n1 2 3 4 6 7 5\n2 6 7 4 5 3 1\n\nSample Output 1:Yes\n2 1 6 4 7 3 5\n\nSample Input 2:4\n1 2 3 4\n2 4 3 1\n\nSample Output 2:No\n2 1 3 4\n\n\nÎ©ç»™å‡ºä¸€æ£µäºŒå‰æ ‘çš„å‰åºå’Œåç»­éå†ï¼Œä¸”æ¯ä¸ªèŠ‚ç‚¹ç¼–å·å”¯ä¸€ï¼Œè¯·åˆ¤æ–­è¿™æ£µäºŒå‰æ ‘æ˜¯å¦å”¯ä¸€ï¼Œéšåè¾“å‡ºè¿™æ£µäºŒå‰æ ‘çš„ä¸­åºéå†ã€‚å¦‚æœä¸å”¯ä¸€åˆ™è¾“å‡ºä»»æ„ä¸€ç§æƒ…å†µã€‚\nä¸ºä»€ä¹ˆå•é å‰åºå’Œåç»­éå†ç»“æœä¸èƒ½ç¡®å®šå”¯ä¸€äºŒå‰æ ‘å‘¢ï¼Ÿå¯¹äºæ ‘çš„éå†é—®é¢˜ï¼Œæˆ‘æ›¾ç»è¯´è¿‡æœ€é‡è¦çš„è«è¿‡äºå¯¹å·¦å³å­æ ‘åŒºé—´çš„åˆ’åˆ†ã€‚å‰åºéå†å¯ä»¥å¾—çŸ¥Påé¢çš„èŠ‚ç‚¹å¯èƒ½æ˜¯Pçš„å­èŠ‚ç‚¹ï¼Œåç»­éå†å‘Šè¯‰æˆ‘ä»¬På‰é¢çš„èŠ‚ç‚¹å¯èƒ½æ˜¯Pçš„å­èŠ‚ç‚¹ï¼Œä¸¤è€…çš„äº¤é›†å³ä¸ºPçš„æ‰€æœ‰å­èŠ‚ç‚¹ã€‚åœ¨å¾—åˆ°æ‰€æœ‰å­èŠ‚ç‚¹çš„éå†åºåˆ—åï¼Œæˆ‘ä»¬éœ€è¦åˆ’åˆ†å·¦å³å­æ ‘ï¼Œè€Œä¸ç¡®å®šæ€§çš„é—®é¢˜å°±åœ¨è¿™ï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹åªæœ‰ä¸€è¾¹çš„å­æ ‘ï¼Œé‚£ä¹ˆä½ å°±æ— æ³•ç¡®å®šå®ƒæ˜¯å·¦å­æ ‘è¿˜æ˜¯å³å­æ ‘ï¼šABCï¼ŒBCAï¼Œä½†ä½ æ— æ³•å¾—çŸ¥ADï¼ŒDAä¸­çš„Dåˆ°åº•æ˜¯Bè¿˜æ˜¯Cã€‚\nç”±äºæœ€ç»ˆçš„ä¸­åºéå†å¯ä»¥è¾“å‡ºä»»æ„æƒ…å†µï¼Œäºæ˜¯æˆ‘ä»¬éƒ½å‡è®¾ä¸€ä¸ªèŠ‚ç‚¹å¦‚æœå­˜åœ¨å­èŠ‚ç‚¹é‚£ä¹ˆå¿…æœ‰å·¦å­æ ‘ã€‚ä»è€Œåœ¨æˆ‘ä»¬è·å¾—å­èŠ‚ç‚¹åŒºé—´åï¼Œæˆ‘ä»¬å¯ä»¥è‚¯å®šç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹å¿…ç„¶æ˜¯å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶ååœ¨åç»­éå†ç»“æœä¸­æ‰¾åˆ°è¯¥èŠ‚ç‚¹çš„ä½ç½®ï¼Œä¸¤è€…ä¸€å¤¹å°±æ˜¯å·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹åŒºé—´ï¼ŒåŒæ—¶å…¶ä½™éƒ¨åˆ†å°±æ˜¯å³å­æ ‘ã€‚ç”±æ­¤é€’å½’ä¸‹å»ï¼Œåœ¨åˆ†ææ ‘ç»“æ„çš„åŒæ—¶ï¼Œç›´æ¥å°†ç”Ÿæˆä¸­åºéå†ã€‚\néå†è¿‡ç¨‹ä¸­åªè¦æœ‰ä¸€æ£µå­æ ‘çš„å¼€å§‹ç´¢å¼•&gt;æœ«ç«¯ç´¢å¼•å°±è¯´æ˜å…¶çˆ¶èŠ‚ç‚¹åªæœ‰å·¦å­æ ‘ï¼ˆå¼€å§‹ç´¢å¼•=æœ«ç«¯ç´¢å¼• è¡¨æ˜æ— å­èŠ‚ç‚¹ï¼‰ï¼Œä»è€Œå¯ä»¥å¾—å‡ºä¸å”¯ä¸€çš„ç»“è®ºã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre, post, in;\n\nbool inOrder(int pre_b, int pre_e, int post_b, int post_e)\n{\n    if (pre_b == pre_e)\n    {\n        in.push_back(pre[pre_b]);\n        return true;\n    }\n    else if (pre_b &gt; pre_e) return false;\n    int bias = (find(post.begin(), post.end(), pre[pre_b + 1]) - post.begin()) - post_b;\n    bool left = inOrder(pre_b + 1, pre_b + 1 + bias, post_b, post_b + bias);\n    in.push_back(pre[pre_b]);\n    bool right = inOrder(pre_b + bias + 2, pre_e, post_b + bias + 1, post_e - 1);\n    return left &amp;&amp; right;\n}\n\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    pre.resize(n), post.resize(n);\n    for (auto &amp;k: pre)\n        cin &gt;&gt; k;\n    for (auto &amp;k: post)\n        cin &gt;&gt; k;\n    if (inOrder(0, n - 1, 0, n - 1))\n        cout &lt;&lt; \"Yes\\n\";\n    else cout &lt;&lt; \"No\\n\";\n    printf(\"%d\", in[0]);\n    for (int i = 1; i &lt; in.size(); ++i)\n        printf(\" %d\", in[i]);\n    printf(\"\\n\");\n}\n","slug":"ã€Œ1119ã€Pre-and-Post-order-Traversals","date":"2022-11-21T17:20:53.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"d6253ae8573741ec535150562a0d9517","title":"ã€1118ã€Birds in Forest","content":"Some scientists took pictures of thousands of birds in a forest. Assume that all the birds appear in the same picture belong to the same tree. You are supposed to help the scientists to count the maximum number of trees in the forest, and for any pair of birds, tell if they are on the same tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive numberÂ  which is the number of pictures. ThenÂ NÂ lines follow, each describes a picture in the format:\n\n\nwhereÂ KÂ is the number of birds in this picture, andÂ Biâ€‹â€™s are the indices of birds. It is guaranteed that the birds in all the pictures are numbered continuously from 1 to some number that is no more thanÂ .\nAfter the pictures there is a positive numberÂ  which is the number of queries. ThenÂ QÂ lines follow, each contains the indices of two birds.\nOutput Specification:For each test case, first output in a line the maximum possible number of trees and the number of birds. Then for each query, print in a lineÂ YesÂ if the two birds belong to the same tree, orÂ NoÂ if not.\nSample Input:4\n3 10 1 2\n2 3 4\n4 1 5 7 8\n3 9 6 4\n2\n10 5\n3 7\n\nSample Output:2 10\nYes\nNo\n\n\nÎ©ç»™å‡ºNå¼ å›¾ä»¥åŠæ¯å¼ å›¾ä¸­é¸Ÿçš„ç¼–å·ï¼Œæ¯å¼ å›¾ä¸­åªæœ‰ä¸€æ£µæ ‘ï¼Œè¾“å‡ºè¿™äº›ç…§ç‰‡ä¸­å¯èƒ½æœ‰å‡ æ£µæ ‘ï¼Œæœ‰å‡ åªé¸Ÿï¼ŒåŒæ—¶åˆ¤æ–­ç»™å‡ºçš„å‡ å¯¹é¸Ÿæ˜¯å¦åœ¨åŒä¸€æ£µæ ‘ä¸Šã€‚\næœ¬è´¨ä¸Šå°±æ˜¯æ±‚è¿é€šåˆ†å›¾æ•°ï¼Œç”±äºä¸çŸ¥é“é¸Ÿçš„ä¸ªæ•°ï¼Œç›´æ¥å¼€ä¸€ä¸ªçš„æ•°ç»„ï¼Œæ ‡è®°å‡ºç°è¿‡çš„é¸Ÿç¼–å·ï¼Œæ¯æ¬¡éƒ½å°†åŒä¸€å¼ ç…§ç‰‡ä¸­çš„é¸Ÿæ‰€åœ¨ç»„ç»‡çš„å¤´å¤´æŒ‡å‘ç¬¬ä¸€åªé¸Ÿçš„å¤´å¤´ï¼Œæœ€åçœ‹æ€»å…±æœ‰å‡ ä¸ªå¤´å¤´å³å¯ã€‚\nisRootå˜é‡æ ‡è®°å·²ç»æ‰¾åˆ°çš„å¤´å¤´é¸Ÿï¼Œé¿å…é‡å¤è®¡æ•°ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nint main()\n\n{\n    int n, m, k, r, t = 0, b;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; belong(1e4 + 1);\n    vector&lt;bool&gt; flag(1e4 + 1, false), isRoot(1e4 + 1, false);\n    iota(belong.begin(), belong.end(), 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m &gt;&gt; r, flag[r] = true;\n        while (belong[r] != r) r = belong[r];\n        for (int j = 1; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k, flag[k] = true;\n            while (k != belong[k]) k = belong[k];\n            belong[k] = r;\n        }\n    }\n    for (int i = 0; i &lt; 1e4 + 1; ++i)\n    {\n        if (!flag[i]) continue;\n        k = belong[i], b = i;\n        while (k != belong[k]) k = belong[k];\n        if (!isRoot[k])\n            isRoot[k] = true, ++t;\n        belong[i] = k;\n    }\n    printf(\"%d %d\\n\", t, b);\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m &gt;&gt; k;\n        printf(belong[m] == belong[k] ? \"Yes\\n\" : \"No\\n\");\n    }\n    system(\"pause\");\n}\n","slug":"ã€1118ã€Birds-in-Forest","date":"2022-11-21T08:30:10.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,å¹¶æŸ¥é›†","author_index":"Starlit Rover"},{"id":"10c9109a3fadc3f6ba7135ecb14ceb9c","title":"ã€Œ1117ã€Eddington Number","content":"British astronomer Eddington liked to ride a bike. It is said that in order to show off his skill, he has even defined an â€œEddington numberâ€,Â EÂ â€“ that is, the maximum integerÂ EÂ such that it is forÂ EÂ days that one rides more thanÂ EÂ miles. Eddingtonâ€™s ownÂ EÂ was 87.\nNow given everydayâ€™s distances that one rides forÂ NÂ days, you are supposed to find the correspondingÂ EÂ (â‰¤N).\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ , the days of continuous riding. ThenÂ NÂ non-negative integers are given in the next line, being the riding distances of everyday.\nOutput Specification:For each case, print in a line the Eddington number for theseÂ NÂ days.\nSample Input:10\n6 7 6 9 3 10 8 2 7 8\n\nSample Output:6\n\n\nÎ©æ‘˜è¦ï¼šthe maximum integerÂ EÂ such that it is forÂ EÂ days that one rides more thanÂ EÂ miles. \nç»™å‡ºæ¯å¤©çš„éª‘è½¦é‡Œç¨‹ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°æœ€å¤§çš„Eä½¿å¾—æœ‰Eå¤©ï¼ˆä¸å¿…è¿ç»­ï¼‰çš„é‡Œç¨‹è¶…è¿‡Eã€‚\nè¿™é‡Œæœ‰ä¸¤ä¸ªå¤§å°å…³ç³»å®¹æ˜“æ··æ·†ï¼šï¼ˆé‡Œç¨‹&gt;Eçš„å¤©æ•°ï¼‰â‰¥ Eã€‚\nç”±æ­¤æˆ‘ä»¬å¯ä»¥å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š\n\nå…¶ä¸­ä»£è¡¨é‡Œç¨‹&gt;çš„å¤©æ•°ï¼Œä»£è¡¨é‡Œç¨‹æ•°ä¸ºçš„å¤©æ•°ã€‚ä»è€Œæˆ‘ä»¬åªè¦å…ˆç»Ÿè®¡å‡ºé‡Œç¨‹&gt;Nçš„å¤©æ•°å’Œå³å¯ï¼Œç„¶åä»Nï½0æ‰¾åˆ°ç¬¬ä¸€ä¸ªçš„å¤©æ•°å°±æ˜¯ç­”æ¡ˆã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n;\n    map&lt;int, int&gt; cnt;\n    vector&lt;int&gt; edt(n + 1, 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        cnt[m] += 1;\n        edt[n] += m &gt; n;\n    }\n    for (k = n; k &gt; 0 &amp;&amp; edt[k] &lt; k; --k)\n        edt[k - 1] = edt[k] + cnt[k];\n    cout &lt;&lt; k;\n}\n","slug":"ã€Œ1117ã€Eddington-Number","date":"2022-11-21T03:24:30.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"åŠ¨æ€è§„åˆ’,Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"1b3a87c044266e0bb63bda9873a9376f","title":"ã€Œ1116ã€Come on! Let's C","content":"â€œLetâ€™s Câ€ is a popular and fun programming contest hosted by the College of Computer Science and Technology, Zhejiang University. Since the idea of the contest is for fun, the award rules are funny as the following:\n\n\nThe Champion will receive a â€œMystery Awardâ€ (such as a BIG collection of studentsâ€™ research papersâ€¦).\n\n\n\nThose who ranked as a prime number will receive the best award â€“ the Minions (å°é»„äºº)!\n\n\n\nEveryone else will receive chocolates.\n\n\n\nGiven the final ranklist and a sequence of contestant IDâ€™s, you are supposed to tell the corresponding awards.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integer , the total number of contestants. Then N lines of the ranklist follow, each in order gives a contestantâ€™s ID (a 4-digit number). After the ranklist, there is a positive integer K followed by K query IDâ€™s.\nOutput Specification:For each query, print in a lineÂ ID: awardÂ where the award isÂ Mystery Award, orÂ Minion, orÂ Chocolate. If the ID is not in the ranklist, printÂ Are you kidding?Â instead. If the ID has been checked before, printÂ ID: Checked.\nSample Input:6\n1111\n6666\n8888\n1234\n5555\n0001\n6\n8888\n0001\n1111\n2222\n8888\n2222\n\nSample Output:8888: Minion\n0001: Chocolate\n1111: Mystery Award\n2222: Are you kidding?\n8888: Checked\n2222: Are you kidding?\n\n\nÎ©ä¸ºä¸€ä¸ªæ¯”èµ›çš„ç”¨æˆ·æä¾›è·å¥–æŸ¥è¯¢æœåŠ¡ï¼Œè§„åˆ™å¦‚ä¸‹ï¼š\n\nç¬¬ä¸€åè·å¾—â€Mystery Awardâ€\n\næ’åä¸ºç´ æ•°çš„ç”¨æˆ·è·å¾—å°é»„äººä¸€åª\n\nå…¶ä»–äººè·å¾—å·§å…‹åŠ›\n\næ²¡å‚ä¸çš„ç”¨æˆ·è®©ä»–gun\n\n\næ³¨æ„åˆ°nä¸è¶…è¿‡10000ï¼Œå› æ­¤ç›´æ¥æ‰“ç´ æ•°è¡¨ï¼Œå»ºç«‹ä¸€ä¸ªvector&lt;bool&gt;(n+1,true)ï¼Œç”¨å¤§ç­›æ³•å°†éç´ æ•°ç½®falseã€‚ç„¶åç”¨mapå»ºç«‹idå’Œrankä¹‹é—´çš„æ˜ å°„ï¼ŒåŒæ—¶é™„ä¸€ä¸ªboolå˜é‡è®°å½•æ˜¯å¦å·²ç»æŸ¥è¯¢è¿‡ã€‚æŒ‰ç…§ ç”¨æˆ·æ˜¯å¦å‚èµ›â†’æ˜¯å¦å·²ç»æ£€æŸ¥â†’æ˜¯å¦ç¬¬ä¸€â†’æ˜¯å¦æ˜¯ç´ æ•°æ’åä¾æ¬¡æ£€æŸ¥å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, t = 2;\n    scanf(\"%d\", &amp;n);\n    vector&lt;bool&gt; isPrime(n + 1, true);\n    for (int i = 2; i &lt; sqrt(n) + 1; t = ++i)\n    {\n        if (!isPrime[i]) continue;\n        while ((t += i) &lt;= n) isPrime[t] = false;\n    }\n    map&lt;string, pair&lt;int, bool&gt;&gt; rank;\n    string id(4, 0);\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        scanf(\"%s\", &amp;id[0]);\n        rank[id] = {i, false};\n    }\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s\", &amp;id[0]);\n        printf(\"%s: \", id.c_str());\n        if (rank.find(id) == rank.end())\n        {\n            printf(\"Are you kidding?\\n\");\n            continue;\n        }\n        else if (rank[id].second) printf(\"Checked\\n\");\n        else if (rank[id].first == 1) printf(\"Mystery Award\\n\");\n        else if (isPrime[rank[id].first]) printf(\"Minion\\n\");\n        else printf(\"Chocolate\\n\");\n        rank[id].second = true;\n    }\n}\n","slug":"ã€Œ1116ã€Come-on-Let-s-C","date":"2022-11-20T12:14:14.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,prime","author_index":"Starlit Rover"},{"id":"4fd53e230858db5e382512fd3cfbd1a2","title":"ã€Œ1115ã€Counting Nodes in a Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the nodeâ€™s key.\nThe right subtree of a node contains only nodes with keys greater than the nodeâ€™s key.\nBoth the left and right subtrees must also be binary search trees.\n\nInsert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤1000) which is the size of the input sequence. Then given in the next line are theÂ NÂ integers inÂ [âˆ’1000,1000]Â which are supposed to be inserted into an initially empty binary search tree.\nOutput Specification:For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format:\nn1 + n2 = n\n\nwhereÂ n1Â is the number of nodes in the lowest level,Â n2Â is that of the level above, andÂ nÂ is the sum.\nSample Input:10\n25 30 42 16 20 20 35 -5 28 22\n\nSample Output:3 + 4 = 7\n\n\nÎ©æŒ‰ç…§ç»™å®šæ•°ç»„æ„å»ºäºŒå‰æœç´¢æ ‘ï¼Œç„¶åè¾“å‡ºæœ€ä½ä¸¤å±‚èŠ‚ç‚¹ä¸ªæ•°ï¼Œä»¥åŠä¸¤è€…ä¹‹å’Œã€‚\nä¸æ˜¯å¾ˆéš¾ï¼Œç”±äºæ•°ç»„ä¸­çš„å€¼å¹¶ä¸æ˜¯ä¸¤ä¸¤ä¸åŒçš„ï¼Œå› æ­¤ä¸èƒ½ç›´æ¥ç”¨å€¼å½“ç´¢å¼•å»æŸ¥æ‰¾å­èŠ‚ç‚¹ã€‚ç›´æ¥åœ¨æ„å»ºBSTçš„è¿‡ç¨‹ä¸­ï¼Œä¸€è¾¹æ’å…¥ä¸€è¾¹è®¡æ•°æ·±åº¦ï¼Œæœ€åå°†ç›¸åº”æ·±åº¦çš„èŠ‚ç‚¹ä¸ªæ•°+1ï¼Œæœ€åè¾“å‡ºæœ€å¤§ä¸¤ä¸ªæ·±åº¦çš„èŠ‚ç‚¹ä¸ªæ•°å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, root = 0;\n    cin &gt;&gt; n;\n    map&lt;int, int, greater&lt;&gt;&gt; cnt{{1, 1}};\n    vector&lt;pair&lt;int, int&gt;&gt; sons(n, {-1, -1});\n    vector&lt;int&gt; value(n);\n    cin &gt;&gt; value[0];\n    for (int i = 1; i &lt; n; ++i)\n    {\n        int depth = 0, *tmp = &amp;root;\n        cin &gt;&gt; value[i];\n        while (++depth, *tmp != -1)\n            tmp = value[i] &gt; value[*tmp] ? &amp;(sons[*tmp].second) : &amp;(sons[*tmp].first);\n        *tmp = i, cnt[depth] += 1;\n    }\n    int a = cnt.begin()-&gt;second, b = ++cnt.begin() == cnt.end() ? 0 : (++cnt.begin())-&gt;second;\n    printf(\"%d + %d = %d\", a, b, a + b);\n}\n","slug":"ã€Œ1115ã€Counting-Nodes-in-a-Binary-Search-Tree","date":"2022-11-20T11:34:27.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search,Tree","author_index":"Starlit Rover"},{"id":"65d0a1b9a75654efd6950a77e52b0ae4","title":"Lab3: page tables","content":"å…„å¼Ÿä»¬ï¼Œæˆ‘XV6åˆå›æ¥å•¦ï¼Œè¿™ä¸ªæ ç›®çš„ç°éƒ½èƒ½æŠŠäººåŸ‹äº†ï¼Œé¸½å­ç‹å®é”¤ï¼ˆå½“ç„¶ä¸æ˜¯å› ä¸ºæ‡’(ââÌ´Ì›á´—âÌ´Ì›â)ï¼‰ã€‚ä¸è¿‡è™½è¿Ÿä½†åˆ°ï¼ä¸»è¦æœ‰æ—¶å€™çœ‹å®Œæ–‡æ¡£å’Œè¯¾ç¨‹ååˆå»æå…¶ä»–é£æœºäº†ï¼Œå›æ¥æ—¶ï¼Œå‘ç°ä¸€åˆ‡å›åˆ°åŸç‚¹ã€‚è¿™å‘¨å‘ç°å†ä¸æçœŸæä¸å®Œäº†ï¼ŒLab3æ˜¯å…³äºé¡µè¡¨çš„ï¼Œæ–‡æ¡£æˆ³è¿™ã€‚ \n\n\n\n\n\n\nâ– Coding\nâ˜‘ï¸ Speed up system calls (easy)ç”±äºç”¨æˆ·åœ¨ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æ—¶éœ€è¦ä»ç”¨æˆ·ç©ºé—´è·³è½¬åˆ°å†…æ ¸ç©ºé—´ï¼Œå­˜åœ¨ä¸€å®šçš„æ—¶é—´å¼€é”€ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å»ºç«‹ä¸€æ®µç”¨æˆ·ï¼ˆåªè¯»ï¼‰å’Œå†…æ ¸å…±äº«çš„å†…å­˜ç©ºé—´æ¥é¿å…ç©ºé—´è·³è½¬çš„æ—¶é—´ï¼Œä»è€ŒåŠ é€Ÿç³»ç»Ÿè°ƒç”¨ã€‚è¿™æ˜¯ä¸€äº›æ“ä½œç³»ç»Ÿçš„å¸¸è§ä¼˜åŒ–æ–¹æ³•ï¼Œæœ¬å®éªŒå°±æ˜¯å¸Œæœ›ä½ ä»¥æ­¤æ¥ä¼˜åŒ–getpidç³»ç»Ÿè°ƒç”¨ã€‚\næˆ‘ä»¬çŸ¥é“æ¯ä¸ªç”¨æˆ·è¿›ç¨‹éƒ½æ‹¥æœ‰è‡ªå·±çš„è™šæ‹Ÿç©ºé—´ï¼Œé€šè¿‡é¡µè¡¨æŸ¥æ‰¾åˆ°ç‰©ç†åœ°å€åå†è¿›è¡Œç›¸åº”çš„æ“ä½œã€‚å› æ­¤è¿™æ®µå…±äº«ç©ºé—´çš„èµ·å§‹åœ°å€ä¹Ÿéœ€è¦è®°å½•åœ¨è¿›ç¨‹çš„é¡µè¡¨ä¸Šã€‚å®éªŒæ–‡æ¡£æŒ‡å‡ºï¼Œæ¯ä¸ªè¿›ç¨‹åœ¨åˆ›å»ºæ—¶éƒ½éœ€è¦æ–°å»ºä¸€ä¸ªåªè¯»é¡µï¼ˆshared memoryï¼‰ï¼Œå¹¶å°†å…¶ç‰©ç†åœ°å€æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€USYSCALLï¼ˆä¸€ä¸ªå·²ç»å­˜åœ¨çš„å®å®šä¹‰ï¼‰ï¼Œç„¶ååœ¨è¿™ä¸€é¡µçš„å¼€å¤´å­˜å‚¨ä¸€ä¸ªstruct usyscallï¼ˆmemlayout.hï¼‰ï¼Œå¹¶æŠŠè¿›ç¨‹pidå­˜å…¥è¿™ä¸ªç»“æ„ä½“ä¸­ï¼š\n76 struct usyscall {                       \n77   int pid;  // Process ID\n78 };     \n\næ¥ç€æˆ‘ä»¬å†æ¥ç…ç…user/ulib.cä¸­ugetpidçš„å…·ä½“å®ç°ï¼š\n144   â”‚ #ifdef LAB_PGTBL\n145   â”‚ int\n146   â”‚ ugetpid(void)\n147   â”‚ {\n148   â”‚   struct usyscall *u = (struct usyscall *)USYSCALL;\n149   â”‚   return u-&gt;pid;\n150   â”‚ }\n151   â”‚ #endif\n\nè¿™ä¸ªå‡½æ•°ç›´æ¥è®¿é—®USYSCALLåœ°å€ï¼Œé€šè¿‡æˆ‘ä»¬è®¾ç½®å¥½çš„é¡µè¡¨å°±å¯ä»¥ç›´æ¥åˆ°ç›¸åº”çš„usyscallç»“æ„ä½“å–å¾—pidï¼Œä»è€Œå¯ä»¥æ›¿ä»£åŸå…ˆéœ€è¦è¿›å…¥å†…æ ¸ç©ºé—´çš„getpidå‡½æ•°ã€‚\né¡µè¡¨ç›¸å…³æ“ä½œåŸºæœ¬éƒ½åœ¨kernel/proc.cæ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å…ˆæ‰¾åˆ°å®ç°ä¸»è¦åœ°å€æ˜ å°„çš„proc_pagetableå‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªå‡½æ•°é€šè¿‡mappageså‡½æ•°å®Œæˆäº†Trampolineï¼ˆç³»ç»Ÿè°ƒç”¨è¿”å›åœ°å€ï¼Œä¹Ÿæ˜¯ç”¨æˆ·è™šæ‹Ÿç©ºé—´ä¸­çš„æœ€é«˜åœ°å€ï¼‰å’ŒTrapframeï¼ˆå½“ä¸­æ–­æ¥ä¸´æ—¶å­˜å‚¨å½“å‰å¯„å­˜å™¨å€¼çš„åœ°å€ï¼Œå°±ä½äºTrampolineçš„ä¸‹æ–¹ï¼‰çš„æ˜ å°„ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦ç”¨mappagesæ¥å®ç°USYSCALLè™šæ‹Ÿåœ°å€çš„æ˜ å°„ï¼Œä½†é—®é¢˜æ˜¯æˆ‘ä»¬éœ€è¦çŸ¥é“ç›¸åº”çš„ç‰©ç†åœ°å€ã€‚\nç”±äºè¿™ä¸ªåªè¯»é¡µæ˜¯åœ¨è¿›ç¨‹åˆ›å»ºæ—¶äº§ç”Ÿçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¥åˆ°åˆ›å»ºè¿›ç¨‹çš„allocprocå‡½æ•°ï¼š\n100   â”‚ // Look in the process table for an UNUSED proc.\n101   â”‚ // If found, initialize state required to run in the kernel,\n102   â”‚ // and return with p-&gt;lock held.\n103   â”‚ // If there are no free procs, or a memory allocation fails, return 0.\n104   â”‚ static struct proc*\n105   â”‚ allocproc(void)\n106   â”‚ {\n107   â”‚   struct proc *p;\n108   â”‚ \n109   â”‚   for(p = proc; p &lt; &amp;proc[NPROC]; p++) {\n110   â”‚     acquire(&amp;p-&gt;lock);\n111   â”‚     if(p-&gt;state == UNUSED) {\n112   â”‚       goto found;\n113   â”‚     } else {\n114   â”‚       release(&amp;p-&gt;lock);\n115   â”‚     }\n116   â”‚   }\n117   â”‚   return 0;\n118   â”‚ \n119   â”‚ found:\n120   â”‚     ......\n\nallocprocå‡½æ•°ä»è¿›ç¨‹è¡¨ä¸­æ‰¾åˆ°ä¸€ä¸ªæœªä½¿ç”¨çš„è¿›ç¨‹å—ç„¶åä¸ºå®ƒåˆ†é…ç›¸åº”çš„é¡µè¡¨ç©ºé—´ï¼ˆkallocï¼šåˆ†é…ä¸€å—é¡µå¤§å°512Bçš„ç©ºé—´ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±åœ¨æ­¤ä»¿ç…§trapframeçš„åšæ³•æ–°å»ºåªè¯»é¡µï¼Œå¹¶å­˜å…¥pidï¼š\n130 + â”‚  // ADD\n131 + â”‚  if((p-&gt;usys = (struct usyscall *)kalloc())==0)\n132 + â”‚  {\n133 + â”‚     // kfree((void*)p-&gt;trapframe);\n134 + â”‚     freeproc(p);\n135 + â”‚     release(&amp;p-&gt;lock);\n136 + â”‚     return 0;\n137 + â”‚  }\n138 + â”‚   p-&gt;usys-&gt;pid=p-&gt;pid;\n139 + â”‚ \n140   â”‚   // An empty user page table.\n141   â”‚   p-&gt;pagetable = proc_pagetable(p);\n142   â”‚   ......\n\nç”±äºåªè¯»é¡µçš„ç‰©ç†åœ°å€è¿˜è¦åœ¨proc_pagetableä¸­ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨procç»“æ„ä½“ï¼ˆkernel/proc.hï¼‰ä¸­åŠ å…¥struct usyscall *usysã€‚\nâš ï¸ æ–°å»ºåªè¯»é¡µå¿…é¡»åœ¨è°ƒç”¨proc_pagetableï¼ˆ141ï¼‰ä¹‹å‰ï¼Œå› ä¸ºéœ€è¦ç”¨ç‰©ç†åœ°å€åšæ˜ å°„ã€‚\nç„¶åæˆ‘ä»¬å°±å¯ä»¥åœ¨proc_pagetableé‡Œå»ºç«‹æ˜ å°„äº†ï¼š\n210 + â”‚   // ADD\n211 + â”‚   if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usys), PTE_R | PTE_U) &lt; 0)\n212 + â”‚   {\n213 + â”‚     uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n214 + â”‚     uvmunmap(pagetable, TRAPFRAME, 1, 0);\n215 + â”‚     uvmfree(pagetable, 0);\n216 + â”‚     return 0;\n217 + â”‚   }\n218 + â”‚\n219   â”‚   return pagetable;\n220   â”‚ }\n\nâš ï¸æƒé™æ˜¯åªè¯»ï¼ˆPTE_Rï¼‰ï¼ŒåŒæ—¶åœ¨ç”¨æˆ·ç©ºé—´å†…è¿è¡Œï¼ˆPTE_Uï¼‰ã€‚å¦‚æœmapå¤±è´¥å°±éœ€è¦è§£é™¤å‰é¢TRAMPOLINEå’ŒTRAPFRAMEçš„æ˜ å°„ã€‚\næœ€åä¸è¦å¿˜è®°åœ¨freeprocä¸­é‡Šæ”¾åˆ†é…æ¥çš„ç‰©ç†ç©ºé—´ï¼š\n168 + â”‚   if(p-&gt;usys)\n169 + â”‚     kfree((void*)p-&gt;usys);\n170 + â”‚   p-&gt;usys = 0;\n\nè¿˜æœ‰å¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯è§£é™¤æ˜ å°„ï¼Œå¦åˆ™ä¼španicâ€”â€”â€œfreewalk: leafâ€ï¼š\n224   â”‚ void proc_freepagetable(pagetable_t pagetable, uint64 sz) {\n225   â”‚   uvmunmap(pagetable, TRAMPOLINE, 1, 0);\n226   â”‚   uvmunmap(pagetable, TRAPFRAME, 1, 0);\n227 + â”‚   uvmunmap(pagetable, USYSCALL, 1, 0);\n228   â”‚   uvmfree(pagetable, sz);\n229   â”‚ }\n\nåœ¨é‡Šæ”¾é¡µè¡¨ç©ºé—´åä¼šè°ƒç”¨freewalkå‡½æ•°æ¥æ£€æŸ¥è¯¥é¡µè¡¨ä¸­çš„æ‰€æœ‰å¶å­pteï¼ˆä¸‰çº§æ˜ å°„æœ€åçš„ç‰©ç†åœ°å€ï¼‰æ˜¯å¦æœ‰æ•ˆï¼ˆPTE_Væ˜¯å¦ä¸º1ï¼‰ï¼Œå¦‚æœå­˜åœ¨ç‰©ç†åœ°å€æœ‰æ•ˆå°±ä¼španicã€‚\n\n\nâ˜‘ï¸ Print a page tableï¼ˆeasyï¼‰å®ç°å‡½æ•°vmprintæ‰“å°å‡ºé¡µè¡¨æ ‘ã€‚é¡µè¡¨æ˜¯ä¸‰çº§æŸ¥æ‰¾ç»“æ„ï¼ŒæŠŠæ‰€æœ‰PTEæ¡ç›®çœ‹ä½œä¸€ä¸ªèŠ‚ç‚¹ï¼Œç‰©ç†åœ°å€æ‰€å¯¹åº”çš„PTEæ¡ç›®ä¸ºå…¶å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä»å®è§‚ä¸Šæ¥çœ‹æ¯ä¸ªL2 page directoryçš„ç‰©ç†åœ°å€éƒ½å¯¹åº”ä¸€ä¸ªæ·±åº¦ä¸è¶…è¿‡3çš„æ ‘ã€‚\nåªè¦çŸ¥é“äº†å¦‚ä½•åˆ¤æ–­PTEï¼ˆpage table entryï¼‰å’ŒPTå°±èƒ½å†™å‡ºé€’å½’å‡½æ•°äº†ã€‚æˆ‘ä»¬å¯ä»¥å‚è€ƒfreewalkå‡½æ•°ï¼ˆkernel/vm.cï¼‰ï¼Œå¯¹å°±æ˜¯ä¸Šé¢åˆšåˆšå‡ºç°çš„é‚£ä½è€å“¥ï¼Œå®ƒå°±æ˜¯é€šè¿‡é€’å½’éå†æ•´æ£µæ ‘æ¥æ£€æŸ¥ç‰©ç†åœ°å€æ˜¯å¦è¿˜æœ‰æ•ˆçš„ï¼š\n266   â”‚ void\n267   â”‚ freewalk(pagetable_t pagetable)\n268   â”‚ {\n269   â”‚   // there are 2^9 = 512 PTEs in a page table.\n270   â”‚   for(int i = 0; i &lt; 512; i++){\n271   â”‚     pte_t pte = pagetable[i];\n272   â”‚     if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){\n273   â”‚       // this PTE points to a lower-level page table.\n274   â”‚       uint64 child = PTE2PA(pte);\n275   â”‚       freewalk((pagetable_t)child);\n276   â”‚       pagetable[i] = 0;\n277   â”‚     } else if(pte &amp; PTE_V){\n278   â”‚       panic(\"freewalk: leaf\");\n279   â”‚     }\n280   â”‚   }\n281   â”‚   kfree((void*)pagetable);\n282   â”‚ }\n\nå¯è§å¦‚æœPTE_Væ˜¯æœ‰æ•ˆçš„ï¼Œæ²¡æœ‰ä»»ä½•æƒé™åˆ™è¯´æ˜è¿™æ˜¯ä¸€ä¸ªPTEï¼Œéœ€è¦ç»§ç»­é€’å½’ï¼Œåä¹‹åˆ™è¯´æ˜æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå³è™šæ‹Ÿåœ°å€å¯¹åº”çš„çœŸå®ç‰©ç†åœ°å€ã€‚\nç”±äºæˆ‘ä»¬éœ€è¦ç”¨ã€ ..ã€‘çš„ä¸ªæ•°æ¥è¡¨ç¤ºæ·±åº¦ï¼Œå› æ­¤åœ¨vmprintä¸­è®¾ç½®ä¸€ä¸ªstatic int depthï¼Œé€’å½’è¿›å…¥å­å‡½æ•°å‰+1ï¼Œé€€å‡ºæ—¶-1ã€‚\né¦–å…ˆåœ¨kernel/exec.cçš„execå‡½æ•°ä¸­åŠ å…¥\n143 + â”‚     if(p-&gt;pid==1)\n144 + â”‚     vmprint(p-&gt;pagetable);\n145 + â”‚ \n146   â”‚     return argc; // this ends up in a0, the first argument to main(argc, argv)\n\nå¯¹äºvmprintçš„å®ç°ï¼Œæˆ‘æ˜¯ç›´æ¥åœ¨execå‡½æ•°å‰æ’å…¥çš„ï¼Œå®éªŒæ–‡æ¡£æ¨èåœ¨kernel/vm.cé‡Œå®ç°ï¼Œé‚£å°±åˆ«å¿˜äº†åœ¨kernel/defs.hé‡Œå£°æ˜ã€‚\n12 + â”‚ void vmprint(pagetable_t pg)\n13 + â”‚ {\n14 + â”‚     static int depth = 1;\n15 + â”‚     if (depth == 1)\n16 + â”‚         printf(\"page table %p\\n\", *pg);\n17 + â”‚     for (int i = 0; i &lt; 512; ++i)\n18 + â”‚     {\n19 + â”‚         pte_t pte = pg[i];\n20 + â”‚         if (pte &amp; PTE_V)\n21 + â”‚         {\n22 + â”‚             uint64 child = PTE2PA(pte);\n23 + â”‚             for (int j = 0; j &lt; depth; ++j)\n24 + â”‚                 printf(\" ..\");\n25 + â”‚             printf(\"%d: pte %p pa %p\\n\", i, pte, child);\n26 + â”‚             if ((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0)\n27 + â”‚             {\n28 + â”‚                 depth += 1;\n29 + â”‚                 vmprint((pagetable_t) child);\n30 + â”‚             }\n31 + â”‚         }\n32 + â”‚     }\n33 + â”‚     depth -= 1;\n34 + â”‚ }\n\nç„¶åå¯åŠ¨qemuåå°±ä¼šè¾“å‡º\nhart 2 starting\nhart 1 starting\npage table 0x0000000021fda801\n ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000\n .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000\n .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000\n .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000\n .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000\n ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000\n .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000\n .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000\n .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000\n .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000\n\n\n\nâ˜‘ï¸ Detecting which pages have been accessed (hard)è¿™é‡Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨pgaccessï¼Œæ¥æ£€æŸ¥ç»™å®šç‰©ç†é¡µä»¬æ˜¯å¦è¢«è®¿é—®è¿‡ï¼ˆaccessedï¼šread or writeï¼‰ï¼Œç”¨one bitæ¥è¡¨ç¤ºä¸€ä¸ªç‰©ç†é¡µçš„ç»“æœï¼Œå¹¶å°†ç»“æœæ‹·è´è‡³ç”¨æˆ·ç©ºé—´ã€‚\npgaccessä¼šæ¥å—ä¸‰ä¸ªå‚æ•°â€”â€”ç¬¬ä¸€ä¸ªæ˜¯èµ·å§‹é¡µçš„è™šæ‹Ÿåœ°å€ï¼Œç¬¬äºŒä¸ªæ˜¯éœ€è¦å¾€åæ£€æŸ¥çš„é¡µæ•°ï¼Œæœ€åä¸€ä¸ªæ˜¯éœ€è¦å°†ç»“æœæ‹·è´åˆ°ç”¨æˆ·ç©ºé—´çš„ç‰©ç†åœ°å€ã€‚æ–‡æ¡£ä¸­è¯´æœ€åç”¨æˆ·ç©ºé—´ä¼šç”¨ä¸€ä¸ªbitmaskçš„æ•°æ®ç»“æ„å­˜å‚¨ç»“æœï¼Œå…¶ä¸­a bitä»£è¡¨1é¡µä¸”ç¬¬ä¸€é¡µä½äºæœ€ä½æœ‰æ•ˆä½ï¼Œå¦å¤–å¯ä»¥è‡ªè¡Œè®¾ç½®ä¸€ä¸ªé¡µæ•°ä¸Šé™ã€‚åœ¨å†…æ ¸ä¸­è¿è¡Œæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªuint64æ¥å­˜å‚¨ç»“æœï¼Œé‚£ä¹ˆé¡µæ•°ä¸Šé™å³ä¸º64ã€‚å¦å¤–æˆ‘ä»¬éœ€è¦è‡ªå·±åœ¨kernel/risv.hä¸­å®šä¹‰PTE_Aï¼Œè‡³äºè¿™ä¸€ä½åœ¨ç‰©ç†åœ°å€ä¸­çš„å“ªä¸€ä½åˆ™éœ€è¦æŸ¥è¯¢riscvæ‰‹å†Œï¼ˆP70ï¼‰ï¼š\n\n\nä½ å¯èƒ½ä¼šé—®PTE_Aä¸æ˜¯æˆ‘ä»¬è‡ªè¡Œå®šä¹‰çš„å—ã€‚äº‹å®ä¸Šï¼Œpgaccessåªæ˜¯å®ç°ä¸€ä¸ªæ£€æŸ¥çš„åŠŸèƒ½ï¼ŒçœŸæ­£ç½®ä½çš„æ˜¯riscvç¡¬ä»¶ã€‚æ–‡æ¡£ä¸­æŒ‡å‡ºâ€œThe RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB missâ€ï¼Œå½“CPUéœ€è¦é‚£ä¸€ç‰©ç†é¡µæ—¶ï¼Œå‘ç°Translation Look-aside Bufferæœªå‘½ä¸­ï¼ˆcacheä¸­æ²¡æœ‰ï¼‰ï¼Œå°±ä¼šå»accessè¿™ä¸€é¡µï¼Œç„¶åå°†å…¶PTE_Aç½®1ï¼Œå› æ­¤PTE_Açš„ä½ç½®æ˜¯ç”±ç¡¬ä»¶è§„å®šçš„ã€‚\næ ¹æ®ä¸Šå›¾å¯çŸ¥PTE_Aä½äºå€’æ•°ç¬¬6ä½ï¼Œé‚£ä¹ˆå°±åœ¨kernel/riscv.hä¸­åŠ å…¥\n346 + â”‚ #define PTE_A (1L &lt;&lt; 6) // access bit\n\nå‡†ç¡®åœ°æ¥è®²ï¼Œé¡µè¡¨ä¸­å­˜å‚¨çš„å¹¶ä¸æ˜¯ç‰©ç†åœ°å€ï¼Œè€Œæ˜¯0(10 bits)+PPN(44 bits)+flags(10 bits)=PTE(64 bits)ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥çœ‹åˆ°kernel/riscv.hä¸­å¾ˆå¤šè½¬æ¢å®å®šä¹‰ï¼š\n348   â”‚ // shift a physical address to the right place for a PTE.\n349   â”‚ #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)\n350   â”‚ \n351   â”‚ #define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)\n352   â”‚ \n353   â”‚ #define PTE_FLAGS(pte) ((pte) &amp; 0x3FF)\n\næƒ³è¦è·å–PTE_Aåªéœ€è¦(PTE&amp;PTE_A)&gt;&gt;6Â Â å³å¯ã€‚å¦å¤–ç”±äºå‚æ•°æ˜¯ä»ç”¨æˆ·ç©ºé—´ä¼ å…¥ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°†è¿™äº›å‚æ•°é€šè¿‡argaddrï¼ˆ64 bitsï¼‰å’Œargintï¼ˆ32 bitsï¼‰æ‹·è´è¿‡æ¥ã€‚ç”±äºä¼ å…¥çš„æ˜¯è™šæ‹Ÿåœ°å€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ç”¨walkå‡½æ•°æ‰¾åˆ°å®é™…çš„ç‰©ç†åœ°å€ã€‚\nkernel/sysproc.cä¸­å·²ç»æŒ‡æ˜äº†å‡½æ•°çš„å®ç°ä½ç½®ï¼Œç›´æ¥æ’¸å°±å®Œäº‹ï¼š\n 79   â”‚#ifdef LAB_PGTBL\n 80   â”‚int\n 81   â”‚sys_pgaccess(void)\n 82   â”‚{\n 83   â”‚    // lab pgtbl: your code here.\n 84 + â”‚    uint64 sa, ua, buf = 0;\n 85 + â”‚    int n;\n 86 + â”‚    if (argaddr(0, &amp;sa) &lt; 0 || argint(1, &amp;n) &lt; 0 || argaddr(2, &amp;ua) &lt; 0)\n 87 + â”‚        return -1;\n 88 + â”‚\n 89 + â”‚    if (n &gt; 64) return -1;\n 90 + â”‚\n 91 + â”‚    struct proc *p = myproc();\n 92 + â”‚    uint64 pg = sa;\n 93 + â”‚    for (int i = 0; i &lt; n; ++i)\n 94 + â”‚    {\n 95 + â”‚        pte_t *pte = walk(p-&gt;pagetable, pg, 0);\n 96 + â”‚        buf += ((*pte &amp; PTE_A) &gt; 0) &lt;&lt; i;\n 97 + â”‚        (*pte) &amp;= (~PTE_A);\n 98 + â”‚        pg += PGSIZE;\n 99 + â”‚    }\n100 + â”‚\n101 + â”‚    return copyout(p-&gt;pagetable, ua, (char *) &amp;buf, sizeof(buf));\n102   â”‚}\n103   â”‚#endif\n\næ–‡æ¡£ä¸­æŒ‡å‡ºæˆ‘ä»¬æ£€æŸ¥å®Œåè¿˜éœ€è¦å°†PTE_Aç½®0ï¼Œå› ä¸ºç¡¬ä»¶åªé¡¾ç€åœ¨è®¿é—®æ—¶ç½®1ï¼Œå¦‚æœä¸å¤ä½é‚£ä¹ˆPTE_Aå°±æ°¸è¿œæ˜¯1äº†ã€‚å› æ­¤åˆ«å¿˜è®°(*pte) &amp;= (~PTE_A)ï¼Œå¦å¤–åˆ«å†™å‡º(*pte &amp; PTE_A &gt; 0)ï¼Œã€&amp;ã€‘çš„ä¼˜å…ˆçº§æ¯”ã€&gt;ã€‘ä½ã€‚\n\n\nâ– References\n\n[1] MIT 6.S081 2021: Lab page tables\n\n[2] MIT6.S081-Lab3 Pgtbl [2021Fall]\n\n\n","slug":"Lab3-page-tables","date":"2022-11-17T16:34:38.000Z","categories_index":"æ“ä½œç³»ç»Ÿ","tags_index":"èµ°ç è§‚èŠ±,xv6","author_index":"Starlit Rover"},{"id":"7239e6ffaff5533d5d38121f0a34ad8b","title":"ã€Œ1114ã€Family Property","content":"This time, you are supposed to help us collect the data for family-owned property. Given each personâ€™s family members, and the estateï¼ˆæˆ¿äº§ï¼‰info under his/her own name, we need to know the size of each family, and the average area and number of sets of their real estate.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤1000). ThenÂ NÂ lines follow, each gives the infomation of a person who owns estate in the format:\nIDÂ FatherÂ MotherÂ kÂ Child1â€‹â‹¯Childkâ€‹Â Mestateâ€‹Â Area\nwhereÂ IDÂ is a unique 4-digit identification number for each person;Â FatherÂ andÂ MotherÂ are theÂ IDâ€˜s of this personâ€™s parents (if a parent has passed away,Â -1Â will be given instead);Â kÂ (0â‰¤kâ‰¤5) is the number of children of this person;Â Childiâ€‹â€™s are theÂ IDâ€˜s of his/her children;Â Mestateâ€‹Â is the total number of sets of the real estate under his/her name; andÂ AreaÂ is the total area of his/her estate.\nOutput Specification:For each case, first print in a line the number of families (all the people that are related directly or indirectly are considered in the same family). Then output the family info in the format:\nIDÂ MÂ AVGsetsâ€‹Â AVGareaâ€‹\nwhereÂ IDÂ is the smallest ID in the family;Â MÂ is the total number of family members;Â AVGsetsâ€‹Â is the average number of sets of their real estate; andÂ AVGareaâ€‹Â is the average area. The average numbers must be accurate up to 3 decimal places. The families must be given in descending order of their average areas, and in ascending order of the IDâ€™s if there is a tie.\nSample Input:10\n6666 5551 5552 1 7777 1 100\n1234 5678 9012 1 0002 2 300\n8888 -1 -1 0 1 1000\n2468 0001 0004 1 2222 1 500\n7777 6666 -1 0 2 300\n3721 -1 -1 1 2333 2 150\n9012 -1 -1 3 1236 1235 1234 1 100\n1235 5678 9012 0 1 50\n2222 1236 2468 2 6661 6662 1 300\n2333 -1 3721 3 6661 6662 6663 1 100\n\nSample Output:3\n8888 1 1.000 1000.000\n0001 15 0.600 100.000\n5551 4 0.750 100.000\n\n\nÎ©æ‰“åœ°ä¸»ï¼Œåˆ†ç”°åœ°ï¼ˆbushi\nç»™å‡ºä¸€ç¾¤äººæ‹¥æœ‰çš„æˆ¿äº§æ•°å’Œæ€»æˆ¿äº§é¢ç§¯ï¼Œä»¥åŠä»–çš„çˆ¶æ¯ã€å­å¥³ä¿¡æ¯ï¼Œè¾“å‡ºå®¶æ—ä¸ªæ•°ï¼Œä»¥åŠæ¯ä¸ªå®¶æ—çš„äººæ•°ã€å¹³å‡æˆ¿äº§æ•°å’Œå¹³å‡é¢ç§¯ã€‚\næœ¬è´¨ä¸Šå°±æ˜¯ç»™å‡ºä¸€ä¸ªå›¾æ±‚å‡ºè¿é€šåˆ†å›¾çš„ä¸ªæ•°ã€‚æˆ‘ä»¬è®¤ä¸ºåœ¨ä¸€ä»£å†…æœ‰è¡€ç¼˜å…³ç³»çš„äººä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ï¼Œå³äº²å­å…³ç³»ï¼Œç„¶åç”¨ä¸€ä¸ªé‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ã€‚æ¥ç€å¯¹æ‰€æœ‰äººè¿›è¡ŒBFSï¼ŒåŒæ—¶flagæ ‡è®°æ˜¯å¦å·²è¢«è®¿é—®ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;int, int, double, double&gt; tiidd;\n\nstruct info\n{\n    set&lt;int&gt; edge;\n    int est = 0, area = 0;\n    bool flag = false;\n};\n\nint main()\n{\n    int n, id, f, m, k, c;\n    scanf(\"%d\", &amp;n);\n    map&lt;int, info&gt; p;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d %d %d %d\", &amp;id, &amp;f, &amp;m, &amp;k);\n        if (f != -1)\n            p[id].edge.insert(f), p[f].edge.insert(id);\n        if (m != -1)\n            p[id].edge.insert(m), p[m].edge.insert(id);\n        for (int j = 0; j &lt; k; ++j)\n        {\n            scanf(\"%d\", &amp;c);\n            p[id].edge.insert(c);\n            p[c].edge.insert(id);\n        }\n        scanf(\"%d %d\", &amp;p[id].est, &amp;p[id].area);\n    }\n\n    vector&lt;tiidd&gt; ans;\n    for (auto &amp;r: p)\n    {\n        if (r.second.flag) continue;\n        r.second.flag = true;\n        set&lt;int&gt; crt{r.first}, nxt;\n        int sum_est = r.second.est, sum_area = r.second.area, num = 1, min_id = r.first;\n        while (!crt.empty())\n        {\n            for (auto &amp;t: crt)\n                for (auto &amp;z: p[t].edge)\n                {\n                    if (p[z].flag) continue;\n                    min_id = min(min_id, z);\n                    p[z].flag = true;\n                    ++num, sum_est += p[z].est, sum_area += p[z].area;\n                    nxt.insert(z);\n                }\n            crt = std::move(nxt);\n            nxt = set&lt;int&gt;();\n        }\n        ans.emplace_back(min_id, num, 1.0 * sum_est / num, 1.0 * sum_area / num);\n    }\n    sort(ans.begin(), ans.end(),\n         [](tiidd &amp;a, tiidd &amp;b) { return get&lt;3&gt;(a) == get&lt;3&gt;(b) ? get&lt;0&gt;(a) &lt; get&lt;0&gt;(b) : get&lt;3&gt;(a) &gt; get&lt;3&gt;(b); });\n    printf(\"%zu\\n\", ans.size());\n    for (auto &amp;t: ans)\n        printf(\"%04d %d %.3f %.3f\\n\", get&lt;0&gt;(t), get&lt;1&gt;(t), get&lt;2&gt;(t), get&lt;3&gt;(t));\n}\n","slug":"ã€Œ1114ã€Family-Property","date":"2022-11-16T02:09:36.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set,BFS,tuple","author_index":"Starlit Rover"},{"id":"e36208e2f8f3b544d6aecbeda1298b6f","title":"ã€Œ1113ã€Integer Set Partition","content":"Given a set ofÂ NÂ (&gt;1) positive integers, you are supposed to partition them into two disjoint setsÂ A1â€‹Â andÂ A2â€‹Â ofÂ n1â€‹Â andÂ n2â€‹Â numbers, respectively. LetÂ S1â€‹Â andÂ S2â€‹Â denote the sums of all the numbers inÂ A1â€‹Â andÂ A2â€‹, respectively. You are supposed to make the partition so thatÂ âˆ£n1â€‹âˆ’n2â€‹âˆ£Â is minimized first, and thenÂ âˆ£S1â€‹âˆ’S2â€‹âˆ£Â is maximized.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives an integerÂ , and thenÂ NÂ positive integers follow in the next line, separated by spaces. It is guaranteed that all the integers and their sum are less thanÂ .\nOutput Specification:For each case, print in a line two numbers:Â âˆ£n1â€‹âˆ’n2â€‹âˆ£Â andÂ âˆ£S1â€‹âˆ’S2â€‹âˆ£, separated by exactly one space.\nSample Input 1:10\n23 8 10 99 46 2333 46 1 666 555\n\nSample Output 1:0 3611\n\nSample Input 2:13\n110 79 218 69 3721 100 29 135 2 6 13 5188 85\n\nSample Output 2:1 9359\n\n\nÎ©å°å­¦ç”Ÿé¢˜ï¼ŒæŠŠä¸€ä¸ªæ•°ç»„åˆ†ä¸ºä¸¤ç»„ï¼Œå…ˆä½¿å¾—ä¸¤ç»„å¤§å°ç›¸å·®æœ€å°ï¼Œç„¶åå†ä½¿ä¸¤ç»„å’Œä¹‹å·®æœ€å¤§ã€‚å¾ˆæ˜¾ç„¶æ’ä¸ªåºä»ä¸­é—´åˆ‡å¼€å°±å¥½äº†ã€‚\nç„¶åå‘ç°æ±‚å’Œä¹Ÿæœ‰åº“å‡½æ•°â€”â€”accumulateï¼š\n#include &lt;numeric&gt;\ntemplate&lt;class InputIt, class T&gt;\nconstexpr // since C++20\nT accumulate(InputIt first, InputIt last, T init)\n{\n    for (; first != last; ++first)\n        init = std::move(init) + *first; // std::move since C++20\n    return init;\n}\n\næŒ‡å®šæ±‚å’Œæ•°ç»„ç»“å°¾çš„è¿­ä»£å™¨å’Œåˆå§‹å€¼initï¼Œæœ€åå°±ä¼šå¾—åˆ°ç›¸åº”åŒºé—´ä¹‹å’Œ+initã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; a(n);\n    for (auto &amp;k: a)\n        cin &gt;&gt; k;\n    sort(a.begin(), a.end());\n    cout &lt;&lt; n % 2 &lt;&lt; \" \" &lt;&lt; accumulate(a.begin() + n / 2, a.end(), 0) - accumulate(a.begin(), a.begin() + n / 2, 0);\n}\n","slug":"ã€Œ1113ã€Integer-Set-Partition","date":"2022-11-15T10:47:35.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"618b8ef040c33dc554fa44d01d787f4c","title":"ã€Œ1112ã€Stucked Keyboard","content":"On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen forÂ kÂ times.\nNow given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string.\nNotice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixedÂ kÂ times whenever it is pressed. For example, whenÂ k=3, from the stringÂ thiiis iiisss a teeeeeestÂ we know that the keysÂ iÂ andÂ eÂ might be stucked, butÂ sÂ is not even though it appears repeatedly sometimes. The original string could beÂ this isss a teest.\n\n\nInput Specification:Each input file contains one test case. For each case, the 1st line gives a positive integerÂ  which is the output repeating times of a stucked key. The 2nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} andÂ _. It is guaranteed that the string is non-empty.\nOutput Specification:For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key.\nSample Input:3\ncaseee1__thiiis_iiisss_a_teeeeeest\n\nSample Output:ei\ncase1__this_isss_a_teest\n\n\nÎ©å¯»æ‰¾æ‰€æœ‰å¡ä½çš„æŒ‰é”®ã€‚é¦–å…ˆæˆ‘ä»¬çŸ¥é“æ¯ä¸ªå¡ä½çš„æŒ‰é”®ä¼šé‡å¤æ¬¡ï¼Œé‚£ä¹ˆç»™å‡ºä¸€ä¸ªè¾“å…¥åæ˜¾ç¤ºçš„å­—ç¬¦ä¸²ï¼Œè¯·åˆ¤æ–­å“ªäº›å­—ç¬¦å¯èƒ½æ˜¯å¡ä½çš„ï¼ˆæŒ‰ç…§å‡ºç°é¡ºåºè¾“å‡ºï¼‰ï¼ŒåŒæ—¶ç»™å‡ºæ­£å¸¸é”®ç›˜çš„è¾“å‡ºã€‚\næ˜¾ç„¶ï¼Œåªè¦ä¸€ä¸ªå­—ç¬¦è¿ç»­å‡ºç°çš„æ¬¡æ•°æœ‰ä¸€æ¬¡ä¸æ˜¯çš„å€æ•°ï¼Œé‚£ä¹ˆå®ƒå°±å¿…ç„¶ä¸æ˜¯å¡ä½çš„æŒ‰é’®ã€‚æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªmap&lt;char,short&gt; flagï¼Œåœ¨éå†å­—ç¬¦ä¸²çš„è¿‡ç¨‹ä¸­åˆ†åˆ«ä»£è¡¨ä»¥ä¸‹å«ä¹‰ï¼š\n\nè¡¨ç¤ºåœ¨ä¹‹å‰çš„å­—ç¬¦ä¸²ä¸­cè¿ç»­å‡ºç°çš„ä¸ªæ•°éƒ½æ˜¯çš„å€æ•°ï¼Œå³æ˜¯å¯èƒ½å¡ä½çš„æŒ‰é’®\n\nè¡¨ç¤ºåœ¨ä¹‹å‰çš„å­—ç¬¦ä¸²ä¸­cæœªå‡ºç°è¿‡ï¼ˆmapçš„åˆå§‹åŒ–å€¼å³ä¸º0ï¼‰\n\nè¡¨ç¤ºcä¸å¯èƒ½æ˜¯å¡ä½çš„æŒ‰é’®ï¼ˆä¹‹å‰çš„å­—ç¬¦ä¸²ä¸­å‡ºç°è¿‡éå€æ•°é•¿åº¦çš„è¿ç»­cä¸²ï¼‰\n\n\né‚£ä¹ˆå±€åŠ¿å°±æ˜æœ—å¤šå•¦ï¼Œç”¨ä¸€ä¸ªvector&lt;char&gt; stuckæ¥å­˜å‚¨æ€€ç–‘å¯¹è±¡ï¼Œç”±äºä¸è¯»åˆ°æœ€åä¸€ä¸ªå­—ç¬¦å°±æ— æ³•è‚¯å®šstuckä¸­çš„æŒ‰é’®ç¡®å®æœ‰å¯èƒ½å¡ä½ï¼Œå› æ­¤æœ€ååœ¨è¾“å‡ºstuckæ—¶éœ€è¦æ£€æŸ¥flagæ˜¯å¦ä¸º1ï¼Œ-1çš„ä¸èƒ½è¾“å‡ºã€‚\néå†æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œå¦‚æœå½“å‰å­—ç¬¦ä¸ä¸‹ä¸€ä¸ªå­—ç¬¦ä¸ç›¸ç­‰ï¼ˆâš ï¸æˆ–æ˜¯åœ¨å­—ç¬¦ä¸²æœ«å°¾çš„å­—ç¬¦ï¼‰ï¼Œå°±å°†è®¡æ•°å™¨å¯¹å–ä½™ï¼Œä¸€æ—¦ä¸ä¸º0ç›´æ¥-1å°æ€ï¼Œå¦‚æœæ˜¯çš„å€æ•°ä¸”é‚£ä¹ˆå°±å…ˆå‹å…¥stuckä½œä¸ºè€ƒå¯Ÿå¯¹è±¡ï¼Œä¹‹å‰å°±ä¸è¦é‡å¤å­˜å…¥stuckäº†ï¼ŒåŒæ—¶å°†è®¡æ•°å™¨å½’0ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int k, cnt = 0;\n    cin &gt;&gt; k;\n    vector&lt;char&gt; stuck;\n    map&lt;char, short&gt; flag;\n    string s;\n    cin &gt;&gt; s;\n    for (int i = 0; i &lt; s.size(); ++i)\n    {\n        cnt += 1;\n        if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == s[i]) continue;\n        if (cnt % k == 0 &amp;&amp; flag[s[i]] == 0)\n            stuck.push_back(s[i]), flag[s[i]] = 1;\n        else if (cnt % k != 0)\n            flag[s[i]] = -1;\n        cnt = 0;\n    }\n    for (auto &amp;c: stuck)\n        if (flag[c] == 1) cout &lt;&lt; c;\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; s.size(); ++i)\n    {\n        cout &lt;&lt; s[i];\n        i += (flag[s[i]] == 1) * (k - 1);\n    }\n}\n","slug":"ã€Œ1112ã€Stucked-Keyboard","date":"2022-11-14T17:01:35.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,string","author_index":"Starlit Rover"},{"id":"d918ffea37eef621e5dbc24cef76eeef","title":"ã€Œ1111ã€Online Map","content":"Input our current position and a destination, an online map can recommend several paths. Now your job is to recommend two paths to your user: one is the shortest, and the other is the fastest. It is guaranteed that a path exists for any request.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives two positive integersÂ NÂ (2â‰¤Nâ‰¤500), andÂ M, being the total number of streets intersections on a map, and the number of streets, respectively. ThenÂ MÂ lines follow, each describes a street in the format:\nV1 V2 one-way length time\n\nwhereÂ V1Â andÂ V2Â are the indices (from 0 toÂ Nâˆ’1) of the two ends of the street;Â one-wayÂ is 1 if the street is one-way fromÂ V1Â toÂ V2, or 0 if not;Â lengthÂ is the length of the street; andÂ timeÂ is the time taken to pass the street.\nFinally a pair of source and destination is given.\nOutput Specification:For each case, first print the shortest path from the source to the destination with distanceÂ DÂ in the format:\nDistance = D: source -&gt; v1 -&gt; ... -&gt; destination\n\nThen in the next line print the fastest path with total timeÂ T:\nTime = T: source -&gt; w1 -&gt; ... -&gt; destination\n\nIn case the shortest path is not unique, output the fastest one among the shortest paths, which is guaranteed to be unique. In case the fastest path is not unique, output the one that passes through the fewest intersections, which is guaranteed to be unique.\nIn case the shortest and the fastest paths are identical, print them in one line in the format:\nDistance = D; Time = T: source -&gt; u1 -&gt; ... -&gt; destination\n\nSample Input 1:10 15\n0 1 0 1 1\n8 0 0 1 1\n4 8 1 1 1\n3 4 0 3 2\n3 9 1 4 1\n0 6 0 1 1\n7 5 1 2 1\n8 5 1 2 1\n2 3 0 2 2\n2 1 1 1 1\n1 3 0 3 1\n1 4 0 1 1\n9 7 1 3 1\n5 1 0 5 2\n6 5 1 1 2\n3 5\n\nSample Output 1:Distance = 6: 3 -&gt; 4 -&gt; 8 -&gt; 5\nTime = 3: 3 -&gt; 1 -&gt; 5\n\nSample Input 2:7 9\n0 4 1 1 1\n1 6 1 1 3\n2 6 1 1 1\n2 5 1 2 2\n3 0 0 1 1\n3 1 1 1 3\n3 2 1 1 2\n4 5 0 2 2\n6 5 1 1 2\n3 5\n\nSample Output 2:Distance = 3; Time = 4: 3 -&gt; 2 -&gt; 5\n\n\nÎ©ç–¯ç‹‚Dijkstraï¼Œç»™å‡ºä¸€ä¸ªå›¾ï¼Œæœ‰äº›è¾¹åŒå‘é€šè¡Œå…¶ä½™è¾¹å•å‘é€šè¡Œï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªæœ‰å‘å›¾ï¼Œæ¯æ¡è¾¹ç»™å‡ºç›¸åº”çš„è·ç¦»å’Œæ—¶é—´ï¼Œç„¶åç»™å‡ºèµ·ç‚¹ä¸ç»ˆç‚¹åˆ†åˆ«æ±‚å‡ºè·¯å¾„æœ€çŸ­ï¼ˆå¤šæ¡è·¯å¾„æœ€çŸ­æ—¶å–æ—¶é—´æœ€çŸ­ï¼‰å’Œæ—¶é—´æœ€çŸ­ï¼ˆå¤šæ¡æ—¶é—´æœ€çŸ­æ—¶å–é€”ç»èŠ‚ç‚¹æ•°æœ€å°‘ï¼‰çš„è·¯å¾„ï¼Œå¦‚æœä¸¤æ¡è·¯å¾„ç›¸åŒåˆ™ä¸€èµ·è¾“å‡ºã€‚\nå°±æ˜¯Dijkstraç®—æ³•ï¼Œæ±‚è·¯å¾„æœ€çŸ­æ—¶å–è¾¹æƒä¸ºpair&lt;distance,time&gt;ï¼Œåˆ©ç”¨pairå¯¹æ¯”è¾ƒè¿ç®—ç¬¦çš„é‡è½½å°±å¯ä»¥ç›´æ¥å¥—ç”¨Dijkstraç®—æ³•ï¼›ç¬¬äºŒæ¬¡åˆ™æ˜¯pair&lt;time,intersection num&gt;ï¼Œé‡å¤ä¸€éæœ€çŸ­è·¯å¾„çš„æµç¨‹ã€‚å¦å¤–å¯¹äºè·¯å¾„çš„è®°å½•åˆ™é‡‡å–è®°å½•æ¯ä¸ªèŠ‚ç‚¹å‰ç½®èŠ‚ç‚¹çš„æ–¹æ³•ï¼Œåœ¨æ¯æ¬¡æ›´æ–°èŠ‚ç‚¹çš„æœ€å°è¾¹æƒæ—¶é¡ºä¾¿æ›´æ–°å®ƒçš„å‰ç½®èŠ‚ç‚¹ã€‚é‚£ä¹ˆæœ€åä»ç»ˆç‚¹å›æº¯è‡³èµ·ç‚¹å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, v1, v2, ow, len, t, s, d;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;vector&lt;tuple&lt;int, int, int&gt;&gt;&gt; info(n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d %d %d %d %d\", &amp;v1, &amp;v2, &amp;ow, &amp;len, &amp;t);\n        info[v1].emplace_back(v2, len, t);\n        if (!ow) info[v2].emplace_back(v1, len, t);\n    }\n    scanf(\"%d %d\", &amp;s, &amp;d);\n    vector&lt;bool&gt; isDtm(n, false);\n    vector&lt;int&gt; dpre(n, -1);\n    vector&lt;pair&lt;int, int&gt;&gt; dist(n, {INT32_MAX, INT32_MAX});\n    pair&lt;int, int&gt; dopt{0, 0}, topt{0, 0};\n    isDtm[s] = true, dist[s] = {0, 0};\n    for (auto &amp;k: info[s])\n        dpre[get&lt;0&gt;(k)] = s, dist[get&lt;0&gt;(k)] = {get&lt;1&gt;(k), get&lt;2&gt;(k)};\n    while (!isDtm[d])\n    {\n        int idx = -1;\n        dopt = {INT32_MAX, INT32_MAX};\n        for (int i = 0; i &lt; n; ++i)\n            if (!isDtm[i] &amp;&amp; dist[i] &lt; dopt)\n                dopt = dist[i], idx = i;\n        isDtm[idx] = true;\n        for (auto &amp;k: info[idx])\n            if (make_pair(get&lt;1&gt;(k) + dopt.first, get&lt;2&gt;(k) + dopt.second) &lt; dist[get&lt;0&gt;(k)])\n            {\n                dist[get&lt;0&gt;(k)] = make_pair(get&lt;1&gt;(k) + dopt.first, get&lt;2&gt;(k) + dopt.second);\n                dpre[get&lt;0&gt;(k)] = idx;\n            }\n    }\n\n    fill(isDtm.begin(), isDtm.end(), false);\n    vector&lt;int&gt; tpre(n, -1);\n    vector&lt;pair&lt;int, int&gt;&gt; time(n, {INT32_MAX, INT32_MAX});\n    isDtm[s] = true, time[s] = {0, 0};\n    for (auto &amp;k: info[s])\n        tpre[get&lt;0&gt;(k)] = s, time[get&lt;0&gt;(k)] = {get&lt;2&gt;(k), 1};\n    while (!isDtm[d])\n    {\n        int idx = -1;\n        topt = {INT32_MAX, INT32_MAX};\n        for (int i = 0; i &lt; n; ++i)\n            if (!isDtm[i] &amp;&amp; time[i] &lt; topt)\n                topt = time[i], idx = i;\n        isDtm[idx] = true;\n        for (auto &amp;k: info[idx])\n            if (make_pair(get&lt;2&gt;(k) + topt.first, topt.second + 1) &lt; time[get&lt;0&gt;(k)])\n            {\n                time[get&lt;0&gt;(k)] = make_pair(get&lt;2&gt;(k) + topt.first, topt.second + 1);\n                tpre[get&lt;0&gt;(k)] = idx;\n            }\n    }\n\n    vector&lt;int&gt; pathd, patht;\n    t = d;\n    while (t != -1) pathd.push_back(t), t = dpre[t];\n    t = d;\n    while (t != -1) patht.push_back(t), t = tpre[t];\n    if (pathd == patht)\n    {\n        printf(\"Distance = %d; Time = %d: %d\", dopt.first, dopt.second, s);\n        for (int i = pathd.size() - 2; i &gt;= 0; --i)\n            printf(\" -&gt; %d\", pathd[i]);\n    }\n    else\n    {\n        printf(\"Distance = %d: %d\", dopt.first, s);\n        for (int i = pathd.size() - 2; i &gt;= 0; --i)\n            printf(\" -&gt; %d\", pathd[i]);\n        printf(\"\\nTime = %d: %d\", topt.first, s);\n        for (int i = patht.size() - 2; i &gt;= 0; --i)\n            printf(\" -&gt; %d\", patht[i]);\n    }\n}\n\nâš ï¸ Dijkstraç®—æ³•ä¸­æ¯ä¸€è½®éƒ½éœ€è¦æ‰¾åˆ°è·èµ·ç‚¹è¾¹æƒå’Œæœ€å°çš„èŠ‚ç‚¹Pï¼Œé‚£ä¹ˆä¸€èˆ¬å’Œèµ·ç‚¹ä¹‹é—´è¿˜æ²¡è·¯çš„èŠ‚ç‚¹è·ç¦»é»˜è®¤ä¸ºï¼Œç¼–ç¨‹æ—¶ä¸€èˆ¬ç›´æ¥å–INT32_MAXã€‚ä½†å¦‚æœä½ æ˜¯ç”¨é‚»æ¥çŸ©é˜µæ¥å­˜å‚¨èŠ‚ç‚¹ä¹‹é—´çš„è¾¹æƒè€Œä¸”æ²¡æœ‰è¾¹çš„æƒé‡ä¹Ÿç›´æ¥è®°ä¸ºINT32_MAXçš„è¯ï¼Œé‚£ä¹ˆä½ è¦æ³¨æ„åœ¨æ›´æ–°èŠ‚ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»æ—¶ï¼Œä½ å¿…é¡»è·³è¿‡è¿™äº›ä¸Pæ²¡æœ‰è¾¹çš„èŠ‚ç‚¹ï¼Œå¦åˆ™ç›¸åŠ æ—¶ä¼šå¯¼è‡´æº¢å‡ºã€‚æˆ‘åœ¨è¿™é‡Œé‡‡ç”¨çš„æ˜¯é‚»æ¥è¡¨çš„å½¢å¼ï¼Œæ„å‘³ç€æ²¡æœ‰è¾¹çš„èŠ‚ç‚¹æ ¹æœ¬æ²¡æœ‰å­˜ï¼Œå› æ­¤ä¸ç”¨æ‹…å¿ƒè¿™ä¸ªé—®é¢˜ã€‚\n","slug":"ã€Œ1111ã€Online-Map","date":"2022-11-14T15:22:03.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Dijkstra,tuple","author_index":"Starlit Rover"},{"id":"1c866b059d574be929326143e875b3a0","title":"ã€Œ1110ã€Complete Binary Tree","content":"Given a tree, you are supposed to tell if it is a complete binary tree.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤20) which is the total number of nodes in the tree â€“ and hence the nodes are numbered from 0 toÂ Nâˆ’1. ThenÂ NÂ lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, aÂ -Â will be put at the position. Any pair of children are separated by a space.\nOutput Specification:For each case, print in one lineÂ YESÂ and the index of the last node if the tree is a complete binary tree, orÂ NOÂ and the index of the root if not. There must be exactly one space separating the word and the number.\nSample Input 1:9\n7 8\n- -\n- -\n- -\n0 1\n2 3\n4 5\n- -\n- -\n\nSample Output 1:YES 8\n\nSample Input 2:8\n- -\n4 5\n0 6\n- -\n2 3\n- 7\n- -\n- -\n\nSample Output 2:NO 1\n\n\nÎ©ç»™å‡ºä¸€æ£µäºŒå‰æ ‘çš„èŠ‚ç‚¹å…³ç³»ï¼Œè¯·åˆ¤æ–­å…¶æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼ˆæ‰€æœ‰èŠ‚ç‚¹ç´¢å¼•ä¸æ»¡äºŒå‰æ ‘ä¸€è‡´ï¼‰ï¼Œè‹¥æ˜¯åˆ™è¾“å‡ºæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ç¼–å·ï¼Œå¦åˆ™è¾“å‡ºæ ¹èŠ‚ç‚¹ç¼–å·ã€‚\né¦–å…ˆæˆ‘ä»¬å°†æ ¹èŠ‚ç‚¹ç¼–å·å˜é‡èµ‹å€¼ï¼Œi.e.ï¼Œæ‰€æœ‰ç¼–å·ä¹‹å’Œï¼Œç„¶åæŠŠæœ‰çˆ¶äº²èŠ‚ç‚¹çš„ç¼–å·éƒ½å‡æ‰ï¼Œå‰©ä¸‹çš„å¿…ç„¶æ˜¯æ ¹èŠ‚ç‚¹ç¼–å·ï¼ˆâš ï¸ä½†è¦ä¿è¯æ‰€æœ‰èŠ‚ç‚¹ä¹‹å’Œä¸èƒ½è¶…å‡ºintèŒƒå›´ï¼‰ã€‚ç„¶åDFSé€’å½’éå†æ•´æ£µæ ‘ï¼ŒæŠŠç›¸åº”çš„èŠ‚ç‚¹ç¼–å·èµ‹å€¼åˆ°å±‚æ¬¡éå†çš„å‘é‡ä¸­ã€‚ç´¢å¼•ä¸ºèŠ‚ç‚¹çš„å·¦å³å­èŠ‚ç‚¹ç´¢å¼•åˆ†åˆ«ä¸ºã€ï¼Œä¸€æ—¦å‘ç°æŸä¸ªèŠ‚ç‚¹çš„ç¼–å·è¶…å‡ºäº†Nå°±è¯´æ˜ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œç›´æ¥è¿”å›falseã€‚\næœ€åå¦‚æœYESå°±è¾“å‡ºå±‚æ¬¡éå†çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ç¼–å·ï¼Œåä¹‹åˆ™è¾“å‡ºrootã€‚\n\nÎ©#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, top;\nvector&lt;int&gt; level;\nvector&lt;pair&lt;int, int&gt;&gt; sons;\n\nbool isCBT(int node, int idx)\n{\n    level[idx] = node;\n    int l = sons[node].first, r = sons[node].second;\n    return ((l != -1 &amp;&amp; 2 * idx + 1 &lt; n) ? isCBT(l, 2 * idx + 1) : (l == -1))\n        &amp;&amp; ((r != -1 &amp;&amp; 2 * idx + 2 &lt; n) ? isCBT(r, 2 * idx + 2) : (r == -1));\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    top = n * (n - 1) / 2;\n    sons.resize(n);\n    string a, b;\n    for (auto &amp;k: sons)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        k.first = a == \"-\" ? -1 : (top -= stoi(a), stoi(a));\n        k.second = b == \"-\" ? -1 : (top -= stoi(b), stoi(b));\n    }\n    level.resize(n);\n    if (isCBT(top, 0))\n        cout &lt;&lt; \"YES \" &lt;&lt; level.back();\n    else cout &lt;&lt; \"NO \" &lt;&lt; top;\n}\n","slug":"ã€Œ1110ã€Complete-Binary-Tree","date":"2022-11-13T15:44:16.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Tree,DFS","author_index":"Starlit Rover"},{"id":"e5acc25f52a3eda31fca71a61f248459","title":"ã€Œ1109ã€Group Photo","content":"Formation is very important when taking a group photo. Given the rules of formingÂ KÂ rows withÂ NÂ people as the following:\n\nThe number of people in each row must beÂ N/KÂ (round down to the nearest integer), with all the extra people (if any) standing in the last row;\n\nAll the people in the rear row must be no shorter than anyone standing in the front rows;\n\nIn each row, the tallest one stands at the central position (which is defined to be the positionÂ , whereÂ mÂ is the total number of people in that row, and the division result must be rounded down to the nearest integer);\n\nIn each row, other people must enter the row in non-increasing order of their heights, alternately taking their positions first to the right and then to the left of the tallest one (For example, given five people with their heights 190, 188, 186, 175, and 170, the final formation would be 175, 188, 190, 186, and 170. Here we assume that you are facing the group so your left-hand side is the right-hand side of the one at the central position.);\n\nWhen there are many people having the same height, they must be ordered in alphabetical (increasing) order of their names, and it is guaranteed that there is no duplication of names.\n\n\nNow given the information of a group of people, you are supposed to write a program to output their formation.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains two positive integersÂ , the total number of people, andÂ KÂ (â‰¤10), the total number of rows. ThenÂ NÂ lines follow, each gives the name of a person (no more than 8 English letters without space) and his/her height (an integer in [30, 300]).\nOutput Specification:For each case, print the formation â€“ that is, print the names of people inÂ KÂ lines. The names must be separated by exactly one space, but there must be no extra space at the end of each line. Note: since you are facing the group, people in the rear rows must be printed above the people in the front rows.\nSample Input:10 3\nTom 188\nMike 170\nEva 168\nTim 160\nJoe 190\nAnn 168\nBob 175\nNick 186\nAmy 160\nJohn 159\n\nSample Output:Bob Tom Joe Nick\nAnn Mike Eva\nTim Amy John\n\n\nÎ©é¦–å…ˆæˆ‘æƒ³é—®ï¼Œè¿™æµ‹è¯•æ ·ä¾‹æ€ä¹ˆæ¯è¡Œä¸ªæ•°ä¸è¡Œæ•°ç›¸åŒå•Šã€‚å½“æˆ‘æ˜¥å…‰æ»¡é¢åœ°submitæ—¶ç»“æœä¸‰ä¸ªWAï¼Œæˆ‘äººå‚»äº†ç›´å‘¼impossibleï¼Œç»“æœåæ¥å‘ç°kæ˜¯è¡Œæ•°ï¼ŒåŸåœ°çˆ†ç‚¸ã€‚\né¢˜ä¸éš¾ï¼Œå°±æ˜¯æ’ä¸€ä¸ªæ‹ç…§é˜Ÿåˆ—ï¼Œè§„åˆ™æ˜¯ï¼š\n\nè¡Œé—´è§„åˆ™ï¼šé«˜çš„äººç«™åæ’ï¼ŒçŸ®çš„åœ¨å‰\n\nè¡Œå†…è§„åˆ™ï¼šä¸€æ’å†…æœ€é«˜çš„ç«™Cä½ï¼Œå³ï¼ˆï¼‰ä¸ªä½ç½®ï¼Œç„¶åæŒ‰ç…§èº«é«˜é™åºæ’åˆ—åˆ†åˆ«åœ¨æœ€é«˜è€…çš„å³å·¦è½®æµæ’åˆ—ã€‚\n\nèº«é«˜ä¸€æ ·è€…æŒ‰ç…§åå­—å­—æ¯åºå‡åºæ’åˆ—\n\n\nè¯»å…¥å§“åå’Œèº«é«˜åæŒ‰ç…§è§„åˆ™é™åºæ’åºï¼Œç„¶åä»æœ€åä¸€æ’å¼€å§‹ï¼Œä»æœ€é«˜è€…å¼€å§‹ï¼Œè®¾ç½®ä¸€ä¸ªbias=0å˜é‡ï¼Œbias = i % 2 ? -bias : -bias - 1ï¼Œä»è€Œå®ç°æœ€é«˜è€…å·¦å³çš„è½®æµåˆ†é…ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;int, string&gt; pis;\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;pis&gt; info(n);\n    for (auto &amp;t: info)\n        cin &gt;&gt; t.second &gt;&gt; t.first;\n    sort(info.begin(), info.end(),\n         [](pis &amp;a, pis &amp;b) { return a.first == b.first ? a.second &lt; b.second : a.first &gt; b.first; });\n    vector&lt;string&gt; row;\n    int r = n / k, u = r + n % r, head = 0, bias = 0;\n    while (head &lt; n)\n    {\n        row.resize(u);\n        for (int i = 0; i &lt; u; ++i)\n        {\n            row[u / 2 + bias] = info[head + i].second;\n            bias = i % 2 ? -bias : -bias - 1;\n        }\n        cout &lt;&lt; row[0];\n        for (int j = 1; j &lt; u; ++j)\n            cout &lt;&lt; \" \" &lt;&lt; row[j];\n        cout &lt;&lt; endl;\n        head += u, u = r, bias = 0, row.clear();\n    }\n}\n","slug":"ã€Œ1109ã€Group-Photo","date":"2022-11-13T11:56:09.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"80283fa8bfdc49e4840f7226c64452a7","title":"ã€Œ1108ã€Finding Average","content":"The basic task is simple: givenÂ NÂ real numbers, you are supposed to calculate their average. But what makes it complicated is that some of the input numbers might not be legal. AÂ legalÂ input is a real number in [âˆ’1000,1000] and is accurate up to no more than 2 decimal places. When you calculate the average, those illegal numbers must not be counted in.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤100). ThenÂ NÂ numbers are given in the next line, separated by one space.\nOutput Specification:For each illegal input number, print in a lineÂ ERROR: X is not a legal numberÂ whereÂ XÂ is the input. Then finally print in a line the result:Â The average of K numbers is YÂ whereÂ KÂ is the number of legal inputs andÂ YÂ is their average, accurate to 2 decimal places. In case the average cannot be calculated, outputÂ UndefinedÂ instead ofÂ Y. In caseÂ KÂ is only 1, outputÂ The average of 1 number is YÂ instead.\nSample Input 1:7\n5 -3.2 aaa 9999 2.3.4 7.123 2.35\n\nSample Output 1:ERROR: aaa is not a legal number\nERROR: 9999 is not a legal number\nERROR: 2.3.4 is not a legal number\nERROR: 7.123 is not a legal number\nThe average of 3 numbers is 1.38\n\nSample Input 2:2\naaa -9999\n\nSample Output 2:ERROR: aaa is not a legal number\nERROR: -9999 is not a legal number\nThe average of 0 numbers is Undefined\n\n\nÎ©è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œå¯¹ä¸åˆæ³•çš„æ•°å­—è¿›è¡ŒæŠ¥é”™è¾“å‡ºï¼Œç„¶åå¯¹æ‰€æœ‰åˆæ³•çš„æ•°å­—æ±‚å–å¹³å‡å€¼ã€‚\næ€»ä½“æ¥è¯´å¹¶ä¸æ˜¯å¾ˆéš¾ï¼Œä¸»è¦æ˜¯é¢˜ç›®æ²¡çœ‹å…¨å°±è¦äº†è€å‘½ã€‚é¦–å…ˆï¼Œæ²¡æœ‰åˆæ³•æ•°å­—çš„è¯æœ€åçš„å¹³å‡å€¼åº”ä¸ºUndefinedï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªåˆæ³•æ•°å­—çš„è¯å¿…é¡»numberè€Œénumbersã€‚å…¶ä»–å°±æ˜¯å¯¹æ•°å­—åˆæ³•æ€§çš„æ£€éªŒäº†ï¼Œå¤§æ¦‚æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š\n\nå°æ•°ç‚¹ä¸ªæ•°\n\nå¤¹æ‚éæ•°å­—å­—ç¬¦\n\nå°æ•°ç‚¹åçš„ä½æ•°ä¸è¶…è¿‡ä¸¤ä½\n\næ•´ä½“æ•°å€¼çš„ç»å¯¹å€¼ä¸&gt;1000\n\n\næˆ‘å¯¹äºå°æ•°ç‚¹æœ€å¤šç²¾ç¡®åˆ°ä¸¤ä½çš„ç†è§£å°±æ˜¯å°æ•°ç‚¹ååªèƒ½æœ‰ä¸¤ä½ï¼Œè€Œæ•´æ•°éƒ¨åˆ†å¯ä»¥æœ‰å‰ç½®0ã€‚é‚£ä¹ˆå…ˆä»¥å­—ç¬¦ä¸²çš„å½¢å¼è¯»å…¥ï¼Œç„¶åéå†æ‰€æœ‰å­—ç¬¦ï¼Œé€ä¸€åˆ¤æ–­æ˜¯å¦ä¸ºå°æ•°ç‚¹ï¼ˆä¹‹å‰æ˜¯å¦å‡ºç°è¿‡ï¼‰ã€éæ•°å­—å­—ç¬¦ã€å°æ•°ç‚¹å‰æœ‰æ•ˆæ•°å­—ä½æ•°æ˜¯å¦&lt;5ã€å°æ•°ç‚¹åä½æ•°æ˜¯å¦&lt;3ã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, cnt = 0;\n    cin &gt;&gt; n;\n    string t;\n    double sum = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; t;\n        int before = 0, after = 0;\n        bool flag = true, point = false, sign = t[0] == '-' &amp;&amp; (t.erase(0, 1), true);\n        for (auto &amp;c: t)\n        {\n            if (c == '.' &amp;&amp; !point)\n            {\n                point = true;\n                continue;\n            }\n            else if (!isdigit(c))\n                flag = false;\n            else if (!point)\n                flag = (before += (before != 0 || c != '0')) &lt; 5;\n            else\n                flag = ++after &lt; 3;\n            if (!flag) break;\n        }\n        if (flag &amp;&amp; stod(t) &lt;= 1000)\n        {\n            sum += (sign ? -1 : 1) * stod(t);\n            cnt += 1;\n        }\n        else\n        {\n            t = (sign ? \"-\" : \"\") + t;\n            printf(\"ERROR: %s is not a legal number\\n\", t.c_str());\n        }\n    }\n    if (!cnt) printf(\"The average of 0 numbers is Undefined\");\n    else printf(\"The average of %d number%s is %.2f\", cnt, cnt == 1 ? \"\" : \"s\", sum / cnt);\n}\n","slug":"ã€Œ1108ã€Finding-Average","date":"2022-11-12T13:58:13.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"c00bb795d937e8dc21c5c90e4285b807","title":"ã€Œ1107ã€Social Clusters","content":"When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. AÂ social clusterÂ is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.\n\n\nInput Specification:Each input file contains one test case. For each test case, the first line contains a positive integerÂ , the total number of people in a social network. Hence the people are numbered from 1 toÂ N. ThenÂ NÂ lines follow, each gives the hobby list of a person in the format:\n\nwhereÂ  is the number of hobbies, andÂ Â is the index of theÂ j-th hobby, which is an integer in [1, 1000].\nOutput Specification:For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:8\n3: 2 7 10\n1: 4\n2: 5 3\n1: 4\n1: 3\n1: 4\n4: 6 8 1 5\n1: 4\n\nSample Output:3\n4 3 1\n\n\nÎ©è¯·ä½ å°†ä¸€ç¾¤äººåˆ’åˆ†ä¸ºå‡ ä¸ªæ²¡æœ‰çˆ±å¥½äº¤é›†çš„ç¾¤ä½“ï¼Œçˆ±å¥½ç”¨ç¼–å·ç»™å‡ºã€‚\nä¸€å¼€å§‹æ²¡æœ‰ç”¨å¹¶æŸ¥é›†ï¼Œç›´æ¥çš„æƒ³æ³•æ˜¯å¯¹çˆ±å¥½è¿›è¡Œåˆ†ç»„ï¼Œå³è®©æ¯ä¸ªçˆ±å¥½æŒ‡å‘ä¸€ä¸ªåˆ†ç»„ç¼–å·ï¼Œå¦‚æœä¸€ä¸ªäººæœ‰ç€ä¸åŒåˆ†ç»„å†…çš„çˆ±å¥½ï¼Œé‚£ä¹ˆå°±æŠŠä¸åŒåˆ†ç»„çš„ç»Ÿè®¡é‡å…¨éƒ¨åŠ åˆ°ä¸€ä¸ªç»„ä¸Šï¼Œç„¶åå°†æ‰€æœ‰å‡ºç°çš„çˆ±å¥½æŒ‡å‘è¿™ä¸ªç»„ã€‚ä¹ä¸€çœ‹æ²¡å•¥é—®é¢˜ï¼Œä½†åœ¨å°†ä¸€ä¸ªçˆ±å¥½çš„åˆ†ç»„æŒ‡å‘é‡å®šå‘æ—¶ï¼Œæœ¬æ¥åŒå±äºä¸€ä¸ªç»„çš„çˆ±å¥½è¿˜æ˜¯æŒ‡å‘åŸæ¥çš„ç»„ï¼Œäº‹å®ä¸Šè¿™ä¸ªç»„å·²ç»è¢«åˆå¹¶åˆ°æ–°çš„ç»„å»äº†ï¼Œæˆ‘ä»¬ä¸åº”å†ç”¨è¿™ä¸ªç»„å»ç»Ÿè®¡äººæ•°äº†ï¼Œç»“æœåé¢æœ‰è¿™äº›çˆ±å¥½çš„äººè¿˜æ˜¯ä¼šè¢«ç»Ÿè®¡åˆ°åŸæ¥çš„ç»„å»ã€‚\nå¹¶æŸ¥é›†å°±æ˜¯ç»™æ¯ä¸ªçˆ±å¥½éƒ½è®¾ç½®ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹å°±æ˜¯è‡ªå·±çš„èŠ‚ç‚¹Rå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªç»„ç»‡çš„å¤´å¤´ï¼Œæ‰€æœ‰ç¥–å®—èŠ‚ç‚¹ï¼ˆä¸æ–­æº¯æºçˆ¶èŠ‚ç‚¹çš„ç»“æœï¼‰ä¸ºRçš„èŠ‚ç‚¹è¢«è®¤ä¸ºæ˜¯å±äºRç»„ç»‡ã€‚åŸºäºè¿™æ ·ä¸€ä¸ªæƒ³æ³•ï¼Œæˆ‘ä»¬é¦–å…ˆè¯»å…¥ä¸€ä¸ªäººçš„æ‰€æœ‰çˆ±å¥½ï¼Œç„¶åé€‰å–ç¬¬ä¸€ä¸ªçˆ±å¥½æ‰€åœ¨ç»„ç»‡çš„å¤´å¤´ï¼ˆæ²¡æœ‰ç»„ç»‡çš„è¯å°±æ˜¯è‡ªå·±ï¼‰ä¸ºåˆå¹¶ç»„ç»‡çš„å¤´å¤´ï¼Œç„¶åå°†å…¶ä½™çˆ±å¥½æ‰€åœ¨å…¶ä»–ç»„ç»‡çš„å¤´å¤´éƒ½åˆå¹¶åˆ°è¿™ä¸ªå¤´å¤´ä¸Šæ¥ï¼ŒåŒæ—¶å°†å…ˆå‰ç»Ÿè®¡çš„äººæ•°ä¹Ÿè¿›è¡Œåˆå¹¶ï¼Œè¢«åˆå¹¶å¤´å¤´çš„ç»Ÿè®¡æ•°é‡å½’0ã€‚\nè¿™æ ·å¯ä»¥ä¿è¯æœ€åç»Ÿè®¡é‡éé›¶çš„ä¸€å®šéƒ½æ˜¯å¤´å¤´ï¼Œè€Œä¸”æ‰€æœ‰ç»Ÿè®¡é‡ä¸€å®šéƒ½æ±‡æ€»åˆ°äº†å¤´å¤´é‚£ã€‚å› ä¸ºæ¯æ¬¡ç»Ÿè®¡é‡éƒ½å¿…ç„¶ä¼šè¢«è½¬ç§»åˆ°å½“å‰å¤´å¤´å¤„ï¼Œå¦‚æœè¯´ä»¥åè¿™ä¸ªå¤´å¤´è¢«åˆå¹¶äº†é‚£ä¹ˆè¿™ä¸ªç»Ÿè®¡é‡ä¼šä¸€èµ·è½¬ç§»ã€‚ç®€å•ç‚¹è¯´ï¼Œå°±æ˜¯æ¯æ¬¡ç»Ÿè®¡é‡éƒ½æ˜¯ä½äºè¯¥æ—¶åˆ»çš„å¤´å¤´ä»¬å¤„ï¼Œé‚£ä¹ˆæœ€åä¹Ÿæ˜¯ä¸€æ ·ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; dad(1001), num(1001, 0);\n    iota(dad.begin(), dad.end(), 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d: \", &amp;m);\n        cin &gt;&gt; k;\n        int r = dad[k], s;\n        while (r != dad[r]) r = dad[r];\n        for (int j = 1; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k;\n            s = dad[k];\n            while (s != dad[s]) s = dad[s];\n            num[r] += num[s], num[s] = 0;\n            dad[s] = dad[k] = r;\n        }\n        num[r] += 1;\n    }\n    sort(num.begin(), num.end(), greater&lt;&gt;());\n    auto tail = find(num.begin(), num.end(), 0);\n    cout &lt;&lt; (tail - num.begin()) &lt;&lt; endl;\n    cout &lt;&lt; *num.begin();\n    for (auto it = num.begin() + 1; it != tail; ++it)\n        cout &lt;&lt; \" \" &lt;&lt; *it;\n}\n","slug":"ã€Œ1107ã€Social-Clusters","date":"2022-11-10T10:09:22.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,å¹¶æŸ¥é›†","author_index":"Starlit Rover"},{"id":"9241d85f7d3a9c013c622065a01dc5ab","title":"ã€Œ1106ã€Lowest Price in Supply Chain","content":"A supply chain is a network of retailersï¼ˆé›¶å”®å•†ï¼‰, distributorsï¼ˆç»é”€å•†ï¼‰, and suppliersï¼ˆä¾›åº”å•†ï¼‰â€“ everyone involved in moving a product from supplier to customer.\nStarting from one root supplier, everyone on the chain buys products from oneâ€™s supplier in a priceÂ PÂ and sell or distribute them in a price that isÂ r% higher thanÂ P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.\nNow given a supply chain, you are supposed to tell the lowest price a customer can expect from some retailers.\n\n\nInput Specification:Each input file contains one test case. For each case, The first line contains three positive numbers:Â , the total number of the members in the supply chain (and hence their IDâ€™s are numbered from 0 toÂ Nâˆ’1, and the root supplierâ€™s ID is 0);Â P, the price given by the root supplier; andÂ r, the percentage rate of price increment for each distributor or retailer. ThenÂ NÂ lines follow, each describes a distributor or retailer in the following format:\n\nwhere in theÂ i-th line,Â Â is the total number of distributors or retailers who receive products from supplierÂ i, and is then followed by the IDâ€™s of these distributors or retailers.Â Â being 0 means that theÂ j-th member is a retailer. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the lowest price we can expect from some retailers, accurate up to 4 decimal places, and the number of retailers that sell at the lowest price. There must be one space between the two numbers. It is guaranteed that the all the prices will not exceedÂ .\nSample Input:10 1.80 1.00\n3 2 3 5\n1 9\n1 4\n1 7\n0\n2 6 1\n1 8\n0\n0\n0\n\nSample Output:1.8362 2\n\n\nÎ©ç¬¬ä¸‰æ¬¡è§è¿™é¢˜ç›®äº†ï¼Œæ„Ÿè§‰æ²¡ä»€ä¹ˆæ–°æ„ï¼Œç§’äº†ã€‚\nè¾“å‡ºå”®ä»·æœ€ä¾¿å®œçš„é”€å”®ä»·æ ¼ä»¥åŠé”€å”®æ­¤ä»·æ ¼çš„é›¶å”®å•†ä¸ªæ•°ã€‚\nç›´æ¥BFSåˆ°ç¬¬ä¸€ä¸ªé›¶å”®å•†å‡ºç°åœæ­¢ï¼Œâš ï¸å¯èƒ½å‡ºç°æ ¹ä¾›åº”å•†å³ä¸ºé›¶å”®å•†çš„æƒ…å†µï¼Œåœ¨éå†è¿‡ç¨‹ä¸­è®°å½•ä»·æ ¼çš„å˜åŒ–ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, cnt = 0;\n    double p, r, t = 1.0;\n    scanf(\"%d %lf %lf\", &amp;n, &amp;p, &amp;r);\n    r = 1 + 0.01 * r;\n    vector&lt;vector&lt;int&gt;&gt; sup(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;m);;\n        sup[i].resize(m);\n        for (auto &amp;k: sup[i])\n            scanf(\"%d\", &amp;k);\n    }\n    vector&lt;int&gt; crt(sup[0]), nxt;\n    cnt = (crt.empty());\n    while (!cnt)\n    {\n        t *= r;\n        for (auto &amp;k: crt)\n        {\n            cnt += (sup[k].empty());\n            nxt.insert(nxt.end(), sup[k].begin(), sup[k].end());\n        }\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    }\n    printf(\"%.4f %d\", p * t, cnt);\n}\n","slug":"ã€Œ1106ã€Lowest-Price-in-Supply-Chain","date":"2022-11-10T06:44:17.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,BFS,Tree","author_index":"Starlit Rover"},{"id":"9fd6e61746966814315473dc06fd52de","title":"ã€Œ1105ã€Spiral Matrix","content":"This time your job is to fill a sequence ofÂ NÂ positive integers into aÂ spiral matrixÂ in non-increasing order. A spiral matrix is filled in from the first element at the upper-left corner, then move in a clockwise spiral. The matrix hasÂ mÂ rows andÂ nÂ columns, whereÂ mÂ andÂ nÂ satisfy the following:Â mÃ—nÂ must be equal toÂ N;Â mâ‰¥n; andÂ mâˆ’nÂ is the minimum of all the possible values.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ N. Then the next line containsÂ NÂ positive integers to be filled into the spiral matrix. All the numbers are no more thanÂ . The numbers in a line are separated by spaces.\nOutput Specification:For each test case, output the resulting matrix inÂ mÂ lines, each containsÂ nÂ numbers. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.\nSample Input:12\n37 76 20 98 76 42 53 95 60 81 58 93\n\nSample Output:98 95 93\n42 37 81\n53 20 76\n58 60 76\n\n\nÎ©è¾“å‡ºä¸€ä¸ªæ•°ç»„çš„é™åºï¼ˆé¡ºæ—¶é’ˆï¼‰æ—‹è½¬çŸ©é˜µï¼Œè¦æ±‚ã€‚\né¦–å…ˆç¡®å®šï¼Œä»å¼€å§‹å¾€ä¸‹æšä¸¾ï¼Œæ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªNçš„å› å­å³ä¸ºã€‚ç„¶åæ¯æ¬¡é¡ºæ—¶é’ˆéå†ä¸€åœˆç»™æ—‹è½¬çŸ©é˜µèµ‹å€¼ï¼Œç”±å¤–å‘å†…æ·±å…¥ï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯æœ‰æ—¶ä¸€åœˆä¼šé€€åŒ–æˆä¸€æ¡è¾¹ï¼Œä¸è¦é‡å¤èµ‹å€¼ï¼Œå¦åˆ™ä¼šè¶Šç•Œè®¿é—®åŸå§‹æ•°ç»„ã€‚å½“ç„¶ç®€å•ä¸€ç‚¹å¯ä»¥æ¯æ¬¡éƒ½æ£€æŸ¥ä¸€ä¸‹idxæ˜¯å¦è¶Šç•Œã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int r, n, m;\n    cin &gt;&gt; r;\n    int seq[r];\n    for (auto &amp;k: seq)\n        cin &gt;&gt; k;\n    sort(seq, seq + r, greater());\n    for (n = int(sqrt(r)); n &gt; 1; --n)\n        if (r % n == 0) break;\n    m = r / n;\n    int mtx[m][n], l = -1, idx = -1;\n    while (++l &lt; (n + 1) / 2)\n    {\n        for (int i = l; i &lt; n - l; ++i)\n            mtx[l][i] = seq[++idx];\n        for (int i = l + 1; i &lt; m - l; ++i)\n            mtx[i][n - l - 1] = seq[++idx];\n        for (int i = n - l - 2; i &gt;= l; --i)\n            mtx[m - l - 1][i] = seq[++idx];\n        if (l != n / 2)\n            for (int i = m - l - 2; i &gt; l; --i)\n                mtx[i][l] = seq[++idx];\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        printf(\"%d\", mtx[i][0]);\n        for (int j = 1; j &lt; n; ++j)\n            printf(\" %d\", mtx[i][j]);\n        printf(\"\\n\");\n    }\n}\n\nä¹‹æ‰€ä»¥åªå¯¹ç«–è¾¹æ£€æŸ¥å³å¯ï¼ˆif (l != n / 2)ï¼‰æ˜¯å› ä¸ºï¼Œå› æ­¤åªå¯èƒ½é€€åŒ–ä¸ºä¸€ä¸ªç‚¹ï¼ˆï¼‰æˆ–æ˜¯ä¸€æ¡ç«–è¾¹ï¼ˆï¼‰ï¼Œè€Œä¸ä¼šå‡ºç°é€€åŒ–æ¨ªè¾¹ã€‚è€Œé€€åŒ–æˆä¸€ä¸ªç‚¹æ—¶ï¼Œåä¸¤è€…forå¾ªç¯éƒ½ä¸ä¼šè¿›å…¥ï¼Œå› æ­¤ä»…è€ƒè™‘ç«–è¾¹å³å¯ã€‚å«Œéº»çƒ¦å°±æ¯æ¬¡éƒ½æ£€æŸ¥idxæ˜¯å¦è¶Šç•Œã€‚\n","slug":"ã€Œ1105ã€Spiral-Matrix","date":"2022-11-02T15:21:40.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"032852f306632572219a0e57a789cd37","title":"ã€Œ1104ã€Sum of Number Segments","content":"Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence { 0.1, 0.2, 0.3, 0.4 }, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) and (0.4).\nNow given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ N, the size of the sequence which is no more thanÂ . The next line containsÂ NÂ positive numbers in the sequence, each no more than 1.0, separated by a space.\nOutput Specification:For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places.\nSample Input:4\n0.1 0.2 0.3 0.4\n\nSample Output:5.00\n\n\nÎ©è¾“å‡ºä¸€ä¸ªæ•°ç»„æ‰€æœ‰è¿ç»­å­ä¸²ä¹‹å’Œä¹‹å’Œï¼Œå¯ä»¥è®¤ä¸ºæ˜¯æŠŠæ‰€æœ‰è¿ç»­å­ä¸²ä¸­å‡ºç°çš„æ•°å­—åŠ èµ·æ¥ã€‚\nå¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬åªéœ€è¦ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°äº†å‡ æ¬¡ï¼Œè€ƒè™‘ç¬¬ä¸ªæ•°ï¼ˆä»0å¼€å§‹æ•°ï¼‰ï¼Œé¦–å…ˆä»¥è¯¥æ•°å­—å¼€å¤´çš„å­ä¸²å…±æœ‰ä¸ªï¼Œè€Œä»¥ç¬¬ä¸ªæ•°å¼€å¤´å¹¶åŒ…å«ç¬¬ä¸ªæ•°çš„è¿ç»­å­ä¸²ä¸ªæ•°éƒ½æ˜¯ï¼Œå› æ­¤ç¬¬ä¸ªæ•°å…±è®¡å‡ºç°æ¬¡ã€‚æœ€ç»ˆç­”æ¡ˆå³ä¸º\n\næœ¬ä»¥ä¸ºåˆæ˜¯æ°´é¢˜ä¸€é“ï¼Œæ²¡æƒ³åˆ°case 2ç»¿çš„æ™ƒçœ¼ã€‚çœ‹äº†åŠå¤©æ‰¾ä¸å‡ºä»€ä¹ˆé”™è¯¯ï¼Œå†¥å†¥ä¹‹ä¸­ä¼°è®¡åˆæ˜¯å››èˆäº”å…¥æˆ–è€…æ˜¯ç²¾åº¦çš„é—®é¢˜ã€‚å‚é˜…äº†ä¸€äº›åšå®¢ä¹‹åï¼Œå‘ç°ç¡®å®æ˜¯doubleçš„é—®é¢˜ã€‚Cè¯­è¨€æµ®ç‚¹æ•°å­˜å‚¨æ˜¯å‚ç…§IEEE 754çš„ï¼Œç®€å•åœ°è¯´å°±æ˜¯ç”±ä¸€ä½ç¬¦å·ä½(S)å’Œå›ºå®šä½æ•°çš„é˜¶ç (E)ã€å°¾æ•°(f)ç»„æˆã€‚ç”±äºå°¾æ•°ä½æ•°æœ‰é™ï¼Œå› æ­¤åœ¨é˜¶ç è¾ƒå¤§æ—¶ä½ä½çš„æ•°å­—æ ¹æœ¬æ— æ³•å­˜å‚¨ä»è€Œé€ æˆäº†ç²¾åº¦çš„æŸå¤±ï¼Œè€Œä¸”æ•°å­—è¶Šå¤§æŸå¤±è¶Šå¤§ã€‚æœ‰å…´è¶£å¯ä»¥çœ‹çœ‹çº æ­£æµ‹è¯•æ•°æ®è¿™ä½åŒå­¦çš„åšå®¢ç”±ä¸€é“ OJ å¼•å‘çš„å…³äº double ç±»å‹çš„ä¸€äº›æ€è€ƒã€‚\næƒ³åœ¨æœ¬é¢˜å†…è§£å†³è¿™ä¸ªé—®é¢˜å¹¶ä¸éš¾ï¼Œåªè¦å°†doubleå·¦ç§»3ä½è½¬å­˜long longï¼Œæœ€åå†/1000.0å³å¯ï¼Œä¸è¿‡è¿™åªèƒ½ç®—ç¼“å…µä¹‹è®¡ã€‚å¦‚æœæƒ³è¦åšåˆ°0è¯¯å·®å¯èƒ½å°±éœ€è¦å®ç°ä¸€ä¸ªå¤§æ•°ç±»ï¼Œè¿™ä¸ç»è®©æˆ‘æƒ³èµ·äº†å¤§ä¸€åšçš„ä¸ªå¤§ä½œä¸šï¼šé«˜ç²¾åº¦å®æ•°è¿ç®—ï¼Œæ˜¯ç”¨é“¾è¡¨å®ç°äº†ä¸€ä¸ªå¤§æ•°ç±»ï¼Œç®—æ˜¯ç”¨ç©ºé—´æ¢ç²¾åº¦ï¼Œé—²æ¥æ— äº‹å¯ä»¥ç…ç…ã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    double k;\n    long long ans = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        ans += (long long)(k * 1000) * (n - i) * (i + 1)  ;\n    }\n    printf(\"%.2lf\", ans/1000.0);\n}\n","slug":"ã€Œ1104ã€Sum-of-Number-Segments","date":"2022-11-02T08:58:20.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"4ef3e4e200e4b84799be544dd9cdda17","title":"ã€Œ1103ã€Integer Factorization","content":"TheÂ Kâˆ’PÂ factorization of a positive integerÂ NÂ is to writeÂ NÂ as the sum of theÂ P-th power ofÂ KÂ positive integers. You are supposed to write a program to find theÂ Kâˆ’PÂ factorization ofÂ NÂ for any positive integersÂ N,Â KÂ andÂ P.\n\n\nInput Specification:Each input file contains one test case which gives in a line the three positive integersÂ NÂ (â‰¤400),Â KÂ (â‰¤N) andÂ PÂ (1&lt;Pâ‰¤7). The numbers in a line are separated by a space.\nOutput Specification:For each case, if the solution exists, output in the format:\nN = n[1]^P + ... n[K]^P\n\nwhereÂ n[i]Â (iÂ = 1, â€¦,Â K) is theÂ i-th factor. All the factors must be printed in non-increasing order.\nNote: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such asÂ 122+42+22+22+12, orÂ 112+62+22+22+22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen â€“ sequence  is said to beÂ largerÂ than  if there existsÂ Â such thatÂ Â forÂ Â andÂ â€‹.\nIf there is no solution, simple outputÂ Impossible.\nSample Input 1:169 5 2\n\nSample Output 1:169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2\n\nSample Input 2:169 167 3\n\n\nÎ©ç»™å®šï¼Œå°†åˆ†è§£ä¸ºï¼Œæ»¡è¶³ã€‚\nä¸€å¼€å§‹æ²¡ä»€ä¹ˆå¤´ç»ªï¼Œå°±æƒ³ç€æšä¸¾å‘—ï¼Œä½†ä»å“ªå¼€å§‹æšä¸¾å‘¢ã€‚\né¦–å…ˆé¢˜ç›®è¦æ±‚å¦‚æœæœ‰å¤šä¸ªè§£åˆ™ä¼˜å…ˆé€‰æ‹©æ›´å¤§çš„è§£ï¼Œå¦‚æœä¹Ÿç›¸ç­‰åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ªä¸åŒfactoræ›´å¤§çš„è§£ï¼Œæˆ‘ä»¬ä¹Ÿè®¤ä¸ºè¿™ä¸ªè§£&gt;å¦ä¸€ä¸ªè§£ã€‚ä¸ºäº†å¯ä»¥å°‘åˆ¤æ–­ä¸€ä¸ªé€‰æ‹©æ¡ä»¶ï¼Œæˆ‘ä»¬ç›´æ¥ä»æœ€å¤§è§£å¼€å§‹éå†ï¼Œè¿™æ ·å…ˆé‡åˆ°çš„å¯è¡Œè§£å°±è‚¯å®šæ˜¯æ›´å¤§çš„ã€‚é¦–å…ˆå¯ä»¥è‚¯å®šï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†ä½œä¸ºæœ€å¤§çš„åˆå§‹ï¼ˆä¸ä¸€å®šå¯è¡Œï¼‰è§£å‘é‡ï¼Œç„¶åå‘ä¸‹éå†ã€‚\næˆ‘ä»¬è§„å®šè¡¨ç¤ºè§£å‘é‡ä¸­æœ€åä¸€ä¸ªéé›¶å…ƒç´ çš„å¼•ç”¨ï¼Œè¡¨ç¤ºè§£å‘é‡ä¸­çš„éé›¶å…ƒç´ çš„ä¸ªæ•°ï¼Œ ï¼Œï¼Œè¡¨ç¤ºç›®å‰æœ€å¤§çš„sï¼Œè¡¨ç¤ºå°†vçš„ç¬¬ä¸€ä¸ª0å…ƒç´ æ”¹ä¸ºtï¼Œè¡¨ç¤ºå°†ä¸‹ä¸€ä¸ªå¯è¡Œè§£èµ‹ç»™ï¼Œç„¶ååˆ¶å®šå¦‚ä¸‹éå†è§„åˆ™ï¼š\n\n\n\n\n\nï¼šæ›´æ–°æœ€ä¼˜è§£ï¼Œï¼Œ\n\nï¼š\n\n\n\nï¼š\n\n\n\n\n\nï¼š\n\nï¼š\n\n\n\n\nç®€å•åœ°è¯´ï¼Œå¦‚æœæ²¡åˆ°Kä¸ªfactorå°±ç»§ç»­åŠ å…¥æœ€å¤§å¯èƒ½çš„factorï¼Œåˆ°äº†Kä¸ªå°±çœ‹factorçš„Pæ–¹å’Œæ˜¯å¦ä¸ºNï¼Œè‹¥m=0é‚£ä¹ˆå°±çœ‹è¿™ä¸ªè§£æ˜¯å¦æ›´ä¼˜ï¼Œsæ›´å¤§çš„è¯å°±æ›´æ–°æœ€ä¼˜è§£ã€‚\nä¸»ä½“éƒ¨åˆ†å·²ç»ç¡®å®šäº†ï¼Œé‚£ä¹ˆåº”è¯¥å¦‚ä½•å®ç°å‘¢ã€‚ç›´æ¥çš„æƒ³æ³•å°±æ˜¯å¯¹æœ€åä¸€ä¸ªéé›¶å…ƒç´ å‡1ï¼Œâš ï¸å¦‚æœå‡åˆ°0äº†å°±å¿…é¡»å¯¹å†å‰ä¸€ä¸ªfactorå‡1ï¼Œå¦åˆ™å°†ä¼šé‡æ–°éå†è¿™æ®µè¿‡ç¨‹ï¼Œé™·å…¥æ­»å¾ªç¯ã€‚ä½†æˆ‘ä»¬è¿˜å¯ä»¥åšå‡ºä¸€äº›ä¼˜åŒ–ã€‚é¦–å…ˆï¼Œæ³¨æ„åˆ°åœ¨çš„æ—¶å€™è‚¯å®šä¼šæ‰§è¡Œï¼Œæ­¤æ—¶æœ€åä¸€ä¸ªå…ƒç´ ä¸ç®¡å‡å¤šå°‘è‚¯å®šï¼Œä¸å¯èƒ½äº§ç”Ÿå¯è¡Œè§£ï¼Œå› æ­¤å¯ä»¥ç›´æ¥æŠŠåˆ é™¤ï¼Œå¯¹å€’æ•°ç¬¬äºŒä¸ªfactorå‡1ã€‚è€Œæ—¶å°±ä¸èƒ½ç›´æ¥æŠŠåˆ é™¤ï¼Œå°±æ‰§è¡Œæ­£å¸¸å‡1ã€‚åŒæ—¶åˆ«å¿˜æ›´æ–°ã€‚\nè‡³æ­¤å°±å·®ä¸å¤šäº†ï¼Œæ¥ä¸‹æ¥åšä¸€äº›ä¼˜åŒ–ã€‚æ³¨æ„åˆ°è¿™ç§é¢˜ç›®ä¸­ä¼šç”¨åˆ°å¾ˆå¤špowå‡½æ•°ï¼Œä½†powå‡½æ•°æ•ˆç‡ä»¤äººå ªå¿§ï¼Œä¸€ç§å¸¸è§çš„åŠæ³•æ˜¯è‡ªå·±å®ç°ä¸€ä¸‹ç®€å•çš„myPowå‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸€é¢˜æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå› æ­¤æˆ‘ä»¬åªä¼šæ±‚ä»¥å†…æ•´æ•°çš„Pæ¬¡æ–¹ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥æ‰“è¡¨ï¼Œç”¨ä¸€ä¸ªvectorå­˜å‚¨1-çš„Pæ¬¡æ–¹å³å¯ã€‚å¦å¤–å½“æ—¶å°±è¯´æ˜æ¥ä¸‹æ¥æ‰€éå†çš„è§£ä¸å¯èƒ½äº§ç”Ÿå¯è¡Œè§£ï¼Œç›´æ¥è·³è¿‡ï¼Œè€Œæˆ‘ä»¬å¯ä»¥ç”¨ä¹‹å‰çš„Pæ¬¡æ–¹vectorå¤–åŠ äºŒåˆ†æŸ¥æ‰¾å¿«é€Ÿæ‰¾åˆ°ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint n, k, p, s, s_max = 0, m;\nvector&lt;int&gt; power{0, 1};\n\ninline int nth_root(int a)\n{\n    int left = 1, right = power.size(), mid;\n    while (left &lt; right - 1)\n    {\n        mid = (left + right) / 2;\n        if (power[mid] &gt; a) right = mid;\n        else left = mid;\n    }\n    return left;\n}\n\n// eliminate the last factor and minus 1\ninline void next(vector&lt;int&gt; &amp;sol)\n{\n    s -= sol.back(), m += power[sol.back()];\n    sol.pop_back();\n    while (!sol.empty() &amp;&amp; sol.back() == 1)\n    {\n        m += 1, s -= 1;\n        sol.pop_back();\n    }\n    while (!sol.empty())\n    {\n        sol.back() -= 1, s -= 1;\n        m += power[sol.back() + 1] - power[sol.back()];\n        if (power[sol.back()] * (k - sol.size()) &lt; m)\n        {\n            m += power[sol.back()];\n            s -= sol.back();\n            sol.pop_back();\n        }\n        else break;\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &amp;n, &amp;k, &amp;p);\n    for (int i = 2; power.back() &lt; n; ++i)\n    {\n        int otc = i;\n        for (int j = 1; j &lt; p; ++j) otc *= i;\n        power.push_back(otc);\n    }\n    vector&lt;int&gt; opt, tmp{nth_root(n)};\n    m = n - power[tmp.back()];\n    s = tmp.back();\n    while (!tmp.empty())\n    {\n        if (tmp.size() == k)\n        {\n            if (m == 0 &amp;&amp; s &gt; s_max)\n            {\n                s_max = s;\n                opt = tmp;\n            }\n            next(tmp);\n        }\n        else if (m &gt; 0)\n        {\n            tmp.push_back(min(tmp.back(), nth_root(m)));\n            m -= power[tmp.back()];\n            s += tmp.back();\n        }\n        else\n        {\n            tmp.push_back(0);\n            next(tmp);\n        }\n    }\n    if (s_max == 0) printf(\"Impossible\");\n    else\n    {\n        printf(\"%d = %d^%d\", n, opt[0], p);\n        for (int i = 1; i &lt; opt.size(); ++i)\n            printf(\" + %d^%d\", opt[i], p);\n    }\n}\n","slug":"ã€Œ1103ã€Integer-Factorization","date":"2022-11-02T02:26:51.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"11aaeea099b9cb0ef7fb12c65a5510db","title":"ã€Œ1102ã€Invert a Binary Tree","content":"The following is from Max Howell @twitter:\nGoogle: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off.\n\nNow itâ€™s your turn to prove that YOU CAN invert a binary tree!\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤10) which is the total number of nodes in the tree â€“ and hence the nodes are numbered from 0 toÂ Nâˆ’1. ThenÂ NÂ lines follow, each corresponds to a node from 0 toÂ Nâˆ’1, and gives the indices of the left and right children of the node. If the child does not exist, aÂ -Â will be put at the position. Any pair of children are separated by a space.\nOutput Specification:For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.\nSample Input:8\n1 -\n- -\n0 -\n2 7\n- -\n- -\n5 -\n4 6\n\nSample Output:3 7 2 6 4 0 5 1\n6 5 7 4 3 2 0 1\n\n\nÎ©è¾“å‡ºåè½¬äºŒå‰æ ‘çš„å±‚æ¬¡å’Œä¸­åºéå†ã€‚\næ²¡ä»€ä¹ˆéš¾åº¦ï¼Œå°±æ˜¯æŠŠäºŒå‰æ ‘çš„å·¦å³èŠ‚ç‚¹éƒ½äº’æ¢ä¸€ä¸‹ã€‚\næ ¹èŠ‚ç‚¹çš„ç¡®å®šåªè¦çœ‹å“ªä¸ªèŠ‚ç‚¹æ²¡çˆ¶èŠ‚ç‚¹å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; son;\nvector&lt;int&gt; in;\n\nvoid in_order(int root)\n{\n    if (root == -1) return;\n    in_order(son[root].second);\n    in.push_back(root);\n    in_order(son[root].first);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    son.resize(n);\n    string l, r;\n    int root = (n - 1) * n / 2;\n    for (auto &amp;k: son)\n    {\n        cin &gt;&gt; l &gt;&gt; r;\n        k.first = (l == \"-\" ? -1 : (root -= stoi(l), stoi(l)));\n        k.second = (r == \"-\" ? -1 : (root -= stoi(r), stoi(r)));\n    }\n    cout &lt;&lt; root;\n    vector&lt;int&gt; crt{3}, nxt;\n    do\n    {\n        for (auto k: crt)\n        {\n            if (son[k].first != -1) nxt.push_back(son[k].first);\n            if (son[k].second != -1) nxt.push_back(son[k].second);\n        }\n        for (int i = int(nxt.size() - 1); i &gt;= 0; --i)\n            cout &lt;&lt; \" \" &lt;&lt; nxt[i];\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    } while (!crt.empty());\n    cout &lt;&lt; endl;\n    in_order(root);\n    cout &lt;&lt; in[0];\n    for (int i = 1; i &lt; n; ++i)\n        cout &lt;&lt; \" \" &lt;&lt; in[i];\n}\n","slug":"ã€Œ1102ã€Invert-a-Binary-Tree","date":"2022-10-29T12:36:57.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,BFS,traversal order,Tree","author_index":"Starlit Rover"},{"id":"4d3cc8d027fb9a0d2261e74e193155cc","title":"ã€Œ1101ã€Quick Sort","content":"There is a classical process namedÂ partitionÂ in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. GivenÂ NÂ distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition?\nFor example, givenÂ N=5Â and the numbers 1, 3, 2, 4, and 5. We have:\n\n1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;\n3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;\n2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;\nand for the similar reason, 4 and 5 could also be the pivot.\n\nHence in total there are 3 pivot candidates.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ . Then the next line containsÂ NÂ distinct positive integers no larger thanÂ 109. The numbers in a line are separated by spaces.\nOutput Specification:For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line.\nSample Input:5\n1 3 2 4 5\n\nSample Output:3\n1 4 5\n\n\nÎ©åœ¨å¿«é€Ÿæ’åºä¸­ç»å¸¸éœ€è¦è®¾å®šä¸€ä¸ªï¼Œæˆ‘ä»¬æŠŠæ”¾å®ƒå·¦è¾¹ï¼Œçš„æ”¾å®ƒå³è¾¹ï¼Œç„¶åé€’å½’åˆ†æ²»ã€‚é‚£ä¹ˆç»™å‡ºä¸€ä¸ªå¿«æ’åºåˆ—ï¼Œè¯·è¾“å‡ºå…¶ä¸­çš„å“ªäº›æ•°å¯èƒ½æ˜¯ã€‚\næ¯”è¾ƒç®€å•ï¼Œé¦–å…ˆå¯ä»¥è‚¯å®šçš„ä¸€ç‚¹æ˜¯æ‰€å¤„çš„ä½ç½®ä¸€å®šå’Œæ’åºåçš„ä½ç½®ç›¸åŒï¼Œå› æ­¤æˆ‘ä»¬å…ˆå¯¹åŸåºåˆ—sortä¸€ä¸‹ï¼Œç„¶åä»å¤´å¼€å§‹éå†ï¼Œå¦‚æœå½“å‰ä½ç½®å…ƒç´ ä¸æ’åºåå…ƒç´ ä¸åŒå°±ç›´æ¥è·³è¿‡ï¼ˆâš ï¸è·³è¿‡æ—¶åˆ«å¿˜è®°å½•å½“å‰æœ€å¤§å€¼ï¼‰ï¼Œå¦åˆ™æ¯”è¾ƒå·¦è¾¹æœ€å¤§å…ƒç´ ä¸å½“å‰å…ƒç´ çš„å¤§å°ï¼Œå¦‚æœå°äºå½“å‰å…ƒç´ å°±è¯´æ˜æ¯”å®ƒå°çš„æ•°éƒ½åœ¨å·¦è¾¹ï¼Œé‚£ä¹ˆå°±æ˜¯ï¼Œç„¶åæ›´æ–°å½“å‰ï¼ˆå·¦è¾¹ï¼‰æœ€å¤§å…ƒç´ ã€‚\nç”±äºä»¬æ‰€å¤„ä½ç½®å°±æ˜¯æ’åºåçš„ä½ç½®ï¼Œå› æ­¤ä»å¤´å¼€å§‹éå†ä¸€å®šæ˜¯æŒ‰ç…§å‡åºå‹å…¥çš„ï¼Œæœ€åå°±æ— éœ€sortäº†ï¼ŒæŒ‰é¡ºåºè¾“å‡ºå³å¯ã€‚\noï¼Œæœ‰ä¸ªæå…¶ç¦»è°±çš„æµ‹è¯•ç‚¹ï¼ˆcase 2ï¼‰ï¼Œå°±æ˜¯0çš„æ—¶å€™éœ€è¦å›è½¦ä¸¤æ¬¡ï¼Œä¹Ÿå°±æ˜¯éœ€è¦æŠŠåˆ—ä¸¾pivotçš„é‚£ä¸€åˆ—ç©ºå‡ºæ¥ï¼Œä¸çŸ¥é“å’‹æƒ³çš„ï¼Œå­©å­å·²ç»å¾ˆä¹…æ²¡æœ‰Presentation Erroräº†ï¼ˆâˆ’ï¼¿âˆ’#ï¼‰ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, left_max = -1;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; seq(n);\n    for (auto &amp;k: seq)\n        cin &gt;&gt; k;\n    vector&lt;int&gt; copy(seq), ans;\n    sort(copy.begin(), copy.end());\n    for (int i = 0; i &lt; n; ++i)\n    {\n        left_max = max(left_max, seq[i]);\n        if (copy[i] != seq[i]) continue;\n        if (left_max &lt;= seq[i]) ans.push_back(seq[i]);\n    }\n    if (ans.empty()) printf(\"0\\n\\n\");\n    else\n    {\n        printf(\"%zu\\n%d\", ans.size(), ans[0]);\n        for (int i = 1; i &lt; ans.size(); ++i)\n            printf(\" %d\", ans[i]);\n    }\n}\n","slug":"ã€Œ1101ã€Quick-Sort","date":"2022-10-29T09:44:37.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"f3192472433d930fd2273aca0588815b","title":"ã€Œ1100ã€Mars Numbers","content":"People on Mars count their numbers with base 13:\n\nZero on Earth is called â€œtretâ€ on Mars.\nThe numbers 1 to 12 on Earth is called â€œjan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, decâ€ on Mars, respectively.\nFor the next higher digit, Mars people name the 12 numbers as â€œtam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jouâ€, respectively.\n\nFor examples, the number 29 on Earth is called â€œhel marâ€ on Mars; and â€œelo novâ€ on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ NÂ (&lt;100). ThenÂ NÂ lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars.\nOutput Specification:For each number, print in a line the corresponding number in the other language.\nSample Input:4\n29\n5\nelo nov\ntam\n\nSample Output:hel mar\nmay\n115\n13\n\n\nÎ©ç«æ˜Ÿä¸Šé¢ä¸ç”¨å­—æ¯ï¼Œè°¢è°¢ã€‚\nç»™åœ°çƒå’Œç«æ˜Ÿç¿»è¯‘æ•°å­—ï¼Œå‡è®¾ç«æ˜Ÿä¸Šçš„æ•°å­—æ˜¯13è¿›åˆ¶çš„ï¼Œè€Œä¸”æœ€å¤šä¸¤ä½ï¼Œè€Œä¸”æ¯ä¸€ä½çš„æ•°å­—è¡¨ç¤ºéƒ½ä¸åŒï¼Œå¦æœ‰ä»¥ä¸‹è§„åˆ™ï¼š\n\n0éœ€è¦å•ç‹¬è¾“å‡ºâ€œtretâ€\n\næŸä½ä¸Šçš„æ•°å­—ä¸º0æ—¶ä¸è¾“å‡º\n\nå¦‚æœä¸¤ä½éƒ½è¾“å‡ºä¸­é—´å¿…é¡»æœ‰ç©ºæ ¼\n\n\nçœŸçš„å¾ˆè®¨åŒè¿™ç§åˆ†ç±»è®¨è®ºé¢˜ï¼Œä¸€ä¸å°å¿ƒå°±æŠŠæ‰€æœ‰å‘éƒ½è¸©äº†ä¸€éã€‚é¦–å…ˆæ ¹æ®è¯»å…¥çš„ä¸€è¡Œå­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºæ•°å­—æ¥åˆ¤æ–­æ˜¯ç«æ˜Ÿæ•°å­—è¿˜æ˜¯åœ°çƒæ•°å­—ã€‚\nå¦‚æœæ˜¯åœ°çƒæ•°å­—ï¼Œåˆ†åˆ«å¯¹13è¿›è¡Œé™¤å’Œå–ä½™æ“ä½œï¼Œç©ºæ ¼éœ€è¦åœ¨ä¸¤è€…éƒ½ä¸ä¸º0æ—¶å‡ºç°ï¼Œâš ï¸0éœ€å•ç‹¬è¾“å‡ºï¼›å¦‚æœæ˜¯ç«æ˜Ÿæ•°å­—ï¼Œåˆ¤æ–­æ˜¯å¦å«ç©ºæ ¼ï¼Œæœ‰ç©ºæ ¼å°±åˆ†åˆ«æŸ¥æ‰¾å¯¹åº”çš„æ•°å­—ï¼Œæ— ç©ºæ ¼æ—¶è¦å¯¹ä¸¤ä½ä¸Šçš„ç«æ˜Ÿæ•°å­—è¡¨ç¤ºéƒ½æŸ¥æ‰¾ä¸€éï¼Œâš ï¸â€œtretâ€ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;string&gt; high{\"\", \"tam\", \"hel\", \"maa\", \"huh\", \"tou\", \"kes\", \"hei\", \"elo\", \"syy\", \"lok\", \"mer\", \"jou\"},\n                   low{\"\", \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jly\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"};\n    int n;\n    cin &gt;&gt; n;\n    getchar();\n    string s;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        getline(cin, s);\n        if (isdigit(s[0]))\n        {\n            int k = stoi(s);\n            if (k) cout &lt;&lt; high[k / 13] &lt;&lt; (k % 13 &amp;&amp; k / 13 ? \" \" : \"\") &lt;&lt; low[k % 13] &lt;&lt; endl;\n            else cout &lt;&lt; \"tret\\n\";\n        }\n        else\n        {\n            int space = s.find(' ');\n            if (space == string::npos)\n            {\n                if (s == \"tret\") cout &lt;&lt; \"0\\n\";\n                else\n                {\n                    int k = int(find(low.begin(), low.end(), s) - low.begin());\n                    cout &lt;&lt; (k == low.size() ? 13 * (find(high.begin(), high.end(), s) - high.begin()) : k) &lt;&lt; endl;\n                }\n            }\n            else\n            {\n                int a = int(find(high.begin(), high.end(), s.substr(0, space)) - high.begin()),\n                        b = int(find(low.begin(), low.end(), s.substr(space + 1, s.size() - space - 1)) - low.begin());\n                cout &lt;&lt; a * 13 + b &lt;&lt; endl;\n            }\n        }\n    }\n}\n","slug":"ã€Œ1100ã€Mars-Numbers","date":"2022-10-28T16:15:14.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"e3cd66a2f1f386d336b0cf25b87033ab","title":"ã€Œ1099ã€Build A Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the nodeâ€™s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.\nBoth the left and right subtrees must also be binary search trees.\n\nGiven the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2.\n\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤100) which is the total number of nodes in the tree. The nextÂ NÂ lines each contains the left and the right children of a node in the formatÂ left_index right_index, provided that the nodes are numbered from 0 toÂ Nâˆ’1, and 0 is always the root. If one child is missing, thenÂ âˆ’1Â will represent the NULL child pointer. FinallyÂ NÂ distinct integer keys are given in the last line.\nOutput Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line.\nSample Input:9\n1 6\n2 3\n-1 -1\n-1 4\n5 -1\n-1 -1\n7 -1\n-1 8\n-1 -1\n73 45 11 58 82 25 67 38 42\n\nSample Output:58 25 82 11 38 67 45 73 42\n\n\nÎ©ç»™å‡ºäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„ç»“æ„ä¸ä¸€ä¸ªæ— åºæ•°ç»„ï¼Œè¾“å‡ºå°†è¿™ä¸ªæ•°ç»„æ”¾å…¥è¯¥ç»“æ„BSTçš„å±‚æ¬¡éå†ç»“æœã€‚\nå¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬åªè¦çŸ¥é“äº†BSTä¸­æ¯ä¸ªèŠ‚ç‚¹åœ¨æ’åºç»“æœä¸­çš„åºå·å³å¯ï¼Œæ¯”å¦‚æœ€å·¦è¾¹çš„èŠ‚ç‚¹æ˜¯æœ€å°çš„ï¼Œå› æ­¤æ’åºåºå·ä¸º0ï¼Œæ ¹æ®BSTçš„æ€§è´¨å¯çŸ¥æ’åºåºå·å°±æ˜¯å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯¹BSTè¿›è¡Œä¸­åºéå†å°±èƒ½å¾—åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æ’åºåºå·ï¼Œå†å¯¹è¿›è¡Œæ’åºï¼Œæ ¹æ®åœ¨æ’åºåºåˆ—ä¸­çš„åºå·æ”¾å…¥ç›¸åº”çš„BSTèŠ‚ç‚¹ï¼Œæœ€åBFSéå†è¾“å‡ºèŠ‚ç‚¹å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; idx; // sort index\nvector&lt;pair&lt;int, int&gt;&gt; son;\n\nvoid make_idx(int r) // In-Order Traversal\n{\n    static int i = 0;\n    if (son[r].first != -1)\n        make_idx(son[r].first);\n    idx[r] = i++;\n    if (son[r].second != -1)\n        make_idx(son[r].second);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    son.resize(n);\n    for (auto &amp;s: son)\n        cin &gt;&gt; s.first &gt;&gt; s.second;\n    idx.resize(n);\n    make_idx(0);\n    vector&lt;int&gt; seq(n);\n    for (auto &amp;k: seq)\n        cin &gt;&gt; k;\n    sort(seq.begin(), seq.end());\n    vector&lt;int&gt; crt{0}, nxt;\n    cout &lt;&lt; seq[idx[0]];\n    do\n    {\n        for (auto &amp;k: crt)\n        {\n            if (son[k].first != -1) nxt.push_back(son[k].first);\n            if (son[k].second != -1) nxt.push_back(son[k].second);\n        }\n        for (auto &amp;k: nxt)\n            cout &lt;&lt; \" \" &lt;&lt; seq[idx[k]];\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    } while (!crt.empty());\n}\n","slug":"ã€Œ1099ã€Build-A-Binary-Search-Tree","date":"2022-10-27T12:04:57.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search,BFS,Tree","author_index":"Starlit Rover"},{"id":"1055437ed759d1b58da767b6a5e1ca44","title":"ã€Œ1098ã€Insertion or Heap Sort","content":"According to Wikipedia:\nInsertion sortÂ iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nHeap sortÂ divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤100). Then in the next line,Â NÂ integers are given as the initial sequence. The last line contains the partially sorted sequence of theÂ NÂ numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in the first line either â€œInsertion Sortâ€ or â€œHeap Sortâ€ to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n\nSample Output 1:Insertion Sort\n1 2 3 5 7 8 9 4 6 0\n\nSample Input 2:10\n3 1 2 8 7 5 9 4 6 0\n6 4 5 1 0 3 2 7 8 9\n\nSample Output 2:Heap Sort\n5 4 3 1 0 2 6 7 8 9\n\n\nğŸå¥½åå•Šï¼ŒçŸ¥é“æœ‰sortå‡½æ•°ï¼Œå°±ä¸“æéƒ¨åˆ†æ’åºã€‚ç»™å‡ºéƒ¨åˆ†æ’åºåºåˆ—ï¼Œåˆ¤æ–­æ˜¯æ’å…¥æ’åºè¿˜æ˜¯å †æ’åºï¼Œå¹¶è¾“å‡ºä¸‹ä¸€æ­¥åçš„æ’åºç»“æœã€‚æ¯æ¬¡éƒ½æœ‰æ’å…¥æ’åºçš„å‹æƒ…å‚æ¼”ï¼Œæ¯æ¬¡éƒ½æ˜¯é™ªè¡¬å…¶ä»–æ’åºç®—æ³•ï¼Œå¥½æƒ¨ã€‚\nåˆ¤æ–­æ–¹å¼ã€æ’å…¥æ’åºçš„å¤„ç†å’Œä¸€ä¸ªå¼¥å¤©å¤§å‘å‚ç…§ã€Œ1089ã€Insert or Merge ï¼Œç¬¬ä¸€æ¬¡å†™å †æ’åºï¼Œè„‘å­è·Ÿç›˜å¤å¼€å¤©è¾Ÿåœ°ä¸€æ ·ã€‚å †æ’åºçš„åº•å±‚æ•°æ®ç»“æ„æ˜¯äºŒå‰æ ‘ï¼Œæ ¹æ®æ ¹èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹çš„å¤§å°å…³ç³»å¯ä»¥åˆ†ä¸ºå¤§é¡¶å †ï¼ˆfather&gt;sonsï¼‰å’Œå°é¡¶å †ï¼ˆfather&lt;sonsï¼‰ã€‚ä»¥å¤§é¡¶å †ä¸ºä¾‹ï¼Œæ¯æ¬¡éƒ½æŠŠäºŒå‰æ ‘åˆ†ä¸ºåªæœ‰ä¸¤å±‚ï¼ˆåªæœ‰çˆ¶äº²å’Œæœ€å¤šä¸¤ä¸ªå„¿å­ï¼‰çš„å°å­å †ï¼Œç„¶åä»æœ€åä¸€ä¸ªå°å †å¼€å§‹ï¼ŒæŠŠå°å †ä¸­æœ€å¤§çš„èŠ‚ç‚¹ä¸æ ¹èŠ‚ç‚¹è¿›è¡Œäº’æ¢ï¼Œä»åå¾€å‰åšå®Œåæ•´æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹å°±æ˜¯æœ€å¤§çš„å…ƒç´ ã€‚ç„¶åæŠŠè¿™ä¸ªæœ€å¤§çš„å…ƒç´ æ”¾åˆ°æœ€åä¸€ä¸ªä½ç½®ä¸Šï¼ˆä¸æœ€åä¸€ä¸ªå…ƒç´ äº’æ¢ï¼‰ï¼Œå¹¶å°†äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°-1ï¼Œå³æœ€åçš„ä½ç½®ä¸å‚ä¸æ¥ä¸‹æ¥çš„æ’åºã€‚æœ€åäºŒå‰æ ‘çš„å±‚æ¬¡éå†ç»“æœå°±æ˜¯å‡åºæ’åˆ—ã€‚\nâš ï¸åœ¨äº’æ¢å°å †çš„çˆ¶å­èŠ‚ç‚¹æ—¶ï¼Œå¦‚æœè¿™ä¸ªå­èŠ‚ç‚¹æ˜¯å¦ä¸€ä¸ªå°å †çš„çˆ¶èŠ‚ç‚¹ï¼Œé‚£ä¹ˆåº”è¯¥é€’å½’å‘ä¸‹è°ƒæ•´ï¼Œç›´åˆ°æ²¡æœ‰å­èŠ‚ç‚¹æˆ–è€…æ— éœ€äº¤æ¢ä¸ºæ­¢ã€‚\näº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ï¼Œåœ¨ç¬¬ä¸€æ¬¡è°ƒæ•´å®Œæ¯•åï¼Œæ¥ä¸‹æ¥çš„æ¯æ¬¡è°ƒæ•´éƒ½æ— éœ€ä»åå¾€å‰ä¾æ¬¡è°ƒæ•´ï¼Œå› ä¸ºæˆ‘ä»¬åªäº¤æ¢äº†æ ¹èŠ‚ç‚¹ä¸æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œä¸æ»¡è¶³å¤§/å°é¡¶å †çš„åªå¯èƒ½æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå› æ­¤åªéœ€ä»æ ¹èŠ‚ç‚¹å‘ä¸‹é€’å½’è°ƒæ•´å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ninline void heap_down(vector&lt;int&gt; &amp;heap, int r, int end)\n{\n    int max_r = (end - 1) / 2, j;\n    while (r &lt;= max_r)\n    {\n        if (2 * r + 2 &lt;= end)\n            j = (heap[2 * r + 2] &gt; heap[2 * r + 1] ? 2 * r + 2 : 2 * r + 1);\n        else if (2 * r + 1 &lt;= end)\n            j = 2 * r + 1;\n        if (heap[j] &gt; heap[r])\n        {\n            swap(heap[j], heap[r]);\n            r = j;\n        }\n        else break;\n    }\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; org(n), crt(n);\n    for (auto &amp;k: org)\n        cin &gt;&gt; k;\n    for (auto &amp;k: crt)\n        cin &gt;&gt; k;\n    int t = n - 1;\n    while (t &gt;= 0 &amp;&amp; crt[t] == org[t]) --t;\n    if (t == -1)\n    {\n        t = 0;\n        while (t &lt; n &amp;&amp; crt[t] &lt;= crt[t + 1]) ++t;\n    }\n    vector&lt;int&gt; copy(org);\n    sort(copy.begin(), copy.begin() + t + 1);\n    bool isHeap = false;\n    for (int i = 0; i &lt; n &amp;&amp; (copy[i] == crt[i] || (isHeap = true, false)); ++i);\n    cout &lt;&lt; (isHeap ? \"Heap\" : \"Insertion\") &lt;&lt; \" Sort\\n\";\n    if (isHeap)\n    {\n        int end = n - 1, max_r = n - 1;\n        for (int i = max_r; i &gt;= 0; --i)\n            heap_down(org, i, end);\n        while (--end, copy != crt)\n        {\n            copy = org;\n            swap(org[0], org[end + 1]);\n            heap_down(org, 0, end);\n        }\n    }\n    else\n        sort(org.begin(), org.begin() + t + 2);\n    for (int i = 0; i &lt; n; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; org[i];\n}\n\nmax_ræ˜¯æ‹¥æœ‰å„¿å­çš„æœ€å¤§èŠ‚ç‚¹ç¼–å·ï¼Œ&gt;max_rçš„èŠ‚ç‚¹å°±æ— éœ€è°ƒæ•´ã€‚\n","slug":"ã€Œ1098ã€Insertion-or-Heap-Sort","date":"2022-10-27T05:01:24.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,heap","author_index":"Starlit Rover"},{"id":"ffc78994f12cf87b4b6e2fe952701b6e","title":"ã€Œ1097ã€Deduplication on a Linked List","content":"Given a singly linked listÂ LÂ with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each valueÂ K, only the first node of which the value or absolute value of its key equalsÂ KÂ will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, givenÂ LÂ being 21â†’-15â†’-15â†’-7â†’15, you must output 21â†’-15â†’-7, and the removed list -15â†’15.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, and a positiveÂ  which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented byÂ âˆ’1.\nThenÂ NÂ lines follow, each describes a node in the format:\nAddress Key Next\n\nwhereÂ AddressÂ is the position of the node,Â KeyÂ is an integer of which absolute value is no more thanÂ 104, andÂ NextÂ is the position of the next node.\nOutput Specification:For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 5\n99999 -7 87654\n23854 -15 00000\n87654 15 -1\n00000 -15 99999\n00100 21 23854\n\nSample Output:00100 21 23854\n23854 -15 99999\n99999 -7 -1\n00000 -15 87654\n87654 15 -1\n\n\nÎ©å¯¹ä¸€ä¸ªé“¾è¡¨è¿›è¡Œç»å¯¹å€¼å»é‡ï¼Œå³å°†ç»å¯¹å€¼ä¸å‰é¢èŠ‚ç‚¹é‡å¤çš„èŠ‚ç‚¹å•ç‹¬å–å‡ºç»„æˆä¸€ä¸ªæ–°çš„é“¾è¡¨ï¼Œæœ€åè¾“å‡ºä¸¤ä¸ªé“¾è¡¨ã€‚\né¦–å…ˆè¯»å…¥æ‰€æœ‰èŠ‚ç‚¹ï¼Œç„¶åç”¨ä¸€ä¸ªmap&lt;int,bool&gt;è®°å½•å‡ºç°è¿‡çš„èŠ‚ç‚¹keyï¼Œå†ç”¨ä¸¤ä¸ªvector&lt;string,int&gt;æ¥æ¨¡æ‹Ÿé“¾è¡¨ï¼Œæœ€åç›´æ¥æŒ‰é¡ºåºè¾“å‡ºå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    string head, crt, nxt;\n    cin &gt;&gt; head &gt;&gt; n;\n    map&lt;string, pair&lt;int, string&gt;&gt; node;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; crt &gt;&gt; m &gt;&gt; nxt;\n        node[crt] = make_pair(m, nxt);\n    }\n    map&lt;int, bool&gt; flag;\n    crt = head;\n    vector&lt;pair&lt;string, int&gt;&gt; stay, rmv;\n    while (crt != \"-1\")\n    {\n        if (flag[abs(node[crt].first)])\n            rmv.emplace_back(crt, node[crt].first);\n        else\n        {\n            stay.emplace_back(crt, node[crt].first);\n            flag[abs(node[crt].first)] = true;\n        }\n        crt = node[crt].second;\n    }\n    stay.emplace_back(\"-1\", 0), rmv.emplace_back(\"-1\", 0);\n    for (int i = 0; i &lt; stay.size() - 1; ++i)\n        printf(\"%s %d %s\\n\", stay[i].first.c_str(), stay[i].second, stay[i + 1].first.c_str());\n    for (int i = 0; i &lt; rmv.size() - 1; ++i)\n        printf(\"%s %d %s\\n\", rmv[i].first.c_str(), rmv[i].second, rmv[i + 1].first.c_str());\n}\n","slug":"ã€Œ1097ã€Deduplication-on-a-Linked-List","date":"2022-10-26T15:57:17.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,string,list","author_index":"Starlit Rover"},{"id":"4284065e5cb88855913cdeb3766387e3","title":"ã€Œ1096ã€Consecutive Factors","content":"Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3Ã—5Ã—6Ã—7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors.\n\n\nInput Specification:Each input file contains one test case, which gives the integer .\nOutput Specification:For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the formatÂ factor[1]*factor[2]*...*factor[k], where the factors are listed in increasing order, and 1 is NOT included.\nSample Input:630\n\nSample Output:3\n5*6*7\n\n\nÎ©è¾“å‡ºä¸€ä¸ªæ•°æœ€é•¿çš„è¿ç»­å› å­ä¸²ï¼Œå› å­ä¸²çš„ä¹˜ç§¯å¯ä»¥æ•´é™¤ã€‚\næƒ³ä¸å‡ºä»€ä¹ˆç²¾å¦™çš„è§£æ³•ï¼Œå•çº¯ä»2åˆ°å¼€å§‹æšä¸¾ï¼Œå¦‚æœè¿™ä¸ªæ•°æ˜¯çš„å› å­å°±å¾€åè¿ç»­æšä¸¾ç›´åˆ°ä¸èƒ½æ•´é™¤ä¸ºæ­¢ï¼Œç„¶åçœ‹è¿™å› å­ä¸²é•¿åº¦æ˜¯å¦è¶…è¿‡äº†ç›®å‰ä¸ºæ­¢çš„æœ€å¤§é•¿åº¦ã€‚\nèµ·åˆæœ‰ä¸ªæƒ³æ³•ï¼Œå°±æ˜¯å¦‚æœæˆ‘æ‰¾åˆ°äº†ä¸€ä¸ªæ»¡è¶³é¢˜æ„çš„å±€éƒ¨æœ€é•¿å› å­ä¸²ï¼Œé‚£ä¹ˆä¸‹ä¸€æ¬¡æˆ‘æ˜¯ä¸æ˜¯å°±å¯ä»¥ç›´æ¥ä»å¼€å§‹æšä¸¾äº†ï¼Œå› ä¸ºï¼ˆæ ¹æ®å±€éƒ¨æœ€é•¿å¯çŸ¥ï¼‰ã€‚ä»”ç»†æ¨æ•²åå°±ä¼šå‘ç°æ˜¯é”™çš„ï¼Œæ¯”å¦‚è¯´60ï¼Œä»2å¼€å§‹æšä¸¾åªèƒ½å¾—åˆ°ï¼Œå¦‚æœè·³è¿‡3ã€4ç›´æ¥ä»5å¼€å§‹æšä¸¾å°±ä¼šé”™è¿‡è¿™ä¸ªæœ€ä¼˜è§£ã€‚æœ¬è´¨åŸå› æ˜¯å› ä¸ºå‰é¢çš„å› å­å¯èƒ½ä¼šå ç”¨åé¢æ•°çš„å› å­æ‰å¯¼è‡´æ— æ³•æ•´é™¤ï¼Œè¿™é‡Œå°±æ˜¯2å ç”¨äº†4çš„ä¸€ä¸ª2å› å­æ‰å¯¼è‡´æ— æ³•æ•´é™¤ã€‚å¦‚æœé¢˜ç›®æ±‚çš„æ˜¯è¿ç»­è´¨å› å­ä¸²å°±æ²¡é—®é¢˜äº†ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n;\n    int m, len, max_len = 0, start = n;\n    for (int i = 2; i &lt;= sqrt(n); ++i)\n    {\n        m = n, len = 0, k = i;\n        while (m % k == 0)\n        {\n            m /= k++;\n            ++len;\n        }\n        max_len = (len &gt; max_len) ? (start = i, len) : max_len;\n    }\n    max_len = max_len == 0 ? 1 : max_len;\n    printf(\"%d\\n%d\", max_len, start);\n    for (int i = 1; i &lt; max_len; ++i)\n        printf(\"*%d\", start + i);\n}\n","slug":"ã€Œ1096ã€Consecutive-Factors","date":"2022-10-25T07:31:44.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"ba694c9323b17ea3ea3e3b2ebd47bf82","title":"ã€Œ1095ã€Cars on Campus","content":"Zhejiang University has 8 campuses and a lot of gates. From each gate we can collect the in/out times and the plate numbers of the cars crossing the gate. Now with all the information available, you are supposed to tell, at any specific time point, the number of cars parking on campus, and at the end of the day find the cars that have parked for the longest time period.\n\n\nInput Specification:Each input file contains one test case. Each case starts with two positive integersÂ , the number of records, andÂ  the number of queries. ThenÂ NÂ lines follow, each gives a record in the format:\nplate_number hh:mm:ss status\n\nwhereÂ plate_numberÂ is a string of 7 English capital letters or 1-digit numbers;Â hh:mm:ssÂ represents the time point in a day by hour:minute:second, with the earliest time beingÂ 00:00:00Â and the latestÂ 23:59:59; andÂ statusÂ is eitherÂ inÂ orÂ out.\nNote that all times will be within a single day. EachÂ inÂ record is paired with the chronologically next record for the same car provided it is anÂ outÂ record. AnyÂ inÂ records that are not paired with anÂ outÂ record are ignored, as areÂ outÂ records not paired with anÂ inÂ record. It is guaranteed that at least one car is well paired in the input, and no car is bothÂ inÂ andÂ outÂ at the same moment. Times are recorded using a 24-hour clock.\nThenÂ KÂ lines of queries follow, each gives a time point in the formatÂ hh:mm:ss. Note: the queries are given inÂ ascendingÂ order of the times.\nOutput Specification:For each query, output in a line the total number of cars parking on campus. The last line of output is supposed to give the plate number of the car that has parked for the longest time period, and the corresponding time length. If such a car is not unique, then output all of their plate numbers in a line in alphabetical order, separated by a space.\nSample Input:16 7\nJH007BD 18:00:01 in\nZD00001 11:30:08 out\nDB8888A 13:00:00 out\nZA3Q625 23:59:50 out\nZA133CH 10:23:00 in\nZD00001 04:09:59 in\nJH007BD 05:09:59 in\nZA3Q625 11:42:01 out\nJH007BD 05:10:33 in\nZA3Q625 06:30:50 in\nJH007BD 12:23:42 out\nZA3Q625 23:55:00 in\nJH007BD 12:24:23 out\nZA133CH 17:11:22 out\nJH007BD 18:07:01 out\nDB8888A 06:30:50 in\n05:10:00\n06:30:50\n11:00:00\n12:23:42\n14:00:00\n18:00:00\n23:59:00\n\nSample Output:1\n4\n5\n2\n1\n0\n1\nJH007BD ZD00001 07:20:09\n\n\nÎ©ç»™æµ™å¤§åœè½¦åœºå†™ä¸ªè®¡æ•°ç»Ÿè®¡å°ç¨‹åºã€‚ç»™å‡ºNæ¡æ±½è½¦è¿›å‡ºè®°å½•ï¼Œç„¶åå¯¹Kä¸ªæ—¶é—´ç‚¹è¾“å‡ºå½“å‰åœè½¦åœºå†…çš„æ±½è½¦æ•°é‡ï¼Œæœ€åè¾“å‡ºå½“å¤©å†…åœè½¦æ—¶é—´æœ€é•¿çš„æ‰€æœ‰è½¦ç‰Œå·ï¼Œä»¥åŠç›¸åº”çš„åœè½¦æ—¶é—´ã€‚å¦ˆå¦ˆå†ä¹Ÿä¸ç”¨æ‹…å¿ƒæˆ‘è¿›æµ™å¤§å•¦ï½æµ™å¤§ä¿å®‰ï¼šæˆ‘ç”¨è„šè¶¾å¤´éƒ½æ•°å¾—å‡ºæ¥ï¼ŒæŠ¢æˆ‘é¥­ç¢—ï¼Œæ»š\né¦–å…ˆæœ‰ä»¥ä¸‹å‡ ä¸ªæ³¨æ„ç‚¹ï¼š\n\nä¸€è¾†è½¦ä¸€å¤©å†…å¯èƒ½æœ‰å¤šæ¬¡è¿›å‡ºè®°å½•\n\nè¿›å‡ºè®°å½•åªæœ‰åœ¨æ—¶é—´è½´ä¸Šç›¸é‚»æ‰å¯ä»¥åŒ¹é…ï¼ˆå³inè®°å½•ä¸‹ä¸€ä¸ªæ—¶é—´ç‚¹è®°å½•ä¸ºoutï¼‰ï¼Œå¿½ç•¥æ— æ³•åŒ¹é…çš„è®°å½•\n\nè®°å½•è¾“å…¥çš„é¡ºåºä¸æ˜¯æ—¶é—´é¡ºåºï¼Œæ—¶é—´ç‚¹æŸ¥è¯¢åˆ™æ˜¯æŒ‰ç…§æ—¶é—´é¡ºåº\n\n\né¦–å…ˆæ‰€æœ‰æ¶‰åŠåˆ°æ—¶é—´çš„å€¼å…¨éƒ½æ¢ç®—æˆsã€‚ç”±äºè®°å½•æ˜¯æ— åºè¾“å…¥ï¼Œæ‰€ä»¥èµ·åˆä¸èƒ½ç¡®å®šå“ªäº›è®°å½•éœ€è¦å¿½ç•¥ï¼Œå› æ­¤æ¯è¾†è½¦çš„è®°å½•éƒ½ç”¨ä¸€ä¸ªset&lt;pair&lt;int,bool&gt;&gt;æ¥å­˜å‚¨è¿›å‡ºï¼ˆtrue/falseï¼‰çš„æ—¶é—´æˆ³ï¼Œå¤–é¢å†å¥—ä¸€ä¸ªmapä»¥ä¾¿ç”¨è½¦ç‰Œå·æŸ¥è¯¢ã€‚\nå› ä¸ºè¦ç»Ÿè®¡æŸä¸ªæ—¶é—´ç‚¹æ ¡å†…æ±½è½¦æ•°é‡ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå…¨å±€æ—¶é—´æˆ³å˜é‡vector&lt;pair&lt;int,bool&gt;&gt; stampå­˜å‚¨æ‰€æœ‰æ±½è½¦è¿›å‡ºè®°å½•ï¼Œåªç»Ÿè®¡æ•°é‡å°±æ— éœ€å­˜å‚¨è½¦ç‰Œå·ã€‚\nåœ¨æ‰€æœ‰è®°å½•éƒ½è¯»å–å®Œæˆåï¼Œå°±å¯¹æ¯ä¸ªè½¦è¾†èƒ½æˆåŠŸåŒ¹é…ï¼ˆoutè®°å½•å‰ä¸€ä¸ªæ˜¯å¦ä¸ºinè®°å½•ï¼‰çš„è®°å½•å¯¹çš„è¿›å‡ºæ—¶é—´ç‚¹å­˜å…¥stampï¼Œé¡ºä¾¿ç”¨ä¸€ä¸ªmapç»Ÿè®¡åœè½¦æ—¶é•¿ã€‚\nå­˜å®Œåå¯¹stampæ’ä¸ªåºï¼Œæ¥ç€å°±å¯ä»¥è¯»å…¥æŸ¥è¯¢æ—¶é—´ç‚¹täº†ï¼Œå¯¹tæ—¶åˆ»å‰çš„è®°å½•è¿›è¡Œè®¡æ•°ï¼Œå¦‚æœæ˜¯inå°±+1ï¼Œoutåˆ™-1ã€‚æ³¨æ„åˆ°æŸ¥è¯¢æ—¶é—´ç‚¹æ˜¯æŒ‰ç…§æ—¶é—´é¡ºåºçš„ï¼Œå› æ­¤æ— åºå›é€€ï¼Œéå†ä¸€æ¬¡stampè¶³çŸ£ã€‚\næœ€åéå†ä¸€éåœè½¦æ—¶é•¿mapï¼Œæ‰¾åˆ°åœæœ€ä¹…çš„é‚£å‡ è¾†è½¦ï¼Œè¾“å‡ºå³å¯ã€‚\nä¸€éè¿‡ï¼Œä¼¼ä¹æ²¡ä»€ä¹ˆå¤§å‘ï¼Œæµ‹è¯•æ ·ä¾‹å·²ç»æ¶µç›–å¾ˆå¤šæ³¨æ„ç‚¹äº†ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, h, m, s, t;\n    cin &gt;&gt; n &gt;&gt; k;\n    map&lt;string, set&lt;pair&lt;int, bool&gt;&gt;&gt; record;\n    string p(7, 0), st(3, 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d:%d:%d %s\", &amp;p[0], &amp;h, &amp;m, &amp;s, &amp;st[0]);\n        t = 3600 * h + 60 * m + s;\n        record[p].emplace(t, st[0] == 'i');\n    }\n    vector&lt;pair&lt;int, bool&gt;&gt; stamp;\n    map&lt;string, int&gt; time;\n    for (auto &amp;r: record)\n    {\n        int pre = -1;\n        for (auto &amp;w: r.second)\n        {\n            if (w.second) pre = w.first;\n            else if (pre &gt; -1)\n            {\n                stamp.emplace_back(pre, true);\n                stamp.emplace_back(w.first, false);\n                time[r.first] += (w.first - pre);\n                pre = -1;\n            }\n        }\n    }\n    sort(stamp.begin(), stamp.end());\n    int idx = 0, cnt = 0;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        scanf(\"%d:%d:%d\", &amp;h, &amp;m, &amp;s);\n        t = 3600 * h + 60 * m + s;\n        while (idx &lt; stamp.size() &amp;&amp; stamp[idx].first &lt;= t)\n        {\n            cnt += stamp[idx].second ? 1 : -1;\n            ++idx;\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    int max_t = 0;\n    set&lt;string&gt; plt;\n    for (auto &amp;w: time)\n    {\n        if (w.second &gt; max_t)\n        {\n            plt.clear();\n            plt.emplace(w.first);\n            max_t = w.second;\n        }\n        else if (w.second == max_t)\n            plt.emplace(w.first);\n    }\n    for (auto &amp;w: plt)\n        printf(\"%s \", w.c_str());\n    printf(\"%02d:%02d:%02d\", max_t / 3600, max_t % 3600 / 60, max_t % 60);\n}\n","slug":"ã€Œ1095ã€Cars-on-Campus","date":"2022-10-25T03:42:18.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,sort,set","author_index":"Starlit Rover"},{"id":"aee00b96e421a4a9f4457610d24d4237","title":"ã€Œ1094ã€The Largest Generation","content":"A family hierarchy is usually presented by a pedigree tree where all the nodes on the same level belong to the same generation. Your task is to find the generation with the largest population.\n\n\nInput Specification:Each input file contains one test case. Each case starts with two positive integersÂ NÂ (&lt;100) which is the total number of family members in the tree (and hence assume that all the members are numbered from 01 toÂ N), andÂ MÂ (&lt;N) which is the number of family members who have children. ThenÂ MÂ lines follow, each contains the information of a family member in the following format:\nID K ID[1] ID[2] ... ID[K]\n\nwhereÂ IDÂ is a two-digit number representing a family member,Â KÂ (&gt;0) is the number of his/her children, followed by a sequence of two-digitÂ IDâ€˜s of his/her children. For the sake of simplicity, let us fix the rootÂ IDÂ to beÂ 01. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the largest population number and the level of the corresponding generation. It is assumed that such a generation is unique, and the root level is defined to be 1.\nSample Input:23 13\n21 1 23\n01 4 03 02 04 05\n03 3 06 07 08\n06 2 12 13\n13 1 21\n08 2 15 16\n02 2 09 10\n11 2 19 20\n17 1 22\n05 1 11\n07 1 14\n09 1 17\n10 1 18\n\nSample Output:9 4\n\n\nÎ©ç»™å‡ºä¸€ä¸ªå®¶è°±æ ‘ï¼Œéœ€è¦è¾“å‡ºåŒè¾ˆçš„æœ€å¤šäººæ•°ä»¥åŠç›¸åº”çš„è¾ˆåˆ†ã€‚\nç»å…¸æ— è„‘çš„BFSé¢˜ï¼Œæ¯æ¬¡å¾€ä¸‹éå†ä¸€ä¸ªlevelï¼Œç»Ÿè®¡è¯¥å±‚äººæ•°æ˜¯å¦è¶…è¿‡æœ€å¤§å€¼ï¼Œå¦‚æœè¶…è¿‡åˆ™è¿›è¡Œæ ‡è®°ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, f;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;vector&lt;int&gt;&gt; child(n + 1);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; f &gt;&gt; k;\n        child[f].resize(k);\n        for (auto &amp;s: child[f])\n            cin &gt;&gt; s;\n    }\n    int max_pop = 1, level = 1, grt = 1;\n    vector&lt;int&gt; crt{1}, nxt;\n    while (++level, !crt.empty())\n    {\n        for (auto &amp;s: crt)\n            std::move(child[s].begin(), child[s].end(), back_inserter(nxt));\n        max_pop = max_pop &gt; nxt.size() ? max_pop : (grt = level, int(nxt.size()));\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    }\n    cout &lt;&lt; max_pop &lt;&lt; \" \" &lt;&lt; grt;\n}\n\n\nTipsç„¶åå‘ç°moveå‡½æ•°è¿˜æœ‰ä¸€ä¸ªç±»ä¼¼insertçš„éšè—ç”¨æ³•ï¼š\ntemplate&lt;class InputIt, class OutputIt&gt;\nOutputIt move(InputIt first, InputIt last, OutputIt d_first)\n{\n    while (first != last) \n    {\n        *d_first++ = std::move(*first++);\n    }\n    return d_first;\n}\n\nå°±æ˜¯æŠŠä¸€è¿ç»­çš„æ•°æ®moveåˆ°æŒ‡å®šä½ç½®ï¼Œæ‰€ä»¥å¯ä»¥çœ‹åˆ°æˆ‘æ²¡æœ‰ç”¨insertå‡½æ•°ã€‚\n","slug":"ã€Œ1094ã€The-Largest-Generation","date":"2022-10-23T11:10:15.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,BFS,Tree","author_index":"Starlit Rover"},{"id":"fe84dbd5061bf8b532b9409db1710e96","title":"ã€Œ1093ã€Count PAT's","content":"The stringÂ APPAPTÂ contains twoÂ PATâ€˜s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters.\nNow given any string, you are supposed to tell the number ofÂ PATâ€˜s contained in the string.\n\n\nInput Specification:Each input file contains one test case. For each case, there is only one line giving a string of no more thanÂ Â characters containing onlyÂ P,Â A, orÂ T.\nOutput Specification:For each test case, print in one line the number ofÂ PATâ€˜s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007.\nSample Input:APPAPT\n\nSample Output:2\n\n\nÎ©è®¡æ•°ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­æœ‰å‡ ä¸ªPATï¼Œå­—ç¬¦å¯ä»¥é‡å¤ä½¿ç”¨ã€‚\nä»åå¾€å‰éå†å­—ç¬¦ä¸²ï¼Œè®¾ç½®ä¸‰ä¸ªè®¡æ•°å˜é‡sum_T,sum_AT,sum_PATï¼Œå­—å¦‚å…¶åï¼Œæ¯ç»è¿‡ä¸€ä¸ªTæ—¶sum_T+=1ï¼Œæ¯ç»è¿‡ä¸€ä¸ªAæ—¶sum_AT+=sum_Tï¼Œæ¯ç»è¿‡ä¸€ä¸ªPæ—¶sum_PAT+=sum_ATï¼ŒåŸç†å¾ˆæ˜¾ç„¶ï¼Œå°±æ˜¯ç›´æ¥ç»Ÿè®¡æ¯ä¸ªAåé¢æœ‰å‡ ä¸ªTæ¥è®¡æ•°ATï¼Œæ¯ä¸ªPåæœ‰å‡ ä¸ªATæ¥è®¡æ•°PATã€‚\nç¬¬ä¸€æ¬¡æäº¤åé¢ä¸¤ä¸ªæµ‹è¯•ç‚¹ç»¿äº†ï¼Œå› ä¸ºæˆ‘åªåœ¨æœ€åæ¨¡äº†ä¸€æ¬¡1000000007ï¼Œä¸­é—´è¿‡ç¨‹ä¼šå‘ç”Ÿæº¢å‡ºï¼Œæ‰€ä»¥æ¯åŠ ä¸€æ¬¡å°±æ¨¡ä¸€æ¬¡ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin &gt;&gt; s;\n    int sum_T = 0, sum_AT = 0, sum_PAT = 0;\n    reverse(s.begin(), s.end());\n    for (auto &amp;c: s)\n    {\n        sum_T += (c == 'T');\n        sum_AT += (c == 'A') * sum_T;\n        sum_PAT = (sum_PAT + (c == 'P') * sum_AT) % 1000000007;\n    }\n    cout &lt;&lt; sum_PAT;\n}\n","slug":"ã€Œ1093ã€Count-PAT-s","date":"2022-10-23T10:24:59.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"075a9a10b3dedbd22ddf3f7a1ad6394e","title":"0-1å¤šèƒŒåŒ…å¸¦çº¦æŸé—®é¢˜ï¼ˆMKARï¼‰","content":"æœ¬æ–‡å…¶å®ä¸æ™ºèƒ½ç®—æ³•æ— å…³ï¼Œè¿™æ˜¯æœ€ä¼˜åŒ–è¯¾ç¨‹çš„ä¸€ä¸ªå°ä½œä¸šï¼Œä¹‹æ‰€ä»¥æ”¾åœ¨æ™ºèƒ½ç®—æ³•ä¸€æ ï¼Œæ˜¯å› ä¸ºè¿™ä¸ªé—®é¢˜çš„å¤§éƒ¨åˆ†è§£æ³•éƒ½æ˜¯æ™ºèƒ½ç®—æ³•ã€‚ä¸‹é¢å‡ºåœºçš„æ˜¯èƒŒåŒ…é—®é¢˜çš„ä¸€ä¸ªå˜ç§â€”â€”å¸¦çº¦æŸçš„å¤šèƒŒåŒ…é—®é¢˜ï¼Œè¿™ä¸ªé—®é¢˜çš„ç²¾ç¡®ç®—æ³•å¤æ‚åº¦æé«˜ï¼Œæ‰€ä»¥ä¸€èˆ¬é€€è€Œæ±‚å…¶æ¬¡å¯»æ‰¾æ‹¥æœ‰å›ºå®šè¿‘ä¼¼æ¯”çš„è¿‘ä¼¼ç®—æ³•ï¼Œæœ¬æ–‡æ±‚è§£é‡‡å–çš„åˆ™æ˜¯ä¸€ç§åŸºäºDPåŠ¨æ€è§„åˆ’çš„è¿‘ä¼¼ç®—æ³•ï¼Œå·§å¦™çš„å¹¶ä¸æ˜¯ç®—æ³•æœ¬èº«ï¼Œç®—æ³•ä¹Ÿä¸èƒ½ä¿è¯æ±‚å‡ºæœ€ä¼˜è§£ï¼Œç²¾ååœ¨äºè¿‘ä¼¼æ¯”çš„è¯æ˜éƒ¨åˆ†ï¼Œè¿™ä¸€éƒ¨åˆ†è¯æ˜æˆ‘å‚è€ƒäº†ç›¸å…³æ–‡çŒ®ï¼Œåˆ†äº«ç»™å¤§å®¶ç»†ç»†å“å‘³ã€‚\n\n\n\n\nâ– é—®é¢˜æè¿°\næœ‰ä¸ªç‰©å“ï¼Œæ¯ä¸ªç‰©å“çš„é‡é‡ä¸ºï¼Œå¦æœ‰ä¸ªèƒŒåŒ…ï¼Œæ¯ä¸ªèƒŒåŒ…çš„å®¹é‡ä¸ºï¼Œå¦å¤–æ¯ä¸ªç‰©å“æœ‰æ”¾å…¥é™åˆ¶ï¼Œåˆ™è¡¨æ˜ç‰©å“å¯ä»¥æ”¾å…¥èƒŒåŒ…ä¸­ï¼Œåˆ™ä¸èƒ½ï¼Œå› æ­¤æ˜¯ä¸€ä¸ªçš„çŸ©é˜µã€‚\né‚£ä¹ˆåœ¨ä¸è¿èƒŒæ”¾å…¥é™åˆ¶è§„åˆ™ï¼ŒåŒæ—¶æ¯ä¸ªèƒŒåŒ…å†…ç‰©å“ä¸è¶…è¿‡ç›¸åº”å®¹é‡æ—¶ï¼Œå¦‚ä½•ä½¿èƒŒåŒ…æ‰€è£…ç‰©å“çš„é‡é‡æœ€å¤§ï¼Ÿä¸Šè¿°é—®é¢˜å¯ä»¥ç”¨ä»¥ä¸‹æ•°å­¦æ¨¡å‹æ¥æè¿°ï¼š\n\n\n\n\n\n\n\n\nâ– ç®—æ³•æè¿°\n\nè®¾ç½®æ˜¯å¦æ”¾å…¥æ ‡è®°åˆ—è¡¨isPutï¼Œåˆå§‹åŒ–ä¸ºFalse\n\nä¾æ¬¡éå†æ¯ä¸€ä¸ªèƒŒåŒ…ï¼Œè®°å½“å‰èƒŒåŒ…çš„ç¼–å·ä¸º\n\næšä¸¾å‡ºå½“å‰isPut=Falseä¸”R[i][j]=1çš„æ‰€æœ‰ç‰©å“é›†item\n\nåˆ©ç”¨DPåŠ¨æ€è§„åˆ’æ±‚å‡ºä»itemä¸­å–å‡ºç‰©å“æ”¾å…¥èƒŒåŒ…çš„æœ€ä¼˜è§£ï¼Œå¹¶å°†å–å‡ºç‰©å“çš„isPutæ ‡è®°ä¸ºTrueï¼ˆè¡¨ç¤ºå‰ä¸ªç‰©å“èƒ½æ”¾å…¥å®¹é‡ä¸ºèƒŒåŒ…çš„æœ€å¤§é‡é‡ï¼‰\n\n\nå›åˆ°æ±‚è§£ä¸‹ä¸€èƒŒåŒ…\n\n\n\n\nâ– è¿‘ä¼¼æ¯”è¯æ˜\n\n\nä¸Šè¿°ç®—æ³•æ±‚å¾—çš„ç›®æ ‡å‡½æ•°å€¼. \n\nProve\næˆ‘ä»¬å‡è®¾ä¸Šè¿°ç®—æ³•æ‰§è¡Œçš„ç›®æ ‡ç»“æœä¸ºï¼Œä¸”èƒŒåŒ…ä¸­çš„ç‰©å“é‡é‡ä¹‹å’Œä¸ºï¼Œè€Œè¯¥ç®—æ³•ä¸­æ²¡æœ‰è¢«æ”¾ç½®äºä»»ä½•èƒŒåŒ…çš„ç‰©å“é›†ä¸ºï¼Œæ¥ä¸‹æ¥è¯æ˜å…¶ä½™ä»»ä½•å¯è¡Œè§£ä»ä¸­å–å‡ºæ”¾å…¥èƒŒåŒ…çš„ç‰©å“é‡é‡æ€»å’Œã€‚\nã€åè¯æ³•ã€‘ å‡è®¾å­˜åœ¨ä¸€ä¸ªå¯è¡Œè§£ï¼Œä½¿å¾—ï¼Œé‚£ä¹ˆæ€»æœ‰ä¸€ä¸ªèƒŒåŒ…å†…çš„ç‰©å“é‡é‡ä¹‹å’Œï¼Œå³èƒŒåŒ…é‡Œé¢å­˜åœ¨ä¸€ä¸ªç‰©å“é›†æœ‰ã€‚æ³¨æ„åˆ°DPåŠ¨æ€è§„åˆ’æ±‚å¾—çš„æ˜¯æœ€ä¼˜è§£ï¼Œå³æ˜¯å½“æ—¶å‰©ä¸‹ç‰©å“æ”¾å…¥èƒŒåŒ…çš„æœ€ä¼˜æ–¹æ¡ˆï¼Œè€Œä¸­çš„ç‰©å“åœ¨ä¸Šè¿°ç®—æ³•ä¸­æ²¡æœ‰è¢«æ”¾å…¥ä»»ä½•èƒŒåŒ…ï¼Œä»è€Œå¯ä»¥å°†ä¸­ç‰©å“æ”¾å…¥èƒŒåŒ…è·å¾—æ›´ä¼˜è§£ï¼ŒçŸ›ç›¾ï¼ä»è€Œå¾—è¯ã€‚\nå¦å¤–ä»å¤–æ”¾å…¥èƒŒåŒ…çš„ç‰©å“æ€»é‡æœ€å¤šå³ä¸ºï¼Œä»è€ŒèƒŒåŒ…æ€»é‡ã€‚\n\n\nâ– æ±‚è§£ç»“æœ\n\n\n\n\n\n\n\nèƒŒåŒ…\næ”¾å…¥ç‰©å“ç¼–å·\nèƒŒåŒ…å†…ç‰©å“é‡é‡ä¹‹å’Œ\nèƒŒåŒ…å®¹é‡\n\n\n\n0\n2, 5, 6, 11, 12, 13\n866\n866\n\n\n1\n3, 14, 16, 19, 20, 22\n908\n908\n\n\n2\n1, 7, 10, 18, 21, 24, 30, 31\n1361\n1361\n\n\n3\n4, 9, 15, 17, 23, 26, 33\n559\n559\n\n\n4\n8, 27, 28, 32, 36, 39, 40, 42, 47, 49\n1216\n1216\n\n\n5\n29, 35, 38, 41, 51, 52\n983\n983\n\n\n6\n25, 34, 37, 53, 54, 55\n1111\n1111\n\n\n7\n71, 72, 80, 83\n300\n300\n\n\n8\n46, 50, 56, 57, 63\n857\n857\n\n\n9\n44, 48, 58, 61, 62, 64, 70\n1462\n1462\n\n\n\n\né—®é¢˜Sampleä¸‹è½½ï¼š å¤šèƒŒåŒ…é—®é¢˜.\næ‰€æœ‰èƒŒåŒ…å‡è£…æ»¡ï¼Œå¯ä»¥ç¡®å®šæ˜¯æœ€ä¼˜è§£ã€‚\n\n\nâ– æ€»ç»“\näº‹å®ä¸Šæ ¹æ®è¯æ˜è¿‡ç¨‹å¯ä»¥çœ‹å‡ºï¼Œä»»æ„ä¸€ä¸ªèƒ½å¤Ÿæ±‚å‡º0-1å•èƒŒåŒ…é—®é¢˜æœ€ä¼˜è§£çš„ç®—æ³•éƒ½å¯ä»¥æ›¿æ¢DPç®—æ³•è¾¾åˆ°1/2çš„ä¸‹ç•Œã€‚åŒæ—¶å¯ä»¥ä¸¾ä¾‹è¯æ˜1/2æ˜¯æœ€ä¼˜ä¸‹ç•Œï¼Œå¦‚èƒŒåŒ…å®¹é‡ï¼Œç‰©å“é‡é‡ä¸ºã€‚æœ€ä¼˜è§£ä¸ºï¼Œè€Œå®é™…è¿è¡Œç»“æœå¯èƒ½ä¸ºï¼Œä¸¤è€…æ¯”å€¼\n\nç”±æ­¤å¯è§ï¼Œå¦‚æœå°†ç‰©å“é‡é‡ä»é«˜åˆ°ä½æ’åˆ—åå†è¿›è¡ŒDPæ±‚è§£å¯ä»¥ä¼˜åŒ–ç®—æ³•ç»“æœã€‚\n\n\nâ– C â˜º D E\nimport numpy as np\nimport pandas as pd\nfrom copy import deepcopy as dp\n\nload = np.array(pd.read_excel(\"/Users/starlitrover/Downloads/æœ€ä¼˜åŒ–/èƒŒåŒ…é—®é¢˜.xlsx\", header=4, usecols=range(1, 11)))\nvalue = np.array(\npd.read_excel(\"/Users/starlitrover/Downloads/æœ€ä¼˜åŒ–/èƒŒåŒ…é—®é¢˜.xlsx\", header=4, usecols=[11]).iloc[:,\n    0])\nsize = np.array(\npd.read_excel(\"/Users/starlitrover/Downloads/æœ€ä¼˜åŒ–/èƒŒåŒ…é—®é¢˜.xlsx\", usecols=range(1, 11), nrows=1).iloc[0, :])\n\nisPut = [False] * len(value)\ntotal = []\nlist = []\nfor i in range(len(size)):\n    item = []\n    for j in range(len(value)):\n        if not isPut[j] and load[j, i] == 1:\n            item.append(j)\n    f = np.zeros([len(item), size[i] + 1])\n    it = [[[] for a in range(size[i] + 1)] for b in range(len(item))]\n    for a in range(1, len(item)):\n        for b in range(value[item[a]], size[i] + 1):\n            if value[item[a]] + f[a - 1, b - value[item[a]]] &gt; f[a - 1, b]:\n                f[a, b] = value[item[a]] + f[a - 1, b - value[item[a]]]\n                it[a][b] = dp(it[a - 1][b - value[item[a]]])\n                it[a][b].append(item[a])\n            else:\n                f[a, b] = f[a - 1, b]\n                it[a][b] = dp(it[a - 1][b])\n    for k in it[len(item) - 1][size[i]]:\n        isPut[k] = True\n    if len(item) &gt; 0:\n        total.append(f[len(item) - 1, size[i]])\n        list.append(it[len(item) - 1][size[i]])\n\nPutIn=pd.DataFrame(columns=range(10),index=range(100))\nPutIn.fillna(0,inplace=True)\nfor i in range(len(list)):\n    for j in list[i]:\n        PutIn[i][j]=1\n\nprint(PutIn)\n\n\n\nâ– References\n\n[1] Approximation Algorithms for the Multiple Knapsack Problem with Assignment Restrictions\n\n[2] Chapter 6: Multiple knapsack problem , Knapsack Problems\n\n\n","slug":"0-1å¤šèƒŒåŒ…å¸¦çº¦æŸé—®é¢˜ï¼ˆMKARï¼‰","date":"2022-10-22T13:17:44.000Z","categories_index":"æ™ºèƒ½ç®—æ³•","tags_index":"python,æ•°å­¦ç…é¦,åŠ¨æ€è§„åˆ’","author_index":"Starlit Rover"},{"id":"a08c0b0ed5f594b2852b4c4eda7ad240","title":"ã€Œ1092ã€To Buy or Not to Buy","content":"Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer isÂ Yes, please tell her the number of extra beads she has to buy; or if the answer isÂ No, please tell her the number of beads missing from the string.\nFor the sake of simplicity, letâ€™s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead.\n\nFigure 1\n\n\n\nInput Specification:Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively.\nOutput Specification:For each test case, print your answer in one line. If the answer isÂ Yes, then also output the number of extra beads Eva has to buy; or if the answer isÂ No, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number.\nSample Input 1:ppRYYGrrYBR2258\nYrR8RrY\n\nSample Output 1:Yes 8\n\nSample Input 2:ppRYYGrrYB225\nYrR8RrY\n\nSample Output 2:No 2\n\n\nÎ©åˆæ˜¯è¯»é¢˜ååˆ†é’Ÿï¼Œåšé¢˜å‡ ç§’é’Ÿã€‚Evaæƒ³è¦åšäº”é¢œå…­è‰²çš„ç ç ä¸²ï¼Œå¥ˆä½•ç ç åº—è€æ¿æ˜¯ä¸ªåè›‹ï¼Œåªè‚¯ä¸€ä¸²ä¸€ä¸²å–ï¼Œç°åœ¨å°±è¯·ä½ åˆ¤æ–­åè€æ¿å–çš„ç ç ä¸²æ˜¯å¦èƒ½æ»¡è¶³Evaæƒ³è¦åšçš„ä¸²ï¼Œå¦‚æœå¯ä»¥è¾“å‡ºå¤šäº†å‡ é¢—ç å­ï¼Œåä¹‹è¾“å‡ºå°‘äº†å‡ é¢—ç å­ã€‚\néå†Evaçš„ç ç å­—ç¬¦ä¸²ï¼Œå¯¹è€æ¿çš„å­—ç¬¦ä¸²ç”¨stringè‡ªå¸¦çš„findå‡½æ•°ï¼Œè‹¥æ²¡æ‰¾åˆ°ï¼ˆ==string::nposï¼‰ç»™lack+=1ï¼Œå¦åˆ™å°±å°†å…¶eraseæ‰ï¼Œé‚£ä¹ˆæœ€åå¦‚æœlackä¸ä¸º0å°±è¾“å‡ºlackï¼Œåä¹‹å°±ç›´æ¥è¾“å‡ºeraseå®Œçš„è€æ¿ç ç ä¸²é•¿åº¦ã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b;\n    cin &gt;&gt; a &gt;&gt; b;\n    int lack = 0;\n    size_t pos;\n    for (auto &amp;c: b)\n    {\n        if ((pos = a.find(c)) == string::npos)\n            lack += 1;\n        else\n            a.erase(pos, 1);\n    }\n    if (lack)\n        cout &lt;&lt; \"No \" &lt;&lt; lack;\n    else\n        cout &lt;&lt; \"Yes \" &lt;&lt; a.size();\n}\n","slug":"ã€Œ1092ã€To-Buy-or-Not-to-Buy","date":"2022-10-22T13:07:25.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"2a6d9618f81bcb5d8f3a7de4f306ec7b","title":"ã€Œ1091ã€Acute Stroke","content":"One important factor to identify acute stroke (æ€¥æ€§è„‘å’ä¸­) is the volume of the stroke core. Given the results of image analysis in which the core regions are identified in each MRI slice, your job is to calculate the volume of the stroke core.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers:Â M,Â N,Â LÂ andÂ T, whereÂ MÂ andÂ NÂ are the sizes of each slice (i.e. pixels of a slice are in anÂ MÃ—NÂ matrix, and the maximum resolution is 1286 by 128);Â LÂ (â‰¤60) is the number of slices of a brain; andÂ TÂ is the integer threshold (i.e. if the volume of a connected core is less thanÂ T, then that core must not be counted).\nThenÂ LÂ slices are given. Each slice is represented by anÂ MÃ—NÂ matrix of 0â€™s and 1â€™s, where 1 represents a pixel of stroke, and 0 means normal. Since the thickness of a slice is a constant, we only have to count the number of 1â€™s to obtain the volume. However, there might be several separated core regions in a brain, and only those with their volumes no less thanÂ TÂ are counted. Two pixels areÂ connectedÂ and hence belong to the same region if they share a common side, as shown by Figure 1 where all the 6 red pixels are connected to the blue one.\n\nFigure 1\n\nOutput Specification:For each case, output in a line the total volume of the stroke core.\nSample Input:3 4 5 2\n1 1 1 1\n1 1 1 1\n1 1 1 1\n0 0 1 1\n0 0 1 1\n0 0 1 1\n1 0 1 1\n0 1 0 0\n0 0 0 0\n1 0 1 1\n0 0 0 0\n0 0 0 0\n0 0 0 1\n0 0 0 1\n1 0 0 0\n\nSample Output:26\n\n\nÎ©ç»Ÿè®¡CTåˆ‡ç‰‡ä¸­è¿ç»­ï¼ˆä¸Šä¸‹å·¦å³å‰åç›¸é‚»ï¼‰éƒ¨åˆ†è¶…è¿‡Tçš„stroke coreä½“ç§¯æ€»å’Œã€‚æœ¬è´¨ä¸Šå°±æ˜¯æ±‚ä¸‰ç»´è¿é€šå—ï¼Œç›´æ¥BFSæˆ–DFSã€‚\nä¹Ÿæ— éœ€è®¾ç½®isVisitedæ ‡è®°å˜é‡ï¼Œåƒç´ ç‚¹ä¸º0å°±è¡¨ç¤ºè¯¥å¤„æ²¡æœ‰strokeæˆ–è€…å·²ç»è®¿é—®è¿‡ã€‚\nç„¶è€Œç”¨DFSé€’å½’æœç´¢æäº¤ï¼Œåé¢ä¸¤ä¸ªæµ‹è¯•ç‚¹åŒåŒSegmentation Faultï¼Œè¿™æ„å‘³ç€é€’å½’è°ƒç”¨å¤ªå¤šäº†å¯¼è‡´æ ˆæº¢å‡ºã€‚äºæ˜¯ä¹æˆ‘ç”¨stackæ¥æ¨¡æ‹Ÿé€’å½’è°ƒç”¨åå°±ACäº†ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;tuple&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, l, t;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; l &gt;&gt; t;\n    vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; pixel(l, vector(m, vector(n, 0)));\n\n    for (int i = 0; i &lt; l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; n; ++k)\n                cin &gt;&gt; pixel[i][j][k];\n    int sum = 0;\n    for (int i = 0; i &lt; l; ++i)\n        for (int j = 0; j &lt; m; ++j)\n            for (int k = 0; k &lt; n; ++k)\n            {\n                if (!pixel[i][j][k]) continue;\n                stack&lt;tuple&lt;int, int, int&gt;&gt; s;\n                s.emplace(i, j, k);\n                int piece = 0;\n                while (!s.empty())\n                {\n                    int a = get&lt;0&gt;(s.top()), b = get&lt;1&gt;(s.top()), c = get&lt;2&gt;(s.top());\n                    s.pop();\n                    if (a &lt; 0 || a &gt;= l || b &lt; 0 || b &gt;= m || c &lt; 0 || c &gt;= n || !pixel[a][b][c]) continue;\n                    pixel[a][b][c] = 0;\n                    ++piece;\n                    if (a &gt; 0) s.emplace(a - 1, b, c);\n                    if (a &lt; l - 1) s.emplace(a + 1, b, c);\n                    if (b &gt; 0) s.emplace(a, b - 1, c);\n                    if (b &lt; m - 1) s.emplace(a, b + 1, c);\n                    if (c &gt; 0) s.emplace(a, b, c - 1);\n                    if (c &lt; n - 1) s.emplace(a, b, c + 1);\n                }\n                sum += piece &gt;= t ? piece : 0;\n            }\n    cout &lt;&lt; sum;\n}\n","slug":"ã€Œ1091ã€Acute-Stroke","date":"2022-10-22T06:47:27.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,stack,tuple,DFS","author_index":"Starlit Rover"},{"id":"a826ea08eba83fcbe604bb29b17897fe","title":"ã€Œ1090ã€Highest Price in Supply Chain","content":"A supply chain is a network of retailersï¼ˆé›¶å”®å•†ï¼‰, distributorsï¼ˆç»é”€å•†ï¼‰, and suppliersï¼ˆä¾›åº”å•†ï¼‰â€“ everyone involved in moving a product from supplier to customer.\nStarting from one root supplier, everyone on the chain buys products from oneâ€™s supplier in a priceÂ PÂ and sell or distribute them in a price that isÂ r% higher thanÂ P. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.\nNow given a supply chain, you are supposed to tell the highest price we can expect from some retailers.\n\n\nInput Specification:Each input file contains one test case. For each case, The first line contains three positive  numbers:Â , the total number of the members in the supply chain (and hence they are numbered from 0 toÂ Nâˆ’1);Â P, the price given by the root supplier; andÂ r, the percentage rate of price increment for each distributor or retailer. Then the next line containsÂ NÂ numbers, each number Â is the index of the supplier for theÂ i-th member.Â Srootâ€‹Â for the root supplier is defined to beÂ âˆ’1. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceedÂ .\nSample Input:9 1.80 1.00\n1 5 4 4 -1 4 5 3 6\n\nSample Output:1.85 2\n\n\nÎ©æ¯”ã€Œ1079ã€Total Sales of Supply Chainç®€å•ï¼Œåªéœ€è¦è¾“å‡ºæœ€å¤§çš„å•†å“å‡ºå”®ä»·æ ¼å’Œä»¥è¯¥ä»·æ ¼å‡ºå”®çš„å•†è´©ä¸ªæ•°ã€‚\nObviouslyï¼Œå°±æ˜¯æ±‚ä¸€æ£µæ ‘çš„æœ€å¤§æ·±åº¦ä»¥åŠæœ€åº•å±‚çš„å¶å­èŠ‚ç‚¹ä¸ªæ•°ï¼Œé‚£ä¹ˆBFSå’ŒDFSçš†å¯ï¼Œæ³¨æ„DFSä¸è¦ä»å¶å­èŠ‚ç‚¹å¾€æ ¹èŠ‚ç‚¹éå†ï¼Œè¿™æ ·ä¼šå¯¼è‡´é¡¶å±‚éƒ¨åˆ†èŠ‚ç‚¹å’Œè¾¹ä¼šè¢«å¤šæ¬¡éå†ï¼Œé€ æˆå¤§é‡è€—æ—¶ã€‚\næˆ‘é‡‡å–çš„æ˜¯é€’å½’DFSï¼Œç”¨å…¨å±€å˜é‡max_dæ¥è¡¨ç¤ºç›®å‰ä¸ºæ­¢éå†åˆ°çš„æœ€å¤§æ·±åº¦ï¼Œnumè®°å½•æ·±åº¦=max_dçš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œå¦‚æœæœ‰èŠ‚ç‚¹æ·±åº¦&gt;max_då°±å°†numç½®1ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint max_d = 0, num = 0;\nvector&lt;vector&lt;int&gt;&gt; rtl;\n\nvoid dfs(int r, int d)\n{\n    if (d &gt; max_d)\n    {\n        num = 1;\n        max_d = d;\n    }\n    else if (d == max_d)\n        num += 1;\n    for (auto &amp;k: rtl[r])\n        dfs(k, d + 1);\n}\n\nint main()\n{\n    int n, m, root = -1;\n    double p, r;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; r;\n    r = 1 + 0.01 * r;\n    rtl.resize(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        root = m == -1 ? i : (rtl[m].push_back(i), root);\n    }\n    dfs(root, 0);\n    printf(\"%.2f %d\", p * pow(r, max_d), num);\n}\n","slug":"ã€Œ1090ã€Highest-Price-in-Supply-Chain","date":"2022-10-21T15:16:17.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Tree,DFS","author_index":"Starlit Rover"},{"id":"c5437ffcf609ae633f4f1165eadcfbba","title":"ã€Œ1089ã€Insert or Merge","content":"According to Wikipedia:\nInsertion sortÂ iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.\nMerge sortÂ works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.\nNow given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?\n\n\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤100). Then in the next line,Â NÂ integers are given as the initial sequence. The last line contains the partially sorted sequence of theÂ NÂ numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in the first line either â€œInsertion Sortâ€ or â€œMerge Sortâ€ to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:10\n3 1 2 8 7 5 9 4 6 0\n1 2 3 7 8 5 9 4 6 0\n\nSample Output 1:Insertion Sort\n1 2 3 5 7 8 9 4 6 0\n\nSample Input 2:10\n3 1 2 8 7 5 9 4 0 6\n1 3 2 8 5 7 4 9 0 6\n\nSample Output 2:Merge Sort\n1 2 3 8 4 5 7 9 0 6\n\n\nÎ©æ ¹æ®ä¸­é—´çš„ä¸€ä¸ªæ’åºç»“æœåˆ¤æ–­é‡‡ç”¨çš„æ˜¯æ’å…¥æ’åºè¿˜æ˜¯å½’å¹¶æ’åºã€‚\nçœ‹æ¥æ’åºé¢˜å·²ç»å¼¹å°½ç²®ç»äº†ã€‚ä¸¤è€…çš„å·®åˆ«å…¶å®è¿˜æ˜¯æŒºå¤§çš„ï¼Œæ’å…¥æ’åºè·Ÿæ‰“æ‰‘å…‹æ—¶æ•´ç†æ‰‹ç‰Œçš„è¿‡ç¨‹å·®ä¸å¤šï¼Œæ‹¿ä¸€å¼ ç‰Œæ‰¾åˆ°ä½ç½®æ’å…¥ï¼Œå› æ­¤ä¸­é—´è¿‡ç¨‹å¿…ç„¶æ˜¯å‰é¢æœ‰åºåé¢åŸæ ·ï¼›è€Œå½’å¹¶æ’åºæ˜¯ç›¸é‚»çš„æœ‰åºç»„è¿›è¡Œåˆå¹¶ï¼Œå› æ­¤ä¸­é—´è¿‡ç¨‹å¿…ç„¶æ˜¯å±€éƒ¨æœ‰åºçš„ã€‚\né‚£ä¹ˆåˆå§‹æƒ³æ³•å°±å¾ˆç®€å•ï¼Œæˆ‘ä»¬å¯¹å½“å‰åºåˆ—å’ŒåŸåºåˆ—ä¸€èµ·ä»åå¾€å‰è¯»ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸åŒå…ƒç´ ï¼Œå¯¹è¯¥å…ƒç´ åŠä¹‹å‰çš„å…ƒç´ è¿›è¡Œæ’åºï¼Œå¦‚æœè¿™æ˜¯æ’å…¥æ’åºï¼Œé‚£ä¹ˆæ’åºåçš„ç»“æœåº”è¯¥ä¸å½“å‰åºåˆ—å®Œå…¨ä¸€è‡´ï¼Œå¦åˆ™å°±æ˜¯å½’å¹¶æ’åºã€‚è¿™ä¸ªæƒ³æ³•æ˜¯æ­£ç¡®çš„ï¼Œä½†æˆ‘æ²¡æƒ³åˆ°æœ‰ä¸€ä¸ªæµ‹è¯•æ ·ä¾‹ä¸­ä¸¤ä¸ªåºåˆ—éƒ½æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œä¸€ä¸ªæ•°æ²¡åŠ¨è¿‡ã€‚æˆ‘å°±çº³é—·äº†ï¼Œè¿™ä½ èƒ½è¯´æ˜¯å“ªç§æ’åºå‘¢ã€‚åæ¥ä»”ç»†æƒ³äº†æƒ³ï¼Œæ—¢ç„¶è¯´äº†æ˜¯éƒ¨åˆ†æ’åºç»“æœï¼Œé‚£ä¹ˆä¸€å®šæ˜¯æ’è¿‡åºçš„ï¼Œè€Œå½“åŸå§‹åºåˆ—å‰ä¸ªæ•°æœ¬æ¥å°±æ˜¯æœ‰åºæ—¶ï¼Œå‰å‡ æ­¥çš„æ’å…¥æ’åºå°±èƒ½åšåˆ°ä¸æ”¹å˜åŸåºåˆ—ã€‚\nâš ï¸å› æ­¤ä¸è¦å¿˜è®°åŠ ä¸Šç´¢å¼•â‰¥0é™åˆ¶ï¼Œå¦å¤–å½“æ‰€æœ‰å…ƒç´ éƒ½ä¸€è‡´æ—¶ï¼Œæˆ‘ä»¬å°±éœ€è¦æ­£å‘éå†æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯ascendingçš„å…ƒç´ ã€‚\nå¦‚æœæ˜¯æ’å…¥æ’åºé‚£ä¹ˆæˆ‘ä»¬å†å¾€åé¢sortä¸€ä½å³å¯ï¼Œè‹¥æ˜¯å½’å¹¶æ’åºï¼Œæˆ‘ä»¬åˆ™å¯ä»¥æ¨¡æ‹Ÿå®é™…çš„å½’å¹¶è¿‡ç¨‹ç„¶ååˆ¤æ–­æ˜¯å¦ä¸å½“å‰åºåˆ—ç›¸ç­‰ï¼ˆç›´æ¥ç¡®å®šå½“å‰åˆ†ç»„çš„å…ƒç´ ä¸ªæ•°å¹¶ä¸æ˜¯é‚£ä¹ˆç®€å•ï¼Œåæ­£å…ƒç´ ä¸ªæ•°æœ€å¤šä¹Ÿæ‰100ï¼‰ï¼Œç„¶åå†å½’å¹¶ä¸€æ¬¡å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, turn;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; org(n), crt(n);\n    for (auto &amp;k: org)\n        cin &gt;&gt; k;\n    for (auto &amp;k: crt)\n        cin &gt;&gt; k;\n    turn = n;\n    while (--turn &gt;= 0 &amp;&amp; crt[turn] == org[turn]);\n    if (turn == -1)\n    {\n        turn = 0;\n        while (turn &lt; n &amp;&amp; crt[turn] &lt;= crt[turn + 1]) ++turn;\n    }\n    vector&lt;int&gt; copy(org);\n    sort(copy.begin(), copy.begin() + turn + 1);\n    bool isMerge = false;\n    // Short-circuit evaluation\n    for (int i = 0; i &lt; n &amp;&amp; (copy[i] == crt[i] || (isMerge = true , false)); ++i);\n    if (isMerge)\n    {\n        int delta = 1;\n        while (delta *= 2, crt != copy)\n        {\n            copy = org;\n            for (int i = 0; i &lt; n; i += delta)\n                sort(org.begin() + i, org.begin() + (i + delta &gt; n ? n : i + delta));\n        }\n    }\n    else\n        sort(org.begin(), org.begin() + turn + 2);\n    cout &lt;&lt; (isMerge ? \"Merge Sort\" : \"Insertion Sort\") &lt;&lt; endl;\n    for (int i = 0; i &lt; n; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; org[i];\n}\n","slug":"ã€Œ1089ã€Insert-or-Merge","date":"2022-10-21T12:50:54.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"358311a56ccea31028176b056f12f8e9","title":"ã€1088ã€Rational Arithmetic","content":"For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.\n\n\nInput Specification:Each input file contains one test case, which gives in one line the two rational numbers in the formatÂ a1/b1 a2/b2. The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.\nOutput Specification:For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line isÂ number1 operator number2 = result. Notice that all the rational numbers must be in their simplest formÂ k a/b, whereÂ kÂ is the integer part, andÂ a/bÂ is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, outputÂ InfÂ as the result. It is guaranteed that all the output integers are in the range ofÂ long int.\nSample Input 1:2/3 -4/2\n\nSample Output 1:2/3 + (-2) = (-1 1/3)\n2/3 - (-2) = 2 2/3\n2/3 * (-2) = (-1 1/3)\n2/3 / (-2) = (-1/3)\n\nSample Input 2:5/3 0/6\n\nSample Output 2:1 2/3 + 0 = 1 2/3\n1 2/3 - 0 = 1 2/3\n1 2/3 * 0 = 0\n1 2/3 / 0 = Inf\n\n\nÎ©ç”¨å¸¦åˆ†æ•°çš„å½¢å¼è¾“å‡ºä¸¤ä¸ªåˆ†æ•°ä¹‹å’Œã€å·®ã€ç§¯ã€å•†ï¼Œå…·ä½“è¾“å‡ºè§„åˆ™å¦‚ä¸‹ï¼š\n\næ•´æ•°éƒ¨åˆ†å’ŒçœŸåˆ†æ•°éƒ¨åˆ†è‹¥ä¸º0åˆ™ä¸è¾“å‡ºï¼Œâš ï¸0å¿…é¡»è¾“å‡ºã€0ã€‘\n\nè´Ÿæ•°éœ€è¦åŠ ä¸Šï¼ˆï¼‰ï¼Œè´Ÿå·è¦ä¹ˆåœ¨æ•´æ•°éƒ¨åˆ†ï¼Œè¦ä¹ˆåœ¨çœŸåˆ†æ•°çš„åˆ†å­éƒ¨åˆ†ï¼ˆæ•´æ•°éƒ¨åˆ†ä¸º0ï¼‰\n\nå½“å¸¦åˆ†æ•°æ•´æ•°å’ŒçœŸåˆ†æ•°éƒ¨åˆ†çš†ä¸ä¸º0æ—¶ï¼Œä¸­é—´éœ€è¦ç”¨spaceåˆ†éš”\n\nå¸¦åˆ†æ•°å¿…é¡»æ˜¯çº¦åˆ†åçš„æœ€ç®€å½¢å¼\n\nåˆ†æ¯ä¸º0ç›´æ¥è¾“å‡ºã€Infã€‘\n\n\næ•´ä½“ä¸éš¾ï¼Œä¸€ä¸ªæ ¼å¼åŒ–è¾“å‡ºå‡½æ•°ï¼Œä¸€ä¸ªç®€åŒ–å‡½æ•°å³å¯ã€‚æ³¨æ„å¸¦åˆ†æ•°ä¸­é—´çš„ç©ºæ ¼å¿…é¡»åœ¨ä¸¤è€…éƒ½è¾“å‡ºçš„æ—¶å€™æ‰æœ‰ã€‚è®¡ç®—æ—¶å¯ä»¥ç”¨ä¸€ä¸ªpairå¯¹æ¥å­˜å–ä¸€ä¸ªåˆ†æ•°çš„åˆ†å­å’Œåˆ†æ¯ï¼Œç„¶ååˆ†æ¯å§‹ç»ˆä¸ºæ­£ã€‚\nå¦å¤–é¢˜ç›®æ—¢ç„¶è¯´äº†long intï¼Œå°±ä¸è¦ä¾¥å¹¸intå¯èƒ½å’Œlong intç­‰é•¿ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\n\ninline void output(pair&lt;long int, long int&gt; f)\n{\n    if (!f.second)\n        cout &lt;&lt; \"Inf\";\n    else\n    {\n        bool flag = f.first &lt; 0 &amp;&amp; (f.first *= -1), space = false;\n        cout &lt;&lt; (flag ? \"(-\" : \"\");\n        if (f.first / f.second || f.first == 0) cout &lt;&lt; f.first / f.second, space = true;\n        if (f.first % f.second) cout &lt;&lt; (space ? \" \" : \"\") &lt;&lt; f.first % f.second &lt;&lt; \"/\" &lt;&lt; f.second;\n        cout &lt;&lt; (flag ? \")\" : \"\");\n    }\n}\n\ninline void simplify(pair&lt;long int, long int&gt; &amp;f)\n{\n    long int g = gcd(f.first, f.second);\n    f.first /= g, f.second /= g;\n    if (f.second &lt; 0) f.first *= -1, f.second *= -1;\n}\n\nint main()\n{\n    pair&lt;long int, long int&gt; a, b, c;\n    scanf(\"%ld/%ld %ld/%ld\", &amp;a.first, &amp;a.second, &amp;b.first, &amp;b.second);\n    simplify(a), simplify(b);\n    long int lab = lcm(a.second, b.second), na = a.first * lab / a.second, nb = b.first * lab / b.second;\n    c.second = lab, c.first = na + nb, simplify(c);\n    output(a), cout &lt;&lt; \" + \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n    c.second = lab, c.first = na - nb, simplify(c);\n    output(a), cout &lt;&lt; \" - \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n    c.second = a.second * b.second, c.first = a.first * b.first, simplify(c);\n    output(a), cout &lt;&lt; \" * \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n    c.second = a.second * b.first, c.first = a.first * b.second, simplify(c);\n    output(a), cout &lt;&lt; \" / \", output(b), cout &lt;&lt; \" = \", output(c), cout &lt;&lt; endl;\n}\n","slug":"ã€1088ã€Rational-Arithmetic","date":"2022-10-20T05:15:51.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,pair,numeric","author_index":"Starlit Rover"},{"id":"36db02f696efbf1ae4833c7a9cd82a86","title":"ã€1087ã€All Roads Lead to Rome","content":"Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integersÂ NÂ (2â‰¤Nâ‰¤200), the number of cities, andÂ K, the total number of routes between pairs of cities; followed by the name of the starting city. The nextÂ Nâˆ’1Â lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. ThenÂ KÂ lines follow, each describes a route between two cities in the formatÂ City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is alwaysÂ ROMÂ which represents Rome.\nOutput Specification:For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness â€“ it is guaranteed by the judge that such a solution exists and is unique.\nHence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the formatÂ City1-&gt;City2-&gt;...-&gt;ROM.\nSample Input:6 7 HZH\nROM 100\nPKN 40\nGDN 55\nPRS 95\nBLN 80\nROM GDN 1\nBLN ROM 1\nHZH PKN 1\nPRS ROM 2\nBLN HZH 2\nPKN GDN 1\nHZH PRS 1\n\nSample Output:3 3 195 97\nHZH-&gt;PRS-&gt;ROM\n\n\nÎ©å¥½ä¹…æ²¡Dijkstraäº†ï¼Œè¿™é“é¢˜è¦è¾“å‡ºçš„ä¸œè¥¿æœ‰äº¿ç‚¹å¤šã€‚\nä»ä¸€ä¸ªåŸå¸‚å»ç½—é©¬ï¼Œæ¯æ¡è·¯ä¸Šæœ‰ä¸€å®šçš„ä»£ä»·ï¼Œåˆ°ä¸€åº§åŸå¸‚èƒ½æ”¶è·ç›¸åº”çš„å¿«ä¹å€¼ï¼Œè¾“å‡ºã€ä»£ä»·æœ€çŸ­çš„è·¯çº¿æ•° æœ€å°ä»£ä»· æœ€å°ä»£ä»·ä¸­çš„æœ€å¤§å¿«ä¹å€¼ å¹³å‡å¿«ä¹å€¼ã€‘å’Œæœ€ä¼˜è·¯çº¿ï¼ˆè¯„ä»·ä¼˜å…ˆçº§ä¾æ¬¡ä¸ºï¼šä»£ä»·æœ€å°ï¼Œå¿«ä¹å¤šå¤šï¼ŒåŸå¸‚å°‘å°‘ï¼‰ã€‚\né¦–å…ˆç”¨Dijkstraæ±‚å‡ºæ‰€æœ‰ä»£ä»·æœ€å°çš„è·¯çº¿ï¼Œè€å¥—è·¯ï¼Œæœ€çŸ­è·¯çº¿ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„ç¼–å·ï¼Œç”±äºè·¯çº¿ä¸å”¯ä¸€ï¼Œæ‰€ä»¥æ¯ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰å¤šä¸ªå‰èŠ‚ç‚¹ï¼Œç”¨vectorè¿›è¡Œå­˜å‚¨ã€‚ç„¶åä»ç»ˆç‚¹DFSå›æº¯ï¼Œå›æº¯çš„è·¯ä¸Šé¡ºä¾¿è®¡ç®—ä¸€ä¸‹å¿«ä¹å€¼å’ŒèŠ‚ç‚¹ä¸ªæ•°ï¼Œç„¶åè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æœ€ä¼˜nextèŠ‚ç‚¹ï¼Œå³å¦‚æœå›åˆ°æŸä¸ªåŸå¸‚å¾—åˆ°äº†ä¸€ä¸ªæ›´ä¼˜çš„ï¼Œé‚£ä¹ˆå°±æ›´æ–°å…¶nextå€¼ï¼Œå›æº¯åˆ°èµ·ç‚¹0å°±åœæ­¢ã€‚é‚£ä¹ˆæœ€åæœ€ä¼˜çš„å¿«ä¹å€¼å’ŒèŠ‚ç‚¹æ•°å°±å­˜å‚¨åœ¨èµ·ç‚¹0çš„infoä¸­ã€‚\nç¬¬ä¸€æ¬¡æäº¤case 3è¶…æ—¶ï¼Œçœ‹åˆ°ç½‘ä¸Šä¹Ÿæ²¡æœ‰äººcase 3è£‚å¼€çš„ï¼Œäºæ˜¯ä¹æˆ‘æ”¹è¿›äº†å›æº¯å‡½æ•°ï¼Œå¯¹äºå·²ç»å›æº¯è¿‡çš„èŠ‚ç‚¹ä¸å†é‡æ–°å›æº¯ï¼Œç›´æ¥ç”¨ä¹‹å‰å¾—å‡ºçš„ç»“æœï¼Œä½†ç»¿è‰²ä¾æ—§ï¼Œç›´åˆ°æˆ‘æŠŠæ‰€æœ‰çš„INT16_MAXæ¢æˆäº†INT32_MAXã€‚INT_MAXæ˜¯ç”¨æ¥ä»£æ›¿Dijkstraä¸­èµ°ä¸é€šè·ç¦»çš„ï¼Œæœ‰æ—¶å€™æ›¿ä»£æ•°å¤ªå°äº†ä¼šå‡ºé—®é¢˜ã€‚\nâš ï¸ å°½é‡ç”¨å¤§æ•°ï¼ˆINT32_MAXï¼‰æ›¿ä»£ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; happy, nxt, path;\nvector&lt;vector&lt;int&gt;&gt; pre;     // previous nodes in the least cost paths\nvector&lt;pair&lt;int, int&gt;&gt; info; // &lt;happiness sum, nodes num&gt;\n\nint collect(int &amp;node)\n{\n    int sum = 0;\n    for (auto k: pre[node])\n    {\n        auto p = make_pair(info[node].first + happy[k], info[node].second - 1);\n        if (p &gt; info[k])\n        {\n            info[k] = p;\n            nxt[k] = node;\n        }\n        sum += (path[k] == -1 ? collect(k) : path[k]);\n    }\n    return path[node]=sum;\n}\n\nint main()\n{\n    int n, k, dst, c;\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    vector&lt;string&gt; city(n, string(3, 0));\n    happy.resize(n, 0);\n    map&lt;string, int&gt; num;\n    cin &gt;&gt; city[0];\n    num[city[0]] = 0;\n    for (int i = 1; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;city[i][0], &amp;happy[i]);\n        num[city[i]] = i;\n        if (city[i] == \"ROM\")\n            dst = i;\n    }\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; cost(n);\n    string c1(3, 0), c2(3, 0);\n    for (int i = 0; i &lt; k; ++i)\n    {\n        scanf(\"%s %s %d\", &amp;c1[0], &amp;c2[0], &amp;c);\n        cost[num[c1]].emplace_back(num[c2], c);\n        cost[num[c2]].emplace_back(num[c1], c);\n    }\n    vector&lt;int&gt; dist(n, INT32_MAX);\n    vector&lt;bool&gt; done(n, false);\n    dist[0] = 0, done[0] = true;\n    pre.resize(n);\n    for (auto &amp;v: cost[0])\n        pre[v.first].push_back(0), dist[v.first] = v.second;\n    while (!done[dst])\n    {\n        int min_d = INT32_MAX;\n        vector&lt;int&gt; opt;\n        for (int i = 1; i &lt; n; ++i)\n        {\n            if (done[i]) continue;\n            else if (dist[i] &lt; min_d)\n            {\n                opt.clear();\n                opt.push_back(i);\n                min_d = dist[i];\n            }\n            else if (dist[i] == min_d)\n                opt.push_back(i);\n        }\n        for (auto &amp;o: opt)\n        {\n            for (auto &amp;v: cost[o])\n                if (dist[o] + v.second &lt; dist[v.first])\n                {\n                    dist[v.first] = dist[o] + v.second;\n                    pre[v.first].clear();\n                    pre[v.first].push_back(o);\n                }\n                else if (dist[o] + v.second == dist[v.first])\n                    pre[v.first].push_back(o);\n            done[o] = true;\n        }\n    }\n    info.resize(n, {INT32_MIN, INT32_MIN});\n    info[dst] = make_pair(happy[dst], 0);\n    nxt = path = vector&lt;int&gt;(n, -1);\n    path[0] = 1;\n    printf(\"%d %d %d %d\\n\", collect(dst), dist[dst], info[0].first, info[0].first / -info[0].second);\n    int idx = 0;\n    printf(\"%s\", city[0].c_str());\n    while ((idx = nxt[idx]) != -1)\n        printf(\"-&gt;%s\", city[idx].c_str());\n}\n\nTips\næ³¨æ„åˆ°å›æº¯å‡½æ•°ä¸­èŠ‚ç‚¹æ•°æˆ‘æ˜¯-1å¤„ç†çš„ï¼Œå› ä¸ºå¿«ä¹æ•°è¦biggerï¼Œè€ŒèŠ‚ç‚¹æ•°è¦å°½é‡smallerï¼Œå¦‚æœè¦ä½¿ç”¨pairçš„æ¯”è¾ƒè¿ç®—å°±éœ€è¦ç»Ÿä¸€ä¸¤è€…ï¼Œæ‰€ä»¥å¯¹èŠ‚ç‚¹æ•°å–äº†ä¸ªè´Ÿ\n\nå¯¹æ‰€æœ‰åŸå¸‚å…ˆè¿›è¡Œäº†ç¼–å·ï¼Œmapç”¨æ¥è·å–ç¼–å·ï¼Œvectorå­˜å–ç¼–å·å¯¹åº”åŸå¸‚å\n\nè·ç¦»ç”¨äº†é‚»æ¥è¡¨çš„ç»“æ„è¿›è¡Œå­˜å‚¨ï¼ŒDijkstraç”¨é‚»æ¥è¡¨è¶³çŸ£\n\n\n","slug":"ã€1087ã€All-Roads-Lead-to-Rome","date":"2022-10-18T15:38:59.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,Dijkstra","author_index":"Starlit Rover"},{"id":"241889b3806f3abfea3a2386c711c8ff","title":"ã€1086ã€Tree Traversals Again","content":"An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.  \n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ NÂ (â‰¤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 toÂ N). ThenÂ 2NÂ lines follow, each describes a stack operation in the format: â€œPush Xâ€ where X is the index of the node being pushed onto the stack; or â€œPopâ€ meaning to pop one node from the stack.\nOutput Specification:For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\n\nSample Output:3 4 2 6 5 1\n\n\nÎ©ç”¨æ ˆè¾“å‡ºä¸€æ£µäºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œç»™å‡ºæ ˆçš„æ“ä½œï¼Œè¯·ä½ è¾“å‡ºåç»­éå†ç»“æœã€‚\néå†é—®é¢˜çš„æ ¸å¿ƒæ°¸è¿œæ˜¯æŠ“ä½å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œç„¶ååˆ’åˆ†å­æ ‘çš„å­æ ‘ã€‚\né‚£ä¹ˆæ ¹æ®æ ˆçš„æ“ä½œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ªä¸­åºéå†åºåˆ—ï¼Œæ³¨æ„åˆ°æ ˆæ“ä½œæœ¬è´¨ä¸Šæ˜¯å…ˆéå†æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å·¦å­æ ‘ï¼Œæœ€åéå†å³å­æ ‘ã€‚ä»è€Œæˆ‘ä»¬å¯å¾—ä¸€æ£µå­æ ‘èŠ‚ç‚¹ä¸­æœ€å…ˆPushçš„å°±æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåªè¦æ‰¾åˆ°æ ¹èŠ‚ç‚¹ä¸€åˆ‡éƒ½å¥½è¯´äº†ï¼Œå·¦è¾¹æ˜¯å·¦å­æ ‘åºåˆ—ï¼Œå³è¾¹æ˜¯å³å­æ ‘åºåˆ—ï¼Œç›´æ¥è¿›è¡Œååºé€’å½’æ“ä½œå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; post, in;\n\nvoid PostOrder(int begin, int end)\n{\n    if (begin &gt; end) return;\n    int root = min_element(in.begin() + begin, in.begin() + end + 1) - in.begin();\n    PostOrder(begin, root - 1);\n    PostOrder(root + 1, end);\n    post.push_back(in[root]);\n}\n\nint main()\n{\n    stack&lt;int&gt; s;\n    int n, m, idx = 0;\n    cin &gt;&gt; n;\n    string opr;\n    vector&lt;int&gt; v(n);\n    for (int i = 0; i &lt; 2 * n; ++i)\n    {\n        cin &gt;&gt; opr;\n        if (opr == \"Push\")\n        {\n            cin &gt;&gt; v[idx];\n            s.push(idx++);\n        }\n        else if (opr == \"Pop\")\n        {\n            in.push_back(s.top());\n            s.pop();\n        }\n    }\n    PostOrder(0, n - 1);\n    for (int i = 0; i &lt; n; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; v[post[i]];\n}\n","slug":"ã€1086ã€Tree-Traversals-Again","date":"2022-10-18T11:47:02.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"a488d0c6dd54b287e5f9b6c39b458e0d","title":"ã€1085ã€Perfect Sequence","content":"Given a sequence of positive integers and another positive integerÂ p. The sequence is said to be aÂ perfect sequenceÂ ifÂ Mâ‰¤mÃ—pÂ whereÂ MÂ andÂ mÂ are the maximum and minimum numbers in the sequence, respectively.\nNow given a sequence and a parameterÂ p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive integersÂ NÂ andÂ p, whereÂ  is the number of integers in the sequence, andÂ  is the parameter. In the second line there areÂ NÂ positive integers, each is no greater thanÂ .\nOutput Specification:For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.\nSample Input:10 8\n2 3 20 4 5 1 6 7 8 9\n\nSample Output:8\n\n\nÎ©å®Œç¾åºåˆ—æŒ‡çš„æ˜¯æ»¡è¶³çš„åºåˆ—ï¼Œç»™å‡ºä¸€ç»„åºåˆ—å’Œï¼Œè¾“å‡ºæœ€å¤šèƒ½å¤Ÿä»è¿™ä¸ªåºåˆ—ä¸­æŠ½å‡ºå…ƒç´ æ„æˆå®Œç¾åºåˆ—çš„ä¸ªæ•°ã€‚\nå¾ˆæ·³æœ´çš„æ€æƒ³ï¼Œè®¾å®šä¸€ä¸ªåªåŠ ä¸å‡çš„åç§»é‡ï¼ˆ1ä¸ªæ•°å­—å¿…ç„¶æˆç«‹ï¼‰ï¼Œå…ˆsortæ•°ç»„ç„¶åé¡ºåºéå†ï¼Œåˆ¤æ–­æ˜¯å¦æˆç«‹ï¼Œæˆç«‹åˆ™ç»§ç»­æ‰¾åˆ°ä¸Šé™ï¼Œå¦åˆ™continueã€‚\næœ€åcase 5æŒ‚äº†ï¼Œæ£€æŸ¥åå‘ç°å¯èƒ½ä¼šæº¢å‡ºï¼Œå°†intæ¢æˆlong intå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    long int n, p;\n    cin &gt;&gt; n &gt;&gt; p;\n    vector&lt;int&gt; arr(n);\n    for (auto &amp;a: arr)\n        cin &gt;&gt; a;\n    sort(arr.begin(), arr.end());\n    int ans = 1;\n    for (int i = 0; i &lt; arr.size() - ans; ++i)\n        while (i + ans &lt; arr.size() &amp;&amp; arr[i + ans] &lt;= arr[i] * p)\n            ++ans;\n    cout &lt;&lt; ans;\n}\n","slug":"ã€1085ã€Perfect-Sequence","date":"2022-10-17T17:27:54.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,vector","author_index":"Starlit Rover"},{"id":"1ce59a895ae0c8cfde6ce2080e52dc00","title":"ã€Œ1084ã€Broken Keyboard","content":"On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen.\nNow given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out.\n\n\nInput Specification:Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], orÂ _Â (representing the space). It is guaranteed that both strings are non-empty.\nOutput Specification:For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key.\nSample Input:7_This_is_a_test\n_hs_s_a_es\n\nSample Output:7TI\n\n\nÎ©å°å°é”®ç›˜æ£€ä¿®å·¥ï¼Œè¾“å‡ºåæ‰çš„é”®ç›˜æŒ‰é”®ï¼ˆåªèƒ½æ˜¯å¤§å†™ï¼‰ã€‚\nå…ˆå°†ä¸¤ä¸ªå­—ç¬¦ä¸²è½¬æˆå¤§å†™ï¼Œç„¶åå°†æ˜¾ç¤ºå‡ºæ¥çš„æ‰€æœ‰å­—ç¬¦mapæˆtrueï¼Œæ¥ç€éå†ä¸€éè¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œå¦‚æœmapä¸­æ²¡æœ‰ï¼ˆfalseï¼‰å°±è¾“å‡ºåŒæ—¶åœ¨mapä¸­ç½®trueé˜²æ­¢é‡å¤è¾“å‡ºã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    string org, scr;\n    cin &gt;&gt; org &gt;&gt; scr;\n    transform(org.begin(), org.end(), org.begin(), ::toupper);\n    transform(scr.begin(), scr.end(), scr.begin(), ::toupper);\n\n    map&lt;char, bool&gt; check;\n    for (auto &amp;c: scr)\n        check[c] = true;\n    for (auto &amp;c: org)\n        if (!check[c])\n        {\n            cout &lt;&lt; c;\n            check[c] = true;\n        }\n}\n","slug":"ã€Œ1084ã€Broken-Keyboard","date":"2022-10-17T16:53:22.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,string,transform","author_index":"Starlit Rover"},{"id":"e0ba25d20b6a90a6cc9db32813ef3126","title":"ã€Œ1083ã€List Grades","content":"Given a list ofÂ NÂ student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval.\n\n\nInput Specification:Each input file contains one test case. Each case is given in the following format:\nN\nname[1] ID[1] grade[1]\nname[2] ID[2] grade[2]\n... ...\nname[N] ID[N] grade[N]\ngrade1 grade2\n\nwhereÂ name[i]Â andÂ ID[i]Â are strings of no more than 10 characters with no space,Â grade[i]Â is an integer in [0, 100],Â grade1Â andÂ grade2Â are the boundaries of the gradeâ€™s interval. It is guaranteed that all the grades areÂ distinct.\nOutput Specification:For each test case you should output the student records of which the grades are in the given interval [grade1,Â grade2] and are in non-increasing order. Each student record occupies a line with the studentâ€™s name and ID, separated by one space. If there is no studentâ€™s grade in that interval, outputÂ NONEÂ instead.\nSample Input 1:4\nTom CS000001 59\nJoe Math990112 89\nMike CS991301 100\nMary EE990830 95\n60 100\n\nSample Output 1:Mike CS991301\nMary EE990830\nJoe Math990112\n\nSample Input 2:2\nJean AA980920 60\nAnn CS01 80\n90 95\n\nSample Output 2:NONE\n\n\nÎ©éå¸¸ç»å…¸çš„æ¡¶æ’åºé—®é¢˜ï¼Œç”±äºæ¯ä¸ªå­¦ç”Ÿçš„åˆ†æ•°ä¸åŒï¼Œå› æ­¤ç›´æ¥æ¥ä¸ªvector&lt;pair&lt;string,string&gt;&gt; info(101)ï¼Œç´¢å¼•å³ä¸ºåˆ†æ•°ï¼Œç„¶åååºè¾“å‡ºä¹‹é—´çš„ä¿¡æ¯å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, g1, g2;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;string, string&gt;&gt; info(101);\n    string name, id;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; id &gt;&gt; m;\n        info[m] = make_pair(name, id);\n    }\n    cin &gt;&gt; g1 &gt;&gt; g2;\n    bool flag = true;\n    for (int i = g2; i &gt;= g1; --i)\n        if (!info[i].first.empty())\n        {\n            cout &lt;&lt; info[i].first &lt;&lt; \" \" &lt;&lt; info[i].second &lt;&lt; endl;\n            flag = false;\n        }\n    if (flag) cout &lt;&lt; \"NONE\";\n}\n","slug":"ã€Œ1083ã€List-Grades","date":"2022-10-15T13:15:04.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,pair","author_index":"Starlit Rover"},{"id":"4561856231e707471afc65c846bfe2ca","title":"ã€Œ1082ã€Read Number in Chinese","content":"Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. OutputÂ FuÂ first if it is negative. For example, -123456789 is read asÂ Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 isÂ yi Shi Wan ling ba Bai.\n\n\nInput Specification:Each input file contains one test case, which gives an integer with no more than 9 digits.\nOutput Specification:For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line.\nSample Input 1:-123456789\n\nSample Output 1:Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu\n\nSample Input 2:100800\n\nSample Output 2:yi Shi Wan ling ba Bai\n\n\nÎ©æ•‘å‘½ï¼Œå¥½éš¾å•Šï¼Œæˆ‘å†ä¸€æ¬¡ä½“ä¼šåˆ°äº†ä¸­å›½æ–‡åŒ–çš„åšå¤§ç²¾æ·±ã€‚\n\n\n- ä½ çœŸçš„ä¼šç”¨æ±‰è¯­è¯»æ•°å­—å—ï¼Ÿ\n- ä¼šå•Šä¼šå•Š\n- ä½ èƒ½æ•™ä¼šè®¡ç®—æœºè¯»å—ï¼Ÿ\n- ç®€ç®€å•å•\n-ï¼ˆto Mr.Computerï¼‰æ¯ä¸ªæ•°å­—è¯»å®ŒååŠ ä¸Šå®ƒçš„ä½å\n-ï¼ˆMr.Computerï¼‰ä¸€åä¸‡äºŒä¸‡ä¸‰åƒå››ç™¾äº”åå…­(?)ï¼ˆ12ï¼Œ3456ï¼‰\n-ï¼ˆto Mr.Computerï¼‰ã€‚ã€‚æœ€åä¸€ä½æ˜¯æ²¡åå­—çš„ï¼Œã€äº¿ã€‘å’Œã€ä¸‡ã€‘åªåœ¨ä½ç½®è¾“å‡º\n-ï¼ˆMr.Computerï¼‰ä¸€äº¿é›¶åƒé›¶ç™¾é›¶åé›¶ä¸‡é›¶åƒé›¶ç™¾é›¶åä¸€ï¼ˆ1ï¼Œ0000ï¼Œ0001ï¼‰\n-ï¼ˆto Mr.Computerï¼‰è¯¶è¯¶è¯¶ï¼Œè¿ç»­çš„0åªè¦è¾“å‡ºä¸€ä¸ªå°±å¤Ÿäº†ï¼Œéƒ½æ˜¯0çš„è¯å°±ä¸ç”¨è¾“å‡ºä½åäº†\n-ï¼ˆMr.Computerï¼‰ä¸€åƒé›¶ä¸€åé›¶ï¼ˆ1010ï¼‰\n-ï¼ˆto Mr.Computerï¼‰ã€‚ã€‚ã€‚æœ«å°¾çš„é›¶ä¸ç”¨è¾“å‡º\n-ï¼ˆMr.Computerï¼‰ï¼ˆnullï¼‰ï¼ˆ0ï¼‰\n-ï¼ˆto Mr.Computerï¼‰å•ª\n-ï¼ˆMr.Computerï¼‰å’\n\n\nå‘ç‚¹åŸºæœ¬éƒ½åœ¨ä¸Šé¢äº†ï¼Œä¸¤ä¸ªå‘ç‚¹å°¤ä¸ºçªå‡ºï¼š1. 0çš„å¤„ç†ï¼›2. äº¿ä¸‡ä½•æ—¶è¾“å‡ºã€‚å¯¹äº0çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªzeroå¸ƒå°”å˜é‡ï¼Œå½“æœ‰0å‡ºç°æ—¶å°†å…¶ç½®trueï¼Œç„¶ååˆ°é0æ•°å­—å‡ºç°æ—¶æ£€æŸ¥zeroï¼Œè‹¥ä¸ºtrueåˆ™å…ˆåŠ ä¸Š0çš„è¯»éŸ³ï¼Œå†å°†zeroç½®falseã€‚ä½†ä¼šå‡ºç°yi Bai Wan ling yi Qianï¼ˆ1001000ï¼‰çš„æƒ…å†µï¼Œå› æ­¤åœ¨è¾“å‡ºäº¿å’Œä¸‡åä¹Ÿéœ€è¦å°†zeroç½®falseã€‚å¯¹äºäº¿ä¸‡çš„è¾“å‡ºä¹Ÿæ˜¯è®¾ç½®ä¸€ä¸ªflagå¸ƒå°”æ•°ç»„ï¼Œå‡ºç°é0æ•°åå°†çš„flagç½®trueï¼Œç­‰åˆ°ä½ç½®æ—¶æ£€æŸ¥ç›¸åº”flagè‹¥ä¸ºtrueåˆ™è¾“å‡ºã€‚å¦å¤–åˆ«å¿˜è®°ç‰¹æ®Šæƒ…å†µ0ã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string n, py[] = {\"ling \", \"yi \", \"er \", \"san \", \"si \", \"wu \", \"liu \", \"qi \", \"ba \", \"jiu \"},\n          ans, sfx[] = {\"\", \"Shi \", \"Bai \", \"Qian \", \"Wan \", \"Shi \", \"Bai \", \"Qian \", \"Yi \"};\n    bool flag[3] = {false, false, false}, zero = false;\n    cin &gt;&gt; n;\n    ans += n[0] == '-' ? (n.erase(0, 1), \"Fu \") : \"\";\n    for (int i = 0; i &lt; n.size(); ++i)\n    {\n        if (n[i] == '0')\n        {\n            zero = true;\n            int r = int(n.size() - i - 1);\n            if (flag[r / 4] &amp;&amp; r % 4 == 0)\n            {\n                ans += sfx[r];\n                zero = false;\n            }\n            continue;\n        }\n        ans += zero ? (zero = false, py[0]) : \"\";\n        ans += py[n[i] - '0'] + sfx[n.size() - i - 1];\n        flag[(n.size() - i - 1) / 4] = true;\n    }\n    if (n == \"0\") ans += py[0];\n    ans.erase(ans.size() - 1);\n    cout &lt;&lt; ans;\n}\n","slug":"ã€Œ1082ã€Read-Number-in-Chinese","date":"2022-10-15T12:11:08.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"8c93de95cc54dabff6d1524322e2911a","title":"ã€Œ1081ã€Rational Sum","content":"GivenÂ NÂ rational numbers in the formÂ numerator/denominator, you are supposed to calculate their sum.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a positive integerÂ NÂ (â‰¤100), followed in the next lineÂ NÂ rational numbersÂ a1/b1 a2/b2 ...Â where all the numerators and denominators are in the range ofÂ long int. If there is a negative number, then the sign must appear in front of the numerator.\nOutput Specification:For each test case, output the sum in the simplest formÂ integer numerator/denominatorÂ whereÂ integerÂ is the integer part of the sum,Â numeratorÂ &lt;Â denominator, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0.\nSample Input 1:5\n2/5 4/15 1/30 -2/60 8/3\n\nSample Output 1:3 1/3\n\nSample Input 2:2\n4/3 2/3\n\nSample Output 2:2\n\nSample Input 3:3\n1/3 -1/6 1/8\n\nSample Output 3:7/24\n\n\nÎ©ç»™å‡ºå‡ ä¸ªåˆ†æ•°ï¼Œè®¡ç®—å…¶æ€»å’Œï¼Œä»¥å¸¦åˆ†æ•°çš„å½¢å¼è¾“å‡ºã€‚\nåœ¨ä»¥å‰éœ€è¦è‡ªå·±æ‰‹å†™æœ€å°å…¬å€æ•°/æœ€å¤§å…¬å› æ•°å‡½æ•°ï¼Œæœ‰äº†numericåº“å‡½æ•°ï¼Œå¦ˆå¦ˆå†ä¹Ÿä¸ç”¨æ‹…å¿ƒæˆ‘å› ä¸ºç é¢˜è€Œåƒä¸ä¸Šé¥­å•¦ã€‚åœ¨è¯»å…¥æ‰€æœ‰åˆ†æ•°çš„æ—¶å€™ï¼Œå…ˆå¯¹æ‰€æœ‰åˆ†æ•°è¿›è¡Œçº¦åˆ†ï¼ŒåŒæ—¶è®¡ç®—è‡³æ­¤ä¸ºæ­¢æ‰€æœ‰åˆ†æ¯çš„æœ€å°å…¬å€æ•°ï¼Œæ ¹æ®æœ€æ–°åˆ†æ¯è®¡ç®—åˆ†å­æ€»å’Œï¼Œæœ€åå†è¿›è¡Œä¸€æ¬¡çº¦åˆ†å³å¯ã€‚\nâš ï¸ åˆ†å­ä¸º0æ—¶åªèƒ½è¾“å‡ºä¸€ä¸ª0ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, g, dmt = 1, nrt = 0, time;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt;&gt; frac(n);\n    for (auto &amp;f: frac)\n    {\n        scanf(\"%d/%d\", &amp;f.first, &amp;f.second);\n        g = gcd(f.first, f.second);\n        f.first /= g, f.second /= g;\n        time = lcm(dmt, f.second) / dmt;\n        nrt = time * nrt + time * dmt / f.second * f.first;\n        dmt *= time;\n    }\n    g = gcd(nrt, dmt);\n    nrt /= g, dmt /= g;\n    if (nrt / dmt == 0 &amp;&amp; nrt != 0)\n        cout &lt;&lt; nrt &lt;&lt; \"/\" &lt;&lt; dmt;\n    else if (nrt % dmt == 0)\n        cout &lt;&lt; nrt / dmt;\n    else\n        cout &lt;&lt; nrt / dmt &lt;&lt; \" \" &lt;&lt; nrt % dmt &lt;&lt; \"/\" &lt;&lt; dmt;\n}\n","slug":"ã€Œ1081ã€Rational-Sum","date":"2022-10-14T09:55:41.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,numeric","author_index":"Starlit Rover"},{"id":"d79e1a49ba7f6556c0817ac0afa7d9ae","title":"ã€Œ1080ã€Graduate Admission","content":"It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure.\nEach applicant will have to provide two grades: the national entrance exam gradeÂ GEâ€‹, and the interview gradeÂ GIâ€‹. The final grade of an applicant isÂ (GEâ€‹+GIâ€‹)/2. The admission rules are:\n\nThe applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.\n\nIf there is a tied final grade, the applicants will be ranked according to their national entrance exam gradeÂ GEâ€‹. If still tied, their ranks must be the same.\n\nEach applicant may haveÂ KÂ choices and the admission will be done according to his/her choices: if according to the rank list, it is oneâ€™s turn to be admitted; and if the quota of oneâ€™s most preferred shcool is not exceeded, then one will be admitted to this school, or oneâ€™s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.\n\nIf there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank,Â even if its quota will be exceeded.\n\n\n\n\nInput Specification:Each input file contains one test case.\nEach case starts with a line containing three positive integers:Â NÂ (â‰¤40,000), the total number of applicants;Â MÂ (â‰¤100), the total number of graduate schools; andÂ KÂ (â‰¤5), the number of choices an applicant may have.\nIn the next line, separated by a space, there areÂ MÂ positive integers. TheÂ i-th integer is the quota of theÂ i-th graduate school respectively.\nThenÂ NÂ lines follow, each containsÂ 2+KÂ integers separated by a space. The first 2 integers are the applicantâ€™sÂ GEâ€‹Â andÂ GIâ€‹, respectively. The nextÂ KÂ integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 toÂ Mâˆ’1, and the applicants are numbered from 0 toÂ Nâˆ’1.\nOutput Specification:For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicantsâ€™ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly.\nSample Input:11 6 3\n2 1 2 2 2 3\n100 100 0 1 2\n60 60 2 3 5\n100 90 0 3 4\n90 100 1 2 0\n90 90 5 1 3\n80 90 1 0 2\n80 80 0 1 2\n80 80 0 1 2\n80 70 1 3 2\n70 80 1 2 3\n100 100 0 2 4\n\nSample Output:0 10\n3\n5 6 7\n2 8\n\n1 4\n\n\nÎ©è¯»é¢˜è¯»çš„å‘•å¿ƒæ²¥è¡€ï¼Œä½†ä¸éš¾ç†è§£é¢˜æ„ï¼Œå†™ä¸€ä¸ªè€ƒè¯•å½•å–ç³»ç»Ÿï¼Œç±»ä¼¼é«˜è€ƒä¸­çš„å¹³è¡Œå¿—æ„¿ï¼Œæ¯ä¸ªäººæœ‰ä¸‰ä¸ªå¿—æ„¿ï¼Œåˆ†æ•°é«˜çš„äººä¼˜å…ˆæ‹©æ ¡ï¼ŒæŒ‰ç…§å¿—æ„¿é¡ºåºä¾æ¬¡æŠ•é€’ï¼Œå¦‚æœè¯¥æ ¡è¿˜æœ‰åé¢å‰©ä½™åˆ™æˆåŠŸå½•å–ã€‚å¦å¤–ï¼Œå¦‚æœæŸæ ¡å½•å–äº†åæ¬¡Rçš„åŒå­¦ï¼Œé‚£ä¹ˆåœ¨é¢å¯¹å…¶ä½™åæ¬¡ä¹Ÿä¸ºRçš„åŒå­¦æ—¶å¯ä»¥å¿½ç•¥äººæ•°é™åˆ¶å½•å–ï¼Œå³åªè¦æœ‰1ä¸ªåé¢å‰©ä½™åæ¬¡ç›¸åŒçš„å¯ä»¥ä¸€èµ·å½•ã€‚\nç”±äºæœ‰ä¸¤ä¸ªåˆ†æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªtupleä¾æ¬¡å­˜å–ã€æ€»åˆ†ï¼Œï¼ŒIDã€‘ç„¶åç›´æ¥sortï¼ˆğŸ’¡tupleå’Œpairå‡å·²é‡è½½è¿‡æ¯”è¾ƒè¿ç®—ç¬¦ï¼ŒæŒ‰ç…§é¡ºåºä¾æ¬¡æ¯”è¾ƒï¼‰ã€‚ç„¶åæ ¹æ®æ’åºæ¬¡åºä¾æ¬¡æ‹©æ ¡ï¼Œæ ¹æ®å…¶å¿—æ„¿ä¾æ¬¡éå†å­¦æ ¡å‰©ä½™äººæ•°ï¼Œå¦‚æœæœ‰å‰©ä½™åé¢åˆ™å½•å–å¹¶breakã€‚å¯¹äºç›¸åŒåæ¬¡å¯ä»¥ä¸€èµ·å½•å–çš„ç‰¹æ®Šæƒ…å†µï¼Œç”¨vectorç»™æ¯ä¸ªå­¦æ ¡ä¸€ä¸ªboolå€¼ï¼Œæ¯å½“ä¸€ä½åŒå­¦å½•å–åå°±å°†å½•å–å­¦æ ¡èµ‹å€¼ä¸ºtrueï¼Œè¡¨ç¤ºåŒåæ¬¡å¯ä»¥ä¸€å¹¶å½•å–ã€‚åˆ°ä¸‹ä¸€ä¸ªåŒå­¦æ—¶å…ˆæ¯”è¾ƒåˆ†æ•°ç¡®å®šæ˜¯å¦ä¸ä¸Šä¸€ä½åŒå­¦åæ¬¡ç›¸åŒï¼Œè‹¥ç›¸åŒåˆ™ä¸åšä»»ä½•ä¿®æ”¹ï¼Œå¦åˆ™å°†æ‰€æœ‰å­¦æ ¡çš„boolå€¼éƒ½ç½®falseã€‚é‚£ä¹ˆåœ¨éå†å¿—æ„¿æ—¶é™¤äº†æ£€æŸ¥å‰©ä½™åé¢ï¼ŒåŒæ—¶æ£€æŸ¥å…¶boolå€¼ã€‚\næ¯ä¸ªå­¦æ ¡çš„å½•å–äººå‘˜ç”¨ä¸€ä¸ªsetå­˜å‚¨ï¼Œæœ€åç›´æ¥è¾“å‡ºã€‚\nä¸€éè¿‡ï¼Œä¸­è§„ä¸­çŸ©ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;tuple&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);\n\n    vector&lt;int&gt; quota(m);\n    for (auto &amp;q: quota)\n        scanf(\"%d\", &amp;q);\n\n    vector&lt;tuple&lt;int, int, int&gt;&gt; score(n);\n    vector&lt;vector&lt;int&gt;&gt; pref(n, vector&lt;int&gt;(k));\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d%d\", &amp;get&lt;1&gt;(score[i]), &amp;get&lt;0&gt;(score[i]));\n        get&lt;0&gt;(score[i]) += get&lt;1&gt;(score[i]);\n        get&lt;2&gt;(score[i]) = i;\n        for (auto &amp;p: pref[i])\n            scanf(\"%d\", &amp;p);\n    }\n\n    sort(score.begin(), score.end(), greater&lt;&gt;());\n\n    vector&lt;bool&gt; green(m, false);\n    pair&lt;int, int&gt; pre{-1, -1};\n    vector&lt;set&lt;int&gt;&gt; admit(m);\n    for (auto &amp;s: score)\n    {\n        if (pre.first != get&lt;0&gt;(s) || pre.second != get&lt;1&gt;(s))\n            fill(green.begin(), green.end(), false);\n        for (auto &amp;p: pref[get&lt;2&gt;(s)])\n            if (quota[p] &gt; 0 || green[p])\n            {\n                quota[p] -= 1;\n                green[p] = true;\n                admit[p].insert(get&lt;2&gt;(s));\n                break;\n            }\n        pre = make_pair(get&lt;0&gt;(s), get&lt;1&gt;(s));\n    }\n\n    for (auto &amp;a: admit)\n    {\n        if (!a.empty())\n        {\n            printf(\"%d\", *a.begin());\n            for (auto aa = ++a.begin(); aa != a.end(); ++aa)\n                printf(\" %d\", *aa);\n        }\n        printf(\"\\n\");\n    }\n}\n\n\nTipssort(score.begin(), score.end(), greater&lt;&gt;());\n\nè¿™é‡Œçš„greateräº‹å®ä¸Šæ˜¯ä¸€ä¸ªé‡è½½äº†()çš„ç»“æ„ä½“structæ¨¡æ¿ï¼Œå› æ­¤åŠ ä¸Šæ‹¬å·ä¹‹åå°±ç±»ä¼¼å‡½æ•°åï¼Œæ•ˆæœç±»ä¼¼å¤§äºç¬¦å·ã€‚\n","slug":"ã€Œ1080ã€Graduate-Admission","date":"2022-10-11T12:44:56.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,set,tuple","author_index":"Starlit Rover"},{"id":"60bfb2bd1454fe93e59a0b3383c25980","title":"ã€Œ1079ã€Total Sales of Supply Chain","content":"A supply chain is a network of retailersï¼ˆé›¶å”®å•†ï¼‰, distributorsï¼ˆç»é”€å•†ï¼‰, and suppliersï¼ˆä¾›åº”å•†ï¼‰â€“ everyone involved in moving a product from supplier to customer.\nStarting from one root supplier, everyone on the chain buys products from oneâ€™s supplier in a priceÂ PÂ and sell or distribute them in a price that isÂ r% higher thanÂ P. Only the retailers will face the customers. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle.\nNow given a supply chain, you are supposed to tell the total sales from all the retailers.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains three positive numbers:Â , the total number of the members in the supply chain (and hence their IDâ€™s are numbered from 0 toÂ Nâˆ’1, and the root supplierâ€™s ID is 0);Â P, the unit price given by the root supplier; andÂ r, the percentage rate of price increment for each distributor or retailer. ThenÂ NÂ lines follow, each describes a distributor or retailer in the following format:\n\nwhere in theÂ i-th line,Â Kiâ€‹Â is the total number of distributors or retailers who receive products from supplierÂ i, and is then followed by the IDâ€™s of these distributors or retailers.Â â€‹Â being 0 means that theÂ j-th member is a retailer, then instead the total amount of the product will be given aftter â€‹. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the total sales we can expect from all the retailers, accurate up to 1 decimal place. It is guaranteed that the number will not exceedÂ .\nSample Input:10 1.80 1.00\n3 2 3 5\n1 9\n1 4\n1 7\n0 7\n2 6 1\n1 8\n0 9\n0 4\n0 3\n\nSample Output:42.4\n\n\nÎ©ç»™å‡ºä¸€ä¸ªç»é”€å•†æ ‘ï¼Œæ ¹èŠ‚ç‚¹æ˜¯æœ€å¤§ä¾›åº”å•†ï¼Œå¶å­èŠ‚ç‚¹æ˜¯é›¶å”®å•†ï¼Œå…¶ä½™ä¾›åº”å•†éƒ½ä»çˆ¶ä¾›åº”å•†è¿›è´§ï¼Œç„¶åå–ç»™è‡ªå·±ä¸‹é¢çš„ä¾›åº”å•†ã€‚æ¯ä¸ªä¾›åº”å•†ï¼ˆåŒ…æ‹¬é›¶å”®å•†ï¼‰å‡ºå”®ä»·æ ¼éƒ½ä¼šæ¯”è‡ªå·±ä¹°å…¥çš„ä»·æ ¼é«˜å‡ºï¼Œå‘ŠçŸ¥æ‰€æœ‰é›¶å”®å•†çš„è¿›è´§é‡ï¼Œè®¡ç®—æ‰€æœ‰é›¶å”®å•†çš„é¢„æœŸæ”¶å…¥æ€»å’Œã€‚\nä¸éš¾çœ‹å‡ºï¼Œé›¶å”®å•†å‡ºå”®ä»·æ ¼åªä¸è‡ªèº«æ‰€å¤„çš„æ·±åº¦æœ‰å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨BFSï¼Œæ¯æ¬¡éå†ä¸€å±‚èŠ‚ç‚¹ï¼Œå°†è¯¥å±‚ä¸­çš„å¶å­èŠ‚ç‚¹è¿›è´§é‡ç›¸åŠ ï¼Œæœ€åå³ä¸ºè¯¥å±‚é›¶å”®å•†çš„é¢„æœŸæ”¶å…¥ã€‚\néå†å®Œæ•´é¢—æ ‘åå†å°†å¾—åˆ°ç»“æœä¹˜ä»¥æœ€å¤§ä¾›åº”å•†çš„å‡ºå”®ä»·æ ¼å³å¯ã€‚\næ— æ„ä¸­è¿˜å‘ç°å…¶å®\"%.nf\"è¿™ç§æµ®ç‚¹æ•°æ ¼å¼åŒ–ä¹Ÿæ˜¯å››èˆäº”å…¥ï¼Œé‡å¡‘ä¸–ç•Œè§‚ã€‚ä¹‹å‰è¿˜æœ‰ä¸€ç¯‡åšå®¢ä¸“é—¨åˆ†æå››èˆäº”å…¥æ—¶è¿˜ä»¥ä¸ºæ˜¯æµ®ç‚¹æ•°è¿ç®—ä¸­çš„ç²¾åº¦æŸå¤±ï¼Œæœªæ›¾æƒ³æ˜¯ç›´æ¥ç»™å››èˆäº”å…¥äº†ï¼Œç©å®Œï¼Œå¾—è¡¥è¯¾å»äº†ã€‚ä¸è¿‡ä»–çš„å››èˆäº”å…¥æœºåˆ¶å› ä¸ºæµ®ç‚¹æ•°ç²¾åº¦çš„é—®é¢˜ä¼šæœ‰ç‚¹å·®å¼‚ï¼Œè¯¦æƒ…å¯è§Cè¯­è¨€printfå‡½æ•°%.2fè¾“å‡ºä¸ºä»€ä¹ˆå››èˆäº”å…¥å®ç°æœºåˆ¶ä¸åŒï¼Ÿã€‚\nâš ï¸+0.5æ“ä½œæ˜¯æµ®ç‚¹æ•°è½¬intæ—¶çš„æ“ä½œï¼Œä¸Šé¢çš„æ ¼å¼åŒ–é»˜è®¤æ˜¯å››èˆäº”å…¥ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    double p, r;\n    cin &gt;&gt; n &gt;&gt; p &gt;&gt; r;\n    r = 1 + r / 100;\n    vector&lt;vector&lt;int&gt;&gt; sup(n);\n    vector&lt;int&gt; ret(n, 0);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        sup[i].resize(m);\n        for (int j = 0; j &lt; m; ++j)\n            cin &gt;&gt; sup[i][j];\n        if (m == 0) cin &gt;&gt; ret[i];\n    }\n\n    vector&lt;int&gt; crt{0}, tmp;\n    double total = 0, rate = 1;\n    while (!crt.empty())\n    {\n        int num = 0;\n        for (auto &amp;k: crt)\n        {\n            if (ret[k])\n                num += ret[k];\n            else\n                tmp.insert(tmp.end(), sup[k].begin(), sup[k].end());\n        }\n        total += rate * num;\n        rate *= r;\n        crt = std::move(tmp);\n        tmp = vector&lt;int&gt;();\n    }\n\n    total *= p;\n    printf(\"%.1f\", total);\n}\n","slug":"ã€Œ1079ã€Total-Sales-of-Supply-Chain","date":"2022-10-11T06:10:22.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,BFS,Tree","author_index":"Starlit Rover"},{"id":"c2d476bf277e1b89715673299c98c76c","title":"ã€Œ1078ã€Hashing","content":"The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to beÂ Â whereÂ TSizeÂ is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions.\nNote that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive numbers:Â  andÂ  which are the user-defined table size and the number of input numbers, respectively. ThenÂ NÂ distinct positive integers are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print â€œ-â€œ instead.\nSample Input:4 4\n10 6 4 15\n\nSample Output:0 1 4 -\n\n\nÎ©å•çº¯è€ƒå“ˆå¸Œæ•£åˆ—ä¸­çš„äºŒæ¬¡æ¢æŸ¥ï¼Œå¯¹äºç”¨æˆ·è¾“å…¥çš„å“ˆå¸Œè¡¨å¤§å°ï¼Œéœ€è¦å°†å…¶æ”¹æˆæœ€å°ä¸”å¤§äºå®ƒçš„ç´ æ•°ï¼Œç„¶åè¾“å‡ºæ¯ä¸ªæ•°çš„å“ˆå¸Œç´¢å¼•ã€‚å¦‚æœ‰å†²çªç”¨äºŒæ¬¡æ¢æŸ¥æ³•å¯»æ‰¾æ–°çš„ç´¢å¼•ï¼Œæ‰¾ä¸åˆ°åˆ™è¾“å‡º-ã€‚\né¦–å…ˆï¼Œ1ä¸æ˜¯ç´ æ•°éœ€è¦å•ç‹¬å¤„ç†ï¼Œç„¶åé—®é¢˜å°±åœ¨äºå¦‚ä½•åˆ¤æ–­ä¸€ä¸ªæ•°æ‰¾ä¸åˆ°å“ˆå¸Œç´¢å¼•ï¼Œè¿™å…¶å®æ¶‰åŠåˆ°ä¸€ä¸ªå•çº¯æœ´ç´ çš„æ•°è®ºå°çŸ¥è¯†ï¼š\n\nè¯æ˜ä¹Ÿå¾ˆæ˜¾ç„¶ï¼Œå±•å¼€å³å¾—ã€‚å› æ­¤å¦‚æœæ—¶éƒ½æ²¡æœ‰ç©ºä½™ç´¢å¼•ï¼Œåé¢è‡ªç„¶ä¹Ÿæ˜¯æ‰¾ä¸åˆ°çš„ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k;\n    cin &gt;&gt; m &gt;&gt; n;\n    m = (m == 1 ? 2 : m);\n    for (int i = m + 1 - m % 2; m &gt; 2; i += 2)\n    {\n        bool flag = false;\n        for (int j = 2; j &lt;= i / j; ++j)\n            if (i % j == 0)\n            {\n                flag = true;\n                break;\n            }\n        if (flag) continue;\n        else\n        {\n            m = i;\n            break;\n        }\n    }\n    vector&lt;bool&gt; flag(m, false);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        int r = k % m, cnt = 1;\n        while (cnt &lt; m &amp;&amp; flag[r])\n        {\n            r = (k + cnt * cnt) % m;\n            ++cnt;\n        }\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; (cnt == m ? \"-\" : (flag[r] = true, to_string(r)));\n    }\n\n}\n","slug":"ã€Œ1078ã€Hashing","date":"2022-10-08T10:51:59.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,hash","author_index":"Starlit Rover"},{"id":"fd5509f1a9c73776f2474d74cf48b6da","title":"ã€Œ1077ã€Kuchiguse","content":"The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speakerâ€™s personality. Such a preference is called â€œKuchiguseâ€ and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle â€œnyan~â€ is often used as a stereotype for characters with a cat-like personality:\n\nItai nyan~ (It hurts, nyan~)\n\nNinjin wa iyada nyan~ (I hate carrots, nyan~)\n\n\nNow given a few lines spoken by the same character, can you find her Kuchiguse?\n\n\nInput Specification:Each input file contains one test case. For each case, the first line is an integerÂ NÂ (2â‰¤Nâ‰¤100). Following areÂ NÂ file lines of 0~256 (inclusive) characters in length, each representing a characterâ€™s spoken line. The spoken lines are case sensitive.\nOutput Specification:For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of allÂ NÂ lines. If there is no such suffix, writeÂ nai.\nSample Input 1:3\nItai nyan~\nNinjin wa iyadanyan~\nuhhh nyan~\n\nSample Output 1:nyan~\n\nSample Input 2:3\nItai!\nNinjinnwaiyada T_T\nT_T\n\nSample Output 2:nai\n\n\nÎ©å¯»æ‰¾æœ€é•¿å…¬å…±åç¼€ï¼Œæ— åˆ™è¾“å‡ºâ€œnaiâ€ã€‚\næœ€ç®€å•çš„æƒ³æ³•å°±æ˜¯å…ˆæŠŠæ‰€æœ‰å¥å­å­˜åˆ°ä¸€ä¸ªvectoré‡Œï¼Œç„¶åä¸€èµ·ä»åå¾€å‰æ•°ã€‚\näº‹å®ä¸Šä¸éœ€è¦è¿™ä¹ˆéº»çƒ¦ï¼Œåªè¦æ¯æ¬¡è¯»å…¥ä¸€ä¸ªæ–°å¥å­åå’Œå½“å‰å…¬å…±åç¼€ä»åè‡³å‰è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åå­˜å–æ–°çš„å…¬å…±åç¼€ã€‚å½“ç„¶å«Œä»åå¾€å‰éº»çƒ¦ï¼Œå°±æŠŠä»–ä»¬éƒ½reverseä¸€ä¸‹ã€‚\nâš ï¸ä½¿ç”¨getlineæ—¶æ³¨æ„ä¸Šä¸€è¡Œæ˜¯å¦è¯»å®Œï¼ŒåŒ…æ‹¬â€™\\nâ€™ï¼ˆéœ€è¦getcharä¸€ä¸‹ï¼‰ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n;\n    string ans, tmp;\n    getchar(); //get '\\n'\n    getline(cin, ans);\n    reverse(ans.begin(), ans.end());\n    for (int i = 1; i &lt; n; ++i)\n    {\n        getline(cin, tmp);\n        reverse(tmp.begin(), tmp.end());\n        for (k = 0; k &lt; min(ans.size(), tmp.size()); ++k)\n            if (ans[k] != tmp[k])\n                break;\n        ans = ans.substr(0, k);\n    }\n    reverse(ans.begin(), ans.end());\n    cout &lt;&lt; (ans.empty() ? \"nai\" : ans);\n}\n","slug":"ã€Œ1077ã€Kuchiguse","date":"2022-10-08T08:39:36.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,reverse,string","author_index":"Starlit Rover"},{"id":"bdaf6b5d6e486b0211610bff2d92703a","title":"ã€Œ1076ã€Forwards on Weibo","content":"Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that onlyÂ LÂ levels of indirect followers are counted.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers:Â NÂ (â‰¤1000), the number of users; andÂ LÂ (â‰¤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 toÂ N. ThenÂ NÂ lines follow, each in the format:\nM[i] user_list[i]\n\nwhereÂ M[i]Â (â‰¤100) is the total number of people thatÂ user[i]Â follows; andÂ user_list[i]Â is a list of theÂ M[i]Â users that followed byÂ user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.\nThen finally a positiveÂ KÂ is given, followed byÂ KÂ UserIDâ€˜s for query.\nOutput Specification:For eachÂ UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that onlyÂ LÂ levels of indirect followers are counted.\nSample Input:7 3\n3 2 3 4\n0\n2 5 6\n2 3 1\n2 3 4\n1 4\n1 5\n2 2 6\n\nSample Output:4\n5\n\n\nÎ©å‘ŠçŸ¥å¾®åšçš„å…³æ³¨ç½‘ç»œå›¾ï¼Œå‡è®¾ä¸€ä¸ªäººå‘å¾®åšï¼Œå…³æ³¨ä»–çš„äººéƒ½ä¼šè½¬å‘ä¸€æ¬¡ï¼Œç›¸åº”è½¬å‘å¾®åšäººçš„å…³æ³¨è€…ä¹Ÿä¼šè½¬å‘ä¸€æ¬¡ï¼Œä½†åŒä¸€ä¸ªäººåªè½¬å‘ä¸€æ¬¡ï¼Œé—®æŒ‡å®šäººå‘åšä¼šå¾—åˆ°å‡ æ¬¡è½¬å‘ï¼Œåªè®¡æ•°Lå±‚å…³æ³¨é“¾å†…çš„äººã€‚\nå¾ˆæ˜¾ç„¶çš„BFSé¢˜ï¼Œæ²¡æœ‰éš¾åº¦ï¼Œæ˜ç¡®æ¯ä¸ªäººçš„followersç„¶åè¿›è¡ŒLæ¬¡BFSï¼Œå¯¹äºå·²ç»éå†è¿‡çš„äººè¿›è¡Œæ ‡è®°ï¼Œå¦‚æœä¸‹ä¸€æ¬¡éå†çš„é›†åˆä¸ºç©ºå°±æå‰é€€å‡ºå¾ªç¯ã€‚æ²¡é‡åˆ°ä»€ä¹ˆå‘ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, l, m, k;\n    cin &gt;&gt; n &gt;&gt; l;\n    vector&lt;vector&lt;int&gt;&gt; follow(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k;\n            follow[k - 1].push_back(i);\n        }\n    }\n    cin &gt;&gt; m;\n    vector&lt;int&gt; crt, nxt;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; k;\n        vector&lt;bool&gt; flag(n, true);\n        flag[k - 1] = false;\n        int cnt = 0;\n        crt.push_back(k - 1);\n        for (int j = 0; j &lt; l &amp;&amp; !crt.empty(); ++j)\n        {\n            for (auto &amp;v: crt)\n                for (auto &amp;u: follow[v])\n                    if (flag[u])\n                    {\n                        nxt.push_back(u);\n                        flag[u] = false;\n                        ++cnt;\n                    }\n            crt = std::move(nxt);\n            nxt = vector&lt;int&gt;();\n        }\n        cout &lt;&lt; cnt &lt;&lt; endl;\n    }\n}\n","slug":"ã€Œ1076ã€Forwards-on-Weibo","date":"2022-10-06T14:08:39.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,BFS,Graph","author_index":"Starlit Rover"},{"id":"50b7040dd173c7b4aabe65b86d7947f4","title":"ã€Œ1075ã€PAT Judge","content":"The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 3 positive integers,Â , the total number of users,Â KÂ (â‰¤5), the total number of problems, andÂ , the total number of submissions. It is then assumed that the user idâ€™s are 5-digit numbers from 00001 toÂ N, and the problem idâ€™s are from 1 toÂ K. The next line containsÂ KÂ positive integersÂ p[i]Â (i=1, â€¦,Â K), whereÂ p[i]Â corresponds to the full mark of the i-th problem. ThenÂ MÂ lines follow, each gives the information of a submission in the following format:\nuser_id problem_id partial_score_obtained\n\nwhereÂ partial_score_obtainedÂ is eitherÂ âˆ’1Â if the submission cannot even pass the compiler, or is an integer in the range [0,Â p[problem_id]]. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, you are supposed to output the ranklist in the following format:\nrank user_id total_score s[1] ... s[K]\n\nwhereÂ rankÂ is calculated according to theÂ total_score, and all the users with the sameÂ total_scoreÂ obtain the sameÂ rank; andÂ s[i]Â is the partial score obtained for theÂ i-th problem. If a user has never submitted a solution for a problem, then â€œ-â€œ must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.\nThe ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their idâ€™s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.\nSample Input:7 4 20\n20 25 25 30\n00002 2 12\n00007 4 17\n00005 1 19\n00007 2 25\n00005 1 20\n00002 2 2\n00005 1 15\n00001 1 18\n00004 3 25\n00002 2 25\n00005 3 22\n00006 4 -1\n00001 2 18\n00002 1 20\n00004 1 15\n00002 4 18\n00001 3 4\n00001 4 2\n00005 2 -1\n00004 2 0\n\nSample Output:1 00002 63 20 25 - 18\n2 00005 42 20 0 22 -\n2 00007 42 - 25 - 17\n2 00001 42 18 18 4 2\n5 00004 40 15 0 25 -\n\n\nÎ©å›½åº†çš„å°¾å·´è¿˜èƒ½é‡ä¸Šè¿™ç§çƒ¦äººçš„é¢˜ç›®ï¼Œæ‚²ä¼¤åŠ å€ã€‚ä¼°è®¡æ˜¯æ²¡ä»€ä¹ˆé¢˜ç›®å¥½ç¼–äº†ï¼ŒPATè¯„æµ‹ç³»ç»Ÿéƒ½æ¥äº†ï¼Œå¯èƒ½æ˜¯å˜ç›¸æ‹›è˜ã€‚éš¾æ˜¯ä¸æ•¢è¯´ï¼Œçƒ¦æ˜¯çœŸçš„çƒ¦ã€‚æ˜å¤©åˆè¦å…³è¿›å»äº†ï¼Œå‘œå‘œå‘œã€‚\nå€ŸåŠ©å¾®è–„çš„PTAä½¿ç”¨ç»éªŒï¼Œç¨å¾®æ•´ç†äº†ä¸€ä¸‹ï¼ˆæ½œï¼‰è§„åˆ™ï¼š\n\nç”¨æˆ·è¿ç¼–è¯‘é˜¶æ®µéƒ½æ²¡é€šè¿‡æ—¶è¾“å…¥çš„åˆ†æ•°ä¸º-1\n\nå•ä¸ªé¢˜ç›®å¤šæ¬¡æäº¤å–æœ€é«˜åˆ†ï¼ˆCase 4ï¼šç¬¬ä¸€æ¬¡æ»¡åˆ†ï¼Œç¬¬äºŒæ¬¡ç¼–è¯‘æ²¡é€šè¿‡ç®—æ»¡åˆ†ï¼‰\n\næ²¡æœ‰é¢˜ç›®é€šè¿‡ç¼–è¯‘ï¼ˆåŒ…æ‹¬æœªæäº¤ï¼‰çš„ç”¨æˆ·ä¸åº”ä¸Šæ¦œ\n\nå¯¹äºæ€»åˆ†ä¸º0ç”¨æˆ·çš„åæ¬¡ï¼Œéœ€è¦æ’é™¤é‚£äº›ä¸å‚ä¸æ’åè€Œæ€»å¾—åˆ†åŒæ ·ä¸º0çš„ç”¨æˆ·\n\nåªæœ‰ä¸€æ¬¡éƒ½æ²¡æäº¤è¿‡çš„é¢˜ç›®è¾“å‡ºâ€œ-â€ï¼Œç¼–è¯‘æ²¡é€šè¿‡è¾“å‡º0\n\nä¾æ¬¡æŒ‰ç…§æ€»åˆ†é™åºã€æ»¡åˆ†é¢˜ç›®ä¸ªæ•°é™åºã€IDå‡åºçš„ä¼˜å…ˆçº§æ¥æ’å\n\nåŒä¸€é¢˜ç›®å¤šæ¬¡æäº¤æ»¡åˆ†ä¸è¦é‡å¤è®¡ç®—\n\n\nå¯¹äºå¤æ‚çš„æ¯”è¾ƒè§„åˆ™åªè¦ç ä¸€ä¸ªcmpå‡½æ•°å³å¯ï¼Œå¤´ç–¼çš„æ˜¯åˆ¤æ–­å“ªäº›ç”¨æˆ·éœ€è¦æ’åï¼Œé¦–å…ˆå¯ä»¥è®¾ç½®ä¸€ä¸ªå…¨ä¸ºfalseçš„boolå‘é‡ï¼Œåªè¦æœ‰é¢˜ç›®é€šè¿‡ç¼–è¯‘ï¼ˆ&gt;-1ï¼‰å°±æ”¹trueè¯´æ˜ä¸Šæ¦œã€‚å¦å¤–å¯¹äºç¼–è¯‘æ²¡é€šè¿‡å’Œä»æ²¡æäº¤è¿‡ä¹Ÿå¾—åŒºåˆ†å¼€ï¼ˆ5ï¼‰ï¼Œé‚£ä¹ˆåˆå§‹åŒ–ç”¨æˆ·é¢˜ç›®åˆ†æ•°éƒ½ä¸º-1ï¼Œè‹¥æ˜¯æäº¤ç¼–è¯‘æœªé€šè¿‡å°±æ”¹æˆ0ã€‚å…¶ä½™æƒ…å†µå°±å–æ›´é«˜åˆ†æ•°ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;numeric&gt;\n\nusing namespace std;\nvector&lt;int&gt; sum, solve;\nvector&lt;vector&lt;int&gt;&gt; score;\n\nbool cmp(int &amp;a, int &amp;b)\n{\n    if (sum[a] != sum[b])\n        return sum[a] &gt; sum[b];\n    else if (solve[a] != solve[b])\n        return solve[a] &gt; solve[b];\n    else\n        return a &lt; b;\n}\n\nint main()\n{\n    int n, k, m, id, q, s;\n    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;\n    vector&lt;int&gt; mark(k), ids(n);\n    vector&lt;bool&gt; flag(n, false);\n    iota(ids.begin(), ids.end(), 0);\n    sum = solve = vector&lt;int&gt;(n, 0);\n    for (auto &amp;v: mark)\n        cin &gt;&gt; v;\n    score = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(k, -1));\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; q &gt;&gt; s;\n        if (score[id - 1][q - 1] == -1 &amp;&amp; s == -1)\n            score[id - 1][q - 1] = 0;\n        else\n            score[id - 1][q - 1] = (score[id - 1][q - 1] &lt; s ? (flag[id - 1] = true, s) : score[id - 1][q - 1]);\n    }\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; k; ++j)\n        {\n            sum[i] += (score[i][j] != -1) * score[i][j];\n            solve[i] += score[i][j] == mark[j];\n        }\n    sort(ids.begin(), ids.end(), cmp);\n    int rank = 1, pre = sum[ids[0]], cnt = 1;\n    for (auto &amp;v: ids)\n    {\n        if (!flag[v]) continue;\n        rank = sum[v] == pre ? rank : cnt;\n        printf(\"%d %05d %d\", rank, v + 1, sum[v]);\n        for (int i = 0; i &lt; k; ++i)\n            cout &lt;&lt; \" \" &lt;&lt; (score[v][i] == -1 ? \"-\" : to_string(score[v][i]));\n        cout &lt;&lt; endl;\n        pre = sum[v];\n        ++cnt;\n    }\n}\n","slug":"ã€Œ1075ã€PAT-Judge","date":"2022-10-06T12:17:54.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"e845b313b55f4309188a47e3699e705a","title":"ã€Œ1074ã€Reversing Linked List","content":"Given a constantÂ KÂ and a singly linked listÂ L, you are supposed to reverse the links of everyÂ KÂ elements onÂ L. For example, givenÂ LÂ being 1â†’2â†’3â†’4â†’5â†’6, ifÂ K=3, then you must output 3â†’2â†’1â†’6â†’5â†’4; ifÂ K=4, you must output 4â†’3â†’2â†’1â†’5â†’6.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the address of the first node, a positiveÂ  which is the total number of nodes, and a positiveÂ  which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.\nThenÂ NÂ lines follow, each describes a node in the format:\nAddress Data Next\n\nwhereÂ AddressÂ is the position of the node,Â DataÂ is an integer, andÂ NextÂ is the position of the next node.\nOutput Specification:For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.\nSample Input:00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\n\nSample Output:00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1\n\n\nÎ©å°†é“¾è¡¨æ¯Kä¸ªå…ƒç´ åè½¬æ’åˆ—ï¼Œè¾“å‡ºæœ€åé“¾è¡¨çš„èŠ‚ç‚¹åœ°å€ã€æ•°å€¼ä»¥åŠä¸‹ä¸€ä¸ªå…ƒç´ çš„åœ°å€ï¼Œå¦‚æœæœ€åçš„èŠ‚ç‚¹ä¸ªæ•°ä¸è¶³Kä¸ªåˆ™æ— éœ€åè½¬ã€‚\nå¦‚æœæ²¡æœ‰æœ€åä¸€å¥è¯ï¼Œç›´æ¥å°±ç”¨ä¸€ä¸ªæ ˆè¯»Kä¸ªè¾“å‡ºKä¸ªã€‚æµ‹è¯•Sampleæ—¶æ‰å‘ç°æœ€åä¸è¶³Kä¸ªæ— éœ€åè½¬ï¼Œé‚£å°±ç›´æ¥ä¸Švectorï¼Œæ¯Kä¸ªreverseä¸€ä¸‹ï¼Œæœ€åä¸è¶³å°±ä¸ç”¨åŠ¨ã€‚å¾ˆæ˜¾ç„¶ï¼Œä¸‹ä¸€ä¸ªå…ƒç´ çš„åœ°å€ä¼šè¿ç€è¾“å‡ºä¸¤æ¬¡ï¼ˆä¸­é—´æ¢äº†ä¸ªè¡Œï¼‰ï¼Œé‚£å°±è®©ä¸‹ä¸€ä¸ªå…ƒç´ ä¸€èµ·è´Ÿè´£è¾“å‡ºäº†ã€‚\né‚£ä¹ˆé™¤äº†é¦–èŠ‚ç‚¹å¤–éƒ½æ˜¯å¹³è¡Œå››è¾¹å½¢å¼çš„è¾“å‡ºï¼Œæœ€åå†è¾“å‡ºä¸ª-1å³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, pair&lt;int, string&gt;&gt; value;\n    string addr, next, head;\n    int n, k, v;\n    cin &gt;&gt; head &gt;&gt; n &gt;&gt; k;\n    for (int j = 0; j &lt; n; ++j)\n    {\n        cin &gt;&gt; addr &gt;&gt; v &gt;&gt; next;\n        value[addr] = {v, next};\n    }\n    vector&lt;string&gt; list;\n    for (string tmp = head; tmp != \"-1\"; tmp = value[tmp].second)\n        list.push_back(tmp);\n    for (int i = k; i &lt;= list.size(); i += k)\n        reverse(list.begin() + i - k, list.begin() + i);\n    printf(\"%s %d \", list[0].c_str(), value[list[0]].first);\n    list.erase(list.begin());\n    // å¹³è¡Œå››è¾¹å½¢è¾“å‡º\n    for (auto &amp;s: list)\n        printf(\"%s\\n%s %d \", s.c_str(), s.c_str(), value[s].first);\n    printf(\"-1\\n\");\n}\n","slug":"ã€Œ1074ã€Reversing-Linked-List","date":"2022-10-06T08:27:35.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,reverse,list","author_index":"Starlit Rover"},{"id":"489d94365958188264d5e930f4f52aca","title":"ã€Œ1073ã€Scientific Notation","content":"Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9].[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponentâ€™s signs are always provided even when they are positive.\nNow given a real numberÂ AÂ in scientific notation, you are supposed to printÂ AÂ in the conventional notation while keeping all the significant figures.\n\n\nInput Specification:Each input contains one test case. For each case, there is one line containing the real numberÂ AÂ in scientific notation. The number is no more than 9999 bytes in length and the exponentâ€™s absolute value is no more than 9999.\nOutput Specification:For each test case, print in one line the input numberÂ AÂ in the conventional notation, with all the significant figures kept, including trailing zeros.\nSample Input 1:+1.23400E-03\n\nSample Output 1:0.00123400\n\nSample Input 2:-1.2E+10\n\nSample Output 2:-12000000000\n\n\nÎ©ç§‘å­¦è®¡æ•°æ³•è½¬å¸¸è§„æ•°å­—ï¼Œæ— éœ€å»é™¤å°¾æ•°0é™ä½äº†äº›éš¾åº¦ï¼Œåªéœ€è¦è®°ä½å°æ•°ç‚¹çš„ä½ç½®å³å¯ã€‚\næ³¨æ„åˆ°é¢˜ç›®ç»™å‡ºçš„ç§‘å­¦è®¡æ•°æ³•æ­£åˆ™è¡¨è¾¾å¼ä¸ºï¼Œè¯´æ˜åœ¨å°æ•°ç‚¹å‰æ°¸è¿œæ˜¯ã€ç¬¦å·ä½+ä¸€ä¸ªæ•°å­—ã€‘ã€‚é‚£ä¹ˆå…ˆæŠŠå…¶ä¸­Eå‰åº•æ•°å»æ‰ç¬¦å·ä½å’Œå°æ•°ç‚¹å•ç‹¬å–å‡ºï¼Œç„¶åè¯»å–Eåé¢çš„æŒ‡æ•°ï¼ˆï¼‰ï¼Œå¦‚æœå‡è®¾é¦–ä¸ªæ•°å­—ç´¢å¼•ä¸º0ï¼Œé‚£ä¹ˆå°æ•°ç‚¹å°±åœ¨ç¬¬ä¸ªæ•°å­—å‰é¢ã€‚è€Œæœ€åæˆ‘ä»¬éœ€è¦è¾“å‡ºçš„æ•°å­—ç´¢å¼•èŒƒå›´å³ä¸ºï¼Œæ³¨æ„å¦‚æœå°æ•°ç‚¹åœ¨ç¬¬ä¸€ä¸ªæ•°å­—å‰é¢å°±éœ€è¦æŠŠå‰ç½®0ä¹Ÿè¾“å‡ºå› æ­¤ï¼Œè¶…å‡ºæ•°å­—ä¸ªæ•°åˆ™éœ€è¦æŠŠå°¾0è¡¥ä¸Šã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s, n;\n    cin &gt;&gt; s;\n    int point;\n    for (int i = 1; i &lt; int(s.size()); ++i)\n    {\n        if (isdigit(s[i]))\n            n += s[i];\n        else if (s[i] == 'E')\n        {\n            point = 1 + stoi(s.substr(i + 1));\n            break;\n        }\n    }\n    cout &lt;&lt; (s[0] == '+' ? \"\" : \"-\");\n    for (int i = min(point - 1, 0); i &lt; max(point, int(n.size())); ++i)\n    {\n        cout &lt;&lt; (i == point ? \".\" : \"\");\n        if (i &lt; 0 || i &gt;= int(n.size()))\n            cout &lt;&lt; '0';\n        else\n            cout &lt;&lt; n[i];\n    }\n\n}\n\nâš ï¸ size_tå’Œintæ¯”è¾ƒè®¡ç®—æ—¶åˆ«å¿˜è½¬æˆintâš ï¸\n","slug":"ã€Œ1073ã€Scientific-Notation","date":"2022-10-05T15:29:56.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"74ba177c21feee6c064587dc81699431","title":"ã€Œ1072ã€Gas Station","content":"A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range.\nNow given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 positive integers:Â , the total number of houses;Â MÂ (â‰¤10), the total number of the candidate locations for the gas stations;Â , the number of roads connecting the houses and the gas stations; andÂ DSâ€‹, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 toÂ N, and all the candidate locations are numbered fromÂ G1 toÂ GM.\nThenÂ KÂ lines follow, each describes a road in the format\nP1 P2 Dist\n\nwhereÂ P1Â andÂ P2Â are the two ends of a road which can be either house numbers or gas station numbers, andÂ DistÂ is the integer length of the road.\nOutput Specification:For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply outputÂ No Solution.\nSample Input 1:4 3 11 5\n1 2 2\n1 4 2\n1 G1 4\n1 G2 3\n2 3 2\n2 G2 1\n3 4 2\n3 G3 2\n4 G1 3\nG2 G1 1\nG3 G2 2\n\nSample Output 1:G1\n2.0 3.3\n\nSample Input 2:2 1 2 10\n1 G1 9\n2 G1 20\n\nSample Output 2:No Solution\n\n\nÎ©åŠ æ²¹ç«™é€‰å€é—®é¢˜ï¼Œç»™å‡ºä¸€ä¸ªæˆ¿å­å’ŒåŠ æ²¹ç«™å¤‡é€‰åœ°ç‚¹çš„æœ‰æƒæ— å‘å›¾ï¼Œæˆ‘ä»¬éœ€è¦ä»å¯é€‰åœ°ç‚¹ä¸­é€‰æ‹©ä¸€ä¸ªæœ€ä¼˜åœ°ç‚¹ï¼Œä½¿åŠ æ²¹ç«™åˆ°æ‰€æœ‰æˆ¿å­çš„æœ€å°è·ç¦»æœ€å¤§ï¼ˆå¯èƒ½ä¸å¸Œæœ›æ¥å¾€è½¦è¾†å™ªå£°å½±å“å±…æ°‘ï¼‰ï¼Œä½†ä¹Ÿéœ€è¦æ‰€æœ‰æˆ¿å­åœ¨æœåŠ¡è·ç¦»å†…ï¼ˆåŒæ—¶ä¸å¿˜è·åˆ©æœ€å¤§ï¼‰ã€‚å¦‚æœæœ‰å¤šä¸ªæœ€ä¼˜è§£åˆ™é€‰æ‹©ä¸æˆ¿å­ä¹‹é—´å¹³å‡è·ç¦»æœ€çŸ­çš„è§£ï¼Œè‹¥ä¾ç„¶æœ‰å¤šä¸ªå°±é€‰æ‹©åºå·æœ€å°çš„åœ°ç‚¹ã€‚\nç¬¬ä¸€ä¸ªéº»çƒ¦é¬¼æ˜¯è¾“å…¥ä¸­çš„åŠ æ²¹ç«™å¤„ç†ï¼Œå¯¹äºç›´æ¥æŠŠGå‰å‡ºå»è½¬æˆæ•°å­—å+Nã€‚ç„¶åå¯¹æ¯ä¸ªåŠ æ²¹ç«™é€‰å€é‡‡å–Dijkstraç®—æ³•ï¼Œä¸€æ—¦æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»å°±breakå¹¶ç›´æ¥è¿›å…¥ä¸‹ä¸€ä¸ªé€‰å€ã€‚å¦‚æœæ‰€æœ‰æˆ¿å­éƒ½åœ¨æœåŠ¡èŒƒå›´å†…ï¼Œé‚£ä¹ˆå†ä¸æœ€ä¼˜è§£ä¾æ¬¡æ¯”è¾ƒæœ€çŸ­è·ç¦»ï¼ˆbiggerï¼‰å’Œå¹³å‡è·ç¦»ï¼ˆsmallerï¼‰ã€‚\nå…¶å®æ•´ä½“æ€è·¯ä¸éš¾ï¼Œä½†Sampleå°±æäººå¿ƒæ€ã€‚æ³¨æ„åˆ°Sample 1ä¸­çš„3.3ï¼Œå…¶å®æœ¬æ¥æ˜¯3.25ï¼Œè¿™é‡Œè¿›è¡Œäº†å››èˆäº”å…¥ã€‚äºæ˜¯ä¹æˆ‘åœ¨æœ€åè¾“å‡ºå¹³å‡è·ç¦»çš„æ—¶å€™åŠ äº†ä¸ª0.05ï¼Œç»“æœcase 4ç‚¸äº†ï¼ŒæŠŠ0.05å»æ‰å´è¿‡äº†ï¼Œè€ŒSample 1è¾“å‡º3.2ã€‚æ˜¯ä¸æ˜¯æœ‰ä»€ä¹ˆå¤§ç—…ï¼Ÿ\n\n10.6 ç»­ummmæˆ‘çŸ¥é“åŸå› äº†å®¶äººä»¬ã€‚è·‘äº†ä¸‹ç½‘ä¸Šå‰å‡ ä¸ªé¢˜è§£ï¼Œå¤§éƒ¨åˆ†Sample 1çš„è¿è¡Œç»“æœæ˜¯3.2ï¼Œæœ‰ä¸€ä¸ªæ˜¯3.3ã€‚Amazingï¼Œæˆ‘èµ¶å¿™çœ‹äº†æ³¢ä»–çš„å››èˆäº”å…¥ï¼Œä»–ç”¨äº†cmathåº“ä¸­çš„roundå‡½æ•°ï¼šround(avg*10)/10ï¼Œç¡®å®ä¹Ÿé€šè¿‡äº†æ‰€æœ‰æµ‹è¯•ç‚¹ã€‚\næˆ‘ä¸ç¦é™·å…¥äº†æ²‰æ€ï¼Œè«éâ€¦æŒ‰ç…§æˆ‘çš„æ€è·¯åšäº†ä¸ªæµ‹è¯•ï¼š\n\n\næœä¸å…¶ç„¶ï¼Œæ˜¯å› ä¸ºæµ®ç‚¹æ•°è¿ç®—çš„ç²¾åº¦è¯¯å·®å¯¼è‡´çš„ã€‚å¦å¤–æµ®ç‚¹æ•°è¿ç®—æ—¶éƒ½æ˜¯è½¬æˆdoubleå‚ä¸è¿ç®—çš„ï¼Œå› æ­¤doubleç»“æœä¹Ÿä¸€æ ·ã€‚çœ‹æ¥0.05è¿˜æ˜¯ä¸é è°±å•Šï¼Œå››èˆäº”å…¥å°±å¾—roundã€‚\n\n10.11 ç»­èšŒåŸ ä½äº†å®¶äººä»¬ï¼Œ\"%.nf\"ä¹Ÿæ˜¯å››èˆäº”å…¥ï¼Œè§ã€Œ1079ã€Total Sales of Supply Chainï¼Œè¡¥è¯¾å»äº†ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, ds, p1, p2, d;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; ds;\n    vector&lt;map&lt;int, int&gt;&gt; dist(n + m + 1);\n    string a, b;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;\n        p1 = a[0] == 'G' ? stoi(a.substr(1, a.size() - 1)) + n : stoi(a);\n        p2 = b[0] == 'G' ? stoi(b.substr(1, b.size() - 1)) + n : stoi(b);\n        dist[p1][p2] = dist[p2][p1] = d;\n    }\n    tuple&lt;int, int, float&gt; ans{0, 0, INT32_MAX};\n    for (int i = n + 1; i &lt; m + n + 1; ++i)\n    {\n        vector&lt;int&gt; min_dist(n + m + 1, INT32_MAX);\n        vector&lt;bool&gt; isVisited(n + m + 1, false);\n        isVisited[i] = true;\n        for (auto &amp;v: dist[i])\n            min_dist[v.first] = v.second;\n        int cnt = n, sum = 0;\n        while (cnt)\n        {\n            int min = INT32_MAX, idx = -1;\n            for (int j = 1; j &lt; n + m + 1; ++j)\n                if (!isVisited[j] &amp;&amp; min_dist[j] &lt; min)\n                {\n                    min = min_dist[j];\n                    idx = j;\n                }\n            if (min &gt; ds) break;\n            for (auto &amp;v: dist[idx])\n                if (!isVisited[v.first] &amp;&amp; v.second + min &lt; min_dist[v.first])\n                    min_dist[v.first] = v.second + min;\n            isVisited[idx] = true;\n            cnt -= (idx &lt;= n ? (sum += min, 1) : 0);\n        }\n        if (!cnt)\n        {\n            int dmin = *min_element(min_dist.begin() + 1, min_dist.begin() + n + 1);\n            float avg = 1.0 * sum / n;\n            if (dmin &gt; get&lt;1&gt;(ans) || dmin == get&lt;1&gt;(ans) &amp;&amp; avg &lt; get&lt;2&gt;(ans))\n                ans = {i - n, dmin, avg};\n        }\n    }\n    if (get&lt;0&gt;(ans))\n        printf(\"G%d\\n%.1f %.1f\", get&lt;0&gt;(ans), float(get&lt;1&gt;(ans)), round(get&lt;2&gt;(ans) * 10) / 10);\n    else\n        printf(\"No Solution\");\n}\n","slug":"ã€Œ1072ã€Gas-Station","date":"2022-10-05T10:12:26.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph,Dijkstra,min_element","author_index":"Starlit Rover"},{"id":"7e7e82299d0e2e6bf939755399447a21","title":"ã€Œ1071ã€Speech Patterns","content":"People often have a preference among synonyms of the same word. For example, some may prefer â€œthe policeâ€, while others may prefer â€œthe copsâ€. Analyzing such patterns can help to narrow down a speakerâ€™s identity, which is useful when validating, for example, whether itâ€™s still the same person behind an online avatar.\nNow given a paragraph of text sampled from someoneâ€™s speech, can you find the personâ€™s most commonly used word?\n\n\nInput Specification:Each input file contains one test case. For each case, there is one line of text no more than 1048576 characters in length, terminated by a carriage returnÂ \\n. The input contains at least one alphanumerical character, i.e., one character from the set [0-9 A-Z a-z].\nOutput Specification:For each test case, print in one line the most commonly occurring word in the input text, followed by a space and the number of times it has occurred in the input. If there are more than one such words, print the lexicographically smallest one. The word should be printed in all lower case. Here a â€œwordâ€ is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.\nNote that words are caseÂ insensitive.\nSample Input:Can1: \"Can a can can a can?  It can!\"\n\nSample Output:can 5\n\n\nÎ©ç»Ÿè®¡ä¸€å¥è¯ä¸­å‡ºç°é¢‘æ¬¡æœ€é«˜çš„wordï¼Œè¿™é‡ŒwordæŒ‡çš„æ˜¯ä¸€ä¸²åªæœ‰æ•°å­—å­—æ¯çš„è¿ç»­å­—ç¬¦ä¸²ã€‚\nmapç»Ÿè®¡æ¯ä¸ªwordçš„é¢‘æ¬¡ï¼Œisalnumå‡½æ•°åˆ¤æ–­æ˜¯å¦ä¸ºæ•°å­—å­—æ¯ï¼Œtolowerå‡½æ•°è´Ÿè´£è½¬æ¢å¤§å†™å­—æ¯ã€‚\nä¸‡äº‹ä¿±å¤‡ï¼Œåªæ¬ ä¸œé£ã€‚æˆ‘ä»¬æ¯æ¬¡å…ˆå°†non-alphanumericalçš„å­—ç¬¦è·³è¿‡ï¼Œç„¶åè¿ç»­é‡‡é›†alphanumericalå­—ç¬¦ï¼Œé¡ºä¾¿è½¬æ¢æˆå°å†™å­—æ¯ï¼Œtolowerå‡½æ•°åªå¯¹å¤§å†™å­—æ¯æœ‰æ•ˆæœï¼Œå…¶ä½™å­—ç¬¦è¿”å›æœ¬èº«ã€‚è®¡æ•°çš„åŒæ—¶æ¯”è¾ƒæ˜¯å¦æ˜¯å½“å‰é¢‘æ¬¡æœ€é«˜çš„å•è¯ï¼Œå¦‚æœä¸æœ€å¤§é¢‘æ¬¡ä¸€æ ·å†æ¯”è¾ƒå­—æ¯åºã€‚\næ€è·¯ç®€å•æ˜äº†ï¼Œä¸­é€”é‡åˆ°äº†ä¸€ä¸ªæœ‰æ„æ€çš„å°bugï¼Œåˆ†äº«ä¸€ä¸‹ï¼š\nfor (int i = -1; i &lt; s.size(); ++i)\n\nè¿™ä¸ªå¾ªç¯ä¸è®ºs.size()å¤šå¤§éƒ½ä¸ä¼šè¿›å…¥ï¼Œæˆ‘ä¸€å¼€å§‹ä¹Ÿå¾ˆç–‘æƒ‘ï¼Œè¿™è¯´æ˜i&lt;s.size()æ˜¯falseï¼Œåæ¥æƒ³èµ·size()çš„è¿”å›ç±»å‹æ˜¯æ— ç¬¦å·æ•´å‹size_tï¼Œæ¯”è¾ƒè¿ç®—å®è´¨æ˜¯åšå‡æ³•ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨åœ¨åšä¸€ä¸ªæ— ç¬¦å·æ•°å‡ä¸€ä¸ªæœ‰ç¬¦å·æ•°æ—¶éƒ½ä¼šå…ˆå°†æœ‰ç¬¦å·æ•°è½¬ä¸ºæ— ç¬¦å·æ•°ï¼Œé‚£ä¹ˆè¿™é‡Œ-1å°±ä¼šç›´æ¥å˜æˆæœ€å¤§çš„æ— ç¬¦å·æ•°ï¼Œå› æ­¤è¿”å›falseä¸ä¼šè¿›å…¥å¾ªç¯ã€‚\nä¸å¾—ä¸è¯´ï¼Œç»†èŠ‚å†³å®šæˆè´¥ã€‚å’Œç»å¯¹ç†æ€§çš„æœºå™¨æ‰“äº¤é“å°±å¿…é¡»æ³¨æ„è¿™äº›ä¸èµ·çœ¼çš„å°ç‚¹ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, int&gt; cnt;\n    string s, word, ans;\n    int max = -1;\n    getline(cin, s);\n    for (int i = 0; i &lt; s.size(); ++i)\n    {\n        while (i &lt; s.size() &amp;&amp; !isalnum(s[i++]));\n        i -= 1;\n        for (; i &lt; s.size() &amp;&amp; isalnum(s[i]); ++i)\n            word += tolower(s[i]);\n        if (++cnt[word] &gt; max)\n        {\n            max = cnt[word];\n            ans = word;\n        }\n        else if (cnt[word] == max &amp;&amp; word &lt; ans)\n            ans = word;\n        word.clear();\n    }\n    cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; max;\n}\n","slug":"ã€Œ1071ã€Speech-Patterns","date":"2022-09-29T06:36:48.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map","author_index":"Starlit Rover"},{"id":"7776532a38433935aad29c44c794b489","title":"ã€Œ1070ã€Mooncake","content":"Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the regionâ€™s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made.\nNote: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans).\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integersÂ NÂ (â‰¤1000), the number of different kinds of mooncakes, andÂ DÂ (â‰¤500Â thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) ofÂ NÂ kinds of mooncakes. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places.\nSample Input:3 200\n180 150 100\n7.5 7.2 4.5\n\nSample Output:9.45\n\n\nÎ©å¦‚ä½•å–æœˆé¥¼èƒ½è·åˆ©æœ€å¤§ï¼Œæœˆé¥¼å¯ä»¥æ‹†åˆ†ï¼Œç®€åŒ–ç‰ˆèƒŒåŒ…é—®é¢˜ã€‚\nç”±äºå¸‚åœºéœ€æ±‚æ˜¯å›ºå®šçš„ï¼Œå› æ­¤å…ˆè®¡ç®—å•ä»·ï¼Œç„¶åå°†æœˆé¥¼æŒ‰å•ä»·æ’åºï¼Œä¾æ¬¡å–å‡ºï¼Œç›´åˆ°å–å‡ºæ€»é‡è¾¾åˆ°å¸‚åœºéœ€æ±‚ä¸ºæ­¢ã€‚\nåªæ˜¯æ²¡æƒ³åˆ°æ°´é¢˜é‡Œé¢è¿˜æš—è—æ°´é›·ï¼Œæµ‹è¯•ç‚¹2ä¸€ç›´è¿‡ä¸å»å®åœ¨ä»¤äººç‹‚èºæŠ“å¤´ã€‚åŸæ¥ã€‚ã€‚æœˆé¥¼åº“å­˜è¯´çš„æ˜¯positive inventory amountsï¼Œæ²¡è¯´è¿‡æ•´æ•°å“¦ï¼Œæ ·ä¾‹ä¸­çš„æ•´æ•°åªæ˜¯ç‰¹æ®Šæƒ…å†µè€Œå·²å•¦ï¼Œä½ è‡ªå·±è¦è¯´æ˜¯æ•´æ•°æˆ‘ä¹Ÿæ²¡æœ‰åŠæ³•è¯¶ã€‚\nPTAçš„misdirectionä¸€ç›´æ˜¯æœ‰ä¸€æ‰‹çš„ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;double, double, double&gt; tddd;\n\nint main()\n{\n    int n;\n    double d, p = 0;\n    cin &gt;&gt; n &gt;&gt; d;\n    vector&lt;tddd&gt; info(n);\n    for (auto &amp;k: info)\n        cin &gt;&gt; get&lt;0&gt;(k);\n    for (auto &amp;k: info)\n    {\n        cin &gt;&gt; get&lt;1&gt;(k);\n        get&lt;2&gt;(k) = get&lt;1&gt;(k) / get&lt;0&gt;(k);\n    }\n    sort(info.begin(), info.end(), [](tddd &amp;a, tddd &amp;b) { return get&lt;2&gt;(a) &gt; get&lt;2&gt;(b); });\n    for (int i = 0; i &lt; n &amp;&amp; d &gt; 0; ++i)\n    {\n        p += (d &lt; get&lt;0&gt;(info[i]) ? d * get&lt;2&gt;(info[i]) : get&lt;1&gt;(info[i]));\n        d -= get&lt;0&gt;(info[i]);\n    }\n    printf(\"%.2f\", p);\n}\n","slug":"ã€Œ1070ã€Mooncake","date":"2022-09-29T05:43:39.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,tuple","author_index":"Starlit Rover"},{"id":"4639b5ea2946dd4eb301e11b5cb60396","title":"ã€Œ1068ã€Find More Coins","content":"Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she must pay the exact amount. Since she has as many asÂ Â coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find some coins to pay for it.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers:Â NÂ (, the total number of coins) andÂ MÂ (, the amount of money Eva has to pay). The second line containsÂ NÂ face values of the coins, which are all positive numbers. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the face valuesÂ Â such thatÂ M. All the numbers must be separated by a space, and there must be no extra space at the end of the line. If such a solution is not unique, output the smallest sequence. If there is no solution, output â€œNo Solutionâ€ instead.\nNote: sequence  is said to be â€œsmallerâ€ than sequence  if there existsÂ Â such that  for allÂ , and .\nSample Input 1:8 9\n5 9 8 7 2 3 4 1\n\nSample Output 1:1 3 5\n\nSample Input 2:4 8\n7 2 4 3\n\nSample Output 2:No Solution\n\n\nÎ©åœ¨ç»™å®šæ•°ç»„ä¸­æ‰¾åˆ°ä¸€ä¸²æ•°ä¹‹å’Œç­‰äºç»™å®šå€¼Aï¼Œå¦‚æœæœ‰å¤šä¸ªè§£åˆ™å–æœ€å°åºåˆ—ã€‚\næ²¡ä»€ä¹ˆå¥½çš„æƒ³æ³•ï¼Œå…ˆæ’åºåæšä¸¾ã€‚ä»æœ€å°çš„æ•°å¼€å§‹ï¼Œå¾€åä¾æ¬¡ç´¯åŠ æ‰¾åˆ°å°±returnã€‚è™½ç„¶è¯´æ˜¯æšä¸¾ï¼Œä½†ä¸ºäº†ä¸è¶…æ—¶è¿˜æ˜¯éœ€è¦æœ‰é¿å…æ— æ„ä¹‰æšä¸¾çš„å‰éªŒå·¥ä½œå’Œåœæ­¢çš„æ¡ä»¶ã€‚\né¦–å…ˆå¦‚æœæ‰€æœ‰æ•°æ€»å’Œéƒ½æ²¡æœ‰åˆ°Aï¼Œé‚£ä¹ˆç›´æ¥â€œNo Solutionâ€ï¼›å¦‚æœåˆšå¥½==Aï¼Œé‚£ä¹ˆç›´æ¥æŠŠæ’åºå®Œæ•°ç»„æ‰“å°ä¸€éã€‚åœ¨æšä¸¾è¿‡ç¨‹ä¸­å¦‚æœå½“å‰å•ä¸ªæ•°å€¼&gt;remainï¼Œè¯´æ˜æ— è§£åŠæ—¶åœæ­¢ã€‚\nçœ‹äº†ä¸€äº›é¢˜è§£ï¼ŒåŸºæœ¬æ˜¯ç”¨01èƒŒåŒ…çš„æ€æƒ³æ¥æ±‚çš„ã€‚æŠŠæ‰€æœ‰æ•°éƒ½çœ‹æˆæ˜¯é‡é‡ä¸ä»·å€¼éƒ½ä¸€è‡´çš„ç‰©å“ï¼Œç„¶åèƒŒåŒ…é™åˆ¶å°±æ˜¯Aï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦ç”¨01èƒŒåŒ…çš„æ€è·¯æ¥æ±‚è§£æœ€å¤§ä»·å€¼å³å¯ï¼Œå¦‚æœæœ€å¤§ä»·å€¼&lt;Aè¯´æ˜æ— è§£ï¼Œ==Aåˆ™æœ‰è§£ã€‚01èƒŒåŒ…æ˜¯ä¸€ç§åŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œå³è‡ªåº•å‘ä¸Šï¼Œä¹Ÿä¸å¤±ä¸ºä¸€å‰‚è‰¯ç­–ã€‚æœ€è¿‘è¢«å­¦æ ¡æ“ä½œç³»ç»Ÿå®éªŒæ•´çš„å¤´ç–¼ï¼Œå°±ä¸å®ç°äº†ï¼ˆé€ƒ\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; coin, solution;\n\nbool dfs(int pos, int m)\n{\n    if (!m) return true;\n    for (int i = pos; i &lt; coin.size(); ++i)\n    {\n        if (m - coin[i] &lt; 0) break;\n        solution.push_back(coin[i]);\n        if (dfs(i + 1, m - coin[i])) return true;\n        else solution.pop_back();\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    int n, m,sum=0;\n    cin &gt;&gt; n &gt;&gt; m;\n    coin.resize(n);\n    for (auto &amp;k: coin) cin &gt;&gt; k, sum+=k;\n    sort(coin.begin(), coin.end());\n    if (sum &lt; m)\n        cout &lt;&lt; \"No Solution\" &lt;&lt; endl;\n    else if (sum == m)\n        for (int i = 0; i &lt; coin.size(); ++i)\n            cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; coin[i];\n    else if (dfs(0, m))\n        for (int i = 0; i &lt; solution.size(); ++i)\n            printf(\"%d%c\", solution[i], i == solution.size() - 1 ? '\\n' : ' ');\n    else printf(\"No Solution\\n\");\n\n}\n","slug":"ã€Œ1068ã€Find-More-Coins","date":"2022-09-28T13:00:31.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"f66bf5b8d2fc86417cb09b027c83ec14","title":"ã€Œ1067ã€Sort with Swap(0, i)","content":"Given any permutation of the numbers {0, 1, 2,â€¦,Â Nâˆ’1}, it is easy to sort them in increasing order. But what ifÂ Swap(0, *)Â is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:\nSwap(0, 1) =&gt; {4, 1, 2, 0, 3}\nSwap(0, 3) =&gt; {4, 1, 2, 3, 0}\nSwap(0, 4) =&gt; {0, 1, 2, 3, 4}\n\nNow you are asked to find the minimum number of swaps need to sort the given permutation of the firstÂ NÂ nonnegative integers.\n\n\nInput Specification:Each input file contains one test case, which gives a positiveÂ  followed by a permutation sequence of {0, 1, â€¦,Â Nâˆ’1}. All the numbers in a line are separated by a space.\nOutput Specification:For each case, simply print in a line the minimum number of swaps need to sort the given permutation.\nSample Input:10\n3 5 7 2 6 4 9 0 8 1\n\nSample Output:9\n\n\nÎ©ç»™å‡º{0,1,â€¦,N-1}çš„ä¸€ä¸ªæ’åˆ—ï¼Œåªèƒ½äº¤æ¢0å’Œå…¶ä»–æ•°å­—çš„ä½ç½®ï¼Œè¯•é—®æœ€å°‘éœ€è¦å‡ æ¬¡äº¤æ¢æ‰èƒ½ä½¿å…¶å‡åºæ’åˆ—ã€‚\näº‹å®ä¸Šè¿™è·Ÿæ’åºæ¯«æ— å…³ç³»ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ¯ä¸ªæ•°éƒ½æœ‰ä¸€ä¸ªè‡ªå·±çš„åº§ä½ï¼Œæœ€åéœ€è¦è®©æ¯ä¸ªæ•°éƒ½åœ¨è‡ªå·±çš„ä½ç½®ä¸Šï¼Œè¿™é“é¢˜ä¸ºäº†æ–¹ä¾¿èµ·è§å°±è§„å®šæ¯ä¸ªæ•°çš„ä½ç½®åºå·ä¸è‡ªå·±ç›¸ç­‰ã€‚\nä¹çœ‹åƒæ˜¯æ’åˆ—ç»„åˆé—®é¢˜ï¼Œä¸€ä¸ªå¾ˆè´ªå¿ƒçš„æ€è·¯å°±æ˜¯æ¯æ¬¡0éƒ½å’Œæœ¬åº”è¯¥åœ¨å®ƒä½ç½®ä¸Šçš„æ•°äº¤æ¢ï¼Œè¿™æ ·èƒ½ä¿è¯æ¯æ¬¡äº¤æ¢éƒ½èƒ½è®©ä¸€ä¸ªæ•°å½’ä½ã€‚ä½†è¯•ç€æ‰‹æ’å‡ æ¬¡ä¼šå‘ç°æœ‰æ—¶å€™æ’ç€æ’ç€0è‡ªå·±å°±ä¼šå½’ä½ï¼Œç„¶è€Œåé¢çš„æ•°ç»„è¿˜å¹¶ä¸æ˜¯æœ‰åºçš„ï¼Œæ­¤æ—¶å°±éœ€è¦è®©0å’Œå…¶ä¸­ä¸€ä¸ªè¿˜ä¸åœ¨è‡ªå·±ä½ç½®ä¸Šçš„æ•°è¿›è¡Œäº¤æ¢ï¼Œä½†è¿™æ ·çš„äº¤æ¢ä¸ä¼šè®©ä»»ä½•æ•°å½’ä½ï¼Œå³æ•ˆç›Šä¸º0ã€‚\næˆ‘ä»¬çŸ¥é“ä¸€æ¬¡äº¤æ¢æœ€å¤šè®©ä¸¤ä¸ªæ•°å½’ä½ï¼Œä½†ç”±äºå…¶ä¸­ä¸€ä¸ªæ˜¯å¸¸é©»å˜‰å®¾0ï¼Œæˆ‘ä»¬å¯ä»¥æš‚ä¸”ä¸è€ƒè™‘ï¼Œå› ä¸ºå…¶ä½™æ•°å½’ä½å0ä¹Ÿå¿…ç„¶å½’ä½ã€‚è¿™æ„å‘³ç€äº¤æ¢ä¸€æ¬¡è®©ä¸€ä¸ªæ•°å½’ä½å°±æ˜¯æœ€å¤§æ•ˆç›Šã€‚é‚£ä¹ˆæˆ‘ä»¬èƒ½å¦é¿å…æ— æ•ˆäº¤æ¢çš„äº§ç”Ÿå‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä¸è¡Œï¼Œä½ ä¼šå‘ç°æ¯ä¸ªä½ç½®äº‹å®ä¸Šéƒ½æ—©å·²å†³å®šä¸‹æ¬¡äº¤æ¢çš„ä½ç½®ã€‚\nå¦‚æœæˆ‘ä»¬æ¥è¡¨ç¤ºæ•°çš„ä½ç½®åºå·ï¼ŒèŠ‚ç‚¹ç¼–å·ï¼Œå®šä¹‰æœ‰å‘è¾¹ã€‚è¿™å¼ å›¾å°±æ˜¯0çš„è·¯çº¿å›¾ï¼Œç„¶è€Œå›¾å¹¶ä¸ä¸€å®šæ˜¯è¿é€šçš„ï¼Œå¯¹äºé‚£äº›0ä¸åœ¨å†…éƒ¨çš„è¿é€šåˆ†å›¾ï¼Œå°±éœ€è¦0è¿›è¡Œä¸€æ¬¡æ— æ•ˆäº¤æ¢è¿›å…¥ï¼Œè¿˜éœ€è¦ä¸€æ¬¡äº¤æ¢æŠŠè¸¢å‡ºå»çš„å…ƒç´ æ¢å›æ¥ã€‚è¿™æ ·ä¸€æ¥å°±ä¼šæ¯”0æ‰€åœ¨çš„è¿é€šåˆ†å›¾å¤š2æ¬¡äº¤æ¢ã€‚\nå¯¹äºåŸæœ¬å°±åœ¨æ­£ç¡®ä½ç½®ä¸Šçš„æ•°ä¸€å¼€å§‹å°±æ ‡è®°æ’é™¤ï¼Œç„¶åæ±‚è¿é€šåˆ†å›¾æ•°å°±å®Œäº‹äº†ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, cnt = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; ptm(n), flag(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; ptm[i];\n        flag[i] = (ptm[i] == i);\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (flag[i]) continue;\n        int j = i;\n        cnt += (i == 0 ? -1 : 1);\n        while (!flag[j])\n        {\n            flag[j] = true;\n            j = ptm[j];\n            ++cnt;\n        }\n    }\n    cout &lt;&lt; cnt;\n}\n","slug":"ã€Œ1067ã€Sort-with-Swap-0-i","date":"2022-09-25T09:25:33.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Graph","author_index":"Starlit Rover"},{"id":"1b4d009413a4a1733c93e882f288fd9a","title":"Lab2: system calls","content":"ä¸Šå‘¨æ‰“äº†ä¸€åœºæ•°æ¨¡å›½èµ›ï¼Œæ‰“å‰å…ƒæ°”è¶…äººï¼Œæ‰“å®Œè‘›ä¼˜èººå¹³ã€‚Lab2åªæœ‰ä¸¤ä¸ªå°å®éªŒï¼Œèšç„¦äºå¦‚ä½•åˆ›å»ºç³»ç»Ÿè°ƒç”¨å‘½ä»¤ï¼Œä¹Ÿå¹¶ä¸æ˜¯é‚£ä¹ˆç®€å•ï¼Œå®éªŒæ–‡æ¡£æˆ³è¿™ã€‚\n\n\n\n\n\n\nâ– Coding\nâ˜‘ï¸ System call tracingÂ (moderate)æˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªtraceç³»ç»Ÿè°ƒç”¨æ¥è¿½è¸ªä¸€ä¸ªå‘½ä»¤ä¸­æŒ‡å®šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶æ‰“å°å‡ºç›¸åº”çš„è¿”å›å€¼ã€‚\n$ trace 2147483647 grep hello README\n4: syscall trace -&gt; 0\n4: syscall exec -&gt; 3\n4: syscall open -&gt; 3\n4: syscall read -&gt; 1023\n4: syscall read -&gt; 966\n4: syscall read -&gt; 70\n4: syscall read -&gt; 0\n4: syscall close -&gt; 0\n\næŒ‡ä»¤æ ¼å¼ï¼štrace mask cmdã€‚maskç”¨æ¥æŒ‡å®šéœ€è¦è¿½è¸ªçš„ç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨æ“ä½œç³»ç»Ÿä¸­æ¯ä¸ªç³»ç»Ÿè°ƒç”¨éƒ½ä¼šæœ‰è‡ªå·±å”¯ä¸€çš„ç¼–å·SYS_syscallï¼ˆåœ¨kernel/syscall.hä¸­çš„å®å®šä¹‰ï¼‰ï¼Œæ¯”å¦‚è¯´forkçš„ç¼–å·å°±æ˜¯SYS_forkï¼Œå¦‚æœmask&amp;(1&lt;&lt;SYS_syscall)!=0å°±è¯´æ˜éœ€è¦è¿½è¸ªè¯¥syscallï¼Œéœ€è¦æ‰“å°å‡ºå…¶è¿”å›å€¼ï¼Œæœ¬è´¨ä¸Šå¦‚æœå‡è®¾ä»£è¡¨å…¶äºŒè¿›åˆ¶ä½ä½æ•°å­—çš„è¯ï¼Œé‚£ä¹ˆå°±ä»£è¡¨éœ€è¦è¿½è¸ªSYS_syscall=çš„ç³»ç»Ÿè°ƒç”¨ã€‚\né‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦åœ¨è¿›ç¨‹ç»“æ„ä½“procä¸­åŠ å…¥int maskï¼Œæ³¨æ„åˆ°ä¸€ä¸ªè¿›ç¨‹ä¸­æ‰§è¡Œä¸åŒç³»ç»Ÿè°ƒç”¨æ˜¯é€šè¿‡forkæ¥å®ç°çš„ï¼Œæœ¬è´¨ä¸Šåˆåˆ›å»ºäº†ä¸€ä¸ªprocå®ä½“ï¼Œå› æ­¤åœ¨forkçš„å®ç°ï¼ˆkernel/proc.cï¼‰ä¸­æˆ‘ä»¬éœ€è¦å®ç°maskçš„ä¼ é€’ï¼š\n    np-&gt;mask = p-&gt;mask;\n\né‚£ä¹ˆæ¥ä¸‹æ¥å°±å¯ä»¥æ‰“å°ä¿¡æ¯pid: syscall name -&gt; return_valueã€‚æˆ‘ä»¬å¯ä»¥åœ¨æ¯ä¸ªç³»ç»Ÿè°ƒç”¨éƒ½å¿…ç»çš„å‡½æ•°syscallï¼ˆkernel/syscall.cï¼‰é‡Œé¢å®ç°ï¼Œé¦–å…ˆè§‚å¯Ÿsyscallå‡½æ•°ï¼š\nvoid syscall(void)\n{\n  int num;\n  struct proc *p = myproc();\n\n  num = p-&gt;trapframe-&gt;a7;\n  if (num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])\n  {\n    p-&gt;trapframe-&gt;a0 = syscalls[num]();\n  }\n  else\n  {\n    printf(\"%d %s: unknown sys call %d\\n\",p-&gt;pid, p-&gt;name, num);\n    p-&gt;trapframe-&gt;a0 = -1;\n  }\n}\n\nå¯ä»¥çœ‹å‡ºpé‡Œé¢å­˜å‚¨äº†æˆ‘ä»¬éœ€è¦çš„pidï¼Œä½†p-&gt;nameå¹¶ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ç³»ç»Ÿè°ƒç”¨åç§°ï¼Œæ³¨æ„åˆ°forkå®ç°ä¸­ï¼ˆkernel/proc.cï¼š304ï¼‰æ˜¯ç›´æ¥æ‹·è´åŸprocçš„nameï¼Œå³nameé‡Œå­˜å‚¨çš„å…¶å®æ˜¯è¿›ç¨‹åï¼š\nsafestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name)ï¼‰;\n\nè¿™é‡Œéœ€è¦æ³¨æ„è¿›ç¨‹ä¸çº¿ç¨‹ä¹‹é—´çš„å·®åˆ«ã€‚è™½ç„¶forkå®Œåä¹Ÿæ˜¯ä¸€ä¸ªprocç»“æ„ä½“ï¼Œä½†äº‹å®ä¸Šåªæ˜¯p-&gt;nameè¿›ç¨‹ä¸‹çš„ä¸€ä¸ªçº¿ç¨‹è€Œå·²ã€‚è¿›ç¨‹æ˜¯å¯¹è¿è¡Œç¨‹åºçš„å°è£…ï¼Œæ˜¯ç³»ç»Ÿè¿›è¡Œèµ„æºè°ƒåº¦å’Œåˆ†é…çš„åŸºæœ¬å•ä½ï¼Œå„è¿›ç¨‹ä¹‹é—´ç›¸äº’éš”ç¦»ä¸å…±äº«æ•°æ®ï¼Œå®ç°äº†æ“ä½œç³»ç»Ÿçš„å¹¶å‘æ€§ï¼›è€Œçº¿ç¨‹åˆ™æ˜¯ä¸€ä¸ªè¿›ç¨‹ä¸­çš„å­ä»»åŠ¡ï¼Œæ˜¯CPUè°ƒåº¦çš„æœ€å°å•ä½ï¼Œä¸€ä¸ªè¿›ç¨‹ä¸­çš„æ‰€æœ‰çº¿ç¨‹å…±äº«è¯¥è¿›ç¨‹çš„æ•°æ®èµ„æºã€‚é‚£ä¹ˆæ¯ä¸ªå‘½ä»¤å°±æ˜¯ä¸€ä¸ªè¿›ç¨‹ï¼Œé‡Œé¢ä¼šæ‰§è¡Œå¤šä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œæ¯ä¸ªç³»ç»Ÿè°ƒç”¨éƒ½æ˜¯ä¸€ä¸ªçº¿ç¨‹ã€‚\nè™½ç„¶pé‡Œé¢æ²¡æœ‰çº¿ç¨‹åç§°çš„ç›´æ¥ä¿¡æ¯ï¼Œä½†è‚¯å®šæœ‰å…¶ä»–ç›¸å…³ä¿¡æ¯ã€‚æ³¨æ„åˆ°\np-&gt;trapframe-&gt;a0 = syscalls[num]();\n\nè¿™é‡Œè°ƒç”¨äº†syscalls[num]ï¼Œç„¶åå°†è¿”å›å€¼ä¼ é€’ç»™äº†a0å¯„å­˜å™¨ï¼ˆRISC-Vçš„Cè§„èŒƒæ˜¯æŠŠè¿”å›å€¼æ”¾åœ¨a0ä¸­ï¼‰ã€‚syscallsæ˜¯ä¸€ä¸ªæ— ç¬¦å·æ•´å‹æŒ‡é’ˆæ•°ç»„ï¼Œå³å‡½æ•°æŒ‡é’ˆã€‚é‚£ä¹ˆå¯ä»¥è‚¯å®šè¿™ä¸ªnumå°†æ˜¯ä¸€ä¸ªé‡è¦çš„çªç ´å£ï¼Œæˆ‘ä»¬åªè¦æŒ‰ç…§syscallsä¸­ç³»ç»Ÿè°ƒç”¨çš„é¡ºåºå®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„sysnameï¼Œsysname[num]å°±æ˜¯ç³»ç»Ÿè°ƒç”¨çš„åç§°äº†ã€‚åŒæ—¶p-&gt;trapframe-&gt;a0å°±æ˜¯å‡½æ•°è¿”å›å€¼ã€‚\n107 + â”‚ extern uint64 sys_trace(void);\n\n132 + â”‚ [SYS_trace]   sys_trace, //static uint64 (*syscalls[])(void)\n\n136 + â”‚ char *sysname[] = {\n137 + â”‚ [SYS_fork]    \"fork\",\n138 + â”‚ [SYS_exit]    \"exit\",\n139 + â”‚ [SYS_wait]    \"wait\",\n140 + â”‚ [SYS_pipe]    \"pipe\",\n141 + â”‚ [SYS_read]    \"read\",\n142 + â”‚ [SYS_kill]    \"kill\",\n143 + â”‚ [SYS_exec]    \"exec\",\n144 + â”‚ [SYS_fstat]   \"stat\",\n145 + â”‚ [SYS_chdir]   \"chdir\",\n146 + â”‚ [SYS_dup]     \"dup\",\n147 + â”‚ [SYS_getpid]  \"getpid\",\n148 + â”‚ [SYS_sbrk]    \"sbrk\",\n149 + â”‚ [SYS_sleep]   \"sleep\",\n150 + â”‚ [SYS_uptime]  \"uptime\",\n151 + â”‚ [SYS_open]    \"open\",\n152 + â”‚ [SYS_write]   \"write\",\n153 + â”‚ [SYS_mknod]   \"mknod\",\n154 + â”‚ [SYS_unlink]  \"unlink\",\n155 + â”‚ [SYS_link]    \"link\",\n156 + â”‚ [SYS_mkdir]   \"mkdir\",\n157 + â”‚ [SYS_close]   \"close\",\n158 + â”‚ [SYS_trace]   \"trace\",\n159   â”‚ };\n160   â”‚ \n161   â”‚ void\n162   â”‚ syscall(void)\n163   â”‚ {\n164   â”‚   int num;\n165   â”‚   struct proc *p = myproc();\n166   â”‚ \n167   â”‚   num = p-&gt;trapframe-&gt;a7;\n168   â”‚   if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {\n169   â”‚     p-&gt;trapframe-&gt;a0 = syscalls[num]();\n170 + â”‚     if(1&lt;&lt;num &amp; p-&gt;mask)\n171 + â”‚         printf(\"%d: syscall %s -&gt; %d\\n\",p-&gt;pid,sysname[num],p-&gt;trapframe-&gt;a0);\n172   â”‚   } else {\n173   â”‚     printf(\"%d %s: unknown sys call %d\\n\",\n174   â”‚             p-&gt;pid, p-&gt;name, num);\n175   â”‚     p-&gt;trapframe-&gt;a0 = -1;\n176   â”‚   }\n177   â”‚ }\n\noå¯¹ï¼Œæˆ‘ä»¬ç”šè‡³è¿˜æ²¡å®ç°traceå‡½æ•°ğŸ’¦ã€‚ä½ å¯èƒ½ä¼šè§‰å¾—ä¸Šé¢çš„åšæ³•å·²ç»é—´æ¥å®ç°äº†traceï¼Œä½†äº‹å®ä¸Štraceæ˜¯åœ¨ç”¨æˆ·æ¨¡å¼ï¼ˆuser modeï¼‰è°ƒç”¨çš„ï¼Œå› æ­¤ä¼ å…¥çš„å‚æ•°è¿˜åœ¨ç”¨æˆ·ç©ºé—´ï¼Œè€Œç³»ç»Ÿè°ƒç”¨éƒ½æ˜¯åœ¨å†…æ ¸ç©ºé—´å†…æ‰§è¡Œçš„ï¼Œä¸ºäº†æ“ä½œç³»ç»Ÿä¸å—è¿›ç¨‹å½±å“ä¸¤è€…æ˜¯åˆ†éš”çš„ã€‚\n\n\nç”¨æˆ·æ€çš„traceå‡½æ•°å·²ç»å¸®æˆ‘ä»¬å®ç°ï¼š\n#include \"kernel/param.h\"\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n  char *nargv[MAXARG];\n\n  if(argc &lt; 3 || (argv[1][0] &lt; '0' || argv[1][0] &gt; '9')){\n    fprintf(2, \"Usage: %s mask command\\n\", argv[0]);\n    exit(1);\n  }\n\n  if (trace(atoi(argv[1])) &lt; 0) {\n    fprintf(2, \"%s: trace failed\\n\", argv[0]);\n    exit(1);\n  }\n\n  for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++){\n    nargv[i-2] = argv[i];\n  }\n  exec(nargv[0], nargv);\n  exit(0);\n}\n\nä¸éš¾çœ‹å‡ºå…³é”®å‡½æ•°æ˜¯int trace(int)ï¼Œé‚£æˆ‘ä»¬éœ€è¦å…ˆåœ¨user/user.hä¸­å£°æ˜è¯¥ç³»ç»Ÿè°ƒç”¨ï¼ŒåŒæ—¶åœ¨user/usys.plï¼ˆç”Ÿæˆæ±‡ç¼–æ–‡ä»¶user/usys.Sï¼‰ä¸­åŠ å…¥entry(\"trace\")ä½¿traceå‡½æ•°å¯ä»¥è¿›å…¥å†…æ ¸æ¨¡å¼ï¼Œå¹¶åœ¨kernel/syscall.hä¸­æ·»åŠ ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å·ï¼Œæ•´ä¸ªç³»ç»Ÿè°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š\n\nuser/user.hï¼šç”¨æˆ·æ€ç¨‹åºè°ƒç”¨è·³æ¿å‡½æ•° trace()\n\nuser/usys.Sï¼šè·³æ¿å‡½æ•° trace ä½¿ç”¨ CPU æä¾›çš„ ecall æŒ‡ä»¤ï¼Œè¿›å…¥å†…æ ¸æ¨¡å¼\n\nkernel/syscall.cï¼šåˆ°è¾¾å†…æ ¸æ¨¡å¼ç»Ÿä¸€æ‰§è¡Œç³»ç»Ÿè°ƒç”¨å¤„ç†å‡½æ•°syscallï¼Œæ‰€æœ‰ç³»ç»Ÿè°ƒç”¨éƒ½ä¼šè·³åˆ°è¿™é‡Œæ¥å¤„ç†\n\nkernel/syscall.cï¼šsyscallæ ¹æ®è·³æ¿ä¼ è¿›æ¥çš„ç³»ç»Ÿè°ƒç”¨ç¼–å·ï¼ŒæŸ¥è¯¢ syscalls[] è¡¨ï¼Œæ‰¾åˆ°å¯¹åº”çš„å†…æ ¸å‡½æ•°å¹¶è°ƒç”¨\n\nkernel/sysproc.cï¼šåˆ°è¾¾ sys_trace å‡½æ•°ï¼Œæ‰§è¡Œå…·ä½“å†…æ ¸æ“ä½œ\n\n\næ¥ä¸‹æ¥åªéœ€åœ¨kernel/sysproc.cä¸­å®ç°sys_traceï¼Œè¯¥å‡½æ•°åªè¦æŠŠç”¨æˆ·ç©ºé—´çš„maskæ‹¿è¿›æ¥å°±è¡Œï¼Œcmdåœ¨æ‰§è¡Œæ—¶äº‹å®ä¸Šå¯ä»¥è®¤ä¸ºæ˜¯traceçš„å¤šä¸ªå­çº¿ç¨‹ï¼Œå› æ­¤maskä¼šä¸€ç›´ä¼ é€’ä¸‹å»ã€‚\nuint64\nsys_trace(void)\n{\n   int mask;\n   if(argint(0, &amp;mask) &lt; 0)\n       return -1;\n   myproc()-&gt;mask=mask;\n   return 0;\n}\n\n\n\nâ˜‘ï¸ Sysinfo (moderate)å®ç°ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨sysinfoï¼Œå®ƒæ¥å—ä¸€ä¸ªæŒ‡å‘struct sysinfoçš„æŒ‡é’ˆï¼Œç„¶åå‘è¿™ä¸ªç»“æ„ä½“å†™å…¥å‰©ä½™ç©ºé—´çš„å­—èŠ‚æ•°å’ŒçŠ¶æ€éâ€UNUSEDâ€çš„è¿›ç¨‹æ•°ã€‚\nâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n       â”‚ File: kernel/sysinfo.h\nâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n   1   â”‚ struct sysinfo {\n   2   â”‚   uint64 freemem;   // amount of free memory (bytes)\n   3   â”‚   uint64 nproc;     // number of process\n   4   â”‚ };\nâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\né¦–å…ˆæˆ‘ä»¬éœ€è¦å®ç°ç»Ÿè®¡å‰©ä½™ç©ºé—´å­—èŠ‚æ•°å’Œå·²ä½¿ç”¨è¿›ç¨‹æ•°çš„å‡½æ•°ã€‚å…³äºç©ºé—´åˆ†é…çš„å®ç°åœ¨kernel/kalloc.cï¼Œæ³¨æ„åˆ°kmemä¸­æœ‰ä¸€é¡¹freelisté“¾è¡¨ï¼Œç„¶åçœ‹kfreeå‡½æ•°\n46   â”‚ void\n47   â”‚ kfree(void *pa)\n48   â”‚ {\n49   â”‚   struct run *r;\n50   â”‚ \n51   â”‚   if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)\n52   â”‚     panic(\"kfree\");\n53   â”‚ \n54   â”‚   // Fill with junk to catch dangling refs.\n55   â”‚   memset(pa, 1, PGSIZE);\n56   â”‚ \n57   â”‚   r = (struct run*)pa;\n58   â”‚ \n59   â”‚   acquire(&amp;kmem.lock);\n60   â”‚   r-&gt;next = kmem.freelist;\n61   â”‚   kmem.freelist = r;\n62   â”‚   release(&amp;kmem.lock);\n63   â”‚ }\n\nkfreeå‡½æ•°å°†paåœ°å€å¼€å§‹PGSIZEå¤§å°çš„ç©ºé—´éƒ½åˆå§‹åŒ–ä¸º1ï¼Œç„¶åå°†paæŒ‚åˆ°freelistçš„å¤´ä¸Šï¼Œå†å°†freelistæŒ‡å‘paï¼Œè€Œkallocå‡½æ•°åˆ™æ˜¯æ¯æ¬¡éƒ½ä½¿ç”¨freelistçš„ç¬¬ä¸€å—PGSIZEç©ºé—´ã€‚è¯´æ˜freelistæ˜¯å¯ç”¨ç©ºé—´çš„é“¾è¡¨ï¼Œè€Œä¸”æ¯æ¬¡åˆ†é…çš„æœ€å°å•å…ƒæ˜¯PGSIZEå­—èŠ‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦æ•°ä¸€ä¸‹freelistçš„å…ƒç´ ä¸ªæ•°ç„¶åä¹˜ä¸ªPGSIZEå³å¯ã€‚\nuint64\ncount_freemem(void)\n{\n  acquire(&amp;kmem.lock);\n  struct run *r = kmem.freelist;\n  uint64 cnt = 0;\n  while (r)\n  {\n    ++cnt;\n    r = r-&gt;next;\n  }\n  release(&amp;kmem.lock);\n  return cnt * PGSIZE;\n}\n\nä¸ºé˜²æ­¢ç«æ€æ¡ä»¶äº§ç”Ÿï¼Œåœ¨ç»Ÿè®¡æ—¶éœ€è¦å…ˆç»™kmemä¸Šé”ã€‚\n\n\nå¯¹äºç»Ÿè®¡çŠ¶æ€ä¸ºéâ€UNUSEDâ€çš„è¿›ç¨‹æ•°ä¹Ÿä¸éš¾ï¼Œæ³¨æ„åˆ°kernel/proc.cä¸­\n11   â”‚ struct proc proc[NPROC];\n\nå¯çŸ¥æœ€å¤§è¿›ç¨‹æ•°å³ä¸ºNPROCï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦éå†procï¼Œç„¶åä¾æ¬¡æ£€æŸ¥çŠ¶æ€å³å¯ã€‚\nuint64\ncount_process(void)\n{\n  uint64 cnt = 0;\n  for (int i = 0; i &lt; NPROC; ++i)\n    if (proc[i].state != UNUSED)\n      ++cnt;\n  return cnt;\n}\n\næœ€åæˆ‘ä»¬åªè¦å°†è¿™ä¸ªsysinfoç»“æ„ä½“æ‹·è´è‡³ç”¨æˆ·ç©ºé—´å³å¯ã€‚é¦–å…ˆé€šè¿‡argaddrå‡½æ•°è·å–ç”¨æˆ·æ€int sysinfo(struct sysinfo *)ä¼ å…¥çš„sysinfoè™šåœ°å€ï¼Œç„¶åç»“åˆè¯¥è¿›ç¨‹çš„é¡µè¡¨pagetableå¯ä»¥å¾—åˆ°è¯¥åœ°å€å¯¹åº”çš„ç‰©ç†åœ°å€ï¼Œæœ€åå°†å†…æ ¸ä¸­çš„sysinfoç»“æ„ä½“æ‹·è´è¿‡å»ã€‚\nuint64\nsys_sysinfo(void)\n{\n  struct proc *p = myproc();\n  struct sysinfo sf;\n  uint64 addr;\n  sf.freemem = count_freemem();\n  sf.nproc = count_process();\n  if (argaddr(0, &amp;addr) &lt; 0 || copyout(p-&gt;pagetable, addr, (char *)&amp;sf, sizeof(sf)) &lt; 0)\n    return -1;\n  return 0;\n}\n\nargaddrç¬¬ä¸€ä¸ªå‚æ•°0æ˜¯æŒ‡ä»a0å¯„å­˜å™¨è·å–ï¼Œæˆ‘ç‰¹åœ°å›å»ç¿»äº†ä¸€ä¸‹è®¡ç»„PPT\n\n\næœç„¶ï¼Œa0ã€a1å­˜å‚¨å‡½æ•°å‚æ•°ï¼Œas I guessã€‚\nå…¶ä½™å£°æ˜ä¹‹ç±»çš„ä¸ä¸Šé¢çš„traceç±»ä¼¼ã€‚å¦å¤–åˆ«å¿˜äº†åœ¨kernel/sysproc.cä¸­åŠ å…¥\n9 + â”‚ #include \"kernel/sysinfo.h\"\n\nå¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œåœ¨xv6å¯åŠ¨åè¾“å…¥sysinfotestä¼šè¾“å‡ºOKã€‚\n$ sysinfotest\nsysinfotest: start\nsysinfotest: OK\n\n\n\nâ– Reference\n[1]MIT 6.S081 2020 Lab2 system callsè®²è§£\n[2][mit6.s081] ç¬”è®° Lab2: System calls | ç³»ç»Ÿè°ƒç”¨\n","slug":"Lab2-system-calls","date":"2022-09-25T03:57:05.000Z","categories_index":"æ“ä½œç³»ç»Ÿ","tags_index":"èµ°ç è§‚èŠ±,xv6","author_index":"Starlit Rover"},{"id":"42640cc884e7d3b61d24e0f58f7990cd","title":"ã€Œ1066ã€Root of AVL Tree","content":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.\n\n\nÂ \nÂ \nNow given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ NÂ (â‰¤20) which is the total number of keys to be inserted. ThenÂ NÂ distinct integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the root of the resulting AVL tree in one line.\nSample Input 1:5\n88 70 61 96 120\n\nSample Output 1:70\n\nSample Input 2:7\n88 70 61 96 120 90 65\n\nSample Output 2:88\n\n\nÎ©AVLï¼Œå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œä¸ä»…æ‹¥æœ‰BSTçš„æ€§è´¨ï¼ŒåŒæ—¶æ¯ä¸ªé¡¶ç‚¹å·¦å³ä¸¤æ£µå­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡1ï¼Œä»è€Œä½¿æ ‘çš„é«˜åº¦å°½å¯èƒ½ç»´æŒåœ¨ä¸€ä¸ªè¾ƒä½æ°´å¹³ï¼Œæé«˜æœç´¢æ•ˆç‡ã€‚ç»™å‡ºä¸€ç»„æ•°æ®ï¼Œè¾“å‡ºæœ€ç»ˆAVLçš„æ ¹èŠ‚ç‚¹ï¼Œæ³¨æ„æ¯ä¸ªå…ƒç´ æ’å…¥åéƒ½åº”åŠæ—¶è°ƒæ•´ä¸ºAVLã€‚\nå½“åˆçœ‹æ ‘è¿™ä¸€å—çš„æ—¶å€™ï¼ŒAVLçš„æ—‹è½¬è°ƒæ•´è®©æˆ‘å¤´ç–¼ä¸å·²ï¼Œç°åœ¨äº¦æ˜¯å¦‚æ­¤ã€‚è‹¦è‹¦æ€ç´¢ï¼ŒåŸæ¥è¿™æ˜¯ç¬¬ä¸€æ¬¡æ’ä¸ŠAVLçš„é¢˜ç›®ï¼Œäºæ˜¯æˆ‘åˆå›å»é‡æ¸©äº†ä¸€éã€Šæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æã€‹é‡Œçš„ç›¸å…³å†…å®¹ã€‚\næ¯æ¬¡æ’å…¥ä¸€ä¸ªæ•°åæˆ‘ä»¬éƒ½ä»è¯¥æ ‘å¼€å§‹å‘æ ¹èŠ‚ç‚¹å›æº¯ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå·¦å³å­æ ‘é«˜åº¦å·®&gt;1çš„èŠ‚ç‚¹Xï¼Œåªè¦å°†è¿™æ£µå­æ ‘æ¢å¤è‡³æ’å…¥å‰çš„é«˜åº¦å³å¯é‡æ–°æ»¡è¶³AVLã€‚\næ¥ä¸‹æ¥æˆ‘ä»¬å°†æ’å…¥åä¸æ»¡è¶³å¹³è¡¡æ€§çš„æƒ…å½¢åˆ†ä¸ºä¸¤ç§ï¼ˆæ¯ç§éƒ½åŒ…å«ä¸¤ä¸ªé•œåƒå¯¹ç§°çš„æƒ…å†µï¼‰ï¼š\n\nå‘XèŠ‚ç‚¹çš„å·¦ï¼ˆå³ï¼‰å­èŠ‚ç‚¹çš„å·¦ï¼ˆå³ï¼‰å­æ ‘æ’å…¥åä¸æ»¡è¶³\n\n\nå‘XèŠ‚ç‚¹çš„å·¦ï¼ˆå³ï¼‰å­èŠ‚ç‚¹çš„å³ï¼ˆå·¦ï¼‰å­æ ‘æ’å…¥åä¸æ»¡è¶³\n\n\næˆ‘ä»¬ç”¨æ¥è¡¨ç¤ºå­æ ‘ï¼Œæ¥è¡¨ç¤ºå­æ ‘çš„é«˜åº¦ï¼Œé¦–å…ˆæ˜¾ç„¶\n\né‚£ä¹ˆä¸å¯èƒ½æ˜¯ç©ºæ ‘ï¼Œå› ä¸ºã€‚å› æ­¤æˆ‘ä»¬è¿˜å¯ä»¥å°†è¿›è¡Œæ‹†åˆ†ï¼š\n\n\nå…¶æ¬¡ï¼Œå¦åˆ™åœ¨æ’å…¥ä¹‹å‰å°±å·²ç»ä¸æ»¡è¶³å¹³è¡¡æ€§ï¼Œå¦å¤–ç”±äºèŠ‚ç‚¹Xæ˜¯ç¬¬ä¸€ä¸ªä¸æ»¡è¶³å¹³è¡¡æ€§çš„èŠ‚ç‚¹ï¼Œå› æ­¤ã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œï¼Œä¸”ã€‚\n\n\næ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é€šè¿‡ä¸¤ç§ä¸åŒçš„æ—‹è½¬æ–¹æ³•åœ¨ä¸ç ´ç¯BSTçš„å‰æä¸‹ä½¿å…¶é‡æ–°ç¬¦åˆå¹³è¡¡æ€§ï¼ˆåºå·ä¸ä¸Šè¿°æƒ…å½¢ç›¸å¯¹åº”ï¼Œåªè€ƒè™‘é•œåƒå¯¹ç§°ä¸­çš„ä¸€ç§æƒ…å†µï¼‰ï¼š\n\næ‹ä½ç»¿ç‚¹å‘ä¸Šæï¼Œæˆä¸ºèŠ‚ç‚¹Xçš„å·¦å­æ ‘\n\n\næ˜¾ç„¶æ»¡è¶³å¹³è¡¡æ€§ï¼Œä¸”BSTçš„æœ‰åºæ€§ä¹Ÿæœªè¢«ç ´å\n\næ‹ä½èŠ‚ç‚¹Rå‘ä¸Šææˆä¸ºæ ¹èŠ‚ç‚¹ï¼Œæƒ³è±¡æ¯æ¡è¾¹çš„ç«¯ç‚¹éƒ½æ˜¯æœ‰ç£æ€§çš„ï¼Œåœ¨ä¸Šæçš„è¿‡ç¨‹ä¸­è„±è½è‡ªåŠ¨å¸é™„åˆ°å…¶ä»–èŠ‚ç‚¹ä¸Šï¼Œç»¿èŠ‚ç‚¹å’ŒèŠ‚ç‚¹Xæˆä¸ºå…¶å·¦å³å­æ ‘ï¼Œè€Œæˆä¸ºç»¿èŠ‚ç‚¹çš„å³å­æ ‘ï¼Œæˆä¸ºXèŠ‚ç‚¹çš„å·¦å­æ ‘ \n\n\n å’Œçš„é«˜åº¦å…³ç³»æ— æ³•ç¡®å®šï¼Œä½†æ³¨æ„åˆ° ï¼Œå› æ­¤ä¾ç„¶å¯ä»¥è‚¯å®šæ˜¯ç¬¦åˆå¹³è¡¡æ€§è¦æ±‚çš„ã€‚\n\n\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nmap&lt;int, pair&lt;int, int&gt;&gt; avl;\nmap&lt;int, int&gt; height;\n\nint insert(int r, int m)\n{\n    if (!r) return m;\n    if (m &gt; r) avl[r].second = insert(avl[r].second, m);\n    else avl[r].first = insert(avl[r].first, m);\n    int left = height[avl[r].first], right = height[avl[r].second], t;\n    if (abs(left - right) &gt; 1)\n    {\n        bool up1 = left &gt; right, up2;\n        auto &amp;son = up1 ? avl[r].first : avl[r].second;\n        up2 = height[avl[son].first] &gt; height[avl[son].second];\n        if (up1 == up2)\n        {\n            auto &amp;gs = up1 ? avl[son].second : avl[son].first;\n            t = gs, gs = r, r = son, son = t;\n            height[gs] = max(height[avl[gs].first], height[avl[gs].second]) + 1;\n        }\n        else\n        {\n            auto &amp;gs = up1 ? avl[son].second : avl[son].first;\n            auto &amp;out_ggs = up1 ? avl[gs].first : avl[gs].second;\n            auto &amp;in_ggs = up1 ? avl[gs].second : avl[gs].first;\n            t = gs, gs = out_ggs, out_ggs = son, son = in_ggs, in_ggs = r, r = t;\n            height[out_ggs] = max(height[avl[out_ggs].first], height[avl[out_ggs].second]) + 1;\n            height[in_ggs] = max(height[avl[in_ggs].first], height[avl[in_ggs].second]) + 1;\n        }\n    }\n    height[r] = max(height[avl[r].first], height[avl[r].second]) + 1;\n    return r;\n}\n\nint main()\n{\n    int n, m, r = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m, height[m] = 1;\n        r = insert(r, m);\n    }\n    cout &lt;&lt; r;\n}\n\nTips\nç”¨å‡ ä¸ªå¼•ç”¨æ¥æ›¿ä»£å†…/å¤–ä¾§çš„å„¿å­ã€å­™å­ã€æ›¾å­™èŠ‚ç‚¹ï¼Œä»è€Œæ— éœ€è€ƒè™‘é•œåƒå¯¹ç§°çš„æƒ…å†µ\n\nç”¨ä¸€ä¸ªmapæ¥å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹å­æ ‘çš„é«˜åº¦ï¼Œåœ¨è¿›è¡Œæ—‹è½¬è°ƒæ•´æ—¶éœ€è¦å¯¹æ”¹å˜çš„èŠ‚ç‚¹é«˜åº¦è¿›è¡Œç»´æŠ¤\n\ninsertå‡½æ•°å®Œæˆæ’å…¥æ“ä½œï¼Œå¹¶å¯¹å›æº¯è¿‡ç¨‹ä¸­ç¬¬ä¸€ä¸ªä¸æ»¡è¶³å¹³è¡¡æ€§çš„èŠ‚ç‚¹å­æ ‘è¿›è¡Œæ—‹è½¬è°ƒæ•´ï¼Œç»“æŸåè¿”å›æ–°å­æ ‘çš„æ ¹èŠ‚ç‚¹\n\næ³¨æ„èŠ‚ç‚¹å…³ç³»çš„èµ‹å€¼æ¬¡åºï¼Œå¦åˆ™å¯èƒ½å‡ºç°å°†èµ‹å€¼åçš„å˜é‡å½“ä½œè€å˜é‡ä½¿ç”¨\n\n\n","slug":"ã€Œ1066ã€Root-of-AVL-Tree","date":"2022-09-24T16:14:37.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,Tree,AVL","author_index":"Starlit Rover"},{"id":"42e41f54cdd74aae9e65b00439b07d2c","title":"ã€Œ1065ã€A+B and C (64bit)","content":"Given three integersÂ A,Â BÂ andÂ CÂ in , you are supposed to tell whetherÂ A+B&gt;C.\n\n\nInput Specification:The first line of the input gives the positive number of test cases,Â TÂ (â‰¤10). ThenÂ TÂ test cases follow, each consists of a single line containing three integersÂ A,Â BÂ andÂ C, separated by single spaces.\nOutput Specification:For each test case, output in one lineÂ Case #X: trueÂ ifÂ A+B&gt;C, orÂ Case #X: falseÂ otherwise, whereÂ XÂ is the case number (starting from 1). Each line should ends withÂ '\\n'.\nSample Input:3\n1 2 3\n2 3 4\n9223372036854775807 -9223372036854775808 0\n\nSample Output:Case #1: false\nCase #2: true\nCase #3: false\n\n\nÎ©å¾ˆè¿·æƒ‘ï¼Œç¬¬ä¸€è¡Œå†™çš„è¿˜æ˜¯å¼€åŒºé—´ï¼Œç»“æœsampleå°±æ¥äº†ä¸€ä¸ªã€‚ç»è¿‡å®é™…æµ‹è¯•ï¼Œæµ‹è¯•æ•°æ®çš„çœŸå®æ•°æ®èŒƒå›´åº”åœ¨ï¼Œå³long long intçš„èŒƒå›´ã€‚\nè™½ç„¶è¯»å–æ•°æ®æ—¶ä¸ä¼šæº¢å‡ºï¼Œä½†åœ¨Aã€Bç›¸åŠ æ—¶å¯èƒ½ä¼šå‘ç”Ÿæº¢å‡ºï¼Œé‚£ä¹ˆæœ€ç®€å•çš„ä¸€ä¸ªæ–¹æ³•å°±æ˜¯é€šè¿‡ç§»é¡¹å°†å¯èƒ½æº¢å‡ºçš„åŠ æ³•å˜ä¸ºå‡æ³•ã€‚æ ¹æ®åªæœ‰åŒå·ç›¸åŠ æ‰å¯èƒ½æº¢å‡ºçš„åŸç†å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å››ç§æƒ…å†µï¼š\n\nAã€BåŒå·ï¼Œæ­¤æ—¶åˆ¤æ–­Cæ˜¯å¦ä¹ŸåŒå·ï¼š\n\nAã€Bã€Céƒ½åŒå·ï¼Œå°†ä¸ç­‰å¼æ”¹ä¸ºA&gt;C-B\n\nAã€Bå’ŒCä¸åŒå·ï¼Œ true /  false\n\n\n\nAã€Bå¼‚å·ï¼ŒA+Bä¸ä¼šæº¢å‡ºï¼Œç›´æ¥åˆ¤æ–­\n\n\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    long long int n, a, b, c;\n    string s[] = {\"false\", \"true\"};\n    cin &gt;&gt; n;\n    bool otc;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%lld %lld %lld\", &amp;a, &amp;b, &amp;c);\n        if ((a ^ b) &gt;= 0)\n            otc = ((a ^ c) &gt;= 0) ? a &gt; c - b : (a &gt;= 0);\n        else\n            otc = a + b &gt; c;\n        printf(\"Case #%d: %s\\n\", i + 1, s[otc].c_str());\n    }\n}\n","slug":"ã€Œ1065ã€A-B-and-C-64bit","date":"2022-09-24T03:10:52.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"fc7708d5c5ede5940549730140fdd222","title":"ã€Œ1064ã€Complete Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the nodeâ€™s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.\nBoth the left and right subtrees must also be binary search trees.\n\nA Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.\nNow given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ NÂ (â‰¤1000). ThenÂ NÂ distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.\nOutput Specification:For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input:10\n1 2 3 4 5 6 7 8 9 0\n\nSample Output:6 3 8 1 5 7 9 0 2 4\n\n\nÎ©ç»™å‡ºä¸€ç»„æ•°ï¼Œè¾“å‡ºå…¶å®Œå…¨ï¼ˆæœ€åä¸€å±‚èŠ‚ç‚¹ä»å·¦è‡³å³æ— é—´éš”æ’åˆ—ï¼‰æœ‰åºäºŒå‰æ•°çš„å±‚æ¬¡éå†ã€‚\né¦–å…ˆæˆ‘ä»¬å¯¹æ‰€æœ‰æ•°å­—è¿›è¡Œæ’åºå¾—åˆ°åºåˆ—ï¼Œæˆ‘ä»¬åªè¦æŒ‰ç…§å±‚æ¬¡éå†çš„é¡ºåºä¾æ¬¡æ±‚å‡ºæ¯ä¸ªæ•°åœ¨ä¸­çš„ç´¢å¼•å³å¯ï¼Œè€Œç´¢å¼•å€¼å³ä¸ºå°äºè¯¥æ•°çš„æ•°å­—ä¸ªæ•°ã€‚\nå¯¹äºæ ¹èŠ‚ç‚¹å¾ˆæ˜¾ç„¶å…¶ç´¢å¼•å€¼å³ä¸ºå·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œè€Œå¯¹äºå…¶ä»–èŠ‚ç‚¹çš„ç´¢å¼•å€¼è®¡ç®—æˆ‘ä»¬å¯ä»¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š\n\nä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘ï¼Œå…¶ä¸­å°äºè¯¥æ•°çš„èŠ‚ç‚¹ä¸ªæ•°ä¾ç„¶æ˜¯å·¦å­æ ‘èŠ‚ç‚¹ä¸ªæ•°\n\nå…¶ä½™éƒ¨åˆ†ï¼ˆCBT-ä¸Šè¿°å­æ ‘ï¼‰ï¼Œè¿™é‡Œæˆ‘ä»¬éœ€è¦åˆ†ä¸¤ç§æƒ…å†µè®¨è®ºï¼š\n\nè¯¥èŠ‚ç‚¹Pä¸ºæŸèŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°äºè¯¥æ•°çš„èŠ‚ç‚¹ä¸ªæ•°å°±æ˜¯å…¶çˆ¶èŠ‚ç‚¹Fçš„Part 2å€¼ï¼Œå³çˆ¶èŠ‚ç‚¹Fçš„å…¶ä½™éƒ¨åˆ†å°äºçˆ¶èŠ‚ç‚¹å€¼çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚æ³¨æ„åˆ°ï¼ŒPå’ŒFçš„å…¶ä½™éƒ¨åˆ†ç›¸æ¯”ä»…å¤šäº†Fæœ¬èº«å’ŒFçš„å³å­æ ‘ï¼Œå³Pçš„å…„å¼Ÿå­æ ‘ï¼Œè€Œå³å­æ ‘ä¸Šçš„èŠ‚ç‚¹å’ŒFçš„å€¼éƒ½&gt;Pï¼Œå› æ­¤ä¸¤è€…æ˜¯ç›¸ç­‰çš„\n\nè¯¥èŠ‚ç‚¹æ˜¯æŸèŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°äºè¯¥æ•°çš„èŠ‚ç‚¹ä¸ªæ•°æ˜¯å°äºå…¶çˆ¶èŠ‚ç‚¹Fçš„èŠ‚ç‚¹ä¸ªæ•°+1ã€‚æ³¨æ„åˆ°ï¼Œçˆ¶èŠ‚ç‚¹Fçš„å…¶ä½™éƒ¨åˆ†ä¸è¯¥èŠ‚ç‚¹å…¶ä½™éƒ¨åˆ†ä»…ç›¸å·®Fæœ¬èº«ä¸Fçš„å·¦å­æ ‘ï¼Œè€ŒFçš„å·¦å­æ ‘æ˜¯Fçš„Part 1å€¼ï¼Œå› æ­¤å°†å…¶ä¸Fçš„å…¶ä½™éƒ¨åˆ†ç›¸åŠ å³ä¸ºå°äºFçš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œæœ€åå†ç®—ä¸ŠFæœ¬èº«+1\n\n\n\n\né¦–å…ˆæˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºæ¯ä¸ªèŠ‚ç‚¹ä¸­å·¦å³å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼ˆè‡ªåº•å‘ä¸Šï¼Œé€å±‚éå†ï¼‰ï¼Œç”¨pair&lt;int,int&gt;æ¥å­˜å‚¨ï¼Œç„¶åæ ¹æ®ä¸Šè¿°åˆ†æä¸éš¾å‘ç°è®¡ç®—ç´¢å¼•æ—¶æˆ‘ä»¬åªéœ€ç”¨åˆ°å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œäºæ˜¯pair.secondï¼ˆåŸæœ¬å­˜å‚¨å³å­æ ‘èŠ‚ç‚¹ä¸ªæ•°çš„éƒ¨åˆ†ï¼‰å°±å¯ä»¥ç”¨å­˜å‚¨Part 2çš„å€¼ã€‚æ³¨æ„åˆ°Part 2åœ¨è®¡ç®—èŠ‚ç‚¹æœ¬èº«ç´¢å¼•æ—¶ä¸éœ€è¦ç”¨åˆ°ï¼ˆå­èŠ‚ç‚¹éœ€è¦ï¼‰ï¼Œæ‰€ä»¥åœ¨è®¡ç®—å®Œç´¢å¼•åé¡ºä¾¿æ›´æ–°å…¶pair.secondã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, level = 1, prod = 2;\n    cin &gt;&gt; n;\n    while (prod &lt; n + 1)\n    {\n        prod *= 2;\n        level += 1;\n    }\n    vector&lt;pair&lt;int, int&gt;&gt; node_num;\n    node_num.resize(prod - 1, pair(0, -1));\n    for (int i = prod / 2 - 1; i &lt; n; ++i)\n        node_num[i] = std::move(pair(0, 0));\n    for (int i = prod / 4; i &gt; 0; i /= 2)\n        for (int j = i - 1; j &lt; 2 * i - 1; ++j)\n            node_num[j] = std::move(pair(node_num[2 * j + 1].first + node_num[2 * j + 1].second + 1,\n                                         node_num[2 * j + 2].first + node_num[2 * j + 2].second + 1));\n    vector&lt;int&gt; keys(n);\n    for (auto &amp;k: keys)\n        cin &gt;&gt; k;\n    sort(keys.begin(), keys.end());\n    cout &lt;&lt; keys[node_num[0].first];\n    node_num[0].second = 0;\n    for (int i = 0; i &lt; n - 1; ++i)\n    {\n        int idx = (i % 2 ? node_num[i / 2].first + 1 : 0) + node_num[i / 2].second + node_num[i + 1].first;\n        cout &lt;&lt; \" \" &lt;&lt; keys[idx];\n        node_num[i + 1].second = idx - node_num[i + 1].first;\n    }\n}\n\n\nÎ ä¸Šè¿°çš„æ€è€ƒæ¨¡å¼åˆæ˜¯ä¸€ç§é€†æ¨çš„è¿‡ç¨‹ï¼Œå¤šå°‘æœ‰ç‚¹åäººç±»ã€‚ä»”ç»†è§‚å¯Ÿèƒ½å¤Ÿå‘ç°æœ‰åºäºŒå‰æ ‘çš„ä¸­åºéå†å³ä¸ºæ’åºç»“æœï¼Œé‚£ä¹ˆé¢˜ç›®å°±èƒ½è½¬åŒ–ä¸ºå·²çŸ¥äºŒå‰æ ‘çš„ä¸­åºéå†å¦‚ä½•æ±‚å…¶å±‚æ¬¡éå†çš„é—®é¢˜ã€‚é‚£ä¹ˆæˆ‘ä»¬å°±é¡ºåŠ¿è€Œä¸ºï¼Œæ¨¡æ‹Ÿä¸€éä¸­åºéå†ï¼Œç„¶ååœ¨æ¨¡æ‹Ÿè¿‡ç¨‹ä¸­é¡ºä¾¿è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹åœ¨å±‚æ¬¡éå†ä¸­çš„ç´¢å¼•ï¼Œç„¶åæ ¹æ®ç´¢å¼•è¿›è¡Œèµ‹å€¼å³å¯ã€‚ç®€å•åœ°è¯´ï¼Œå°±æ˜¯ç«™åœ¨å±‚æ¬¡éå†çš„è§’åº¦å»åšä¸­åºéå†ã€‚\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nint n;\nvector&lt;int&gt; level, keys;\n\nvoid InOrder(int node)\n{\n    if (node &gt;= n) return;\n    static int idx = 0;\n    InOrder(2 * node + 1);\n    level[node] = keys[idx++];\n    InOrder(2 * node + 2);\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    keys.resize(n);\n    level.resize(n);\n    for (auto &amp;k: keys)\n        cin &gt;&gt; k;\n    sort(keys.begin(), keys.end());\n    InOrder(0);\n    for (int i = 0; i &lt; level.size(); ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; level[i];\n}\n","slug":"ã€Œ1064ã€Complete-Binary-Search-Tree","date":"2022-09-22T08:21:20.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,traversal order,Tree","author_index":"Starlit Rover"},{"id":"70201c87e9f11a4fa65c8ac00911ccba","title":"ã€Œ1063ã€Set Similarity","content":"Given two sets of integers, the similarity of the sets is defined to beÂ , whereÂ â€‹Â is the number of distinct common numbers shared by the two sets, andÂ Â is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets.\n\n\nInput Specification:Each input file contains one test case. Each case first gives a positive integerÂ which is the total number of sets. ThenÂ NÂ lines follow, each gives a set with a positiveÂ  and followed byÂ MÂ integers in the range [0,109]. After the input of sets, a positive integerÂ  is given, followed byÂ Â lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 toÂ ). All the numbers in a line are separated by a space.\nOutput Specification:For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place.\nSample Input:3\n3 99 87 101\n4 87 101 5 87\n7 99 101 18 5 135 18 99\n2\n1 2\n1 3\n\nSample Output:50.0%\n33.3%\n\n\nÎ©æ±‚ä¸¤é›†åˆçš„ç›¸ä¼¼åº¦=äº¤é›†å…ƒç´ /å¹¶é›†å…ƒç´ ã€‚\nå®é™…æ±‚è§£è¿‡ç¨‹ä¸­åªéœ€è¦æ±‚äº¤é›†å…ƒç´ å³å¯ï¼Œå¹¶é›†å…ƒç´ æ•°=é›†åˆ1+é›†åˆ2-äº¤é›†ã€‚ç”±äºC++é‡Œé¢å·²ç»æ”¯æŒæ±‚äº¤é›†çš„å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œä¸è¿‡ç”¨æ³•ä¸æ˜¯é‚£ä¹ˆå¥½è®°ï¼Œå½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥ç”¨ç±»ä¼¼å½’å¹¶æ’åºçš„æ€æƒ³ç›´æ¥å®ç°ï¼š\ntemplate&lt;class InputIt1, class InputIt2,\n         class OutputIt, class Compare&gt;\nOutputIt set_intersection(InputIt1 first1, InputIt1 last1,\n                          InputIt2 first2, InputIt2 last2,\n                          OutputIt d_first, Compare comp)\n{\n    while (first1 != last1 &amp;&amp; first2 != last2) {\n        if (comp(*first1, *first2)) {\n            ++first1;\n        } else {\n            if (!comp(*first2, *first1)) {\n                *d_first++ = *first1++; // *first1 and *first2 are equivalent.\n            }\n            ++first2;\n        }\n    }\n    return d_first;\n}\n\näº‹å®ä¸ŠPythonä¸­çš„setå®¹å™¨åšçš„æŒºå¥½ï¼Œäº¤å¹¶è¿ç®—éƒ½ç¬¦å·åŒ–äº†ï¼Œå®ç°èµ·æ¥ä¹Ÿå¾ˆå¿«ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n;\n    set&lt;int&gt; s[n];\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; k;\n            s[i].insert(k);\n        }\n    }\n\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m &gt;&gt; k;\n        set&lt;int&gt; inter;\n        set_intersection(s[m - 1].begin(), s[m - 1].end(), s[k - 1].begin(), s[k - 1].end(),\n                         inserter(inter, inter.begin()));\n        printf(\"%.1f%%\\n\", inter.size() * 1.0 / (s[m - 1].size() + s[k - 1].size() - inter.size()) * 100);\n    }\n}\n\nğŸğŸnum=eval(input())\nsets=[set() for i in range(num)]\nfor i in range(num):\n    nums=list(map(eval,input().split()))\n    n=nums[0]\n    for j in range(n):\n        m=nums[j+1]\n        sets[i].add(m)\nn=eval(input())\nfor i in range(n):\n    a,b=map(eval,input().split())\n    inter=sets[a-1]&amp;sets[b-1]\n    print(\"%.1f%%\"%(len(inter)/(len(sets[a-1])+len(sets[b-1])-len(inter))*100))\n","slug":"ã€Œ1063ã€Set-Similarity","date":"2022-09-21T08:11:18.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,set","author_index":"Starlit Rover"},{"id":"61bd7651739e9a5cb7671d4227eb7db6","title":"ã€Œ1062ã€Talent and Virtue","content":"About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about peopleâ€™s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a â€œsageï¼ˆåœ£äººï¼‰â€; being less excellent but with oneâ€™s virtue outweighs talent can be called a â€œnoblemanï¼ˆå›å­ï¼‰â€; being good in neither is a â€œfool manï¼ˆæ„šäººï¼‰â€; yet a fool man is better than a â€œsmall manï¼ˆå°äººï¼‰â€ who prefers talent than virtue.\nNow given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guangâ€™s theory.\n\n\nInput Specification:Each input file contains one test case. Each case first gives 3 positive integers in a line:Â , the total number of people to be ranked;Â , the lower bound of the qualified grades â€“ that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; andÂ , the higher line of qualification â€“ that is, those with both grades not below this line are considered as the â€œsagesâ€, and will be ranked in non-increasing order according to their total grades. Those with talent grades belowÂ HÂ but virtue grades not are considered as the â€œnoblemenâ€, and are also ranked in non-increasing order according to their total grades, but they are listed after the â€œsagesâ€. Those with both grades belowÂ H, but with virtue not lower than talent are considered as the â€œfool menâ€. They are ranked in the same way but after the â€œnoblemenâ€. The rest of people whose grades both pass theÂ LÂ line are ranked after the â€œfool menâ€.\nThenÂ NÂ lines follow, each gives the information of a person in the format:\nID_Number Virtue_Grade Talent_Grade\n\nwhereÂ ID_NumberÂ is an 8-digit number, and both grades are integers in [0, 100]. All the numbers are separated by a space.\nOutput Specification:The first line of output must give , the total number of people that are actually ranked. ThenÂ MÂ lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their IDâ€™s.\nSample Input:14 60 80\n10000001 64 90\n10000002 90 60\n10000011 85 80\n10000003 85 80\n10000004 80 85\n10000005 82 77\n10000006 83 76\n10000007 90 78\n10000008 75 79\n10000009 59 90\n10000010 88 45\n10000012 80 100\n10000013 90 99\n10000014 66 60\n\nSample Output:12\n10000013 90 99\n10000012 80 100\n10000003 85 80\n10000011 85 80\n10000004 80 85\n10000007 90 78\n10000006 83 76\n10000005 82 77\n10000002 90 60\n10000014 66 60\n10000008 75 79\n10000001 64 90\n\n\nÎ©é™¤äº†æ’åºè§„åˆ™æœ‰ç‚¹å¤æ‚å¤–ï¼Œä¹Ÿåªæ˜¯ä¸€é“ç®€å•çš„ä¿¡æ¯åˆ†ç±»è¾“å‡ºé¢˜ã€‚æ ¹æ®å¸é©¬å…‰å…ˆç”Ÿï¼ˆç ¸ç¼¸çš„é‚£ä½\nï¼‰çš„ç†è®ºï¼Œäººåˆ†ä¸ºåœ£äººï¼ˆï¼‰ã€å›å­ï¼ˆï¼‰ã€æ„šäººï¼ˆï¼‰ã€å°äººï¼ˆï¼‰ã€‚ç»™å‡ºäººæ•°Nã€Hã€Lï¼Œä»¥åŠæ¯äººçš„Tã€Vï¼Œè¯·æŒ‰ç…§å‰è¿°çš„é¡ºåºåˆ†ç±»å¹¶è¾“å‡ºï¼ŒåŒä¸€ç±»ä¸­æŒ‰ç…§é™åºæ’åˆ—ï¼Œç›¸ç­‰æ—¶æŒ‰ç…§é™åºæ’åºï¼Œå†ç›¸ç­‰æ—¶æŒ‰ç…§IDå‡åºæ’åˆ—ã€‚\nå¯¹äºæ’åºè§„åˆ™ï¼Œåªéœ€è¦å†™ä¸€ä¸ªcmpå‡½æ•°ç„¶åsortå³å¯ï¼Œå…¶ä½™å°±æ˜¯å¦‚ä½•ç»„ç»‡æ•°æ®ç»“æ„çš„é—®é¢˜äº†ã€‚ä¸€å¼€å§‹æˆ‘ç”¨mapå­˜å‚¨äº†IDæ‰€å¯¹åº”çš„Tã€Vï¼Œç„¶ååˆ†ç±»æ—¶åªå­˜å‚¨IDï¼Œå°†mapä½œä¸ºå…¨å±€å˜é‡ä»è€Œå®ç°å¯¹IDçš„sortã€‚ä¸å¹¸çš„æ˜¯ï¼Œæäº¤åå‡ºç°äº†è¶…æ—¶ï¼Œå…¶å®ä»”ç»†æƒ³æƒ³ï¼Œæ’åºæ—¶éœ€è¦ä¸æ–­åœ°è®¿é—®mapï¼Œæœ€åè¾“å‡ºè¿˜è¦å†è®¿é—®ä¸€éã€‚è€Œï¼Œå¦‚æœè¯´æ‰€æœ‰äººéƒ½åœ¨åŒä¸€ç±»ï¼Œé‚£ä¹ˆè®¿é—®mapçš„æ—¶é—´å°†ä¼šæ˜¯è‡´å‘½çš„ã€‚æœ€åæˆ‘é‡‡ç”¨äº†tupleï¼Œå°†IDã€Tã€Véƒ½å­˜å‚¨åœ¨ä¸€èµ·ï¼ˆç±»ä¼¼äºç»“æ„ä½“ï¼‰ï¼Œæ¶ˆé™¤äº†è®¿é—®æ—¶é—´ï¼ŒRun Timeé™¡è·Œã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;string, int, int&gt; tsii;\n\nbool cmp(tsii &amp;a, tsii &amp;b)\n{\n    if (get&lt;1&gt;(a) + get&lt;2&gt;(a) != get&lt;1&gt;(b) + get&lt;2&gt;(b))\n        return get&lt;1&gt;(a) + get&lt;2&gt;(a) &gt; get&lt;1&gt;(b) + get&lt;2&gt;(b);\n    else if (get&lt;1&gt;(a) != get&lt;1&gt;(b))\n        return get&lt;1&gt;(a) &gt; get&lt;1&gt;(b);\n    else\n        return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);\n}\n\nint main()\n{\n    int N, L, H, t, v;\n    scanf(\"%d %d %d\", &amp;N, &amp;L, &amp;H);\n    int valid = N;\n    vector&lt;tuple&lt;string, int, int&gt;&gt; men[4];\n    string s;\n    s.resize(8);\n    for (int i = 0; i &lt; N; ++i)\n    {\n        scanf(\"%s %d %d\", &amp;s[0], &amp;v, &amp;t);\n        if (t &lt; L || v &lt; L)\n        {\n            valid -= 1;\n            continue;\n        }\n        else if (t &gt;= H &amp;&amp; v &gt;= H)\n            men[0].emplace_back(s, v, t);\n        else if (t &lt; H &amp;&amp; v &gt;= H)\n            men[1].emplace_back(s, v, t);\n        else if (t &lt;= v &amp;&amp; v &lt; H)\n            men[2].emplace_back(s, v, t);\n        else\n            men[3].emplace_back(s, v, t);\n    }\n    printf(\"%d\\n\", valid);\n    for (auto &amp;m: men)\n    {\n        sort(m.begin(), m.end(), cmp);\n        for (auto &amp;k: m)\n            printf(\"%s %d %d\\n\", get&lt;0&gt;(k).c_str(), get&lt;1&gt;(k), get&lt;2&gt;(k));\n    }\n}\n","slug":"ã€Œ1062ã€Talent-and-Virtue","date":"2022-09-21T03:12:33.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,tuple","author_index":"Starlit Rover"},{"id":"1e574a5e3fca1a756fff12eb87b95cbe","title":"Lab1: Xv6 and Unix utilities","content":"è¿™å­¦æœŸå¼€å§‹å­¦æ“ä½œç³»ç»Ÿå•¦ï¼Œä¸€å‘¨äº”èŠ‚è¯¾ï¼Œæ˜¯ä¸€ä½è€æ•™å¸ˆï¼Œé™¤äº†è®²è¯æ…¢äº†ç‚¹è¿˜ç»å¸¸è¯·åŒå­¦ä»¬å›ç­”ä¸€äº›ç¥å¥‡é—®é¢˜å¤–æ„Ÿè§‰è¿˜å¥½ï¼Œå’Œä¸Šå­¦æœŸçš„å¯„ç½‘è¿˜æ˜¯æœ‰å·®è·çš„ã€‚æš‘å‡æƒ³é¢„ä¹ æ¥ç€çš„ï¼Œä¸è¿‡ç»å†äº†ä¸€äº›äº‹æƒ…æœ‰ç‚¹é¢“ï¼Œç°åœ¨å›å¿†èµ·æ¥åƒæ˜¯ä¸Šä¸ªä¸–çºªçš„å‡æœŸäº†ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œå¤§å­¦=å¤§ä¸äº†è‡ªå­¦ï¼Œæ‰€ä»¥æ‰“å¼€äº†MITÂ·S081ã€‚\nè¯¾ç¨‹é…å¥—å®éªŒåŸºäºæ•™æˆä»¬è‡ªå·±å†™çš„ä¸€ä¸ªç±»UNIXæ•™å­¦æ“ä½œç³»ç»Ÿâ€”â€”xv6ï¼Œé€šè¿‡xv6ä¸Šçš„å®éªŒä½ èƒ½å¤Ÿå¯¹æ“ä½œç³»ç»Ÿä¸­çš„ä¸€äº›æ¦‚å¿µä»¥åŠæ“ä½œç†è§£æ›´æ·±ï¼Œç²¾å“è‰¯å¿ƒï¼ŒåºŸè¯ä¸å¤šè¯´ï¼Œå¸Œæœ›è¿™å­¦æœŸèƒ½å¥½å¥½åšå®éªŒï¼ˆ\\è®¤çœŸè„¸ï¼‰ã€‚\nç¬¬ä¸€ä¸ªå®éªŒä¸»è¦ä»¥ç†Ÿæ‚‰xv6ä»¥åŠç³»ç»Ÿè°ƒç”¨å‡½æ•°ä¸ºä¸»ï¼Œå®éªŒæ–‡æ¡£æˆ³è¿™ã€‚\n\n\n\n\nâ– å®‰è£…xv6\nä¼—æ‰€å‘¨çŸ¥ï¼Œç¯å¢ƒä¸¤å°æ—¶ï¼Œå®éªŒ5åˆ†é’Ÿã€‚ä¸è¿‡å®‰è£…xv6ä¼¼ä¹ååˆ†é¡ºåˆ©å¹¶æ²¡æœ‰é­é‡å¤ªå¤šçš„ä¸æµ‹ï¼Œå½“ç„¶å¾ˆå¤§ä¸€éƒ¨åˆ†åŸå› æ˜¯ç«™åœ¨åˆ«äººçš„è¡€æ³ªå²ä¸Šã€‚å¦‚æœä½ ä¹Ÿæ˜¯M1ç”¨æˆ·ï¼Œå¯ä»¥å‚è€ƒMIT 6.S081/Fall 2020 æ­å»ºrisc-vä¸xv6å¼€å‘è°ƒè¯•ç¯å¢ƒè¿™ç¯‡åšå®¢ã€‚\nå‰ç½®ç¯å¢ƒä¸»è¦æ˜¯ï¼š\n\ngcc / clang ï¼šç”¨æ¥ç¼–è¯‘riscv-gnu-toolchain å·¥å…·é“¾\n\nriscv-gnu-toolchain å·¥å…·é“¾ï¼šç”¨æ¥ç¼–è¯‘è°ƒè¯•xv6ï¼Œéœ€è¦ä¸‹è½½æºç è¿›è¡Œç¼–è¯‘\n\nqemuï¼šå¯ä»¥è¿è¡Œä¸åŒæ¶æ„ä¸‹æ“ä½œç³»ç»Ÿçš„è™šæ‹Ÿæœºï¼Œç”¨Cè¯­è¨€æ¥æ¨¡æ‹Ÿç¡¬ä»¶çš„æ‰§è¡Œï¼Œç”±äºxv6æ˜¯è¿è¡Œåœ¨RISC-Væ¶æ„ä¸Šçš„ï¼Œå› æ­¤éœ€è¦qemuæ¥è¿è¡Œ.\n\n\nä¸Šè¿°ç¯å¢ƒé…ç½®å®Œæˆåï¼Œå³å¯\n&gt; git clone git://g.csail.mit.edu/xv6-labs-2021\n&gt; cd xv6-labs-2021\n&gt; git checkout util\n\næœ€åé€šè¿‡make qemuæ¥ç¼–è¯‘xv6å¹¶è¿è¡Œï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥åœ¨xv6çš„å‘½ä»¤è¡Œä¸­è¾“å…¥å‘½ä»¤äº†ã€‚\n\n\nâ– Coding\nâ˜‘ï¸ sleep (easy)ç¬¬ä¸€ä¸ªå®éªŒéå¸¸ç®€å•ï¼Œå®ç°ç”¨æˆ·æŒ‡å®šæ—¶é—´çš„åœé¡¿ï¼Œè€Œxv6ç³»ç»Ÿå†…ç½®sleepå‡½æ•°ï¼Œä¸»è¦æ˜¯ç†Ÿæ‚‰ç å‘½ä»¤æ—¶çš„ä¸€äº›åŸºæœ¬æ ¼å¼ã€‚é¦–å…ˆæ¯ä¸ªå‘½ä»¤éƒ½ä¼šä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼šint argc&amp;char *argv[]ï¼Œargcæ˜¯ä¼ å…¥å‚æ•°çš„ä¸ªæ•°ï¼Œè€Œargvæ˜¯æ‰€æœ‰ä¼ å…¥å‚æ•°çš„å­—ç¬¦ä¸²å½¢å¼æ•°ç»„ã€‚é‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±éå¸¸çš„æ¸…æ™°æ˜äº†äº†ï¼Œåªéœ€è¦æŠŠç”¨æˆ·ä¼ å…¥çš„æ—¶é—´è½¬ä¸ºæ•°å­—ï¼Œç„¶åè°ƒç”¨sleep()å³å¯ã€‚\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int arg, char *argv[])\n{\n    if (arg &lt;= 1)\n    {\n        fprintf(2, \"usage: sleep n\\n\");\n        exit(1);\n    }\n    else if (arg &gt; 2)\n    {\n        fprintf(2, \"ERROR: too much arguments!\\nusage: sleep n\\n\");\n        exit(1);\n    }\n\n    char *s = argv[1];\n    int n = 0;\n    while (*s &gt;= '0' &amp;&amp; *s &lt;= '9')\n        n = 10 * n + *s++ - '0';\n    if (*s != 0)\n    {\n        fprintf(2, \"ERROR: the second parameter must be a number!\\n\");\n        exit(0);\n    }\n    sleep(n);\n    exit(0);\n}\n\nâš ï¸argv[0]æ˜¯å‘½ä»¤åç§°ï¼ŒçœŸæ­£çš„å‚æ•°ä»argv[1]å¼€å§‹ã€‚å¦å¤–ä¸è¦å¿˜è®°é”™è¯¯å¤„ç†ä¸é”™è¯¯æç¤ºã€‚\n\n\nâ˜‘ï¸ pingpongÂ (easy)å…ˆç”¨forkå‡½æ•°åˆ›å»ºå­è¿›ç¨‹ï¼Œç„¶åä½¿ç”¨pipeå‡½æ•°è¿›è¡Œè¿›ç¨‹é—´é€šè®¯ï¼Œæœ€åé€šè¿‡getpidå‡½æ•°è·å–è¿›ç¨‹idå¹¶è¾“å‡ºâ€œPIDï¼šreceived â€¦â€ã€‚\né¦–å…ˆé€šè¿‡forkè¿”å›å€¼æ˜¯å¦ä¸º0åˆ¤æ–­æ˜¯å­è¿›ç¨‹orçˆ¶è¿›ç¨‹ï¼ˆçˆ¶è¿›ç¨‹è¿”å›å­è¿›ç¨‹idï¼‰ï¼Œforkå®Œä¹‹åä¸¤è€…çš„èµ„æºéƒ½æ˜¯ä¸€æ ·çš„è€Œä¸”éƒ½ä»forkå‡½æ•°ç»§ç»­è¿è¡Œã€‚é‚£ä¹ˆæˆ‘ä»¬å…ˆç”¨pipeåˆ›å»ºä¸€ä¸ªç®¡é“ï¼Œç”¨ä¸€ä¸ªint p[2]æ¥è®°å½•ç®¡é“ä¸¤ç«¯çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œp[1]å†™p[2]è¯»ã€‚\né‚£ä¹ˆå…ˆåœ¨çˆ¶è¿›ç¨‹ä¸­writeï¼Œç„¶åå­è¿›ç¨‹readå®Œè¾“å‡ºå¹¶writeï¼Œçˆ¶è¿›ç¨‹é€šè¿‡waitå‡½æ•°ï¼ˆç­‰å¾…ç¬¬ä¸€ä¸ªå­è¿›ç¨‹ç»“æŸï¼Œå¦‚æœæ²¡æœ‰å­è¿›ç¨‹ç›´æ¥ç»§ç»­ï¼‰ç­‰å¾…å­è¿›ç¨‹ç»“æŸå†ç»§ç»­readå¹¶è¾“å‡ºã€‚\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main(int arg, char *argv[])\n{\n    int p[2];\n    pipe(p);\n    char buff[5];\n    if (fork() == 0)\n    {\n        if (read(p[0], buff, 5) != 5)\n        {\n            printf(\"Read Parent ERROR!\\n\");\n            exit(1);\n        }\n        close(p[0]);\n        printf(\"%d: received %s\\n\", getpid(), buff);\n        write(p[1], \"pong\", 5);\n        close(p[1]);\n    }\n    else\n    {\n        write(p[1], \"ping\", 5);\n        close(p[1]);\n        wait(0);\n        if (read(p[0], buff, 5) != 5)\n        {\n            printf(\"Read Child ERROR!\\n\");\n            exit(1);\n        }\n        printf(\"%d: received %s\\n\", getpid(), buff);\n        close(p[0]);\n    }\n    exit(0);\n}\n\nreadå‡½æ•°è¿”å›è¯»å–çš„å­—èŠ‚æ•°ï¼Œè¾¾åˆ°æ–‡ä»¶æœ«å°¾è¿”å›0ï¼Œå‡ºé”™è¿”å›-1ï¼Œwriteç±»ä¼¼ã€‚\nâš ï¸è¯»å†™å®ŒåŠæ—¶closeï¼Œä¸è¦å¿˜è®°å­—ç¬¦ä¸²æœ«å°¾çš„â€™\\0â€™ã€‚\nè‡³äºä¸ºä»€ä¹ˆçˆ¶è¿›ç¨‹å†™çš„æ¯”å­è¿›ç¨‹è¯»çš„å¿«ï¼Œæˆ‘æƒ³æ˜¯å› ä¸ºå­è¿›ç¨‹å› ä¸ºéœ€è¦å¤åˆ¶èµ„æºè¿˜éœ€è¦è€—è´¹é¢å¤–çš„æ—¶é—´ï¼Œå› æ­¤å¼€å§‹æ‰§è¡Œçš„æ—¶é—´ä¼šæ™šäºçˆ¶è¿›ç¨‹ã€‚\n$ pingpong\n4: received ping\n3: received pong\n$\n\n\n\nâ˜‘ï¸ primes (moderate/hard)ä¸æ˜¯ä¸€ä¸ªå‘½ä»¤ï¼Œä½†æœ‰åŠ©äºä½ ç†è§£pipeçš„å·¥ä½œæµç¨‹ã€‚è¾“å…¥primeså‘½ä»¤åè¾“å‡º2-35ä¹‹é—´çš„ç´ æ•°ã€‚è™½ç„¶ä¸ªæ•°æœ‰é™è€Œä¸”å¾ˆå°‘å¯ä»¥ç›´æ¥æšä¸¾ï¼Œä½†å¸Œæœ›ä½ åˆ©ç”¨pipeåˆ¶ä½œä¸€ä¸ªåŸƒæ°ç´ æ•°ç­›ã€‚å¤§è‡´çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\n\n\nå®ƒçš„æ€æƒ³å¾ˆç®€å•ï¼Œé¦–å…ˆç”¨æœ€å°ç´ æ•°2ç­›å»ä¸ºå…¶å€æ•°çš„æ•°å­—ï¼Œç„¶åå†ç­›å»ä¸ºç¬¬äºŒå°ç´ æ•°3çš„å€æ•°ï¼Œä¾æ¬¡ç±»æ¨ã€‚ä¸éš¾å‘ç°ï¼Œå¦‚æœè¯¥æ•°ç»„æ˜¯ä»¥2å¼€å§‹çš„ä¸€ä¸²è¿ç»­æ•°å­—çš„è¯ï¼Œé‚£ä¹ˆæ¯æ¬¡ç­›å®Œåçš„æœ€å°æ•°å­—ä¸€å®šæ˜¯ç´ æ•°ï¼Œå¦åˆ™å¿…ç„¶è¿˜å­˜åœ¨æ¯”å…¶å°çš„ç´ æ•°æœªè¢«ç­›é€‰ï¼Œè¿™æ˜¯çŸ›ç›¾çš„ã€‚å› æ­¤æˆ‘ä»¬åªè¦æ¯æ¬¡è¾“å‡ºæœ€å°æ•°å­—ç„¶åç­›å»è¯¥æ•°å­—çš„å€æ•°å³å¯ã€‚\nå¾ˆæ˜¾ç„¶è¿™é‡Œéœ€è¦pipeå®ç°ä¼ é€’çš„åŠŸèƒ½ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¯æ¬¡å…ˆä»ä¸Šä¸€ä¸ªpipeä¸­è¯»å‡ºå‰©ä¸‹çš„æ•°ç»„ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ–°çš„pipeï¼Œå°†è¯¥è½®ç­›é€‰åå‰©ä½™çš„æ•°å­—å†™å…¥æ–°pipeä¸­ï¼Œæ¥ç€forkä¸€ä¸ªæ–°è¿›ç¨‹ï¼Œæœ‰ç‚¹ç±»ä¼¼å‡½æ•°é€’å½’è°ƒç”¨ï¼Œæˆ‘ä¸‹é¢ç”¨å¾ªç¯ä»£æ›¿äº†é€’å½’ã€‚\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint main()\n{\n    int buff[34], p[2], size = 34;\n    for (int i = 0; i &lt; 34; ++i)\n        buff[i] = i + 2;\n    pipe(p);\n    write(p[1], buff, size * sizeof(int));\n    close(p[1]);\n\n    while(size)\n    {\n        if (fork() == 0)\n        {\n            read(p[0], buff, size * sizeof(int));\n            close(p[0]);\n            pipe(p);\n            printf(\"prime %d\\n\", buff[0]);\n            int cnt = 0, prime = buff[0];\n            for (int i = 0; i &lt; size; ++i)\n                if (buff[i] % prime != 0)\n                    buff[cnt++] = buff[i];\n            size = cnt;\n            write(p[1], buff, cnt * sizeof(int));\n            close(p[1]);\n        }\n        else\n        {\n            wait(0);\n            exit(0);\n        }\n    }\n    exit(0);\n}\n\nä¹‹æ‰€ä»¥çˆ¶è¿›ç¨‹éœ€è¦waitæ˜¯å› ä¸ºå¦‚æœä¸waitç¬¬ä¸€ä¸ªè¿›ç¨‹åœ¨æ‰§è¡Œå®Œåå°±ç›´æ¥exit(0)äº†ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´ç³»ç»Ÿä»¥ä¸ºä½ æ‰§è¡Œå®Œäº†äº‹å®ä¸Šå¹¶æ²¡æœ‰çš„å±€é¢ï¼š\n$ primes\np$r ime 2\nprime 3\nprime 5\nprime 7\nprime 11\nprime 13\nprime 17\nprime 19\nprime 23\nprime 29\nprime 31\n\nä½ ä¼šå‘ç°åœ¨è¾“å‡ºç¬¬ä¸€æ¡ä¿¡æ¯çš„è¿‡ç¨‹ä¸­ç³»ç»Ÿä»¥ä¸ºè¿›ç¨‹ç»“æŸï¼Œäºæ˜¯è¾“å‡ºã€$ ã€‘ï¼Œå…¶å®åªæ˜¯ç¬¬ä¸€ä¸ªè¿›ç¨‹ç»“æŸäº†ï¼Œä½†å®ƒéœ€è¦å¯¹åˆ›å»ºçš„æ‰€æœ‰è¿›ç¨‹è´Ÿè´£ã€‚\nâš ï¸åˆ›å»ºæ–°ç®¡é“å‰è®°å¾—æŠŠè€ç®¡é“çš„ç«¯å£closeï¼Œå¦åˆ™å°±ä¸¢å¤±äº†ã€‚\nâ˜‘ï¸ find (moderate)å®ç°ä¸€ä¸ªç®€å•çš„æŸ¥æ‰¾æ–‡ä»¶å‘½ä»¤findï¼Œå‘½ä»¤æ ¼å¼ä¸ºã€find rootfile filenameã€‘ï¼Œå…±è®¡ä¸¤ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆè¿™é‡Œæˆ‘ä»¬éœ€è¦å­¦ä¼šå¦‚ä½•è®¿é—®æ–‡ä»¶ã€‚\né€šè¿‡é˜…è¯»user/ls.cï¼Œä¸éš¾å¾—çŸ¥æ¯ä¸ªè·¯å¾„éƒ½æ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œæ–‡ä»¶å†…è®°å½•è¯¥è·¯å¾„ä¸‹çš„å­æ–‡ä»¶ä¿¡æ¯ï¼Œé¦–å…ˆé€šè¿‡open(char *path, int flag)å‡½æ•°æ‰“å¼€å¯¹åº”è·¯å¾„pathçš„æ–‡ä»¶ï¼Œè¿”å›ç›¸åº”çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œflagæ˜¯è¯»å†™æ ‡å¿—ã€‚ç„¶åç”¨stat(int fd, struct stat *st)å°†fdå¯¹åº”çš„æ–‡ä»¶å¤¹/æ–‡ä»¶çš„ä¿¡æ¯å†™å…¥ç»“æ„ä½“stï¼Œå…¶ä¸­st.typeè¡¨ç¤ºå…¶ï¼ˆæ–‡ä»¶å¤¹T_DIR/æ–‡ä»¶T_FILEï¼‰ç±»å‹ã€‚\nè¿™æ˜¯ä¸€æ–¹é¢ï¼Œä½†æ›´é‡è¦çš„æ˜¯è·å–è·¯å¾„ä¸‹å­æ–‡ä»¶çš„ä¿¡æ¯ï¼Œä¾‹å¦‚æ–‡ä»¶åã€‚fdå¯¹åº”çš„æ–‡ä»¶å†…éƒ¨è®°å½•äº†æ‰€æœ‰å­æ–‡ä»¶çš„ä¿¡æ¯ï¼Œå¯ä»¥é€šè¿‡read(fd, &amp;de, sizeof(de))Â Â Â Â æ¥è·å–ä¸€ä¸ªå­æ–‡ä»¶ä¿¡æ¯ï¼Œå…¶ä¸­deæ˜¯å­æ–‡ä»¶ä¿¡æ¯ç»“æ„ä½“ç±»å‹çš„ä¸€ä¸ªå®ä½“ã€‚deåŒ…å«inumå’Œnameï¼Œinumç»™ä¸åŒæ–‡ä»¶å¤¹å’Œæ–‡ä»¶ç¼–å·ï¼Œnameä¸ºæ–‡ä»¶åæˆ–æ–‡ä»¶å¤¹åã€‚\né‚£ä¹ˆé€šè¿‡stat(path+'/'+de.name, &amp;st)å°±èƒ½è·å–å­æ–‡ä»¶çš„ç›¸å…³ä¿¡æ¯ï¼Œå†ç”±stã€‚tyoeåˆ¤æ–­æ˜¯å¦ä¸ºæ–‡ä»¶å¤¹è¿›è¡Œé€’å½’æœç´¢ã€‚\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\nvoid search(char *path, char *name)\n{\n    struct dirent de;\n    struct stat st;\n    char buf[512], *p;\n    int fd;\n\n    if ((fd = open(path, 0)) &lt; 0)\n    {\n        fprintf(2, \"find: cannot open %s\\n\", path);\n        return;\n    }\n\n    if (fstat(fd, &amp;st) &lt; 0)\n    {\n        fprintf(2, \"find: cannot stat %s\\n\", path);\n        close(fd);\n        return;\n    }\n\n    switch (st.type)\n    {\n    case T_FILE:\n        printf(\"find: %s is a file instead of a path.\\n\", path);\n        break;\n    case T_DIR:\n        if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof(buf))\n        {\n            printf(\"find: path too long!\\n\");\n            break;\n        }\n        strcpy(buf, path);\n        p = buf + strlen(path);\n        *p++ = '/';\n\n        while (read(fd, &amp;de, sizeof(de)) == sizeof(de))\n        {\n            // dno't forget inum==0!\n            if (!strcmp(de.name, \".\") || !strcmp(de.name, \"..\") || de.inum == 0)\n                continue;\n            memmove(p, de.name, DIRSIZ);\n            p[DIRSIZ] = 0;\n            if (stat(buf, &amp;st) &lt; 0)\n            {\n                printf(\"find: cannot stat %s\", buf);\n                continue;\n            }\n            switch (st.type)\n            {\n            case T_DIR:\n                search(buf, name);\n                break;\n            case T_FILE:\n                if (!strcmp(de.name, name))\n                    printf(\"%s\\n\", buf, path);\n                break;\n            // default:\n            //    break;\n            }\n        }\n        break;\n    }\n    close(fd);\n}\n\nint main(int argc, char *argv[])\n{\n    if (argc &lt; 3)\n    {\n        fprintf(2, \"usage: find rootpath filename.\\n\");\n        exit(1);\n    }\n\n    search(argv[1], argv[2]);\n    exit(0);\n}\n\nç®€å•åœ°è¯´ï¼Œdeæ˜¯å­æ–‡ä»¶ä¿¡æ¯ç»“æ„ä½“ï¼Œstæ˜¯æœ¬èº«ä¿¡æ¯ç»“æ„ä½“ã€‚DIRSIZæ˜¯æ–‡ä»¶åå›ºå®šé•¿åº¦ï¼Œæ–¹ä¾¿å¤„ç†ã€‚memmove(Â void*Â dest,Â constÂ void*Â src,Â size_tÂ countÂ )ä»srcæ‹·è´countä¸ªå­—èŠ‚åˆ°destï¼Œå¦‚æœæ˜¯å­—ç¬¦ä¸²è®°å¾—è¡¥0ã€‚bufæ¥å­˜å‚¨è·¯å¾„ä»¥åŠå­ç›®å½•çš„è·¯å¾„å­—ç¬¦ä¸²ã€‚\nâš ï¸å­æ–‡ä»¶ä¿¡æ¯é‡Œé¢ä¼šåŒ…å«å½“å‰ç›®å½•ã€.ã€‘ã€ä¸Šçº§ç›®å½•ã€..ã€‘è¿˜æœ‰ä¸€ä¸ªinum==0 &amp;&amp; de.name==\"\"çš„èŠ‚ç‚¹ï¼ˆå¤§æ¦‚æŸ¥é˜…äº†ä¸€ä¸‹ï¼Œde.inum==0è¡¨ç¤ºè¿™æ˜¯ä¸€å—å·²ç»åˆå§‹åŒ–å¹¶ä¸”å¯ä»¥ç”¨æ¥åˆ›å»ºæ–‡ä»¶æˆ–è€…æ–‡ä»¶å¤¹çš„ä½ç½®ï¼‰ï¼Œæ³¨æ„ç»•é“é¿å…æ— é™é€’å½’ï¼Œæ— é™é€’å½’å°†å¯¼è‡´æ ˆæº¢å‡ºï¼Œè¿è¡Œæ—¶ä¼šå‡ºç°usertrap()ã€‚\n Â Â Â $ echo &gt; b\n$ mkdir a\n$ echo &gt; a/b\n$ find . b\n./b\n./a/b\n$ \n\n\n\nâ˜‘ï¸ xargs (moderate)xargså‘½ä»¤æ˜¯ä¸€ä¸ªå¯ä»¥æ‰©å±•è¾“å…¥å‚æ•°çš„å‘½ä»¤ï¼Œé€šè¿‡cmd1 ï½œ xargs cmd2å¯ä»¥å°†cmd1å‘½ä»¤çš„è¾“å‡ºæ·»åŠ åˆ°cmd2çš„è¾“å…¥å‚æ•°ä¸­ï¼Œå¦‚æœcmd1è¾“å‡ºæœ‰å¤šè¡Œåˆ™åˆ†åˆ«æ·»åŠ æ‰§è¡Œï¼Œæ•ˆæœä¸UNIXä¸­çš„xargs -n 1ç­‰åŒï¼š\n$ echo \"1\\n2\" | xargs -n 1 echo line\nline 1\nline 2\n\n$ echo hello too | xargs echo bye\nbye hello too\n\né¦–å…ˆæˆ‘ä»¬éœ€è¦æŠŠxargsåé¢å‘½ä»¤åŸæœ¬å°±è·Ÿç€çš„å‚æ•°æ‹·è´è¿‡å»ï¼Œæˆ‘è¿™é‡Œæ˜¯ç›´æ¥æŠŠå­—ç¬¦ä¸²æŒ‡é’ˆæ‹·è´è¿‡å»ï¼ˆç›¸å½“äºæµ…æ‹·è´ï¼‰ï¼Œå¹¶æ²¡æœ‰mallocä¸€å—æ–°ç©ºé—´ã€‚\nå¯¹äºè¿½åŠ çš„å‚æ•°ï¼Œæˆ‘ä»¬ä»æ ‡å‡†è¾“å…¥ï¼ˆfdä¸º0ï¼‰è¯»å…¥ã€‚ç„¶åå°±ä¸€ä¸ªä¸€ä¸ªå­—ç¬¦åœ°è¯»ï¼Œè¯»åˆ°â€™\\nâ€™æˆ–â€™ â€˜å°±mallocä¸€å—æ–°çš„ç©ºé—´å°†è¿™ä¸ªå‚æ•°å¤åˆ¶è¿‡æ¥å¹¶å°†å¤´æŒ‡é’ˆå­˜å…¥char *para[MAXARG]ï¼Œå¦‚æœè¯»åˆ°äº†â€™\\nâ€™æˆ–è€…æ–‡ä»¶ç»“å°¾å°±æ‰§è¡Œä¸€æ¬¡execå‡½æ•°ï¼ˆâš ï¸execå‡½æ•°ä¸ä¼šè¿”å›è°ƒç”¨å‡½æ•°ï¼Œå¦‚æœè¿”å›å°±è¯´æ˜æ‰§è¡Œå¤±è´¥exit(1)ï¼‰ã€‚\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"kernel/param.h\"\n#include \"user/user.h\"\n#define MAXLEN 512\n\nint main(int argc, char *argv[])\n{\n    if (argc &lt; 2)\n    {\n        fprintf(2, \"usage: xargs command.\\n\");\n        exit(1);\n    }\n\n    char buf[MAXLEN], *para[MAXARG];\n    int flag = 1;\n\n    // shallow copy xisting parameters\n    for (int i = 1; i &lt; argc; ++i)\n        para[i - 1] = argv[i];\n\n    // flag==0 means EOF\n    while (flag)\n    {\n        int cnt = argc - 1, len = 0;\n        // read a line from standard input\n        while ((flag = read(0, buf + len, 1)))\n        {\n            if (buf[len] == '\\n' || buf[len] == ' ')\n            {\n                if (len)\n                {\n                    para[cnt] = (char *)malloc(len + 1);\n                    memmove(para[cnt], buf, len);\n                    para[cnt][len] = 0;\n                    len = 0;\n                    if (++cnt &gt; MAXARG)\n                    {\n                        printf(\"xargs: too many arguments!\\n\");\n                        exit(1);\n                    }\n                }\n\n                if (buf[len] == '\\n')\n                    break;\n            }\n            else if (len + 1 &gt; MAXLEN)\n            {\n                printf(\"xargs: argument too long!\\n\");\n                exit(1);\n            }\n            else\n                ++len;\n        }\n        if (!fork())\n        {\n            exec(para[0], para);\n            exit(1);\n        }\n        else\n            wait(0);\n    }\n    exit(0);\n}\n\nâš ï¸å‘½ä»¤å‚æ•°ä¸ªæ•°æœ‰é™åˆ¶ï¼ˆMAXARGï¼‰ï¼Œå¦å¤–éœ€è¦å…³æ³¨ä¸€ä¸ªå‚æ•°é•¿åº¦ä¸èƒ½è¶…è¿‡è‡ªå·±å®šä¹‰çš„bufï¼ˆMAXLENï¼‰ã€‚\n\n\nâ– Grading &amp; Debug\ncd xv6-labs-2021\n./grade-lab-util command_name\n\ne.g.\n&gt; ./grade-lab-util sleep   \nmake: `kernel/kernel' is up to date.\n== Test sleep, no arguments == sleep, no arguments: OK (1.3s) \n== Test sleep, returns == sleep, returns: OK (0.9s) \n== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) \n\næ‰€æœ‰Testéƒ½æ˜¾ç¤ºOKå³å¯ã€‚\n\n\nDebugéœ€è¦ç”¨gdbè¿›è¡Œè¿œç¨‹è°ƒè¯•ï¼Œé¦–å…ˆåœ¨ä¸€ä¸ªå‘½ä»¤æ¡†ä¸­ï¼ˆåœ¨xv6-labs-2021ç›®å½•ä¸‹ï¼‰make qemu-gdbï¼Œç„¶åæ–°å»ºä¸€ä¸ªå‘½ä»¤æ¡†çª—å£ï¼ˆè¿˜æ˜¯åœ¨xv6-labs-2021ç›®å½•ä¸‹ï¼‰riscv64-unknown-elf-gdb user/_xargsï¼ˆã€_ã€‘+å‘½ä»¤åç§° ï¼‰ã€‚å¦‚æœè¿æ¥å¤±è´¥åœ¨gdbç•Œé¢è¾“å…¥target remote localhost:25501ï¼ˆç«¯å£å·è§qemuç•Œé¢æœ€åä¸€è¡Œtcp::xxxxxï¼‰ã€‚ä¸å¸Œæœ›æ¯æ¬¡è¾“å…¥å¯ä»¥å†™å…¥~/.gdbinitã€‚bè®¾ç½®æ–­ç‚¹ï¼Œcè¿è¡Œè‡³æ–­ç‚¹ï¼Œnå•æ­¥æ‰§è¡Œï¼Œp argæŸ¥çœ‹argå€¼ã€‚\n\n","slug":"Lab1-Xv6-and-Unix-utilities","date":"2022-09-13T10:32:31.000Z","categories_index":"æ“ä½œç³»ç»Ÿ","tags_index":"èµ°ç è§‚èŠ±,xv6","author_index":"Starlit Rover"},{"id":"0eaf91694ac904eb1b9bccba53543259","title":"ã€Œ1060ã€Are They Equal","content":"If a machine can save only 3 significant digits, the float numbers 12300 and 12358.9 are considered equal since they are both saved asÂ Â with simple chopping. Now given the number of significant digits on a machine and two float numbers, you are supposed to tell if they are treated equal in that machine.\n\n\nInput Specification:Each input file contains one test case which gives three numbersÂ Â andÂ , whereÂ  is the number of significant digits, andÂ AÂ andÂ BÂ are the two float numbers to be compared. Each float number is non-negative, no greater thanÂ , and that its total digit number is less than 100.\nOutput Specification:For each test case, print in a lineÂ YESÂ if the two numbers are treated equal, and then the number in the standard formÂ 0.d[1]...d[N]*10^kÂ (d[1]&gt;0 unless the number is 0); orÂ NOÂ if they are not treated equal, and then the two numbers in their standard form. All the terms must be separated by a space, with no extra space at the end of a line.\nNote: Simple chopping is assumed without rounding.\nSample Input 1:3 12300 12358.9\n\nSample Output 1:YES 0.123*10^5\n\nSample Input 2:3 120 128\n\nSample Output 2:NO 0.120*10^3 0.128*10^3\n\n\nÎ©ç»™å®šåº•æ•°çš„å­˜å–ç²¾åº¦ï¼Œå¿½ç•¥æŒ‡æ•°çš„ç²¾åº¦èŒƒå›´ï¼Œåˆ¤æ–­ä¸¤ä¸ªæ•°ç”¨ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤ºåï¼ˆæœ‰ç²¾åº¦çš„æŸå¤±ï¼‰æ˜¯å¦ç›¸ç­‰ã€‚\nè¿™ç§é¢˜ç›®å°±æ˜¯é‚£ç§æœˆçƒæ‘ï¼Œåˆ°å¤„éƒ½æ˜¯ç¯å½¢å‘ï¼Œå½“ç„¶ç¢°åˆ°è¿™ç§é¢˜ç›®ä¹Ÿä¸è¦å®³æ€•ï¼ŒæŠŠæ‰€æœ‰å‘éƒ½è¸©ä¸€éå°±æ— æ•Œå•¦ã€‚\nç§‘å­¦è®¡æ•°æ³•æ— éå°±ä¸¤ä¸ªé‡è¦æ•°æ®â€”â€”åº•æ•°å’ŒæŒ‡æ•°ï¼Œæˆ‘ä»¬å¯ä»¥å»ºä¸€ä¸ªç§‘å­¦è®¡æ•°æ³•çš„classæ¥ç»Ÿä¸€æ ¼å¼åŒ–ã€‚\nå¯¹äºåˆšè¯»å…¥çš„çº¯å¤©ç„¶æ•°å­—å­—ç¬¦ä¸²nï¼Œæˆ‘ä»¬å…ˆæ±‚æŒ‡æ•°ã€‚ç”¨find('.')å‡½æ•°ç¡®å®šå°æ•°ç‚¹çš„ä½ç½®ï¼Œå¦‚æœä¸å­˜åœ¨å°æ•°ç‚¹å°±å–ã€æœ€åä¸€ä¸ªå­—ç¬¦ç´¢å¼•+1=n.size()ã€‘ï¼Œç„¶åå°†å°æ•°ç‚¹å»é™¤ï¼ˆâš ï¸å»é™¤åå°æ•°ç‚¹çš„ç´¢å¼•å°±å˜æˆäº†å°æ•°ç‚¹åä¸€ä½æ•°å­—çš„ç´¢å¼•ï¼Œä¹Ÿæ˜¯æ ¼å¼åŒ–ä¸­ç¬¬ä¸€ä¸ªé0æ•°å­—å°†è¦ç§»åˆ°çš„ä½ç½®ï¼‰æ‰¾ç¬¬ä¸€ä¸ªé0æ•°å­—çš„ä½ç½®ï¼Œæ‰¾åˆ°åå°±å°†æ‰€æœ‰å‰ç½®0å»é™¤ã€‚æ­¤æ—¶è‹¥å­—ç¬¦ä¸²ä¸ºç©ºè¯´æ˜ä¸º0ï¼ˆå¤§å‘ï¼‰ï¼Œå•ç‹¬æŒ‡å®šä¸€ä¸‹æŒ‡æ•°ä¸º0ï¼›éç©ºå°±ç”¨ã€å°æ•°ç‚¹ä½ç½®ï¼ˆç»ˆç‚¹ï¼‰-ç¬¬ä¸€ä¸ªé0æ•°å­—ä½ç½®ï¼ˆèµ·ç‚¹ï¼‰ã€‘ï¼Œå³ä¸ºæ‰€æ±‚æŒ‡æ•°ã€‚\nç„¶åå¦‚æœæ­¤æ—¶å­—ç¬¦ä¸²ä¸è¶³nä½çš„è¯å°±é€šè¿‡æ·»åŠ åç½®â€˜0â€™æ¥è¡¥åˆ°nä½ï¼Œè¿™æ ·å°±å¾—åˆ°äº†åº•æ•°å’ŒæŒ‡æ•°ã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Float\n{\npublic:\n    string data;\n    int bias = 0;\n\n    explicit Float(int n)\n    {\n        cin &gt;&gt; data;\n        size_t point = data.find('.');\n        if (point == string::npos)\n            point = data.size();\n        else\n            data.erase(data.begin() + point);\n\n        for (char &amp;it: data)\n        {\n            if (it != '0')\n                break;\n            ++bias;\n        }\n        data.erase(0, bias);\n        if (data.empty())\n        {\n            data = \"0\";\n            bias = 0;\n        }\n        else\n            bias = point - bias;\n        while (data.size() &lt; n)\n            data += \"0\";\n    }\n\n    inline string format(int n)\n    {\n        return \"0.\" + data.substr(0, n) + \"*10^\" + to_string(bias);\n    }\n};\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    Float a(n), b(n);\n    if (a.bias == b.bias &amp;&amp; a.data.substr(0, n) == b.data.substr(0, n))\n        cout &lt;&lt; \"YES \" &lt;&lt; a.format(n) &lt;&lt; endl;\n    else\n        cout &lt;&lt; \"NO \" &lt;&lt; a.format(n) &lt;&lt; \" \" &lt;&lt; b.format(n) &lt;&lt; endl;\n}\n\n\nTipsâ˜”ï¸\nstring.find(char)è¿”å›ç¬¬ä¸€ä¸ªå­—ç¬¦æ‰€åœ¨çš„ä¸‹æ ‡ç´¢å¼•ï¼ˆä¸æ˜¯è¿­ä»£å™¨ï¼‰ï¼Œå¦‚æœæ²¡æ‰¾åˆ°å°±ä¼šè¿”å›string::nposï¼Œå³size_tç±»å‹çš„æœ€å¤§å€¼\n\nå­—ç¬¦ä¸²çš„åˆ é™¤å‡½æ•°string.erase()æœ‰ä¸¤ç§ç”¨æ³•ï¼š\n\nstring.erase(iterator pos)ï¼šç›´æ¥ä¼ å…¥è¯¥å­—ç¬¦çš„è¿­ä»£å™¨è¿›è¡Œåˆ é™¤\n\nstring.erase(int start,int num)ï¼šæŒ‡å®šèµ·å§‹ç´¢å¼•å’Œè¿ç»­åˆ é™¤çš„å­—ç¬¦ä¸ªæ•°ï¼Œåˆ é™¤string[start:start+num]ï¼Œstart+numå¤„å­—ç¬¦ä¿ç•™\n\n\n\n\n","slug":"ã€Œ1060ã€Are-They-Equal","date":"2022-09-11T08:00:39.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"d25a64f6e3048948d06ba269622dda29","title":"ã€Œ1059ã€Prime Factors","content":"Given any positive integerÂ N, you are supposed to find all of its prime factors, and write them in the formatÂ â€‹.\n\n\nInput Specification:Each input file contains one test case which gives a positive integerÂ NÂ in the range ofÂ long int.\nOutput Specification:FactorÂ NÂ in the formatÂ NÂ =Â p1â€‹^k1â€‹*p2â€‹^k2â€‹*â€¦*pmâ€‹^kmâ€‹, whereÂ piâ€‹â€™s are prime factors ofÂ NÂ in increasing order, and the exponentÂ kiâ€‹Â is the number ofÂ piâ€‹Â â€“ hence when there is only oneÂ piâ€‹,Â kiâ€‹Â is 1 and mustÂ NOTÂ be printed out.\nSample Input:97532468\n\nSample Output:97532468=2^2*11*17*101*1291\n\n\nÎ©ç»å…¸åˆ†è§£è´¨å› æ•°ï¼Œæ„Ÿè§‰å·²ç»ä¸ä¼šåšå¤§ä¸€çš„é¢˜ç›®äº†ï¼ŒçœŸçš„å¹´çºªå¤§äº†ã€‚\næœ‰ä¸¤ç§æ€è·¯ï¼Œé¦–å…ˆå»ºç«‹ä¸€ä¸ªç´ æ•°è¡¨ï¼Œæˆ‘ä»¬çŸ¥é“ä¸€ä¸ªæ•°çš„è´¨å› æ•°ä¸ä¼šè¶…è¿‡å…¶å¹³æ–¹æ ¹ï¼Œé‚£ä¹ˆç”±äºï¼Œå› æ­¤æˆ‘ä»¬åªéœ€æ‰¾å‡ºæ‰€æœ‰5000ä»¥å†…çš„ç´ æ•°ç„¶åä¸€ä¸ªä¸€ä¸ªç´ æ•°å»é™¤ã€‚\nè¿™ç§åšæ³•æ²¡ä»€ä¹ˆç¾æ„Ÿã€‚æˆ‘é‡‡å–äº†ä¸€ç‚¹ä¼˜åŒ–ï¼Œä¸å»ºç«‹ç´ æ•°è¡¨ï¼Œé¦–å…ˆå¯ä»¥è‚¯å®šæœ€å°çš„å› æ•°ä¸€å®šæ˜¯ç´ æ•°ï¼Œå¦åˆ™è¿˜ä¼šå­˜åœ¨æ›´å°çš„å› æ•°è€ŒçŸ›ç›¾ã€‚æ ¹æ®è¿™ä¸€æ¡æ€§è´¨ï¼Œæˆ‘ä»¬åªéœ€æ¯æ¬¡æ‰¾æœ€å°çš„å› å­å³å¯ï¼Œå¿…ç„¶æ˜¯ç´ æ•°ï¼Œç„¶åæ¥ç€æ‰¾çš„æœ€å°ç´ å› å­ï¼Œå‘¨è€Œå¤å§‹ã€‚å¦å¤–å¾ªç¯æœç´¢çš„èŒƒå›´ä¹Ÿä¸å¿…ä»2å¼€å§‹ï¼Œæ ¹æ®æˆ‘ä»¬çš„ç­–ç•¥å¯ä»¥å‘ç°æ¯è½®å‘ç°çš„æœ€å°ç´ å› å­å¿…ç„¶ä¸Šä¸€è½®æ‰¾åˆ°çš„æœ€å°ç´ å› å­ï¼ˆå¦åˆ™å¿…ç„¶æ›´æ—©æ‰¾åˆ°ï¼‰ï¼Œå› æ­¤å¯ä»¥å°†å¾ªç¯èŒƒå›´å®šä¸ºï¼ˆäº‹å®è¯æ˜æ¯”æ›´å¿«ï¼‰ã€‚å¦å¤–æ¯æ‰¾åˆ°ä¸€ä¸ªå°±æ›´æ–°å¹¶é‡æ–°å¼€å§‹å¾ªç¯ï¼Œç›´åˆ°ä¸å†å˜åŒ–ä¸ºæ­¢ã€‚\nå¦‚æ­¤ä¸€æ¥ï¼Œæˆ‘ä»¬å°±èƒ½å¯¹æœç´¢åŒºé—´çš„ä¸¤ç«¯åŒæ—¶è¿›è¡Œä¼˜åŒ–ï¼Œè¿è¡Œæ—¶ç”¨ä¸€ä¸ªmapè®°å½•æ¯ä¸ªå‡ºç°çš„æ¬¡æ•°æœ€åç»Ÿä¸€è¾“å‡ºå³å¯ã€‚\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;int, int&gt; pf;\n    int n, m = -1, pre = 2;\n    cin &gt;&gt; n;\n    cout &lt;&lt; n &lt;&lt; \"=\";\n    if (n == 1) cout &lt;&lt; \"1\";\n    else\n    {\n        while (m != n)\n        {\n            m = n;\n            for (int i = pre; i &lt;= n / 2; ++i)\n                if (n % i == 0)\n                {\n                    pf[i] += 1;\n                    n /= (pre = i);\n                    break;\n                }\n        }\n        pf[n] += 1;\n        bool flag = true;\n        for (auto &amp;k: pf)\n            cout &lt;&lt; (flag ? (flag = false, \"\") : \"*\") &lt;&lt; k.first &lt;&lt; (k.second == 1 ? \"\" : \"^\" + to_string(k.second));\n    }\n}\n","slug":"ã€Œ1059ã€Prime-Factors","date":"2022-09-08T13:23:41.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,prime","author_index":"Starlit Rover"},{"id":"2d08ef1e83c7532f13470f67dbd15fc9","title":"ã€Œ1058ã€A+B in Hogwarts","content":"If you are a fan of Harry Potter, you would know the world of magic has its own currency system â€“ as Hagrid explained it to Harry, â€œSeventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, itâ€™s easy enough.â€ Your job is to write a program to computeÂ A+BÂ whereÂ AÂ andÂ BÂ are given in the standard form ofÂ Galleon.Sickle.KnutÂ (GalleonÂ is an integer in ,Â SickleÂ is an integer in , andÂ KnutÂ is an integer in ).\n\n\nInput Specification:Each input file contains one test case which occupies a line withÂ AÂ andÂ BÂ in the standard form, separated by one space.\nOutput Specification:For each test case you should output the sum ofÂ AÂ andÂ BÂ in one line, with the same format as the input.\nSample Input:3.2.1 10.16.27\n\nSample Output:14.1.28\n\n\nÎ©ä¸éš¾ï¼Œå¯ä»¥çœ‹æˆæ˜¯ä¸€ä¸ªå„æ•°ä½è¿›åˆ¶ä¸åŒçš„ä¸‰ä½æ•°ç›¸åŠ ï¼Œä¸ªä½æ•°æ˜¯29è¿›åˆ¶ï¼Œåä½æ˜¯17è¿›åˆ¶ï¼Œè¾“å‡ºæœ€ç»ˆå’Œã€‚\næƒ³ç”¨tupleç»ƒç»ƒæ‰‹ï¼ˆæ¸©é¦¨æç¤ºï¼šäº‹å®è¯æ˜æ²¡äº‹ä¸è¦ç”¨å¥‡å¥‡æ€ªæ€ªçš„å®¹å™¨ï¼‰ï¼Œç„¶åå‘ç°tupleçš„å–å…ƒç´ å‡½æ•°get&lt;&gt;()æ˜¯ä¸€ä¸ªæ¨¡ç‰ˆå‡½æ•°ï¼Œå°–æ‹¬å·å†…çš„å€¼å¿…é¡»åœ¨ç¼–è¯‘é˜¶æ®µç¡®å®šï¼Œå› æ­¤ä¸èƒ½æ˜¯å˜é‡ã€‚å¹¸å¥½åªæœ‰ä¸‰ä½ï¼Œæšä¸¾ä¸€æ³¢ã€‚ã€‚ã€‚ä¹Ÿå¾ˆç´¯ï¼Œå¦å¤–åªè¦è®¾ç½®ä¸€ä¸ªcarryå˜é‡æ¨¡æ‹Ÿç«–å¼åŠ æ³•å³å¯ã€‚\n\n#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\nusing namespace std;\n\nint main()\n{\n    tuple&lt;int, int, int&gt; a, b, c;\n    scanf(\"%d.%d.%d %d.%d.%d\", &amp;get&lt;0&gt;(a), &amp;get&lt;1&gt;(a), &amp;get&lt;2&gt;(a), &amp;get&lt;0&gt;(b), &amp;get&lt;1&gt;(b), &amp;get&lt;2&gt;(b));\n    int carry = 0;\n    get&lt;2&gt;(c) = (get&lt;2&gt;(a) + get&lt;2&gt;(b) + carry) % 29;\n    carry = (get&lt;2&gt;(a) + get&lt;2&gt;(b) + carry) / 29;\n    get&lt;1&gt;(c) = (get&lt;1&gt;(a) + get&lt;1&gt;(b) + carry) % 17;\n    carry = (get&lt;1&gt;(a) + get&lt;1&gt;(b) + carry) / 17;\n    get&lt;0&gt;(c) = get&lt;0&gt;(a) + get&lt;0&gt;(b) + carry;\n    printf(\"%d.%d.%d\", get&lt;0&gt;(c), get&lt;1&gt;(c), get&lt;2&gt;(c));\n}\n","slug":"ã€Œ1058ã€A-B-in-Hogwarts","date":"2022-09-08T12:03:34.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,tuple","author_index":"Starlit Rover"},{"id":"c3a496a07a213e1385fa77bc05492d6e","title":"ã€Œ1057ã€Stack","content":"Stack is one of the most fundamental data structures, which is based on the principle of Last In First Out (LIFO). The basic operations include Push (inserting an element onto the top position) and Pop (deleting the top element). Now you are supposed to implement a stack with an extra operation: PeekMedian â€“ return the median value of all the elements in the stack. WithÂ NÂ elements, the median value is defined to be theÂ -th smallest element ifÂ NÂ is even, or -th ifÂ NÂ is odd.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ . ThenÂ NÂ lines follow, each contains a command in one of the following 3 formats:\nPush key\nPop\nPeekMedian\n\nwhereÂ keyÂ is a positive integer no more thanÂ .\nOutput Specification:For eachÂ PushÂ command, insertÂ keyÂ into the stack and output nothing. For eachÂ PopÂ orÂ PeekMedianÂ command, print in a line the corresponding returned value. If the command is invalid, printÂ InvalidÂ instead.\nSample Input:17\nPop\nPeekMedian\nPush 3\nPeekMedian\nPush 2\nPeekMedian\nPush 1\nPeekMedian\nPop\nPop\nPush 5\nPush 4\nPeekMedian\nPop\nPop\nPop\nPop\n\nSample Output:Invalid\nInvalid\n3\n2\n2\n1\n2\n4\n4\n5\n3\nInvalid\n\n\nÎ©æœ¬ä»¥ä¸ºæ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿæ ˆçš„å°é¢˜ï¼Œæ²¡æƒ³åˆ°å¤–åŠ PeekMedianåŠŸèƒ½ï¼›æœ¬ä»¥ä¸ºåªéœ€è¾“å‡ºæ ˆä¸­é—´å…ƒç´ å³å¯ï¼Œæ²¡æƒ³åˆ°æ˜¯æ‰€æœ‰å…ƒç´ æ’åºåçš„ä¸­é—´å…ƒç´ ã€‚\næœ¬æ¥æƒ³ç”¨multisetå®¹å™¨æ¥å®ç°å…ƒç´ è‡ªåŠ¨æ’åºçš„ï¼Œä¸è¿‡ä¸­é—´å…ƒç´ çš„è¿­ä»£å™¨å¹¶ä¸å¥½æ±‚ã€‚ä¸æƒ³è¶…æ—¶è¿˜æ˜¯åªèƒ½ç”¨çº¿æ€§å®¹å™¨vector+äºŒåˆ†æœç´¢ã€‚\næ€æƒ³éå¸¸çº¯æœ´ï¼Œä¸€ä¸ªstackæ¥æ¨¡æ‹Ÿï¼Œä¸€ä¸ªvectoræ¥æ’åºã€‚vectorçš„æ’å…¥å’Œåˆ é™¤éƒ½ä½¿ç”¨äºŒåˆ†æœç´¢æ¥å¯»æ‰¾ä½ç½®ï¼Œå‹‰å‹‰å¼ºå¼ºä¸ä¼šè¶…æ—¶ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, left, right, mid;\n    cin &gt;&gt; n;\n    stack&lt;int&gt; stk;\n    vector&lt;int&gt; order;\n    string s;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; s;\n        if (s == \"Push\")\n        {\n            cin &gt;&gt; m;\n            left = 0, right = stk.size(), mid = (left + right) / 2;\n            while (left &lt; right - 1)\n            {\n                (order[mid] &gt; m) ? (right = mid) : (left = mid);\n                mid = (left + right) / 2;\n            }\n            int fix = (!order.empty() &amp;&amp; order[left] &lt; m) ? 1 : 0;\n            order.insert(order.begin() + left + fix, m);\n            stk.push(m);\n        }\n        else if (!stk.empty())\n        {\n            if (s == \"Pop\")\n            {\n                int t = stk.top();\n                cout &lt;&lt; t &lt;&lt; endl;\n                left = 0, right = stk.size(), mid = (left + right) / 2;\n                while (left &lt; right)\n                {\n                    if (order[mid] != t)\n                        (order[mid] &gt; t) ? (right = mid) : (left = mid);\n                    else break;\n                    mid = (left + right) / 2;\n                }\n                stk.pop();\n                order.erase(order.begin() + mid);\n            }\n            else\n                cout &lt;&lt; order[(stk.size() - 1) / 2] &lt;&lt; endl;\n        }\n        else\n            cout &lt;&lt; \"Invalid\" &lt;&lt; endl;\n    }\n}\n\n\nTipsä¸¤æ¬¡äºŒåˆ†æœç´¢è¿˜æ˜¯æœ‰ç‚¹å·®å¼‚çš„ï¼ŒPopæ—¶ä½ å¯ä»¥ç¡®å®šå­˜åœ¨è¯¥å…ƒç´ ï¼Œåªè¦order[mid]==valueÂ Â Â Â å³å¯é€€å‡ºå¾ªç¯ï¼Œè€ŒPushæ—¶æˆ‘ä»¬å¯»æ‰¾çš„æ˜¯æ’å…¥è¯¥å…ƒç´ çš„ä½ç½®ï¼Œé€€å‡ºå¾ªç¯çš„æ—¶å€™rightå’Œlleftæœ€å¤šå·®1ï¼ˆleft &lt; right - 1ä¸ºé˜²æ­¢right=left+1 &amp;&amp; mid==leftæ—¶è€Œæ— é™å¾ªç¯ï¼‰ï¼Œæ­¤æ—¶order[mid]æ—¢æœ‰å¯èƒ½==mï¼Œä¹Ÿæœ‰å¯èƒ½&lt;mï¼Œåè€…ä¸èƒ½ç›´æ¥æ’å…¥ï¼Œå› æ­¤å¼•å…¥ä¸€ä¸ªfixå¯¹ä½ç½®è¿›è¡Œä¿®æ­£ã€‚\n","slug":"ã€Œ1057ã€Stack","date":"2022-09-08T02:14:58.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search,stack","author_index":"Starlit Rover"},{"id":"f2cca43e895bb7a04b6723f4b34dca34","title":"ã€Œ1056ã€Mice and Rice","content":"Mice and RiceÂ is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse.\nFirst the playing order is randomly decided forÂ Â programmers. Then everyÂ â€‹Â programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every Â â€‹Â winners are then grouped in the next match until a final winner is determined.\nFor the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers:Â â€‹Â andÂ , the number of programmers and the maximum number of mice in a group, respectively. If there are less than Â â€‹Â mice at the end of the playerâ€™s list, then all the mice left will be put into the last group. The second line containsÂ NPâ€‹Â distinct non-negative numbersÂ  where eachÂ Â is the weight of theÂ -th mouse respectively. The third line gives the initial playing order which is a permutation ofÂ Â (assume that the programmers are numbered from 0 toÂ ). All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the final ranks in a line. TheÂ -th number is the rank of theÂ -th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line.\nSample Input:11 3\n25 18 0 46 37 3 19 22 57 56 10\n6 0 8 7 10 5 9 1 4 2 3\n\nSample Output:5 5 5 2 5 5 5 3 1 3 5\n\n\nÎ©å¥‡å¥‡æ€ªæ€ªï¼Œè«åå…¶å¦™ã€‚\nç”±äºå¯¹é¢˜ç›®çš„é«˜è¶…è§£è¯»ï¼Œå¯¼è‡´æˆ‘æ‰‹ç®—Sampleéƒ½ç®—ä¸å‡ºOutputã€‚\nå¯¹åªè€é¼ çš„ä½“é‡è¿›è¡Œåˆ†ç»„æ¯”è¾ƒï¼Œæ¯ç»„ä¸è¶…è¿‡ä¸ªè€é¼ ã€‚æ¯ç»„æœ€èƒ–çš„é‚£åªè‚¥ä»”å°†èµ¢å¾—ç»„å†…æ¯”èµ›ï¼Œè¿›å…¥ä¸‹ä¸€è½®æ¯”èµ›ï¼Œæ¯ç»„è¾“æ‰çš„è€é¼ éƒ½å°†è·å¾—ç›¸åŒçš„åæ¬¡ã€‚ä¸‹ä¸€è½®æ¯”èµ›è¿˜æ˜¯æŒ‰ç…§ä¸è¶…è¿‡ä¸ªè€é¼ è¿›è¡Œåˆ†ç»„æ¯”èµ›ï¼Œä»¥åŒæ ·çš„æ–¹å¼é€‰æ‹©å‡ºwinnerè¿›å…¥ä¸‹ä¸€è½®ç›´è‡³è¯ç”Ÿç¬¬ä¸€åè‚¥ä»”ã€‚\nè¾“å…¥å°±ä¸‰è¡Œï¼Œå‰ä¸¤è¡Œå°±æ˜¯å’Œå„ä¸ªè€é¼ çš„ä½“é‡ï¼Œè€Œç¬¬ä¸‰è¡Œé¢˜ç›®ä¸­è¯´æ˜¯â€œinitial playing orderâ€ï¼Œå³åˆå§‹æ¯”èµ›é¡ºåºã€‚é‚£ä¹ˆæˆ‘æƒ³0å·æ˜¯ç¬¬ä¸€ä½é€‰æ‰‹ï¼Œè€Œæ˜¯æœ€åä¸€ä½é€‰æ‰‹ï¼Œç»“æœå‘ç°ç®—å‡ºæ¥ä¸å¯¹ï¼Œæ‡µäº†ã€‚å…¶å®ç¬¬äºŒè¡Œå·²ç»ç»™æ¯ä¸ªè€é¼ æŒ‰ç…§é¡ºåºç¼–äº†å·ï¼Œç¬¬ä¸‰è¡Œæ˜¯æ ¹æ®ç¼–å·ç»™å‡ºå‚èµ›é¡ºåºï¼Œï¼Œï¼Œå¯èƒ½ä¸­åˆåƒå¤ªå¤šæŠŠè„‘å­å¡ä½äº†ã€‚\n\n\nç”±äºæœ€åéœ€è¦æŒ‰ç¼–å·è¾“å‡ºï¼Œå› æ­¤å¯ä»¥ç”¨pairè®°å½•æ¯åªè€é¼ çš„ä½“é‡å’Œç¼–å·ï¼Œç„¶åæ ¹æ®å‚èµ›é¡ºåºå¯¹è€é¼ è¿›è¡Œæ’åˆ—ï¼š\nfor (int i = 0; i &lt; np; ++i)\n{\n    cin &gt;&gt; k;\n    order[k] = i;\n}\nsort(weight.begin(), weight.end(), [](pii &amp;a, pii &amp;b) { return order[a.second] &lt; order[b.second]; });    \n\næ¥ä¸‹æ¥æ¯åªè€é¼ é€‰å‡ºæœ€èƒ–è‚¥ä»”ä½œä¸ºèµ¢å®¶ï¼Œå¹¶å°†å…¶çš„åæ¬¡èµ‹ä¸ºï¼ˆå…¶ä¸­wä¸ºæœ¬è½®å°†è¦é€‰å‡ºçš„èµ¢å®¶æ•°ï¼Œ-1è§£å†³äº†æ•´é™¤æ—¶æ— éœ€+1çš„é—®é¢˜ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´å…ˆæŠŠè¿›å…¥ä¸‹ä¸€è½®æ¯”èµ›è€é¼ çš„åæ¬¡éƒ½èµ‹æˆä¸‹ä¸€è½®è¾“å®¶çš„åæ¬¡ï¼Œé‚£ä¹ˆåªè¦è®¡ç®—ä¸‹ä¸€è½®èµ¢å®¶æ•°+1å³å¯ã€‚ç›´åˆ°é€‰å‡ºå”¯ä¸€çš„èµ¢å®¶ç»“æŸã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;pair&lt;int, int&gt;&gt; weight;\nvector&lt;int&gt; order;\ntypedef pair&lt;int, int&gt; pii;\n\nint main()\n{\n    int np, ng, k;\n    cin &gt;&gt; np &gt;&gt; ng;\n    order.resize(np);\n    for (int i = 0; i &lt; np; ++i)\n    {\n        cin &gt;&gt; k;\n        weight.emplace_back(k, i);\n    }\n    for (int i = 0; i &lt; np; ++i)\n    {\n        cin &gt;&gt; k;\n        order[k] = i;\n    }\n    sort(weight.begin(), weight.end(), [](pii &amp;a, pii &amp;b) { return order[a.second] &lt; order[b.second]; });\n    int r = np == 1 ? 1 : (np - 1) / ng + 2;\n    vector&lt;int&gt; rank(np, r);\n    vector&lt;pii&gt; next;\n    while (weight.size() != 1)\n    {\n        r = r == 2 ? 1 : (r - 2) / ng + 2;\n        for (int i = 0; i &lt; weight.size(); i += ng)\n        {\n            int maxw = weight[i].first;\n            auto iter = weight.begin() + i;\n            for (int j = i + 1; j &lt; i + ng &amp;&amp; j &lt; weight.size(); ++j)\n                if (weight[j].first &gt; maxw)\n                {\n                    maxw = weight[j].first;\n                    iter = weight.begin() + j;\n                }\n            rank[iter-&gt;second] = r;\n            next.push_back(*iter);\n        }\n        weight = std::move(next);\n        next = vector&lt;pii&gt;();\n    }\n    for (int i = 0; i &lt; np; ++i)\n        cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; rank[i];\n}\n\n\nTipsä½ å¯èƒ½ä¼šå¯¹r = r == 2 ? 1 : (r - 2) / ng + 2;æ„Ÿåˆ°ç–‘æƒ‘ï¼Œä¸ºä»€ä¹ˆéœ€è¦å¯¹2å•ç‹¬è®¾ç½®ä¸€ç§æƒ…å†µã€‚ç»è¿‡ä¸Šé¢çš„è®²è§£ï¼Œä½ ä¼šçŸ¥é“åé¢é‚£ä¸ªå¼å­è®¡ç®—çš„å°±æ˜¯ä¸‹ä¸€è½®è¾“å®¶çš„åæ¬¡ï¼Œé‚£ä¹ˆæˆ‘ä»¬æŠŠ2ä»£å…¥ä¼šå‘ç°ç»“æœè¿˜æ˜¯2ï¼Œ2ä¼¼ä¹æ˜¯ä¸€ä¸ªä¸åŠ¨ç‚¹ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆæ— æ³•è®¡ç®—å‡ºæ’å1çš„ç»“æœå‘¢ï¼Ÿé¦–å…ˆr=2æ˜¯è¯¥è½®è¾“å®¶çš„åæ¬¡ï¼Œé‚£ä¹ˆä¸‹ä¸€è½®å¾ˆæ˜¾ç„¶å°±åªæœ‰ä¸€ä¸ªäººå‚èµ›äº†ã€‚æˆ‘ä»¬è®¡ç®—ä¸‹ä¸€è½®è¾“å®¶åæ¬¡çš„æ€è·¯å¾ˆç®€å•ï¼Œå°±æ˜¯è®¡ç®—æ¯”èµ›ç»„æ•°+1ï¼Œæ³¨æ„åˆ°è¿™ä¸ªåæ¬¡å°±æ˜¯é€šè¿‡æ’é™¤æ‰æ‰€æœ‰èµ¢å®¶æ‰è®¡ç®—å‡ºæ¥ç»™è¾“å®¶çš„ã€‚ç„¶è€Œä¸€ä¸ªäººçš„æ¯”èµ›ä¸­é‚£ä¸ªäººæ—¢æ˜¯èµ¢å®¶ä¹Ÿæ˜¯è¾“å®¶ï¼Œæ‰€ä»¥è®¡ç®—å‡ºæ¥çš„åæ¬¡2æ ¹æœ¬ä¸ä¼šè½åˆ°å·²ç»è¢«ä½œä¸ºèµ¢å®¶è€Œæ’é™¤çš„ä»–å¤´ä¸Šï¼Œä¹Ÿå°±æ¯«æ— æ„ä¹‰ã€‚è¿™æ˜¯ä¸€ä¸ªæŒºæœ‰æ„æ€çš„é€»è¾‘æ‚–è®ºã€‚\n","slug":"ã€Œ1056ã€Mice-and-Rice","date":"2022-09-07T09:55:58.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"a7cca520edea6b39e829c30cbac4d862","title":"ã€Œ1055ã€The World's Richest","content":"Forbes magazine publishes every year its list of billionaires based on the annual ranking of the worldâ€™s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths ofÂ NÂ people, you must find theÂ MÂ richest people in a given range of their ages.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers:Â  - the total number of people, andÂ  - the number of queries. ThenÂ NÂ lines follow, each contains the name (string of no more than 8 characters without space), age (integer in ), and the net worth (integer in ) of a person. Finally there areÂ KÂ lines of queries, each contains three positive integers:Â  - the maximum number of outputs, and [Amin,Â Amax] which are the range of ages. All the numbers in a line are separated by a space.\nOutput Specification:For each query, first print in a lineÂ Case #X:Â whereÂ XÂ is the query number starting from 1. Then output theÂ MÂ richest people with their ages in the range [Amin,Â Amax]. Each personâ€™s information occupies a line, in the format\nName Age Net_Worth\n\nThe outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, outputÂ None.\nSample Input:12 4\nZoe_Bill 35 2333\nBob_Volk 24 5888\nAnny_Cin 95 999999\nWilliams 30 -22\nCindy 76 76000\nAlice 18 88888\nJoe_Mike 32 3222\nMichael 5 300000\nRosemary 40 5888\nDobby 24 5888\nBilly 24 5888\nNobody 5 0\n4 15 45\n4 30 35\n4 5 95\n1 45 50\n\nSample Output:Case #1:\nAlice 18 88888\nBilly 24 5888\nBob_Volk 24 5888\nDobby 24 5888\nCase #2:\nJoe_Mike 32 3222\nZoe_Bill 35 2333\nWilliams 30 -22\nCase #3:\nAnny_Cin 95 999999\nMichael 5 300000\nAlice 18 88888\nCindy 76 76000\nCase #4:\nNone\n\n\nÎ©åˆæ˜¯ä¸€é“åå•ç½—åˆ—é¢˜ï¼Œç»™å‡ºç¦å¸ƒæ–¯æ’è¡Œæ¦œä¸Šæ‰€æœ‰ç”¨æˆ·çš„å§“åã€å¹´é¾„å’Œèº«ä»·ï¼Œéœ€è¦ä½ è¾“å‡ºç»™å®šå¹´é¾„æ®µä¹‹é—´èº«ä»·æœ€é«˜çš„å‰Mä½ç”¨æˆ·ä¿¡æ¯ï¼Œè‹¥èº«ä»·ä¸€è‡´åˆ™æŒ‰å¹´é¾„é™åºæ’åˆ—ï¼Œè‹¥å¹´é¾„ä¹Ÿä¸€è‡´åˆ™æŒ‰å§“åé™åºæ’åˆ—ã€‚ä¸å­˜åœ¨è¾“å‡ºNoneã€‚\næ²¡æƒ³åˆ°C++é‡Œæœ‰tupleè¿™ç§ç¥å¥‡çš„æ•°æ®ç»“æ„ï¼Œæœ¬è´¨ä¸Šæ˜¯æ³›åŒ–çš„pairå®¹å™¨ï¼Œæ˜¯ä¸€ä¸ªå¯ä»¥åŒ…å«ä¸åŒç±»å‹æ•°æ®çš„ç»“æ„ä½“ç±»å‹ï¼Œé‚£ä¹ˆç”¨æˆ·ä¿¡æ¯å°±æ— éœ€å»ºclassäº†ã€‚\nç”±äºæœ€ç»ˆéœ€è¦è¾“å‡ºæŒ‡å®šå¹´é¾„æ®µä¹‹é—´èº«ä»·æœ€é«˜çš„äººï¼Œå› æ­¤ä¸èƒ½ç®€å•åœ°é€šè¿‡å‡ æ¬¡sortå°±ç›´æ¥è¾“å‡ºã€‚ä½†æ€æƒ³ä¹Ÿå¾ˆç®€å•ï¼ŒæŒ‰ç…§ã€èº«ä»·&gt;å¹´é¾„&gt;å§“åã€‘çš„ä¼˜å…ˆçº§å¯¹æ‰€æœ‰ç”¨æˆ·è¿›è¡Œæ’åºï¼Œç„¶åä»é«˜èº«ä»·å¼€å§‹éå†ï¼ŒåŒæ—¶è®¡æ•°ç¬¦åˆç»™å®šå¹´é¾„æ®µçš„ç”¨æˆ·ä¸ªæ•°ï¼Œä¸€æ—¦è¾¾åˆ°Mä¾¿é€€å‡ºå¾ªç¯ã€‚\nä¸€å¼€å§‹æ‡’å¾—å†™compareå‡½æ•°ï¼Œç›´æ¥å°±sortäº†3æ¬¡ï¼š\n// sort name\nsort(info.begin(),info.end(),[](tsii &amp;a,tsii &amp;b){return get&lt;0&gt;(a)&lt; get&lt;0&gt;(b);});\n// sort age \nsort(info.begin(),info.end(),[](tsii &amp;a,tsii &amp;b){return get&lt;1&gt;(a)&lt; get&lt;1&gt;(b);});\n// sort net worths\nsort(info.begin(),info.end(),[](tsii &amp;a,tsii &amp;b){return get&lt;2&gt;(a)&gt; get&lt;2&gt;(b);});\n\næäº¤åå‘ç°æœ‰ä¸¤ä¸ªæ•°æ®é‡è¾ƒå¤§çš„æµ‹è¯•ç‚¹æŒ‚äº†ï¼Œå¯ä»¥è¯´æ˜ä¸€ç‚¹ï¼šsortå‡½æ•°åœ¨å¤„ç†å¤§é‡æ•°æ®æ—¶é‡‡ç”¨çš„ä¸æ˜¯ç¨³å®šæ’åºç®—æ³•ï¼Œå³åœ¨cmpå‡½æ•°ä¸­æ»¡è¶³ï¼ˆæ³¨æ„cmpå‡½æ•°å¿…é¡»ä¸¥æ ¼å¼±åºï¼‰çš„ä¸¤ä¸ªå¯¹è±¡åœ¨æ’åºåæ¬¡åºä¼šå’ŒåŸå…ˆä¸åŒï¼ˆP.s. äº‹å®ä¸Šç¨³å®šæ’åºå¯ä»¥ç”¨stable_sortå‡½æ•°ï¼‰ã€‚æ‰€ä»¥åªèƒ½è‡ªå·±å†™ä¸ªcmpå‡½æ•°äº†ï¼š\nbool cmp(tsii &amp;a, tsii &amp;b)\n{\n    if (get&lt;2&gt;(a) != get&lt;2&gt;(b))\n        return get&lt;2&gt;(a) &gt; get&lt;2&gt;(b);\n    else if(get&lt;1&gt;(a) != get&lt;1&gt;(b))\n        return get&lt;1&gt;(a) &lt; get&lt;1&gt;(b);\n    else\n        return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);\n}\n\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tuple&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef tuple&lt;string, int, int&gt; tsii;\n\ninline bool cmp(tsii &amp;a, tsii &amp;b)\n{\n    if (get&lt;2&gt;(a) != get&lt;2&gt;(b))\n        return get&lt;2&gt;(a) &gt; get&lt;2&gt;(b);\n    else if (get&lt;1&gt;(a) != get&lt;1&gt;(b))\n        return get&lt;1&gt;(a) &lt; get&lt;1&gt;(b);\n    else\n        return get&lt;0&gt;(a) &lt; get&lt;0&gt;(b);\n}\n\nint main()\n{\n    vector&lt;tsii&gt; info;\n    int n, k, age, net;\n    string name;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; age &gt;&gt; net;\n        info.emplace_back(name, age, net);\n    }\n    sort(info.begin(), info.end(), &amp;cmp);\n    int m, amin, amax, cnt;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cnt = 0;\n        cin &gt;&gt; m &gt;&gt; amin &gt;&gt; amax;\n        printf(\"Case #%d:\\n\", i + 1);\n        for (auto &amp;t: info)\n            if (get&lt;1&gt;(t) &gt;= amin &amp;&amp; get&lt;1&gt;(t) &lt;= amax)\n            {\n                printf(\"%s %d %d\\n\", get&lt;0&gt;(t).c_str(), get&lt;1&gt;(t), get&lt;2&gt;(t));\n                if (++cnt == m)\n                    break;\n            }\n        if (cnt == 0)\n            printf(\"None\\n\");\n    }\n}\n","slug":"ã€Œ1055ã€The-World-s-Richest","date":"2022-09-06T12:17:47.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,tuple","author_index":"Starlit Rover"},{"id":"f1b87526b0a747be6a4f224868f65aa7","title":"ã€Œ1053ã€Path of Equal Weight","content":"Given a non-empty tree with rootÂ R, and with weightÂ Wiâ€‹Â assigned to each tree nodeÂ Tiâ€‹. TheÂ weight of a path fromÂ RÂ toÂ LÂ is defined to be the sum of the weights of all the nodes along the path fromÂ RÂ to any leaf nodeÂ L.\nNow given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, letâ€™s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.\n\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containingÂ , the number of nodes in a tree,Â , the number of non-leaf nodes, andÂ , the given weight number. The next line containsÂ NÂ positive numbers whereÂ  corresponds to the tree nodeÂ . ThenÂ MÂ lines follow, each in the format:\nID K ID[1] ID[2] ... ID[K]\n\nwhereÂ IDÂ is a two-digit number representing a given non-leaf node,Â KÂ is the number of its children, followed by a sequence of two-digitÂ IDâ€˜s of its children. For the sake of simplicity, let us fix the root ID to beÂ 00.\nOutput Specification:For each test case, print all the paths with weight S inÂ non-increasingÂ order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.\nNote: sequenceÂ is said to beÂ greater thanÂ sequenceÂ if there existsÂ Â such thatÂ Â forÂ , andÂ .\nSample Input:20 9 24\n10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2\n00 4 01 02 03 04\n02 1 05\n04 2 06 07\n03 3 11 12 13\n06 1 09\n07 2 08 10\n16 1 15\n13 3 14 16 17\n17 2 18 19\n\nSample Output:10 5 2 7\n10 4 10\n10 3 3 6 2\n10 3 3 6 2\n\n\n\nÎ©\nè¾“å‡ºæ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹æƒé‡å’Œä¸ºç»™å®šå€¼çš„æƒé‡è·¯å¾„ã€‚\nå…¶å®ä¸Šé¢è¿™ä¸ªçœŸçš„å°å„¿ç§‘ï¼Œä¸ç®¡æ˜¯DFSè¿˜æ˜¯BFSéƒ½ä¸‰ä¸‹äº”é™¤äºŒï¼Œè¿™ä¸ªè¾“å‡ºé¡ºåºæ˜¯çœŸçš„éº»çƒ¦ï¼Œå®³å¾—æˆ‘é‡æ„äº†ä¸¤æ¬¡ã€‚\nè®²è®²æˆ‘çš„å¿ƒè·¯å†ç¨‹å§ã€‚ä¸€å¼€å§‹æƒ³çš„æ¯”è¾ƒç²—ç³™ï¼Œè§‰å¾—è¾“å‡ºé¡ºåºåº”è¯¥å’ŒBFSæ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥ä¸Šæ¥å°±BFSæ‰¾åˆ°æƒé‡å’Œç¬¦åˆè¦æ±‚çš„æ‰€æœ‰å¶å­ç»“ç‚¹ï¼Œæ ¹æ®çˆ¶èŠ‚ç‚¹è¿›è¡Œå›æº¯ç„¶åä¾æ¬¡è¾“å‡ºã€‚ç„¶åå°±å‘ç°æœ€å…ˆè¾“å‡ºçš„åªèƒ½è¯´æ˜è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°æ˜¯æœ€å°‘çš„ï¼Œä¸­é—´èŠ‚ç‚¹çš„æƒé‡ä¹Ÿå¯ä»¥è¾ƒå°ã€‚\nè½¬å¿µä¸€æƒ³ï¼Œè¾“å‡ºé¡ºåºçš„æ€æƒ³æ˜¯æ¯æ¬¡å…ˆæ‰¾æƒé‡è¾ƒå¤§çš„èŠ‚ç‚¹è¿›è¡Œéå†ï¼Œäº‹å®ä¸Šä¸DFSæ˜¯ä¸€è‡´çš„ï¼Œæˆ‘ä»¬åªéœ€è¦å°†ä¾¿åˆ©çš„é¡ºåºå…ˆå¯¹æƒé‡æ’åºä¸€éå³å¯ã€‚äºæ˜¯ä¹ç®€å•åœ°é‡æ„äº†ä¸‹ä»£ç ï¼Œè¿˜æ˜¯å¾ˆå¿«çš„ï¼Œæ˜¥é£æ‹‚é¢ï¼Œå°æ‰‹ä¸€ç‚¹ã€‚å”¯æœ‰æœ€åä¸€ä¸ªæµ‹è¯•ç‚¹æ˜¯ç»¿çš„ï¼Œç™¾æ€ä¸å¾—å…¶è§£ï¼Œå¤œæ·±äº†ï¼Œçœ‹äº†äº›ç½‘ä¸Šçš„é¢˜è§£ï¼Œè±ç„¶å¼€æœ—ï¼Œé—®é¢˜å°±åœ¨äºå¯¹æƒé‡ç›¸åŒèŠ‚ç‚¹çš„ä¾¿åˆ©é¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼Œæœ€å…¸å‹çš„æ —å­å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œç”±äºç¬¬äºŒå±‚æƒé‡ç›¸ç­‰ï¼Œå› æ­¤å¯èƒ½ä¼šå…ˆå¾€å·¦è¾¹éå†ã€‚\n\n\nå½“ç„¶å®åœ¨ä¸è¡Œæˆ‘ä»¬å°±å…ˆä¸€è‚¡è„‘å„¿æ‰¾åˆ°æ‰€æœ‰èŠ‚ç‚¹æœ€åå†ä¸€èµ·æ’ä¸ªåºï¼Œä½†æ²¡ä»€ä¹ˆæ„æ€ã€‚æˆ‘æƒ³å€ŸåŠ©å¹¶æŸ¥é›†çš„æ€æƒ³ï¼Œå°†å±äºåŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹è€Œä¸”æƒé‡ç›¸åŒçš„å­èŠ‚ç‚¹è¿›è¡Œåˆå¹¶ï¼Œå³ä¸€ä¸ªèŠ‚ç‚¹ä¸ä¼šå­˜åœ¨æƒé‡ä¸€æ ·çš„å­èŠ‚ç‚¹ï¼Œå¦‚æ­¤ä¸€æ¥å°±å¯ä»¥æŠŠè¿™äº›åŒæƒå¼‚çˆ¶åŒçˆ·ï¼ˆè¿™äº›çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ç›¸åŒï¼‰çš„å­èŠ‚ç‚¹æ”¾åœ¨ä¸€èµ·sortäº†ã€‚\nå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š\n\nè®¾ç½®ä¸€ä¸ªå‘é‡ï¼Œç”¨æ¥è¡¨ç¤ºèŠ‚ç‚¹å°†è‡ªå·±æ‰€æœ‰å­èŠ‚ç‚¹æ‰˜ä»˜ç»™åŒæƒåŒçˆ¶çš„èŠ‚ç‚¹\nâš ï¸æˆ‘ä»¬éœ€è¦å°†å¶èŠ‚ç‚¹çš„å±æ€§ä¹Ÿä¸€å¹¶æ‰˜ä»˜ï¼Œè®©DFSçŸ¥é“è¿™ä¸ªèŠ‚ç‚¹ä¹Ÿèƒ½ä½œä¸ºå¶å­èŠ‚ç‚¹ï¼š\n\n\næ¯è¯»å…¥éå¶å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ—¶ï¼Œå»ºç«‹ä¸€ä¸ªæƒé‡åˆ°èŠ‚ç‚¹ç¼–å·çš„mapæ˜ å°„ï¼Œè¡¨ç¤ºå½“å‰èŠ‚ç‚¹å·²å­˜åœ¨æƒé‡ä¸ºçš„å­èŠ‚ç‚¹ï¼Œä¹‹åå¯¹æ‰€æœ‰æƒé‡ä¸ºçš„å­èŠ‚ç‚¹ï¼Œéƒ½é‡‡å–ï¼›è‹¥ä¸å­˜åœ¨è¯¥æƒé‡æ˜ å°„åˆ™\n\nå¯¹æ‰€æœ‰èŠ‚ç‚¹æ›´æ–°çˆ¶èŠ‚ç‚¹ï¼šï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹å‹å…¥çœŸæ­£çˆ¶èŠ‚ç‚¹çš„å­©å­å‘é‡ä¸­ï¼š.push_back()\n\nå¯¹æ‰€æœ‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ ¹æ®æƒé‡è¿›è¡Œé™åºæ’åº\n\nä»æ ¹èŠ‚ç‚¹å¼€å§‹DFSï¼Œæœ€åä¾æ¬¡å›æº¯è¾“å‡ºæƒé‡è·¯å¾„\n\n\n\n\nğŸğŸ§¬\nBFS#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, s, id, k, child;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n    vector&lt;int&gt; weight(n), dad(n, -1), ans, nxt, crt, sum(n, 0);\n    for (auto &amp;w: weight)\n        cin &gt;&gt; w;\n    sum[0] = weight[0];\n    vector&lt;vector&lt;int&gt;&gt; children(n);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; k;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; child;\n            dad[child] = id;\n            children[id].push_back(child);\n        }\n    }\n    crt = children[0];\n    while (!crt.empty())\n    {\n        for (auto &amp;c: crt)\n        {\n            sum[c] += sum[dad[c]] + weight[c];\n            if (sum[c] == s &amp;&amp; children[c].empty())\n                ans.push_back(c);\n            else if (sum[c] &lt; s)\n                nxt.insert(nxt.end(), children[c].begin(), children[c].end());\n        }\n        crt = std::move(nxt);\n        nxt = vector&lt;int&gt;();\n    }\n    vector&lt;int&gt; path;\n    for (auto c: ans)\n    {\n        path.push_back(weight[c]);\n        while (dad[c] != -1)\n        {\n            c = dad[c];\n            path.push_back(weight[c]);\n        }\n        for (auto item = path.rbegin(); item &lt; path.rend(); ++item)\n            cout &lt;&lt; (item == path.rbegin() ? \"\" : \" \") &lt;&lt; *item;\n        cout &lt;&lt; endl;\n        path.clear();\n    }\n}\n\n\n\nDFS#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nvector&lt;int&gt; weight, ans, sum;\nvector&lt;vector&lt;int&gt;&gt; children;\nvector&lt;bool&gt; isLeaf;\n\nvoid search(int papa, int &amp;s)\n{\n    if (sum[papa] == s &amp;&amp; isLeaf[papa])\n        ans.push_back(papa);\n    for (auto k: children[papa])\n    {\n        sum[k] = weight[k] + sum[papa];\n        if (sum[k] &lt;= s)\n            search(k, s);\n    }\n}\n\nint main()\n{\n    int n, m, s, id, k, child;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n\n    vector&lt;int&gt; dad(n, -1), real;\n    weight.resize(n);\n    sum.resize(n, 0);\n    isLeaf.resize(n, true);\n    real.resize(n);\n    iota(real.begin(), real.end(), 0);\n\n    for (auto &amp;w: weight)\n        cin &gt;&gt; w;\n    sum[0] = weight[0];\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; k;\n        isLeaf[id] = false;\n        map&lt;int, int&gt; idx;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; child;\n            if (idx.find(weight[child]) == idx.end())\n                idx[weight[child]] = child;\n            else\n            {\n                real[child] = idx[weight[child]];\n                isLeaf[real[child]] = isLeaf[real[child]] || isLeaf[child];\n            }\n            dad[child] = real[id];\n        }\n    }\n\n    children.resize(n);\n    for (int i = 1; i &lt; n; ++i)\n    {\n        dad[i] = real[dad[i]];\n        children[dad[i]].push_back(i);\n    }\n\n    for (auto &amp;v: children)\n        sort(v.begin(), v.end(), [](int &amp;a, int &amp;b) { return weight[a] &gt; weight[b]; });\n\n    search(0, s);\n\n    vector&lt;int&gt; path;\n    for (auto c: ans)\n    {\n        path.push_back(weight[c]);\n        while (dad[c] != -1)\n        {\n            c = dad[c];\n            path.push_back(weight[c]);\n        }\n        for (auto item = path.rbegin(); item &lt; path.rend(); ++item)\n            cout &lt;&lt; (item == path.rbegin() ? \"\" : \" \") &lt;&lt; *item;\n        cout &lt;&lt; endl;\n        path.clear();\n    }\n}\n\n\n\nTips\n\nç»™ä¸€ä¸ªvectorå¢åºèµ‹å€¼ï¼š\n#include &lt;numeric&gt;\n       â€¦â€¦\nvector&lt;int&gt; v(num); //éœ€è¦å…ˆç¡®å®šå‘é‡å¤§å°\niota(v.begin(),v.end(),start);\n\næœ€ç»ˆå°±ä¼šå¾—åˆ°\n\nå°†vector v1æ’å…¥åˆ°v2çš„æœ€åï¼š\nv2.insert(v2.end(), v1.begin(), v1.end());\n\n","slug":"ã€Œ1053ã€Path-of-Equal-Weight","date":"2022-09-04T04:51:05.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,å¹¶æŸ¥é›†,numeric,Tree","author_index":"Starlit Rover"},{"id":"3f7468577cc2a85a47786082d8825b1f","title":"ã€Œ1052ã€Linked List Sorting","content":"A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integerÂ keyÂ and aÂ NextÂ pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positiveÂ  and an address of the head node, whereÂ NÂ is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented byÂ âˆ’1.\nThenÂ NÂ lines follow, each describes a node in the format:\nAddress Key Next\n\nwhereÂ AddressÂ is the address of the node in memory,Â KeyÂ is an integer in , andÂ NextÂ is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.\nOutput Specification:For each test case, the output format is the same as that of the input, whereÂ NÂ is the total number of nodes in the list and all the nodes must be sorted order.\nSample Input:5 00001\n11111 100 -1\n00001 0 22222\n33333 100000 11111\n12345 -1 33333\n22222 1000 12345\n\nSample Output:5 12345\n12345 -1 00001\n00001 0 11111\n11111 100 22222\n22222 1000 33333\n33333 100000 -1\n\n\nÎ©å¯¹é“¾è¡¨è¿›è¡Œæ’åºï¼Œæ˜¾ç„¶æœ¬é¢˜ä¸ç”¨é“¾è¡¨å®¹å™¨ã€‚è¿™ä¸ªä¾‹å­åå¾—å¾ˆï¼Œäº‹å®ä¸Šç»™å‡ºçš„æ‰€æœ‰èŠ‚ç‚¹å¹¶ä¸ä¸€å®šéƒ½åœ¨å¤´èŠ‚ç‚¹æ‰€åœ¨çš„é“¾è¡¨ä¸Šã€‚\né¦–å…ˆè¯»å…¥æ‰€æœ‰èŠ‚ç‚¹å¹¶ç”¨ä¸¤ä¸ªmapåˆ†åˆ«å»ºç«‹ä»addressåˆ°valueå’Œnext addressçš„æ˜ å°„ï¼Œç„¶åæ ¹æ®å¤´èŠ‚ç‚¹éå†è¯¥é“¾è¡¨ä¸Šæ‰€æœ‰èŠ‚ç‚¹å»ºç«‹ä»valueåˆ°addressçš„æ˜ å°„ï¼Œé‚£ä¹ˆæ­¤æ—¶valueä½œä¸ºé”®å€¼å°±å·²æœ‰åºï¼Œæ¥ä¸‹æ¥æŒ‰é¡ºåºè¾“å‡ºå³å¯ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, key;\n    string head, add, nxt;\n    cin &gt;&gt; n &gt;&gt; head;\n    map&lt;string, string&gt; next;\n    map&lt;string, int&gt; keys;\n    map&lt;int, string&gt; addr;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; add &gt;&gt; key &gt;&gt; nxt;\n        keys[add] = key;\n        next[add] = nxt;\n    }\n    while (head != \"-1\")\n    {\n        addr[keys[head]] = head;\n        head = next[head];\n    }\n    cout &lt;&lt; addr.size() &lt;&lt; \" \";\n    for (auto &amp;k: addr)\n        printf(\"%s\\n%s %d \", k.second.c_str(), k.second.c_str(), k.first);\n    cout &lt;&lt; \"-1\";\n}\n","slug":"ã€Œ1052ã€Linked-List-Sorting","date":"2022-09-02T01:38:56.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,list","author_index":"Starlit Rover"},{"id":"78ee87089723b81f295cec55a974e19f","title":"ã€Œ1051ã€Pop Sequence","content":"Given a stack which can keepÂ MÂ numbers at most. PushÂ NÂ numbers in the order of 1, 2, 3, â€¦,Â NÂ and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, ifÂ MÂ is 5 andÂ NÂ is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000):Â MÂ (the maximum capacity of the stack),Â NÂ (the length of push sequence), andÂ KÂ (the number of pop sequences to be checked). ThenÂ KÂ lines follow, each contains a pop sequence ofÂ NÂ numbers. All the numbers in a line are separated by a space.\nOutput Specification:For each pop sequence, print in one line â€œYESâ€ if it is indeed a possible pop sequence of the stack, or â€œNOâ€ if not.\nSample Input:5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\n\nSample Output:YES\nNO\nNO\nYES\nNO\n\n\n\nÎ©\néš¾å¾—è§åˆ°çš„æ ˆé¢˜ï¼Œæ•°å­—1-Nä¾æ¬¡å…¥æ ˆï¼Œç»™å‡ºKç»„å‡ºæ ˆåºåˆ—å’Œæ ˆçš„æœ€å¤§å®¹é‡ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦å¯è¡Œã€‚\né¦–å…ˆåˆ†æå‡ºæ ˆæ„å‘³ç€æ‰€æœ‰æ¯”å°çš„æ•°å­—éƒ½å·²å…¥è¿‡æ ˆï¼Œç”±æ­¤ä¸ºçªç ´å£åˆ‡å…¥ã€‚æˆ‘ä»¬å¯ä»¥ç”¨pairæ¥è¡¨ç¤ºæ ˆä¸­çš„ä¸€ä¸²è¿ç»­æ•°å­—ï¼Œç„¶åæˆ‘ä»¬è®¾ç«‹ä¸€ä¸ªæ¨¡æ‹Ÿæ ˆsimå’Œä¸¤ä¸ªå˜é‡ï¼štopâ€”â€”å½“å‰æ ˆé¡¶å…ƒç´ ï¼›expâ€”â€”è¿˜æœªè¿›æ ˆçš„æœ€å°å…ƒç´ ï¼Œæ¥ä¸‹æ¥æ ¹æ®è¯»å…¥çš„æ•°å­—åˆ¤æ–­æ˜¯å‹å…¥æ•°å­—ä¸²è¿˜æ˜¯å‡ºæ ˆï¼š\n\nï¼šå‡ºæ ˆ\n\nï¼šå‹å…¥æ•°å­—ä¸²ï¼ˆå› ä¸ºæ˜¯å‡ºæ ˆåºåˆ—ï¼Œæ‰€ä»¥å·²å‡ºæ ˆï¼Œä½†è€ƒè™‘æ ˆæ­¤æ—¶çš„å®¹é‡æ—¶å¿…é¡»ç®—ä¸Šï¼‰ï¼Œæ›´æ–°ã€\n\nï¼šæ— éœ€æ”¹å˜æ ˆsimï¼Œä½†éœ€è¦æ›´æ–°\n\nï¼šä¸å­˜åœ¨çš„å‡ºæ ˆæƒ…å†µï¼Œå¦‚æœä¸€å¼€å§‹æ²¡æœ‰è¯»å…¥å…¨éƒ¨çš„å‡ºæ ˆåºåˆ—å°±ä¸èƒ½ç›´æ¥breakï¼Œå› ä¸ºåé¢è¿˜æ²¡è¯»å®Œ\n\n\n\n\näº‹å®ä¸Šï¼Œä¸Šè¿°ç®—æ³•æ˜¯ä¸€ç§é€†å‘æ¨¡æ‹Ÿè¿‡ç¨‹ï¼Œæ€è€ƒèµ·æ¥ç›¸å¯¹åäººç±»ï¼Œè¿˜æœ‰ä¸€ç§æ­£å‘æ€è·¯ã€‚ç”±äºå…¥æ ˆé¡ºåºè‚¯å®šæ˜¯1-Nï¼Œé‚£ä¹ˆå°±æ¨¡æ‹Ÿå…¥æ ˆè¿‡ç¨‹ï¼Œå°†1-Né€ä¸€å‹æ ˆï¼Œåœ¨å‹æ ˆçš„è¿‡ç¨‹ä¸­é¡ºä¾¿æ¯”å¯¹å‡ºæ ˆåºåˆ—ï¼Œå½“å‘ç°å‹æ ˆæ•°å­—å’Œå‡ºæ ˆåºåˆ—å½“å‰æ•°å­—å»åˆæ—¶ï¼Œå¼€å§‹å‡ºæ ˆï¼Œå¹¶å°†å‡ºæ ˆåºåˆ—çš„ç´¢å¼•å·å‘åç§»åŠ¨ç›´åˆ°æ ˆé¡¶å…ƒç´ ä¸å‡ºæ ˆåºåˆ—å½“å‰ç´¢å¼•å…ƒç´ ä¸ç¬¦ï¼Œå¦å¤–æ¯æ¬¡å‹æ ˆæ—¶éƒ½è¦æ£€æŸ¥æ ˆå®¹é‡æ˜¯å¦ç¬¦åˆè¦æ±‚ã€‚æœ€åè‹¥æ ˆç©ºå°±è¯´æ˜â€œYESâ€ã€‚\n\n\nğŸ\nâ¥‚â¥‚â¥‚#include &lt;iostream&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k, s;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        stack&lt;pair&lt;int, int&gt;&gt; sim;\n        int top = 0, exp = 1, size = 0;\n        bool flag = true;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            cin &gt;&gt; s;\n            if (!flag) continue;\n            if (top == s)\n            {\n                if (sim.top().first == sim.top().second)\n                {\n                    sim.pop();\n                    top = sim.empty() ? 0 : sim.top().second;\n                }\n                else\n                    sim.top().second = (--top);\n                size -= 1;\n            }\n            else if (s &gt; exp)\n            {\n                sim.emplace(exp, s - 1);\n                if ((size + s - exp + 1) &gt; m)\n                    flag = false;\n                else size += (s - exp);\n                top = s - 1;\n                exp = s + 1;\n            }\n            else if (s == exp)\n                exp += 1;\n            else\n                flag = false;\n        }\n        cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl;\n    }\n}\n\nâ¥¬â¥¬â¥¬#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        vector&lt;int&gt; seq(n);\n        stack&lt;int&gt; sim;\n        for (auto &amp;s: seq)\n            cin &gt;&gt; s;\n        int idx = 0;\n        for (int j = 0; j &lt; n; ++j)\n        {\n            sim.push(j + 1);\n            if (sim.size() &gt; m) break;\n            while (!sim.empty() &amp;&amp; sim.top() == seq[idx])\n            {\n                sim.pop();\n                ++idx;\n            }\n        }\n        cout &lt;&lt; (sim.empty() ? \"YES\" : \"NO\") &lt;&lt; endl;\n    }\n}\n","slug":"ã€Œ1051ã€Pop-Sequence","date":"2022-09-01T13:57:33.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,stack","author_index":"Starlit Rover"},{"id":"2b81f5e1a24a7a3ee74c167bb705ac9b","title":"ã€Œ1050ã€String Subtraction","content":"Given two stringsÂ S1â€‹Â andÂ S2â€‹,Â S=S1â€‹âˆ’S2â€‹Â is defined to be the remaining string after taking all the characters inÂ S2â€‹Â fromÂ S1â€‹. Your task is simply to calculateÂ S1â€‹âˆ’S2â€‹Â for any given strings. However, it might not be that simple to do itÂ fast.\n\n\nInput Specification:Each input file contains one test case. Each case consists of two lines which givesÂ S1â€‹Â andÂ S2â€‹, respectively. The string lengths of both strings are no more thanÂ 104. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string.\nOutput Specification:For each test case, printÂ S1â€‹âˆ’S2â€‹Â in one line.\nSample Input:They are students.\naeiou\n\nSample Output:Thy r stdnts.\n\n\nÎ©å°†S2ä¸­å­—ç¬¦ä»S1ä¸­å»é™¤ï¼Œ100msæ—¶é—´é™åˆ¶ã€‚\nç”¨map&lt;char,bool&gt; flagè®°å½•S2ä¸­æ‰€æœ‰å­—ç¬¦ï¼Œç„¶åéå†S1è¾“å‡ºï¼Œåªæœ‰flag[c]=falseçš„å­—ç¬¦æ‰èƒ½è¾“å‡ºã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s1, s2;\n    getline(cin, s1);\n    map&lt;char, bool&gt; flag;\n    getline(cin, s2);\n    for (auto &amp;c: s2)\n        flag[c] = true;\n    for (auto &amp;c: s1)\n        if (!flag[c])\n            cout &lt;&lt; c;\n}\n","slug":"ã€Œ1050ã€String-Subtraction","date":"2022-09-01T09:19:53.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map","author_index":"Starlit Rover"},{"id":"97a7c2039503607af8d71bdb64c1e600","title":"ã€Œ1049ã€Counting Ones","content":"The task is simple: given any positive integerÂ , you are supposed to count the total number of 1â€™s in the decimal form of the integers from 1 toÂ . For example, givenÂ Â being 12, there are five 1â€™s in 1, 10, 11, and 12.\n\n\nInput Specification:Each input file contains one test case which gives the positiveÂ .\nOutput Specification:For each test case, print the number of 1â€™s in one line.\nSample Input:12\n\nSample Output:5\n\n\nÎ©çŸ­å°ç²¾æ‚çš„é¢˜ç›®å¾€å¾€æš—è—æ€æ°”ã€‚\né¢˜æ„å¾ˆç®€å•ï¼Œç»™å‡ºæ­£æ•´æ•°ï¼Œéœ€è¦è¾“å‡º1-Nä¹‹é—´æ‰€æœ‰æ•°å­—ä¸­1å‡ºç°çš„æ¬¡æ•°ã€‚\næ€ä¹ˆä¹±å…¥ä¸€ä¸ªé«˜ä¸­æ’åˆ—ç»„åˆçš„é—®é¢˜ï¼Œè„‘å­é”ˆçš„ç®€ç›´å®å½“å“ã€‚ç¬¬ä¸€æƒ³æ³•æ˜¯ç”¨çš„è¡¨è¾¾å¼ç›´æ¥å†™å‡ºè¡¨è¾¾å¼ç„¶åï¼ˆè®¡ç®—æœºï¼šé‚£æˆ‘èµ°ï¼Ÿï¼‰ï¼Œç¡®å®æ²¡ä»€ä¹ˆå¿…è¦ã€‚è¿™æ—¶å€™ä½ å°±ä¼šå‘ç°ç¼–ç¨‹å’Œæ•°å­¦é¢˜ä¹‹é—´æ€è€ƒæ–¹å¼çš„å·®å¼‚æ‰€åœ¨ã€‚ç¼–ç¨‹æ—¶ä½ å¿…é¡»ç‰¢è®°è®¡ç®—æœºæœ€æ“…é•¿çš„å°±æ˜¯ç¹æ‚é‡å¤çš„åŠ³åŠ¨ï¼Œè€Œäººçš„æ„ä¹‰åªæ˜¯å€ŸåŠ©è‡ªèº«æ„Ÿæ€§çš„ä¼˜åŠ¿å°†é—®é¢˜æŠ½è±¡ä»¥åç”¨ä¸€ç§æ›´ä¸ºç†æ€§çš„æ–¹å¼å‘Šè¯‰è®¡ç®—æœºå…·ä½“çš„å¤„äº‹è§„åˆ™ã€‚\næœ¬è´¨ä¸Šæ¥è®²ï¼Œäººä»è§£å†³é—®é¢˜çš„ä¸»ä½“å˜æˆäº†åˆ¶å®šè§„åˆ™è®¡åˆ’çš„ä¸»ä½“ã€‚\n\n\næ—¢ç„¶ä¸æ˜¯æˆ‘ç®—ï¼Œé‚£æšä¸¾ä¸€æ³¢å°±å¥½å•¦ï¼ˆè¯•è¯•å°±é€ä¸–ï¼‰ã€‚\nå…¶å®å½“ç¡®å®šæ—¶ï¼Œ1æ‰€èƒ½å‡ºç°çš„ä½æ•°å°±å·²ç¡®å®šï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è®¡ç®—æ¯ä¸ªä½ç½®ä¸Šå‡ºç°1çš„ä¸ªæ•°æœ€åç›¸åŠ å³å¯ã€‚é‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æå¦‚ä½•è®¡ç®—ç¬¬ä½ï¼ˆï¼‰ä¸º1çš„æ•°å­—ä¸ªæ•°ã€‚\nå‡è®¾\n\nå¦‚ä½•è®¡ç®—1-Nä¸­å½¢å¦‚çš„æ•°å­—ä¸ªæ•°å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥åšå¦‚ä¸‹è€ƒé‡ï¼š\n\nå½“æ—¶ï¼Œå¯ä»¥ä»»å–ï¼Œå³æ­¤æ—¶å…±æœ‰ç§å¯èƒ½ï¼ˆä¹‹æ‰€ä»¥ä¸ç”¨-1æ˜¯å› ä¸ºè¿˜æœ‰å…¨ä¸º0çš„æƒ…å†µï¼‰\n\nå½“æ—¶ï¼Œå¿…é¡»è€ƒè™‘çš„å–å€¼äº†\n\nï¼Œé‚£ä¹ˆåœ¨è¯¥ä½ä¸Šå°±ä¸ä¼šå‡ºç°1ï¼Œä¸å­˜åœ¨æ»¡è¶³è¦æ±‚çš„æƒ…å†µ\n\nï¼Œé‚£ä¹ˆæ„å‘³ç€çš„å–å€¼åªæœ‰ç§å¯èƒ½\n\nï¼Œæ„å‘³ç€å¯ä»¥ä»»å–ï¼Œå› æ­¤å…±è®¡ç§æƒ…å†µ\n\n\n\n\nå°†ä¸Šè¿°ä¸¤è€…ç›¸åŠ å³ä¸ºæ‰€æ±‚ã€‚é‚£ä¹ˆæˆ‘ä»¬åªè¦å¯¹æ¯ä¸€ä¸ªå¯èƒ½ä½éƒ½åº”ç”¨ä¸Šè¿°ç®—æ³•è®¡ç®—æœ€åæ±‚å’Œå°±å¥½å•¦ã€‚\nè‹¥ï¼Œè¡¨æ˜ä¸ºç©ºä¸²ï¼Œé‚£ä¹ˆç›¸åº”å€¼ä¹Ÿä¸º0ã€‚\n\nğŸ#include &lt;iostream&gt;\n\nusing namespace std;\n\ninline int time10(int a, int n)\n{\n    for (int i = 0; i &lt; n; ++i)\n        a *= 10;\n    return a;\n}\n\nint main()\n{\n    int sum = 0, a, b;\n    string n;\n    cin &gt;&gt; n;\n    int m = n.size();\n    for (int i = 0; i &lt; m; ++i)\n    {\n        if (i == 0) a = 0;\n        else a = time10(stoi(n.substr(0, i)), m - i - 1);\n        if (n[i] == '0') b = 0;\n        else if (n[i] == '1')\n            b = (m == i + 1 ? 0 : stoi(n.substr(i + 1, m - i - 1))) + 1;\n        else\n            b = time10(1, m - i - 1);\n        sum += a + b;\n    }\n    cout &lt;&lt; sum;\n}\n\nâš ï¸è¿™é‡Œç”¨äº†å°†å­—ç¬¦ä¸²è½¬ä¸ºintçš„å‡½æ•°stoiï¼Œä½†æ³¨æ„å°†ç©ºä¸²ä¼ å…¥stoiæ—¶ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œéœ€å•ç‹¬å¤„ç†ï¼Œè€Œatoiåˆ™ä¼šç›´æ¥ä½œ0å¤„ç†ã€‚\n","slug":"ã€Œ1049ã€Counting-Ones","date":"2022-08-31T09:58:01.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"0d4898cefd298a76df1cccb4e68d417b","title":"ã€Œ1048ã€Find Coins","content":"Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many asÂ Â coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers:Â NÂ (, the total number of coins) andÂ MÂ (, the amount of money Eva has to pay). The second line containsÂ NÂ face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print in one line the two face valuesÂ â€‹Â andÂ â€‹Â (separated by a space) such thatÂ Â andÂ â€‹. If such a solution is not unique, output the one with the smallestÂ â€‹. If there is no solution, outputÂ No SolutionÂ instead.\nSample Input 1:8 15\n1 2 8 7 2 4 11 15\n\nSample Output 1:4 11\n\nSample Input 2:7 14\n1 8 7 2 4 11 15\n\nSample Output 2:No Solution\n\n\nÎ©In a wordï¼Œæ‰¾åˆ°ä¸€å¯¹ç›¸å·®æœ€å¤§çš„æ•°å­—ä¹‹å’Œä¸ºç»™å®šæ•°å­—ã€‚\nå› ä¸ºé™åˆ¶äº†æ•°å¯¹çš„ä¸ªæ•°ï¼Œç›´æ¥éå†æ„Ÿè§‰ä¹Ÿè¡Œã€‚æˆ‘ç”¨ä¸€ä¸ªmapæ¥è®°å½•æ¯ç§é¢å€¼ç¡¬å¸çš„ä¸ªæ•°ï¼Œç„¶åç›´æ¥éå†mapï¼Œå¯»æ‰¾çš„ç¡¬å¸æ˜¯å¦å­˜åœ¨ï¼Œä¸€æ—¦å°±å¯ä»¥breakäº†ã€‚\nä¸ºäº†é˜²èŒƒä¸¤ä¸ªç›¸åŒé¢å€¼ç¡¬å¸ä½œç¥Ÿçš„æƒ…å†µï¼Œåˆ¤æ–­å‰åº”å…ˆå°†ã€‚\n\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, f, ans = -1;\n    cin &gt;&gt; n &gt;&gt; m;\n    map&lt;int, int&gt; cnt;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; f;\n        ++cnt[f];\n    }\n    for (auto &amp;c: cnt)\n    {\n        if (c.first &gt; m / 2)\n            break;\n        c.second -= 1;\n        if (cnt[m - c.first])\n        {\n            ans = c.first;\n            break;\n        }\n    }\n    cout &lt;&lt; (ans == -1 ? \"No Solution\" : to_string(ans) + \" \" + to_string(m - ans));\n}\n","slug":"ã€Œ1048ã€Find-Coins","date":"2022-08-31T07:03:51.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map","author_index":"Starlit Rover"},{"id":"031d2c36fd739bf94778d5ddc84b6f38","title":"æ¨¡æ‹Ÿé€€ç«","content":"æ¨¡æ‹Ÿé€€ç«ç®—æ³•ï¼Œé¡¾åæ€ä¹‰ï¼Œæ¨¡æ‹Ÿæ™¶ä½“é€€ç«è¿‡ç¨‹ã€‚æ™¶ä½“åœ¨åŠ çƒ­åå›ºä½“åŒ–ä¸ºæ¶²æ€ï¼Œå†…éƒ¨åŸå­è¿åŠ¨åŠ å‰§ï¼Œä¼šç¦»å¼€åŸæœ‰ä½ç½®å‘å››å‘¨æ‰©æ•£ã€‚æ­¤æ—¶æ…¢æ…¢è¿›è¡Œé€€ç«å†·å´ä½¿å…¶é‡æ–°å›ºåŒ–ï¼Œç²’å­å¾€å¾€ä¼šåœç•™åœ¨æ¯”åŸå…ˆèƒ½é‡ä½å¾—å¤šçš„ä½ç½®ä¸Šï¼Œæœ¬è´¨ä¸Šä¹Ÿæ˜¯é€šè¿‡éšæœºæ€§è·³å‡ºå±€éƒ¨æœ€ä¼˜ã€‚\næœ¬æ–‡å°è¯•ç”¨æ¨¡æ‹Ÿé€€ç«ç®—æ³•å¯¹TSPé—®é¢˜ï¼ˆtravelling salesman problemï¼‰è¿›è¡Œæ±‚è§£ï¼Œå¹¶ä¸Gurobiæ±‚è§£å™¨è¿›è¡Œå¯¹æ¯”ã€‚\n\n\n\n\n\n\nÎ©\næ¨¡æ‹Ÿé€€ç«çš„ç®—æ³•æµç¨‹éå¸¸ç®€å•ï¼Œä¸€èˆ¬ç”¨æ¥æ±‚è§£æœ€å°åŒ–çš„ä¼˜åŒ–é—®é¢˜ï¼š\n\nç»™å‡ºä¸€ä¸ªæ»¡è¶³æ‰€æœ‰çº¦æŸæ¡ä»¶çš„åˆå§‹è§£ï¼Œåˆ¶å®šå¯¹è§£ç©ºé—´è¿›è¡Œç¼–ç çš„è§„åˆ™ï¼Œå¹¶è®¾å®šåˆå§‹æ¸©åº¦ã€é™æ¸©å‚æ•°ã€æœ€ä½æ¸©åº¦\n\né€šè¿‡2å˜æ¢æ³•/3å˜æ¢æ³•/éšæœºè°ƒæ¢å¯¹è§£è¿›è¡Œæ”¹é€ ï¼š\n\n2å˜æ¢æ³•ï¼šéšæœºå–ä¸¤ä¸ªéšæœºæ•°ï¼Œå°†è¯¥è§£ç´¢å¼•ä¸ºä¹‹é—´çš„åºåˆ—è¿›è¡Œåè½¬ï¼ˆé€†åºæ’åˆ—ï¼‰\n3å˜æ¢æ³•ï¼šéšæœºå–3ä¸ªéšæœºæ•°ï¼Œå–å‡ºç´¢å¼•ä¹‹é—´çš„åºåˆ—ç½®äºç´¢å¼•å…ƒç´ çš„åé¢\néšæœºè°ƒæ¢ï¼šéšæœºå–ä¸¤ä¸ªéšæœºæ•°ï¼Œå°†ä¸¤ä½ç½®å¤„çš„å…ƒç´ è¿›è¡Œè°ƒæ¢\n\n\næ±‚æ”¹é€ è§£ä¸åŸè§£ä¹‹é—´çš„ç›®æ ‡å‡½æ•°å·®ï¼š\n\næŒ‰ç…§ä¸‹è¿°æ¦‚ç‡æ¥å—æ”¹é€ è§£ï¼Œäº§ç”Ÿä¸€éšæœºæ•°ä¸Pè¿›è¡Œæ¯”è¾ƒï¼Œè‹¥åˆ™å¦åˆ™ç»´æŒåŸè§£\n\n\n\n\n\né™æ¸©ï¼š\n\nè‹¥æˆ–è€…è¿ç»­å¤šæ¬¡çš„è¿­ä»£è¿‡ç¨‹ä¸­éƒ½æ²¡æœ‰æ¥å—æ”¹é€ è§£å°±é€€å‡ºå¾ªç¯ï¼Œå¦åˆ™é‡å¤2ï½5æ­¥\n\n\n\n\nå¯è§æ¨¡æ‹Ÿé€€ç«ä¸­æœ€æ ¸å¿ƒçš„å†…å®¹ä¾¿æ˜¯\n\n æ—¶ç›´æ¥æ¥å—éå¸¸å®¹æ˜“ç†è§£ï¼Œæ¯•ç«Ÿç›®æ ‡å‡½æ•°æ›´å°äº†ï¼›è€Œæ¨¡æ‹Ÿé€€ç«ç®—æ³•çš„æ ¸å¿ƒå°±åœ¨äºæ—¶è¿˜æ˜¯ä»¥ä¸€å®šæ¦‚ç‡æ¥å—ï¼Œè€Œä¸”åˆ†æä¸Šå¼å¯ä»¥å‘ç°å½“åˆå§‹æƒ…å†µä¸‹Tæ›´å¤§æ—¶Pä¹Ÿä¼šè¾ƒå¤§ï¼Œéšç€Tæ…¢æ…¢é™ä½åPä¹Ÿä¼šè¶‹è¿‘äº0ã€‚å¾ˆæ˜¾ç„¶ï¼Œè¿™æ˜¯åˆ©ç”¨éšæœºæ€§é¿å…ç²’å­åœ¨åˆå§‹æƒ…å†µä¸­å°±è½äºå±€éƒ¨æœ€ä¼˜ã€‚åˆšå¼€å§‹é™æ¸©æ—¶ç²’å­è¿˜æ˜¯æœ‰ä¸€å®šæ¦‚ç‡è·³å‡ºå½“å‰æ‰€å¤„åŒºåŸŸï¼Œæ‰©å¤§æœå¯»èŒƒå›´ï¼›åˆ°åæ¥æ¸©åº¦é€æ¸é™ä½ï¼Œç²’å­çš„çŠ¶æ€å¼€å§‹æ”¶æ•›ï¼Œè·³å‡ºçš„æ¦‚ç‡å°±å¾ˆå°äº†ï¼Œè¿™æ˜¯é¿å…ç²’å­è·³å‡ºæœ€ä¼˜è§£æ‰€åœ¨åŒºåŸŸè€Œéš¾ä»¥æ”¶æ•›ã€‚\n\n\n\nTSPï¼šæ—…è¡Œæ¨é”€å‘˜é—®é¢˜\næ—…è¡Œæ¨é”€å‘˜æ˜¯ä¸€ä¸ªéå¸¸ç»å…¸çš„NP-Hardé—®é¢˜ï¼Œå³åœ¨å¤šé¡¹å¼æ—¶é—´å†…ä¹Ÿæ— æ³•éªŒè¯è§£çš„æ­£ç¡®æ€§ã€‚é—®é¢˜å¤§æ„éå¸¸ç®€å•ï¼Œå°±æ˜¯æœ‰ä¸ªåŸå¸‚ï¼Œä¸¤ä¸¤ä¹‹é—´è·ç¦»å·²çŸ¥ï¼Œæœ‰ä¸ªsalesmanä»æŸä¸ªåŸå¸‚å‡ºå‘å¸Œæœ›èƒ½å¤Ÿæ¸¸å†å…¶ä»–æ¯åº§åŸå¸‚ä¸€éï¼ŒåŒæ—¶æœ€åå›åˆ°å‡ºå‘åŸå¸‚ï¼Œé‡åº¦å¼ºè¿«ç—‡æ‚£è€…çš„ä»–å¸Œæœ›è®¾è®¡å‡ºä¸€æ¡æ»¡è¶³ä¸Šè¿°è¦æ±‚çš„æœ€çŸ­è·¯çº¿ã€‚\nå¦‚æœä½ æ˜¯ä»–çš„æœ‹å‹ï¼Œä½ ä¼šå¦‚ä½•åŠé€€ä»–ï¼Œè¯·å†™ä¸€ç¯‡ä¸å°‘äº200è¯çš„æ„ŸåŒ–ä¿¡ã€‚ï¼ˆ100ï¼‰\n\n\nâœ¦ åˆå§‹åŒ–åŸå¸‚åæ ‡å’Œè·ç¦»çŸ©é˜µå¯ä»¥é€šè¿‡éšæœºç”Ÿæˆæˆ–è€…åŠ è½½ä¹‹å‰ç”Ÿæˆçš„åæ ‡æ¥åˆå§‹åŒ–\nimport numpy as np\nimport random as rd\n\n# éšæœºç”ŸæˆåŸå¸‚åæ ‡\nloc = np.zeros([100, 2])\nfor i in range(len(loc)):\n    loc[i] = (rd.random() * 100, rd.random() * 100)\nnp.save(\"loc.npy\", loc) # ä¿å­˜ç”Ÿæˆåæ ‡\n\n# å¯¼å…¥ä¹‹å‰åŸå¸‚åæ ‡\n# loc=np.load(\"loc.npy\")\n\nnum = len(loc)\n# å¤šä¸€åˆ—æ–¹ä¾¿å¤„ç†å›åˆ°åŸåŸå¸‚çš„çº¦æŸ\ndist = np.zeros([num, num + 1])\n\n# è®¡ç®—è·ç¦»çŸ©é˜µ\nfor i in range(num):\n    for j in range(i + 1, num):\n        dist[i, j] = dist[j, i] = np.linalg.norm(loc[i] - loc[j])\ndist[:, num] = dist[:, 0]\n\nâœ¦ è´ªå¿ƒæ±‚åˆå§‹è§£TSPé—®é¢˜çš„è§£åŸºæœ¬ä¸éœ€è¦ç¼–ç ï¼ŒåŒ…å«æ‰€æœ‰åŸå¸‚ä¸€ä¸ªå…¨æ’åˆ—çš„åˆ—è¡¨å°±å¯ä»¥ä½œä¸ºå¯è¡Œè§£çš„ç¼–ç ã€‚æˆ‘è¿™é‡Œè§„å®šäº†0å·ä½œä¸ºèµ·ç‚¹å’Œç»ˆç‚¹ã€‚\nç”¨è´ªå¿ƒç®—æ³•æ„é€ åˆå§‹è§£ï¼Œå³ä»èµ·ç‚¹åŸå¸‚å¼€å§‹æ¯æ¬¡é€‰æ‹©ç¦»å½“å‰åŸå¸‚æœ€è¿‘çš„ä¸”è¿˜æœªè®¿é—®è¿‡çš„åŸå¸‚ä½œä¸ºä¸‹ä¸€ä¸ªç›®çš„åœ°ã€‚åœ¨åŸå¸‚æ•°è¾ƒå°‘æ—¶è´ªå¿ƒç»“æœå‡ ä¹å°±æ˜¯æœ€ä¼˜è§£ï¼ŒåŸå¸‚æ•°å¤§äº†å°±å˜»å˜»ã€‚\n# è´ªå¿ƒæ±‚åˆå§‹è§£\npath=[0]\nisVisited=[False]*num\nisVisited[0]=True\ncrt=0\nsum_d=0\nfor i in range(num):\n    idx=np.argsort(dist[crt])\n    for j in idx:\n        if j!=num and not isVisited[j] and j!=crt:\n            path.append(j)\n            sum_d+=dist[crt,j]\n            isVisited[j]=True\n            crt=j\n            break\npath.append(0)\nsum_d+=dist[crt,0]\ninit_sum=sum_d\nprint(\"distance of initial solution:\",sum_d)\n\n\n    \n  \n\n\nâœ¦ æ¨¡æ‹Ÿé€€ç«è®¾ç½®å¥½åˆå§‹æ¸©åº¦ã€é™æ¸©å‚æ•°ã€æœ€ä½æ¸©åº¦ä¹‹åå³å¯å¼€å§‹é€€ç«ã€‚æˆ‘åœ¨è¿™é‡Œå°è¯•äº†2å˜æ¢æ³•ã€3å˜æ¢æ³•ã€2 3å˜æ¢æ³•ç›¸ç»“åˆï¼ˆè®¾ç½®diceéª°å­éšæœºé€‰æ‹©ï¼‰çš„æ¨¡å¼ï¼Œæœ€åå‘ç°è¿˜æ˜¯2å˜æ¢æ³•çš„æ•ˆæœæœ€ä½³ã€‚\n# è®¾ç½®åˆå§‹å‚æ•°\nT=1\na=0.999\n\npath_opt=path\nsum_opt=sum_d\ncnt=0\nwhile T&gt;1e-300:\n    # dice=rd.randint(1,2)\n    # if dice==1:\n    m=rd.randint(1,num-2)\n    n=rd.randint(m+1,num)\n    delta=dist[path[m-1],path[n-1]]+dist[path[m],path[n]]-dist[path[m-1],path[m]]-dist[path[n-1],path[n]]\n    # elif dice==2:\n    #     m=rd.randint(1,num-3)\n    #     n=rd.randint(m+2,num-1)\n    #     delta=dist[path[m],path[n-1]]+dist[path[m],path[n+1]]+\\\n    #       dist[path[n],path[m-1]]+dist[path[n],path[m+1]]-\\\n    #       dist[path[m],path[m-1]]-dist[path[m],path[m+1]]-\\\n    #       dist[path[n],path[n-1]]-dist[path[n],path[n+1]]\n\n    if delta&lt;0 or rd.random()&lt;np.exp(-delta/T):\n        # if dice==1:\n        path[m:n]=path[n-1:m-1:-1]\n        # elif dice==2:\n        #     path[m],path[n]=path[n],path[m]\n\n        sum_d+=delta\n        cnt=0\n        if sum_d&lt;sum_opt:\n            path_opt=path\n            sum_opt=sum_d\n    else:\n        cnt+=1\n        if cnt==300:\n            break\n    T=a*T\n\nprint(\"Current Temperature:\\t\",T)\nprint(\"Minimum Distance:\\t\\t\",sum_opt)\nprint(\"Initial Distance:\\t\\t\",init_sum)\nx=loc[path_opt,0]\ny=loc[path_opt,1]\nplt.plot(x,y,'b*-',linewidth=1)\nplt.show()\n\nå…¶ä¸­ä¸€ä¾‹çš„ç»“æœå¦‚ä¸‹ï¼š\n\n\né¡ºä¾¿å°†å…¶å¯è§†åŒ–ï¼š\n\n\n\n\nGurobi\næƒ³ç€ç”¨Gurobiä¹Ÿæ¥æ’ä¸€è„šï¼Œæ²¡æƒ³åˆ°èŠ±çš„æ—¶é—´æ¯”ç ä¸Šé¢çš„æ¨¡æ‹Ÿé€€ç«è¿˜é•¿ã€‚å› ä¸ºè¿™é‡Œæœ‰ä¸ªé—®é¢˜â€”â€”å¦‚ä½•ä¿è¯Gurobiç»™å‡ºçš„è§£æ˜¯ä¸€ä¸ªè¿é€šå›¾ï¼Ÿ\nä»”ç»†æƒ³æƒ³ï¼Œä¼šå‘ç°å¤šä¸ªè¿é€šå›¾å’Œä¸€ä¸ªè¿é€šå›¾çš„æ€»è¾¹æ•°ä»¥åŠæ¯ä¸ªé¡¶ç‚¹åº¦è¦æ±‚éƒ½æ˜¯ç›¸åŒçš„ï¼Œå¦‚æœä¼˜åŒ–æ¨¡å‹å¯¹è¿é€šæ€§æ²¡æœ‰é™åˆ¶çš„è¯ä¼šå‡ºå¤§é—®é¢˜ï¼š\n\n\n\n\n\n\nåæ¥å‘ç°Gurobiå®˜æ–¹æœ‰ç»™å‡ºæ±‚è§£TSPé—®é¢˜çš„æ¡ˆä¾‹ï¼Œè¯¦æƒ…æˆ³è¿™ã€‚\nä»–åœ¨ä¸Šè¿°æ¨¡å‹ä¸­åˆæ·»åŠ äº†ä»¥ä¸‹çº¦æŸï¼ˆ*ï¼‰ï¼š\n\nç®€å•åœ°è¯´ï¼Œå¦‚æœä¸€ä¸ªè§£ä¸­åŒ…å«å¤šä¸ªè¿é€šåˆ†å›¾ï¼Œé‚£ä¹ˆè‚¯å®šå­˜åœ¨çœŸå­é›†ï¼ŒSä¸­æ‰€æœ‰çš„è¾¹æ•°ï¼ˆä¸¤ä¸ªç«¯ç‚¹éƒ½åœ¨Sä¸­ï¼‰ä¹‹å’Œ==Sä¸­çš„åŸå¸‚æ•°é‡ï¼Œä¸”æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„Så³ä¸ºä¸€ä¸ªè¿é€šåˆ†å›¾ã€‚å› æ­¤ä»–å°±éå¸¸æš´åŠ›åœ°æŠŠæ‰€æœ‰çœŸå­é›†éƒ½æšä¸¾ä¸€éï¼Œè®©ä»–ä»¬éƒ½ä¸æ»¡è¶³è¿™ä¸ªæ¡ä»¶ã€‚\nç„¶è€Œåœ¨å®é™…å®ç°çš„è¿‡ç¨‹ä¸­ï¼Œè¿™æ˜¯ä¸ªç³Ÿç³•é€é¡¶çš„æƒ³æ³•ã€‚å› ä¸ºå¦‚æ­¤ä¸€æ¥çº¦æŸä¸ªæ•°ä¼šéšç€åŸå¸‚æ•°çš„å¢åŠ è€Œå‘ˆæŒ‡æ•°å¼å¢é•¿ã€‚è¯´å®åœ¨ä¸€ç‚¹ï¼Œç†æƒ³æ˜¯ç†æƒ³ï¼Œç°å®æ˜¯ç°å®ã€‚é‚£å’‹åŠå‘¢ï¼Ÿä¸è¦æ…Œï¼Œæ—¢ç„¶Gurobiå‡ºäº†å®˜æ–¹æ–‡æ¡£ï¼Œè¯´æ˜ä»–ä»¬è¿˜æ˜¯æœ‰èƒ½åŠ›è§£å†³çš„ã€‚\näºæ˜¯ä¹ä»–ä»¬æ‹¿å‡ºäº†åå«Lazy Constraintsçš„æ³•å®ï¼Œç¿»è¯‘ä¸€ä¸‹åº”è¯¥å«æƒ°æ€§çº¦æŸï¼Œé¡¾åæ€ä¹‰ï¼Œè¿™ä¸ªçº¦æŸéå¸¸çš„æ‡’ï¼Œåªæœ‰åœ¨æŒ‡å®šæ¡ä»¶æ‰ä¼šè·³å‡ºæ¥åˆ¤æ–­è§£çš„åˆç†æ€§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æ­£å¸¸æ±‚è§£çš„è¿‡ç¨‹ä¸­ä¸ä¼šæ·»åŠ è¯¥çº¦æŸï¼Œåœ¨ç”¨æˆ·æŒ‡å®šçš„æƒ…å†µä¸‹å†å»åˆ¤æ–­ï¼Œè¿™æ ·å°±è½»æ¾å¤šå•¦ã€‚\næœ¬æ¥æƒ³ç€ç›´æ¥å¥—ç”¨å®˜æ–¹æ¨¡ç‰ˆè·‘ä¸€é€šï¼Œå¥ˆä½•ä»–åˆšå¼€å§‹ç›´æ¥è¯»å–äº†ä¸€ä¸ªjsonæ–‡ä»¶ï¼Œä¸æ˜¯å¾ˆæ¸…æ¥šè¯»å®Œåçš„æ•°æ®æ ¼å¼ï¼Œéƒ¨åˆ†åœ°æ–¹ä¹Ÿæ²¡çœ‹æ‡‚åœ¨åšä»€ä¹ˆï¼Œå¯¼è‡´åœ¨å¥—ç”¨è‡ªå·±å˜é‡åæ€»ä¼šå‡ºç°è¿™æ ·é‚£æ ·çš„å°bugï¼Œå¾ˆçƒ¦ï¼Œç®€å•åœ°é‡æ„äº†ä¸‹ã€‚\n\n\næƒ³è¦æ„é€ æƒ°æ€§çº¦æŸéœ€è¦è‡ªå·±å®ç°ä¸€ä¸ªCallbackå‡½æ•°æ¥æŒ‡å®šä»€ä¹ˆæ¡ä»¶è°ƒç”¨è¯¥å‡½æ•°ï¼Œç„¶åè¯¥å‡½æ•°å†å†³å®šæ»¡è¶³ä»€ä¹ˆè¦æ±‚æ—¶æ·»åŠ Lazy Constraintï¼š\ndef delSubtour(model, where):\n    # GRB.Callback.MIPSOLï¼šå‘ç°æ–°çš„MIPè§£\n    if where == GRB.Callback.MIPSOL:\n        # make a list of edges selected in the solution\n        vals = model.cbGetSolution(model._vars)\n        edges = gp.tuplelist((i, j) for i, j in model._vars.keys()\n                             if vals[i, j] &gt; 0.5)\n        adj = {}\n        for i, j in edges:\n            adj.setdefault(i, set()).add(j)\n            adj.setdefault(j, set()).add(i)\n        circle = set([0])\n        next = set([0])\n        new = set()\n        while next:\n            for k in next:\n                new |= adj[k]\n            next = new - circle\n            circle |= next\n\n        if len(circle) &lt; num:\n            model.cbLazy(gp.quicksum(model._vars[i, j] for i, j in combinations(circle, 2)) &lt;= len(circle) - 1)\n\nCallbackå‡½æ•°çš„æ¡ä»¶é€‰é¡¹å¯ä»¥è§å®˜æ–¹æ–‡æ¡£ã€‚whereæŒ‡å®šè°ƒç”¨æ¡ä»¶ï¼Œæˆ‘è¿™é‡Œçš„MIPSOLæ˜¯æŒ‡å½“Gurobiæ‰¾åˆ°ä¸€ä¸ªæ··åˆæ•´æ•°è§„åˆ’ï¼ˆMIPï¼‰è§£ï¼ˆSOLï¼‰æ—¶ï¼Œå°±ä¼šæ‰§è¡Œè¯¥å‡½æ•°çš„ä¸»ä½“éƒ¨åˆ†ã€‚è€Œä¸»ä½“éƒ¨åˆ†å…ˆé€šè¿‡cbGetSolutionå‡½æ•°è·å–æ‰¾åˆ°çš„è¯¥è§£ï¼Œç„¶åå°†çš„é¡¶ç‚¹å…ƒç»„å¯¹æ”¾å…¥ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œæ ¹æ®è¯¥åˆ—è¡¨å»ºç«‹ä¸€ä¸ªé€šè¿‡åŸå¸‚ç¼–å·å¯ä»¥è®¿é—®è¿æ¥é¡¶ç‚¹çš„é‚»æ¥å­—å…¸adjï¼Œæœ€åæ±‚å‡º0å·åŸå¸‚æ‰€åœ¨è¿é€šå›¾çš„åŸå¸‚ä¸ªæ•°ï¼Œä¸åŸå¸‚æ€»æ•°è¿›è¡Œæ¯”è¾ƒå°±èƒ½è¯´æ˜æ‰€æœ‰åŸå¸‚æ˜¯å¦è¿é€šã€‚å¦‚æœä¸è¿é€šï¼Œæ­¤æ—¶å†æ·»åŠ çº¦æŸï¼ˆ*ï¼‰ã€‚\n\n\nGurobiæ±‚è§£çš„å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\nimport random as rd\n# combinations(list,n): æšä¸¾æ‰€æœ‰é•¿åº¦ä¸ºnçš„å…¨æ’åˆ—\nfrom itertools import combinations, product\n\n\ndef delSubtour(model, where):\n    # GRB.Callback.MIPSOLï¼šå‘ç°æ–°çš„MIPè§£\n    if where == GRB.Callback.MIPSOL:\n        # make a list of edges selected in the solution\n        vals = model.cbGetSolution(model._vars)\n        edges = gp.tuplelist((i, j) for i, j in model._vars.keys()\n                             if vals[i, j] &gt; 0.5)\n        adj = {}\n        for i, j in edges:\n            adj.setdefault(i, set()).add(j)\n            adj.setdefault(j, set()).add(i)\n        circle = set([0])\n        next = set([0])\n        new = set()\n        while next:\n            for k in next:\n                new |= adj[k]\n            next = new - circle\n            circle |= next\n\n        if len(circle) &lt; num:\n            model.cbLazy(gp.quicksum(model._vars[i, j] for i, j in combinations(circle, 2)) &lt;= len(circle) - 1)\n\n\nm = gp.Model(\"TSP\")\n\nvars = m.addVars(dist.keys(), obj=dist, vtype=GRB.BINARY)\n\n# Symmetry\nm.addConstrs(vars[j, i] == vars[i, j] for i, j in dist.keys())\n\n# two edges to each city\nm.addConstrs((vars.sum(i, '*') == 2) for i in range(num))\n\n# Optimize the model\nm._vars = vars\nm.Params.lazyConstraints = 1\n# setObjectiveå‡½æ•°æ­¤æ—¶ä¼¼ä¹æ²¡ç”¨\n# m.setObjective(vars.prod(dist), GRB.MINIMIZE)\nm.optimize(delSubtour)\n\n\nvals = m.getAttr('x', vars)\nedges = gp.tuplelist((i, j) for i, j in vals.keys() if vals[i, j] &gt; 0.5 and i &lt; j)\nadj = {}\nfor i, j in edges:\n    adj.setdefault(i, []).append(j)\n    adj.setdefault(j, []).append(i)\nisVisited = [False] * num\nx = [];\ny = []\nidx = 0\ntotal = 0\nfor i in range(num - 1):\n    x.append(loc[idx, 0])\n    y.append(loc[idx, 1])\n    pre = idx\n    isVisited[idx] = True\n    idx = adj[idx][0] if not isVisited[adj[idx][0]] else adj[idx][1]\n    total += dist[pre, idx]\n\ntotal += dist[idx, 0]\nx.append(loc[0, 0])\ny.append(loc[0, 1])\nprint(\"Minimum Distanceï¼š\", total)\n\n\nimport matplotlib.pyplot as plt\n# è®¾ç½®å­—ä½“\nplt.rc('font', family='Times New Roman')\n# è®¾ç½®å›¾åƒçš„åƒç´ \nplt.rcParams['figure.dpi'] = 150\n# è®¾ç½®å­—ä½“çš„é¢œè‰²\nplt.rcParams['text.color'] = 'black'\nplt.plot(x, y, 'b*-', linewidth=1)\nplt.show()\n\nç”±äºGurobiæ±‚è§£çš„æ˜¯æœ€ä¼˜è§£ï¼Œå› æ­¤è§„æ¨¡ä¸€æ—¦ç¨å¤§å°±è¦è·‘å¾ˆä¹…ã€‚åŸå¸‚æ•°é‡ä¸º50å·¦å³çš„æ±‚è§£é€Ÿåº¦è¿˜æ˜¯å¾ˆå¿«çš„ï¼Œ100å°±å¼€å§‹æ€è€ƒäººç”Ÿäº†ã€‚\n\n    \n  \n\n\n\n    \n  \n\n\n\n    \n  \n\n","slug":"æ¨¡æ‹Ÿé€€ç«","date":"2022-08-28T05:33:08.000Z","categories_index":"æ™ºèƒ½ç®—æ³•","tags_index":"python,æ•°å­¦ç…é¦,TSP,Gurobi","author_index":"Starlit Rover"},{"id":"6791030d5707ab0b9f17e02b4e398cd4","title":"ã€Œ1047ã€Student List for Course","content":"Zhejiang University has 40,000 students and provides 2,500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 numbers:Â NÂ (â‰¤40,000), the total number of students, andÂ KÂ (â‰¤2,500), the total number of courses. ThenÂ NÂ lines follow, each contains a studentâ€™s name (3 capital English letters plus a one-digit number), a positive numberÂ CÂ (â‰¤20) which is the number of courses that this student has registered, and then followed byÂ CÂ course numbers. For the sake of simplicity, the courses are numbered from 1 toÂ K.\nOutput Specification:For each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the studentsâ€™ names in alphabetical order. Each name occupies a line.\nSample Input:10 5\nZOE1 2 4 5\nANN0 3 5 2 1\nBOB5 5 3 4 2 1 5\nJOE4 1 2\nJAY9 4 1 2 5 4\nFRA8 3 4 2 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 5 4 2\nLOR6 4 2 4 1 5\n\nSample Output:1 4\nANN0\nBOB5\nJAY9\nLOR6\n2 7\nANN0\nBOB5\nFRA8\nJAY9\nJOE4\nKAT3\nLOR6\n3 1\nBOB5\n4 7\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n5 9\nAMY7\nANN0\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n\n\nÎ©æ‰“å°è¯¾ç¨‹é€‰è¯¾åå•ï¼Œå¦ˆå¦ˆå†ä¹Ÿä¸ç”¨æ‹…å¿ƒæˆ‘åœ¨æµ™å¤§æ‰¾å·¥ä½œå•¦ã€‚ï¼ˆæµ™å¤§ï¼šä¿å®‰è€ƒè™‘ä¸€ä¸‹ï¼Ÿï¼‰\né¢˜ç›®çš„é€»è¾‘éå¸¸æ¸…æ™°ç®€å•ï¼Œè€Œä¸”æœ€åéœ€è¦å­—æ¯åºè¾“å‡ºå¾ˆå®¹æ˜“å°±æƒ³åˆ°äº†setå®¹å™¨ï¼Œäºæ˜¯ä¹ä¸€é€šä»£ç çŒ›å¦‚è™ï¼Œä¿¡å¿ƒæ»¡æ»¡åœ°è¶…æ—¶äº†ã€‚è¿™ä¸æ¯«éš¾ä¸ä½ç é¾„é«˜è¾¾äºŒå¹´çš„æˆ‘ï¼Œä¸‰ä¸‹äº”é™¤äºŒå°±æŠŠcinå’Œcoutç»™æ¢äº†ï¼Œç«Ÿç„¶è¿˜æ˜¯è¶…æ—¶ã€‚æœ€åæŠŠsetæ¢æˆvectorï¼Œç„¶åå†sortä¸€ä¸‹ï¼Œå‹‰å‹‰å¼ºå¼ºã€‚\nTo sum upï¼Œä¸€èˆ¬è¶…æ—¶æ’é›·æ–¹å‘ï¼š\n\ncinâ†’ scanf ï¼›coutâ†’ printf\n\nsetã€mapâ†’ vector\n\nä¼˜åŒ–ç®—æ³•ï¼Œå‡å°‘é‡å¤è®¡ç®—\n\n\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, c, d;\n    scanf(\"%d %d\", &amp;n, &amp;m);\n    vector&lt;vector&lt;string&gt;&gt; info(m);\n    string name(5, ' ');\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;name[0], &amp;c);\n        for (int j = 0; j &lt; c; ++j)\n        {\n            scanf(\"%d\", &amp;d);\n            info[d - 1].push_back(name);\n        }\n    }\n    for (int i = 0; i &lt; m; ++i)\n    {\n        printf(\"%d %lu\\n\", i + 1, info[i].size());\n        sort(info[i].begin(), info[i].end());\n        for (auto &amp;s: info[i])\n            printf(\"%s\\n\", s.c_str());\n    }\n}\n","slug":"ã€Œ1047ã€Student-List-for-Course","date":"2022-08-26T05:56:35.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,vector","author_index":"Starlit Rover"},{"id":"40786dbbe04360f3225c33f6e57bde2b","title":"ã€Œ1046ã€Shortest Distance","content":"The task is really simple: givenÂ NÂ exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains an integer, followed byÂ Â integer distancesÂ â€‹, whereÂ â€‹Â is the distance between theÂ i-th and theÂ (i+1)-st exits, andÂ DNâ€‹Â is between theÂ N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integerï¼Œ withÂ Â lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 toÂ N. It is guaranteed that the total round trip distance is no more thanÂ .\nOutput Specification:For each test case, print your results inÂ Â lines, each contains the shortest distance between the corresponding given pair of exits.\nSample Input:5 1 2 4 14 9\n3\n1 3\n2 5\n4 1\n\nSample Output:3\n10\n7\n\n\nÎ©ä¼°è®¡æ˜¯ç«æ˜Ÿä¸Šçš„é«˜é€Ÿå…¬è·¯ï¼Œå‡ºå£èƒ½å›´æˆä¸€ä¸ªåœˆã€‚\nç»™å‡ºç›¸é‚»å‡ºå£çš„è·ç¦»ï¼Œç„¶åéœ€è¦ä½ è¾“å‡ºå‡ å¯¹æŒ‡å®šå‡ºå£ä¹‹é—´çš„æœ€çŸ­è·ç¦»ã€‚\né‚£ä¹ˆæ˜¾ç„¶åªæœ‰ä¸¤æ¡è·¯ï¼Œä¸”è·¯é•¿ä¹‹å’Œæ˜¯åœ†çš„å‘¨é•¿ã€‚\né¦–å…ˆï¼Œå¦‚æœæ¯æ¬¡éƒ½æ˜¯å¯¹ä¸­é—´æ‰€æœ‰ç›¸é‚»è·¯é•¿è¿›è¡Œç›¸åŠ å¿…ç„¶æ˜¯ä¼šè¶…æ—¶çš„ï¼Œæˆ‘ä»¬å¿…é¡»é™åˆ¶è®¡ç®—é‡ã€‚æœ¬è´¨ä¸Šå¯ä»¥å°†åœˆçœ‹æˆä¸€æ®µå¼¯äº†çš„æ•°è½´ï¼Œé‚£ä¹ˆè®¡ç®—åœ¨å’Œä¸Šçš„å‡ºå£è·ç¦»æ—¶ï¼Œåªéœ€æ¯”è¾ƒå’Œå³å¯ï¼ˆä¸ºåœ†å‘¨é•¿ï¼‰ã€‚è€Œæ•°è½´ä¸Šçš„åæ ‡è®¡ç®—ç›´æ¥ä»¥ç¬¬ä¸€ä¸ªå‡ºå£ä½œä¸ºåŸç‚¹ç„¶åä¾æ¬¡ç›¸åŠ å³å¯ã€‚\nâ€œThe task is really simple.â€\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; dist(n + 1);\n    dist[0] = 0;\n    for (int i = 1; i &lt; n + 1; ++i)\n    {\n        cin &gt;&gt; dist[i];\n        dist[i] += dist[i - 1];\n    }\n    int m, a, b;\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        int d = dist[(a &gt; b ? a : b) - 1] - dist[(a &gt; b ? b : a) - 1];\n        if (d &gt; dist[n] / 2)\n            cout &lt;&lt; dist[n] - d &lt;&lt; endl;\n        else\n            cout &lt;&lt; d &lt;&lt; endl;\n    }\n}\n","slug":"ã€Œ1046ã€Shortest-Distance","date":"2022-08-26T03:40:01.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,vector","author_index":"Starlit Rover"},{"id":"126557f0372d68b5bf8540ce837256a8","title":"ã€Œ1045ã€Favorite Color Stripe","content":"Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.\nIt is said that a normal human eye can distinguish about less than 200 different colors, so Evaâ€™s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.\nNote that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Evaâ€™s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ  which is the total number of colors involved (and hence the colors are numbered from 1 toÂ N). Then the next line starts with a positive integerÂ  followed byÂ MÂ Evaâ€™s favorite color numbers given in her favorite order. Finally the third line starts with a positive integerÂ  which is the length of the given stripe, followed byÂ LÂ colors on the stripe. All the numbers in a line a separated by a space.\nOutput Specification:For each test case, simply print in a line the maximum length of Evaâ€™s favorite stripe.\nSample Input:6\n5 2 3 1 5 6\n12 2 2 4 1 5 5 6 3 1 1 5 6\n\nSample Output:7\n\n\nÎ©ä¸å¾—ä¸è¯´ï¼ŒåºŸè¯çœŸå¤šï¼ŒèƒŒæ™¯ä¹Ÿå¥‡å¥‡æ€ªæ€ªï¼Œçœ‹ä¸ªé¢˜è´¹äº†æˆ‘è€åŠå¤©ã€‚\näººè¯ç‰ˆï¼Œç»™å®šä¸€ä¸²æ•°å­—åºåˆ—ï¼Œæˆ‘ä»¬éœ€è¦ä»å¦ä¸€ä¸ªæ•°å­—åºåˆ—ä¸­å°½å¯èƒ½å¤šåœ°æŒ‰é¡ºåºæŠ½å‡ºæ•°å­—ï¼Œä½†æŠ½å‡ºçš„æ•°å­—å¿…é¡»æŒ‰ç…§çš„é¡ºåºæ’åˆ—ï¼Œå³ä¸­çš„æ•°å­—å¯ä»¥é‡å¤ä¹Ÿå¯ä»¥ç¼ºå¤±ï¼Œä½†æ•°å­—å¿…é¡»æ˜¯è¿™ä¸ªé¡ºåºå‡ºç°çš„ã€‚\nå¾ˆæ˜¾ç„¶ï¼Œä¸åœ¨ä¸­çš„æ•°å­—å…¶å®æ˜¯å™ªéŸ³ï¼Œç›´æ¥è¿‡æ»¤ã€‚é¦–å…ˆæˆ‘ä»¬å®šä¹‰ç”¨æ¯”è¾ƒè¿ç®—ç¬¦+æ‹¬å·çš„å½¢å¼æ¥è¡¨ç¤ºæ•°å­—åœ¨ä¸­çš„æ’åˆ—ï¼š\n\nå¦å¤–æˆ‘ä»¬è§„å®šç¬¦åˆä¸­é¡ºåºçš„æ•°å­—ä¸²æ˜¯åˆæ³•çš„ã€‚\né‚£ä¹ˆå¯¹äºï¼Œæˆ‘ä»¬å¯ä»¥ç»Ÿè®¡å‡ºå½“å‰ï¼ˆè¯»å…¥åºåˆ—çš„è¿‡ç¨‹ä¸­ï¼‰åºåˆ—ä¸­æ‰€å«æ•°å­—å‡çš„æœ€å¤§åˆæ³•æ•°å­—ä¸²é•¿åº¦ã€‚å½“æˆ‘ä»¬è¯»å…¥ä¸€ä¸ªæ•°å­—åï¼Œåªéœ€ï¼Œç„¶ååŒæ—¶æ›´æ–°\n\næœ€åè¾“å‡ºå³å¯ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, a, b;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; next(n + 1, -1);\n    map&lt;int, int&gt; cnt;\n    cin &gt;&gt; a;\n    for (int i = 1; i &lt; m; ++i)\n    {\n        cin &gt;&gt; b;\n        next[a] = b;\n        a = b;\n    }\n    next[a] = 0;\n    auto &amp;ans = cnt[a];\n\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; a;\n        if (next[a] != -1)\n        {\n            b = ++cnt[a];\n            while (next[a] != 0)\n            {\n                if (b &gt; cnt[next[a]])\n                    cnt[next[a]] = b;\n                else break;\n                a = next[a];\n            }\n        }\n    }\n    cout &lt;&lt; ans;\n}\n","slug":"ã€Œ1045ã€Favorite-Color-Stripe","date":"2022-08-23T08:40:23.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"åŠ¨æ€è§„åˆ’,Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"e150e507cccee9246ee324168daabc61","title":"ã€Œ1044ã€Shopping in Mars","content":"Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options:\n\nCut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).\nCut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).\nCut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).\n\nNow given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer.\nIf it is impossible to pay the exact amount, you must suggest solutions with minimum lost.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 numbers:Â , the total number of diamonds on the chain, and, the amount that the customer has to pay. Then the next line containsÂ NÂ positive numbersÂ which are the values of the diamonds. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, printÂ i-jÂ in a line for each pair ofÂ Â such thatÂ . Note that if there are more than one solution, all the solutions must be printed in increasing order ofÂ i.\nIf there is no solution, outputÂ i-jÂ for pairs ofÂ Â such thatÂ Â with  minimized. Again all the solutions must be printed in increasing order ofÂ i.\nIt is guaranteed that the total value of diamonds is sufficient to pay the given amount.\nSample Input 1:16 15\n3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13\n\nSample Output 1:1-5\n4-6\n7-8\n11-11\n\nSample Input 2:5 13\n2 4 5 7 9\n\nSample Output 2:2-4\n4-5\n\n\nÎ©æœ€è¿‘æ€ä¹ˆå…¨æ˜¯Marsçš„é¢˜ç›®ï¼Œå¦ˆå¦ˆå†ä¹Ÿä¸ç”¨æ‹…å¿ƒæˆ‘åœ¨è€å®¶æ‰¾å·¥ä½œå•¦ã€‚\nç«æ˜Ÿäººå–œæ¬¢ç”¨ä¸€ä¸²é’»çŸ³æ¥ä»˜é’±ï¼Œä¸Šé¢æ¯é¢—é’»çŸ³çš„ä»·å€¼ä¸ä¸€ï¼Œè€Œä¸”åªèƒ½ç”¨å…¶ä¸­è¿ç»­çš„ä¸€å°ä¸²æ¥ä»˜ã€‚ç»™å®šè¿™ä¸€ä¸²é’»çŸ³çš„ä»·å€¼å’Œéœ€è¦ä»˜è´¹çš„å•†å“ä»·æ ¼ï¼Œè¾“å‡ºæ‰€æœ‰æŸå¤±æœ€å°çš„é’»çŸ³å­ä¸²ï¼Œé¢˜ç›®ä¿è¯é’»çŸ³æ€»ä»·å€¼&gt;å•†å“ä»·æ ¼ï¼Œæ‹’ç»åƒéœ¸ç‹é¤ï¼Œéš¾å¾—æœ‰åŸåˆ™çš„é¢˜ç›®ï¼Œç‚¹èµã€‚\nå¾ˆæ˜¾ç„¶çš„ä¸€ä¸ªæƒ³æ³•ï¼Œä»æ¯ä¸€é¢—é’»çŸ³å¼€å§‹å¾€åéå†ï¼Œæ‰¾åˆ°é’»çŸ³æ€»ä»·å€¼åˆšå¥½â‰¥å•†å“ä»·å€¼çš„end indexï¼Œè®¡ç®—ï¼ˆé’»çŸ³æ€»ä»·-å•†å“ä»·å€¼ï¼‰ï¼Œä¸å…¨å±€æœ€å°å€¼è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥æ›´å°åˆ™æ›¿æ¢åŸå…ˆåºåˆ—ï¼›è‹¥ç›¸ç­‰åˆ™æ·»åŠ è‡³å½“å‰åºåˆ—å°¾éƒ¨ã€‚\nHoweverï¼Œä½ å¾ˆå¿«ä¼šå‘ç°ï¼Œè¿™é‡Œé¢å…¶å®æœ‰ç€å¤§é‡çš„é‡å¤è®¡ç®—ï¼Œå°¤å…¶æ˜¯ç›¸é‚»çš„èµ·å§‹é’»çŸ³æ‰€å¼•å¯¼çš„åºåˆ—ä¹‹é—´ä¼šæœ‰å¾ˆå¤§ä¸€éƒ¨åˆ†é‡åˆã€‚ç®€åŒ–çš„æ–¹å¼ä¹Ÿéå¸¸ç®€å•ï¼Œåœ¨forå¾ªç¯éå†ä¸­ä¸å¿…æ”¹å˜end indexï¼Œå› ä¸ºä¸‹ä¸€ä¸ªèµ·å§‹é’»çŸ³çš„end indexåªä¼šæ¯”å½“å‰å¤§è€Œä¸ä¼šå°ã€‚æˆ‘ä»¬åªéœ€è¦åœ¨è¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯å‰å°†è¯¥è½®é’»çŸ³æ€»ä»·å‡å»å½“å‰èµ·å§‹é’»çŸ³çš„ä»·å€¼å³å¯ï¼Œè¿™æ ·å°±æ— éœ€é‡å¤è®¡ç®—ä¸­é—´é’»çŸ³ï¼Œç›¸å½“äºæ•´ä¸ªè¿‡ç¨‹æ¯ä¸ªé’»çŸ³ä»·å€¼åªä¼šåŠ ä¸€æ¬¡ã€‚\nä¸€æ—¦å‘ç°å³ä½¿æŠŠåé¢çš„é’»çŸ³éƒ½åŠ ä¸Šä¹Ÿæ— æ³•è¾¾åˆ°å•†å“ä»·æ ¼ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥breakã€‚\nå¦å¤–éœ€è¦æé˜²ä»·å€¼ä¸º0çš„çŸ³å¤´é’»çŸ³ã€‚\n\nC â˜º D E# include &lt;iostream&gt;\n# include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; dia(n);\n    vector&lt;pair&lt;int, int&gt;&gt; seq;\n    for (auto &amp;d: dia)\n        cin &gt;&gt; d;\n    int min_lost = m, end = 0, sum = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        while (end &lt; n &amp;&amp; sum &lt; m)\n            sum += dia[end++];\n        if (end == n &amp;&amp; sum &lt; m)\n            break;\n        if (sum - m &lt; min_lost)\n        {\n            min_lost = sum - m;\n            seq.clear();\n            seq.emplace_back(i + 1, end);\n        }\n        else if (sum - m == min_lost)\n            seq.emplace_back(i + 1, end);\n        sum -= dia[i];\n    }\n    for (auto &amp;s: seq)\n        cout &lt;&lt; s.first &lt;&lt; \"-\" &lt;&lt; s.second &lt;&lt; endl;\n}\n","slug":"ã€Œ1044ã€Shopping-in-Mars","date":"2022-08-23T05:43:36.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"åŠ¨æ€è§„åˆ’,Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"67f2a5903961e96580b14bb51c7ce9c9","title":"ç²’å­ç¾¤ç®—æ³•","content":"é€šè¿‡ä¸Šä¸€èŠ‚æˆ‘ä»¬å¾—çŸ¥é—ä¼ ç®—æ³•æ˜¯ä¸€ç§æ™ºèƒ½çš„éšæœºæœç´¢ç®—æ³•ï¼Œèƒ¡ä¹±éšæœºçš„è¿‡ç¨‹ä¸­éšéšé€ç€ä¸€ä¸ç« æ³•ï¼Œè¿™æ˜¯å€Ÿé‰´äº†å¤§è‡ªç„¶çš„ç”Ÿå­˜æ³•åˆ™ã€‚è€Œä»Šå¤©ç™»åœºçš„ç²’å­ç¾¤ç®—æ³•ä¹Ÿæºäºæ—¥å¸¸ç”Ÿæ´»ã€‚\nå½“åœ°ä¸Šæ‰è½ä¸€å¨èœ‚èœœæ—¶ï¼Œæˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°å®ƒçš„æ–¹ä½ï¼Œæ€ä¹ˆåŠå‘¢ï¼Ÿäºæ˜¯ä¹æˆ‘ä»¬æ”¾å‡º100åªèš‚èšï¼Œè®©ä»–ä»¬åœ¨è¿™ç‰‡å¹¿è¢¤æ— å çš„åœŸåœ°ä¸Šéšæœºæœç´¢ã€‚ä½†å¹¶ä¸æ˜¯å®Œå…¨éšæœºï¼Œå½“æœ‰ä¸€åªèš‚èšå—…åˆ°äº†æé«˜æµ“åº¦çš„èœ‚èœœæ°”æ¯æ—¶ï¼Œå®ƒä¼šå¯¹å…¶ä»–èš‚èšå¤§å–Šï¼ˆè§¦è§’ï¼šä½ ç¤¼è²Œå—ï¼‰ï¼šâ€œCome hereï¼â€œï¼Œäºæ˜¯ä¹æ‰€æœ‰èš‚èšä¼šå¾€å®ƒçš„æ–¹ä½é æ‹¢ã€‚ç„¶è€Œæ¯ä¸€åªèš‚èšä¹Ÿæ˜¯ä¸€ä¸ªå•ç‹¬çš„ä¸ªä½“ï¼Œå®ƒä»¬ä¼šæœ‰è‡ªå·±çš„æœç´¢è®°å¿†ï¼Œå¯¹äºè‡ªå·±æœç´¢è·¯å¾„ä¸Šå‡ºç°è¿‡æœ€é«˜æµ“åº¦çš„æ–¹ä½ä¹Ÿä¸€ç›´å¿µå¿µä¸å¿˜ï¼Œå› æ­¤æ¯ä¸€åªèš‚èšè¿˜ä¼šå‘è‡ªå·±çš„å†å²æœ€å¼ºæ–¹ä½é æ‹¢ã€‚ç”±æ­¤æ¯ä¸ªèš‚èšçš„è¿åŠ¨æ–¹å¼éƒ½æ˜¯é€šè¿‡è¿åŠ¨æƒ¯æ€§+ä¸ªä½“è®¤çŸ¥+ç¾¤ä½“åä½œå†³å®šçš„ã€‚\n\n\n\n\n\n\n\nÎ©åŸºç¡€çš„ç®—æ³•æµç¨‹éå¸¸ç®€å•æ˜“æ‡‚ï¼š\n\næœ‰å¿…è¦çš„è¯éœ€å¯¹ä¼˜åŒ–é—®é¢˜çš„å¯è¡Œè§£è¿›è¡Œç¼–ç \n\nåˆå§‹åŒ–å„ç²’å­çš„ä½ç½®å’Œé€Ÿåº¦ï¼Œæ¯ä¸ªä½ç½®åæ ‡å¯¹åº”ä¸€ä¸ªå¯è¡Œè§£\n\næŒ‡å®šç²’å­é€‚åº”åº¦ï¼ˆèœ‚èœœæ°”æ¯æµ“åº¦ï¼‰è®¡ç®—æ–¹å¼ï¼Œè®¡ç®—å„ä¸ªç²’å­çš„é€‚åº”å€¼\n\nä¸ä¸ªä½“æœ€é«˜é€‚åº”å€¼è¿›è¡Œæ¯”è¾ƒï¼Œæ›´é«˜åˆ™è¿›è¡Œæ›¿æ¢ï¼Œå¹¶è®°å½•å½“å‰ä½ç½®\n\nä¸ç¾¤ä½“æœ€é«˜é€‚åº”å€¼è¿›è¡Œæ¯”è¾ƒï¼Œæ›´é«˜åˆ™è¿›è¡Œæ›¿æ¢ï¼Œå¹¶è®°å½•å½“å‰ä½ç½®\n\næ›´æ–°å½“å‰ç²’å­é€Ÿåº¦\n\nå…¶ä¸­ä¸ºæƒ¯æ€§ç³»æ•°ï¼Œè¡¨ç¤ºç»´æŒå½“å‰é€Ÿåº¦çš„è¶‹åŠ¿å› å­ï¼›å‡ä¸ºæ¯æ¬¡æ›´æ–°æ—¶äº§ç”Ÿçš„éšæœºæ•°ï¼›åˆ™ä¸ºå¯¹ä¸ªä½“æœ€ä¼˜ã€ç¾¤ä½“æœ€ä¼˜æ–¹ä½çš„å­¦ä¹ å› å­ï¼›åˆ†åˆ«ä¸ºä¸ªä½“æœ€ä¼˜ä½ç½®åæ ‡ã€ç¾¤ä½“æœ€ä¼˜ä½ç½®åæ ‡\n\næ›´æ–°å½“å‰ç²’å­æ–¹ä½\n\n\n\n\n\né‚£ä¹ˆåœ¨ç®—æ³•å¼€å§‹å‰ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦æŒ‡å®šã€ç²’å­ä¸ªæ•°ã€æœ€å¤§è¿­ä»£æ¬¡æ•°ã€å­¦ä¹ å› å­*2ã€æƒ¯æ€§ç³»æ•°ã€‘ï¼Œå¦å¤–ç”±äºå¯è¡Œè§£åŸŸå¾€å¾€æ˜¯ä¸€å—æœ‰é™çš„åŒºåŸŸï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½è®©é€Ÿåº¦è¿‡å¤§ï¼Œéœ€è¦è®¾å®šä¸€ä¸ªé€Ÿåº¦ä¸Šé™ï¼Œè€Œè¿™ä¸ªä¸Šé™å¾€å¾€é€šè¿‡æ–¹ä½çš„æœ€å¤§ç»å¯¹å€¼è¿›è¡Œè®¾å®šï¼Œå³\n\næ³¨æ„ç®—æ³•ä¸­çš„ï¼Œéƒ½å¯ä»¥æ˜¯ç»´å‘é‡ï¼Œä¸‹é¢è¯·æ¬£èµæˆ‘éšä¾¿åº”ç”¨çš„ä¸€ä¸ªæ¡ˆä¾‹ã€‚\n\nÆºè¿™ä¸ªæ¡ˆä¾‹æ˜¯Gurobiæ±‚è§£å™¨ï¼ˆä¸æ˜¯å¹¿å‘Šï¼ä¸è¿‡å­¦ç”Ÿç‰ˆå…è´¹ç”³è¯·è¿˜æ˜¯å¾ˆé¦™çš„ï¼ŒPythonä½“éªŒä¹Ÿä¸é”™ï¼‰å®˜æ–¹ç»™å‡ºçš„ï¼Œä¸€ä¸ªå»ºå¡”é—®é¢˜ï¼Œå®˜æ–¹æ–‡æ¡£è§è¿™ã€‚\nç®€å•åœ°è¯´ï¼Œå°±æ˜¯è®¾è®¡ä¸€ä¸ªé€šè®¯å¡”çš„é€‰å€æ–¹æ¡ˆï¼Œæ¯ä¸ªå¡”çš„æ­å»ºè´¹ç”¨å’Œè¦†ç›–çš„åœ°åŒºä¸åŒï¼Œä¸åŒåœ°åŒºæ‰€æ¶µç›–çš„äººå£ä¹Ÿä¸åŒï¼Œç”±äºèµ„é‡‘æœ‰é¢„ç®—é™åˆ¶ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨é¢„ç®—èŒƒå›´å†…æ±‚å‡ºèƒ½å¤Ÿè¦†ç›–æœ€å¤§äººæ•°çš„æ­å»ºæ–¹æ¡ˆã€‚\nâˆ» å¯¼å…¥æ•°æ®åŸé¢˜ä¸­åªæœ‰6åº§å¡”ï¼Œé‚£ä¹ˆæ„å‘³ç€åªæœ‰64ç§æƒ…å†µï¼Œæˆ‘30ä¸ªç²’å­å°±å·²ç»å äº†ä¸€å¤§åŠï¼Œè¿™è¿˜è¿­ä»£ä¸ªæ¯›çƒï¼Œäºæ˜¯ä¹æˆ‘æŠŠå¡”æ•°æ”¹æˆäº†10ï¼ŒåŒæ—¶æ›´æ”¹äº†ä¸ªåˆ«å¡”æ‰€æ¶µç›–çš„åœ°åŒºã€‚ä¸‹é¢æ˜¯åŸºæœ¬ä¿¡æ¯çš„å¯¼å…¥ï¼š\nimport numpy as np\nimport random as rd\n\n# å„åœ°åŒºäººå£æ•°é‡\npop = np.array([523, 690, 420, 1010, 1200, 850, 400, 1008, 950])\n# å»ºå¡”è´¹ç”¨\ncost = np.array([4.2, 6.1, 5.2, 5.5, 4.8, 9.2, 7.6, 5.8, 8.7, 4.9])\ntn = len(cost)\n# èµ„é‡‘é¢„ç®—\nbudget = 20\n# æ¯åº§å¡”æ¶µç›–çš„åœ°åŒº\ncover = np.array([[False] * len(pop)] * tn)\ncover[0][[0, 5]] = True\ncover[1][[8]] = True\ncover[2][[3, 4]] = True\ncover[3][[2, 6]] = True\ncover[4][[6, 8]] = True\ncover[5][[0]] = True\ncover[6][[1, 5]] = True\ncover[7][[2]] = True\ncover[8][[3, 7]] = True\ncover[9][[7]] = True\n\nâˆ» ç‰¹æ®ŠåŒ–å¤„ç†åœ¨æœ¬é¢˜ä¸­æ²¡æœ‰ç›´æ¥çš„åæ ‡ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸ªæ–¹æ¡ˆè¿›è¡Œç¼–ç ï¼Œç”±äºæ¯åº§å¡”åªæœ‰å»º/ä¸å»ºä¸¤ç§æƒ…å†µï¼Œé‚£ä¹ˆä¸€ä¸ª10ä½äºŒè¿›åˆ¶æ•°å³å¯è¡¨ç¤ºä¸€ç§æ–¹æ¡ˆ\n\nä½†æ˜¯è¿™é‡Œæœ‰æœ€å¤§èµ„é‡‘çº¦æŸï¼Œæ„å‘³ç€å¹¶ä¸æ˜¯éšä¾¿ä¸€ä¸ª10ä½äºŒè¿›åˆ¶æ•°å°±æ˜¯å¯è¡Œè§£ã€‚è¿™é‡Œæˆ‘é‡‡å–çš„æ–¹æ³•æ˜¯ï¼Œåˆå§‹ç²’å­ç”Ÿæˆçš„éƒ½æ˜¯å¯è¡Œè§£ï¼Œä½†å¯¹äºæœç´¢è¿‡ç¨‹ä¸­äº§ç”Ÿçš„ä¸å¯è¡Œè§£ï¼Œæˆ‘ä»¬å°†å…¶é€‚åº”å€¼è®¾ä¸º0ï¼Œä»è€Œå¯¹æœç´¢è¿‡ç¨‹ä¸ä¼šé€ æˆå¤ªå¤§å½±å“ã€‚\nâˆ» å‚æ•°è®¾ç½®æ¥ä¸‹æ¥è®¾ç½®å„ä¸ªå‚æ•°ï¼š\n# å‚æ•°è®¾å®š\npn = 20           # ç²’å­æ•°é‡\niter = 500        # è¿­ä»£æ¬¡æ•°\nmaxx = 2**tn-1    # x_max(å…¨ä¸º1)\nr_vx = 0.5        # x_max/v_max\nmaxv = r_vx*maxx  # v_max\nw = 0.5           # æƒ¯æ€§ç³»æ•°\nc1 = 5            # ä¸ªä½“å­¦ä¹ å› å­\nc2 = 3            # ç¾¤ä½“å­¦ä¹ å› å­\n\nâˆ» è§£ç å‡½æ•°åœ¨è®¡ç®—ä¸‹ä¸€æ­¥åæ ‡æ—¶æˆ‘ä»¬ä¸ç›´æ¥å¯¹ä¸€ä¸ªåç»´å‘é‡è¿›è¡Œæ“ä½œï¼Œæ¯•ç«Ÿæ¯ä¸€ä½å°±ä¸¤ä¸ªé€‰æ‹©ä¹Ÿä¸èƒ½å­˜åœ¨å°æ•°ã€‚æˆ‘å…ˆå°†äºŒè¿›åˆ¶æ•°è½¬æ¢ä¸ºåè¿›åˆ¶æ•°ï¼Œåœ¨è¿›è¡Œåæ ‡çš„è®¡ç®—ï¼Œå³è¿™é‡Œçš„åæ ‡å’Œé€Ÿåº¦éƒ½æ˜¯1ç»´çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªå°†åè¿›åˆ¶æ•°è½¬æ¢ä¸ºåä½äºŒè¿›åˆ¶åˆ—è¡¨çš„è§£ç å‡½æ•°ï¼š\ndef decode(p):\n    b = list(bin(p)[2:])\n    a = ['0'] * (tn - len(b))\n    a.extend(b)\n    a = list(map(int, a))\n    return a\n\nè½¬æ¢æ—¶åˆ«å¿˜äº†æŠŠå‰ç½®0è¡¥å…¨ã€‚\nâˆ» ç²’å­ç¾¤åˆå§‹åŒ–åˆå§‹åŒ–èµ·ç‚¹åæ ‡å’Œé€Ÿåº¦ï¼Œè¿™é‡Œæ„é€ çš„æ¯ä¸ªç²’å­éƒ½æ˜¯å¯è¡Œè§£ï¼š\n# åˆå§‹åŒ–ç²’å­ç¾¤\nx = []\nv = []\nfor i in range(pn):\n    a = [1] * tn\n    while sum(cost * a) &gt; budget:\n        c = rd.randint(0, maxx)\n        a = decode(c)\n    x.append(c)\n    v.append(r_vx * c)\n\nâˆ» é€‚åº”åº¦å‡½æ•°å¾ˆæ˜¾ç„¶æœ¬é—®ä¸­çš„é€‚åº”åº¦å‡½æ•°å³ä¸ºæ¶µç›–çš„äººå£æ€»æ•°ï¼Œæˆ‘ä»¬åªéœ€åˆ¤æ–­æ¯ä¸ªåœ°åŒºæ˜¯å¦æœ‰å¡”è¦†ç›–å³å¯ï¼Œå¯¹äºä¸å¯è¡Œè§£åˆ™ç›´æ¥è¿”å›0ã€‚\nâš ï¸åœ¨elseé‡Œä¼šå‡ºå¤§é—®é¢˜ï¼Œç”±äºidxä¸ºç©ºï¼Œæ‰€ä»¥å’Œpopç›¸ä¹˜çš„ä¹Ÿæ˜¯ä¸ªNoneã€‚\n# é€‚åº”åº¦å‡½æ•°\ndef adpt(p):\n    a = decode(p)\n    if sum(cost * a) &gt; budget or p == 0:\n        return 0\n    else:\n        idx = list(np.where(np.array(a) == 1)[0])\n        return sum(list(map(bool, sum(cover[idx]))) * pop)\n\nâˆ» è¿­ä»£æœç´¢è¿™é‡Œæ³¨æ„å½“é€Ÿåº¦å’Œåæ ‡è¶…å‡ºä¸Šä¸‹é™æ—¶éœ€è¦åŠæ—¶è°ƒæ•´ã€‚\n# ç²’å­ç¾¤æœç´¢\nmaxp = 0\noptx = 0\nmaxp_idv = list(map(adpt, x))\noptx_idv = x\nrecord_p = []\nrecord_iter = []\nfor i in range(iter):\n    for j in range(pn):\n        v[j] = w * v[j] + c1 * rd.random() * (optx - x[j]) + c2 * rd.random() * (optx_idv[j] - x[j])\n        if abs(v[j]) &gt; maxv:\n            v[j] = maxv if v[j] &gt; 0 else -maxv\n        x[j] = round(x[j] + v[j])\n        if x[j] &lt; 0:\n            x[j] = 0\n        elif x[j] &gt; maxx:\n            x[j] = maxx\n        new_adpt = adpt(x[j])\n        if new_adpt &gt; maxp_idv[j]:\n            maxp_idv[j] = new_adpt\n            optx_idv[j] = x[j]\n            if new_adpt &gt; maxp:\n                maxp = new_adpt\n                optx = x[j]\n                record_p.append(new_adpt)\n                record_iter.append(i)\n\nprint(\"æœ€å¤§è¦†ç›–äººæ•°ï¼š\\t\", maxp)\nprint(\"æœ€ä½³å»ºå¡”è®¡åˆ’ï¼š\\t\", decode(optx))\n\næœ€ç»ˆæ±‚å¾—çš„ç»“æœï¼š\n\n\nè¿™ä¸Gurobiç»™å‡ºçš„æœ€ä¼˜è§£ç»“æœä¸€è‡´ï¼š\n\n\nâˆ» ç»˜åˆ¶æœç´¢è¿‡ç¨‹import matplotlib.pyplot as plt\n\n# è®¾ç½®å­—ä½“\nplt.rc('font', family='Times New Roman')\n# è®¾ç½®å›¾åƒçš„åƒç´ \nplt.rcParams['figure.dpi'] = 150\n# è®¾ç½®å­—ä½“çš„é¢œè‰²\nplt.rcParams['text.color'] = 'black'\n\nplt.plot(record_iter, record_p, color='b', linestyle='-.', marker='*', label='Survived')\nplt.ylabel('max Population', fontsize=13)\nplt.xlabel('iteration num', fontsize=13)\nplt.xticks(ticks=record_iter)\nplt.show()\n\nç”¨matplotlibåº“æˆ‘ä»¬å¯ä»¥ç»˜åˆ¶å‡ºæœ€å¤§äººå£æ•°çš„å˜åŒ–è¿‡ç¨‹ï¼Œç”±äºè¿è¡Œé€Ÿåº¦å¾ˆå¿«ï¼Œæ‰€ä»¥æˆ‘å¤šè¿è¡Œäº†å‡ æ¬¡ï¼š\n\n\n    \n  \n\n\n    \n    \n\n\nå’³å’³ï¼Œè™½ç„¶å§ç®—æ³•é²æ£’æ€§ä¸é«˜ï¼Œä¸è¿‡å°±ä»¥ä¸Šå››ç§æƒ…å†µæ¥çœ‹ï¼Œäº”ç™¾è½®è¿­ä»£æ˜¯è¶³å¤Ÿäº†ï¼Œæœ€åä¹Ÿå°±408æ¬¡ã€‚åªèƒ½è¯´è°ƒå‚çœŸçš„æ˜¯ä¸€é—¨æŠ€æœ¯æ´»ï¼Œæˆ‘è§‰å¾—æˆ‘è¿™é‡Œçš„å‚æ•°è‚¯å®šä¸æ˜¯æœ€ä¼˜çš„ï¼Œæˆ–è®¸ç”¨æ™ºèƒ½ç®—æ³•æœç´¢æ™ºèƒ½ç®—æ³•çš„å‚æ•°ä¼šæ˜¯ä¸ªå¥½ä¸»æ„ï¼ˆç¦æ­¢å¥—å¨ƒ\\dogeï¼‰ã€‚\n","slug":"ç²’å­ç¾¤ç®—æ³•","date":"2022-08-22T02:55:53.000Z","categories_index":"æ™ºèƒ½ç®—æ³•","tags_index":"python,æ•°å­¦ç…é¦,Gurobi","author_index":"Starlit Rover"},{"id":"77ba14d37a0bc8ef24c6a9af2180a766","title":"ã€Œ1043ã€Is It a Binary Search Tree","content":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:\n\nThe left subtree of a node contains only nodes with keys less than the nodeâ€™s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.\nBoth the left and right subtrees must also be binary search trees.\n\nIf we swap the left and right subtrees of every node, then the resulting tree is called theÂ Mirror ImageÂ of a BST.\nNow given a sequence of integer keys, you are supposed to tell if it is the preorder traversal sequence of a BST or the mirror image of a BST.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ NÂ (â‰¤1000). ThenÂ NÂ integer keys are given in the next line. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, first print in a lineÂ YESÂ if the sequence is the preorder traversal sequence of a BST or the mirror image of a BST, orÂ NOÂ if not. Then if the answer isÂ YES, print in the next line the postorder traversal sequence of that tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.\nSample Input 1:7\n8 6 5 7 10 8 11\n\nSample Output 1:YES\n5 7 6 8 11 10 8\n\nSample Input 2:7\n8 10 11 8 6 7 5\n\nSample Output 2:YES\n11 8 10 7 5 6 8\n\nSample Input 3:7\n8 6 8 5 10 9 11\n\nSample Output 3:NO\n\n\nÎ©ç»™å®šä¸€ä¸²æ•°å­—ï¼Œéœ€è¦ä½ åˆ¤æ–­æ˜¯å¦ä¸ºä¸€é¢—äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰æˆ–é•œåƒBSTçš„å‰åºéå†ç»“æœï¼Œè‹¥æ˜¯åˆ™è¾“å‡ºè¯¥BSTçš„ååºéå†ã€‚\nåˆ¤æ–­æ˜¯å¦ä¸ºBSTçš„å‰åºéå†ç»“æœï¼Œæˆ‘ä»¬å°±å…ˆå‡è®¾itâ€™s trueï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªæ•°å­—å³ä¸ºé¦–èŠ‚ç‚¹ï¼Œç„¶åæˆ‘ä»¬å¯ä»¥å°†åé¢çš„æ•°å­—è·Ÿé¦–èŠ‚ç‚¹æ•°å­—è¿›è¡Œæ¯”è¾ƒåˆ†ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘éƒ¨åˆ†ï¼Œç„¶åé€’å½’åˆ¤æ–­å·¦å­æ ‘(&lt;top node)å’Œå³å­æ ‘(â‰¥top node)æ˜¯å¦ä¸ºå‰åè¿ç»­çš„ä¸¤éƒ¨åˆ†ï¼Œå¦‚æœæ˜¯éè¿ç»­çš„åˆ™è¯´æ˜ä¸æ˜¯BSTçš„å‰åºéå†ã€‚è€Œåç»­éå†åˆ™åˆšå¥½å¯ä»¥åœ¨é€’å½’åˆ¤æ–­ä¸­å®Œæˆï¼Œæ³¨æ„åˆ°åç»­åˆšå¥½ä¸å‰åºæ˜¯ç›¸åçš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å…ˆé€’å½’åˆ¤æ–­ç„¶åå†è¾“å‡ºå½“å‰èŠ‚ç‚¹çš„æ•°å­—ï¼Œè¿™æ ·å¯ä»¥ä¿è¯å…ˆè¾“å‡ºå­æ ‘ç„¶åå†è¾“å‡ºä¸­é—´èŠ‚ç‚¹ã€‚\nå¯¹äºæ ‘çš„é¡ºåºéå†é—®é¢˜ï¼Œæ ¸å¿ƒç‚¹æ°¸è¿œæ˜¯å‡†ç¡®åˆ’åˆ†å‡ºå‰ã€ä¸­ã€åä¸‰éƒ¨åˆ†ã€‚\næ‰€è°“é•œåƒBSTæ˜¯æŒ‡ä¸€é¢—BSTçš„é•œåƒç¿»è½¬ç»“æœï¼Œä¹Ÿæ˜¯æœ¬é¢˜ä¸€ä¸ªæ£˜æ‰‹ä¹‹å¤„ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è®¾ç½®ä¸€ä¸ªisMIrrorå˜é‡ï¼Œç„¶åå°†ç›´æ¥æ¯”è¾ƒæ”¹æˆå°†æ¯”è¾ƒç»“æœä¸è¯¥å˜é‡è¿ç­‰è¿›è¡Œåˆ¤æ–­ï¼š ï¼Œè¿™æ ·å°±å¯ä»¥åˆ›é€ é•œåƒä¸–ç•Œï¼ˆå¯¹è½¬é”™ï¼Œé”™è½¬å¯¹ï¼‰ã€‚å› æ­¤å¦‚æœæ—¶åˆ¤æ–­å¤±è´¥ï¼Œé‚£å°±å†åˆ¤æ–­ï¼Œå¯¹ä¸€å³å¯ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nvector&lt;int&gt; pre, post;\nbool isMirror = false;\n\nbool isPreOrder(int start, int end)\n{\n    if (start == end)\n    {\n        post.push_back(pre[start]);\n        return true;\n    }\n    else if (start &gt; end)\n        return true;\n    int mid = pre[start], less_end = start + 1, great_end;\n    while (less_end &lt;= end &amp;&amp; (pre[less_end] &lt; mid) == !isMirror)\n        ++less_end;\n    great_end = less_end;\n    less_end -= 1;\n    while (great_end &lt;= end &amp;&amp; (pre[great_end] &gt;= mid) == !isMirror)\n        ++great_end;\n    if (great_end != end + 1)\n        return false;\n    bool flag = isPreOrder(start + 1, less_end) &amp;&amp; isPreOrder(less_end + 1, great_end - 1);\n    post.push_back(mid);\n    return flag;\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    pre.resize(n);\n    for (auto &amp;k: pre)\n        cin &gt;&gt; k;\n    bool flag;\n    if (isPreOrder(0, n - 1))\n        flag = true;\n    else\n    {\n        isMirror = true;\n        flag = isPreOrder(0, n - 1);\n    }\n    cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl;\n    if (flag)\n        for (int i = 0; i &lt; n; ++i)\n            cout &lt;&lt; (i == 0 ? \"\" : \" \") &lt;&lt; post[i];\n}\n","slug":"ã€Œ1043ã€Is-It-a-Binary-Search-Tree","date":"2022-08-21T16:26:25.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search,traversal order,Tree","author_index":"Starlit Rover"},{"id":"0a8ba608dac170a09a78aa1ee9a709bb","title":"ã€Œ1042ã€Shuffling Machine","content":"Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid â€œinside jobsâ€ where employees collaborate with gamblers by performing inadequate shuffles, many casinos employÂ automatic shuffling machines. Your task is to simulate a shuffling machine.\nThe machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:\nS1, S2, ..., S13, \nH1, H2, ..., H13, \nC1, C2, ..., C13, \nD1, D2, ..., D13, \nJ1, J2\n\nwhere â€œSâ€ stands for â€œSpadeâ€, â€œHâ€ for â€œHeartâ€, â€œCâ€ for â€œClubâ€, â€œDâ€ for â€œDiamondâ€, and â€œJâ€ for â€œJokerâ€. A given order is a permutation of distinct integers in [1, 54]. If the number at theÂ i-th position isÂ j, it means to move the card from positionÂ iÂ to positionÂ j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ KÂ (â‰¤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.\nSample Input:2\n36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47\n\nSample Output:S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5\n\n\nÎ©ç®€ç­”çš„æ´—ç‰Œæ¨¡æ‹Ÿç¨‹åºï¼Œå¦ˆå¦ˆå†ä¹Ÿä¸ç”¨æ‹…å¿ƒæˆ‘åœ¨æ¾³é—¨æ‰¾å·¥ä½œå•¦ã€‚\nç»™å‡ºæ´—ç‰Œè½®æ•°å’Œæ¯å¼ ç‰Œä¸‹ä¸€æ¬¡çš„ä½ç½®ï¼Œå…¶ä¸­ç¬¬ä¸ªæ•°å­—ä»£è¡¨åŸæœ¬çš„ç¬¬å¼ ç‰Œåº”è¢«æ´—åˆ°ç¬¬çš„ä½ç½®ä¸Šï¼Œä¸æ–­è¿­ä»£æ´—ç‰Œç›´è‡³è¾¾åˆ°æŒ‡å®šæ¬¡æ•°ã€‚\néå¸¸çš„easyï¼Œç”¨ä¸¤ä¸ªvectorä¸æ–­è®°å½•æ¯æ¬¡æ´—å‰çš„é¡ºåºå’Œæ´—ä¹‹åçš„é¡ºåºï¼Œæœ€åæŒ‰é¡ºåºè¾“å‡ºå³å¯ã€‚\nå“¦å¯¹ï¼Œæ„é€ åˆå§‹åºåˆ—è¿˜çœŸæ˜¯ä¸€ä»¶éº»çƒ¦äº‹ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;string&gt; cards(54), next(54);\n    vector&lt;int&gt; order(54);\n    string shcd[] = {\"S\", \"H\", \"C\", \"D\"};\n    for (int i = 0; i &lt; 4; ++i)\n        for (int j = 1; j &lt; 14; ++j)\n            cards[i * 13 + j - 1] = (shcd[i] + to_string(j));\n    cards[52] = \"J1\";\n    cards[53] = \"J2\";\n    for (auto &amp;k: order)\n        cin &gt;&gt; k;\n    for (int j = 0; j &lt; n; ++j)\n    {\n        for (int i = 0; i &lt; 54; ++i)\n            next[order[i] - 1] = cards[i];\n        cards = next;\n    }\n    cout &lt;&lt; cards[0];\n    for (int i = 1; i &lt; 54; ++i)\n        cout &lt;&lt; \" \" &lt;&lt; cards[i];\n}\n","slug":"ã€Œ1042ã€Shuffling-Machine","date":"2022-08-21T14:57:46.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,vector","author_index":"Starlit Rover"},{"id":"0b17d25479bad782d0ac02fc7689837c","title":"ã€Œ1041ã€Be Unique","content":"Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins.\n\n\nInput Specification:Each input file contains one test case. Each case contains a line which begins with a positive integerÂ NÂ (â‰¤) and then followed byÂ NÂ bets. The numbers are separated by a space.\nOutput Specification:For each test case, print the winning number in a line. If there is no winner, printÂ NoneÂ instead.\nSample Input 1:7 5 31 5 88 67 88 17\n\nSample Output 1:31\n\nSample Input 2:5 888 666 666 888 888\n\nSample Output 2:None\n\n\nÎ©æˆ‘è€å®¶é‚£è¾¹å–å½©ç¥¨ï¼Œè§„åˆ™å¾ˆæœ‰è¶£ï¼Œç¬¬ä¸€ä¸ªä¹°åˆ°å”¯ä¸€æ•°å­—çš„äººä¸­å¥–ã€‚æŒ‰ç…§æ—¶é—´é¡ºåºç»™å‡ºæ‰€æœ‰ä¹°å®¶æ‰€ä¹°çš„æ•°å­—ï¼Œè¦æ±‚è¾“å‡ºwinnerçš„æ•°å­—ï¼Œæ²¡æœ‰åˆ™Noneã€‚\né‚£ä¹ˆå¯ä»¥ç”¨ä¸€ä¸ªvectoræ¥è®°å½•å½©ç¥¨æ•°å­—çš„æ—¶é—´é¡ºåºï¼Œé‚£ä¹ˆå¦‚ä½•å¿«é€Ÿåˆ¤æ–­åœ¨æ­¤ä¹‹å‰æ˜¯å¦å·²æœ‰ç›¸åŒæ•°å­—å‘¢ã€‚è¿™é‡Œæˆ‘å¦å¤–ç”¨äº†ä¸€ä¸ªmapå»ºç«‹èµ·äº†ï¼ˆlottery numberï¼Œvector indexï¼‰çš„æ˜ å°„ï¼Œä»è€Œèƒ½å¿«é€Ÿæ‰¾åˆ°vectorä¸­çš„ä½ç½®ï¼Œæ‰¾åˆ°åç›´æ¥å°†å…¶çš„ä¸­å¥–èµ„æ ¼ç½®falseï¼Œå› æ­¤vectorçš„ç±»å‹ä¸º&lt;int,bool&gt;ï¼Œæœ€åå†ä»å¤´æ‰¾çš„ä¸€ä¸ªtrueçš„æ•°å­—å³å¯ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, bool&gt;&gt; lottery;\n    map&lt;int, int&gt; idx;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        if (idx.find(m) == idx.end())\n        {\n            idx[m] = lottery.size();\n            lottery.push_back({m, true});\n        }\n        else\n            lottery[idx[m]].second = false;\n    }\n    for (auto &amp;k: lottery)\n        if (k.second)\n        {\n            cout &lt;&lt; k.first;\n            return 0;\n        }\n    cout &lt;&lt; \"None\";\n}\n","slug":"ã€Œ1041ã€Be-Unique","date":"2022-08-20T15:19:44.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"6e5180ebfe96513fbbfe6405ce489018","title":"ã€Œ1040ã€Longest Symmetric String","content":"Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, givenÂ Is PAT&amp;TAP symmetric?, the longest symmetric sub-string isÂ s PAT&amp;TAP s, hence you must outputÂ 11.\n\n\nInput Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000.\nOutput Specification:For each test case, simply print the maximum length in a line.\nSample Input:Is PAT&amp;TAP symmetric?\n\nSample Output:11\n\n\nÎ©è¾“å‡ºæœ€é•¿å¯¹ç§°å­ä¸²çš„é•¿åº¦ï¼Œç®€æ´æ˜äº†ï¼Œè·Ÿè¿™ç¯‡åšå®¢ä¸€æ ·ï¼Œæˆ‘å–œæ¬¢ã€‚\nå¯¹äºå¯¹ç§°å­—ç¬¦ä¸²æˆ‘ä»¬å¯ä»¥æ ¹æ®å¯¹ç§°ä¸­å¿ƒç‚¹å»å¯»æ‰¾ï¼Œè€Œä¸­å¿ƒç‚¹å¯èƒ½æ˜¯å­—ç¬¦ï¼ˆå¥‡å¯¹ç§°ï¼‰ä¹Ÿå¯èƒ½æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸­é—´ï¼ˆå¶å¯¹ç§°ï¼‰ï¼Œé‚£ä¹ˆä¸­å¿ƒç‚¹å…±æœ‰ç§é€‰æ‹©ã€‚ç„¶åè®¡ç®—ä¸­å¿ƒç‚¹å‘¨å›´ä¸¤ä¸ªé‚»è¿‘å­—ç¬¦çš„ç´¢å¼•ï¼Œå¾ªç¯æ‰¾å‡ºæœ€é•¿å¯¹ç§°å­ä¸²ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    getline(cin, s);\n    int max = 1;\n    for (int i = 0; i &lt; 2 * s.size(); ++i)\n    {\n        int left = i / 2, right = (i + i % 2) / 2 + 1, sum = i % 2;\n        while (left &gt;= 0 &amp;&amp; right &lt; s.size())\n        {\n            if (s[left--] == s[right++])\n                sum += 2;\n            else\n                break;\n        }\n        if (sum &gt; max)\n            max = sum;\n    }\n    cout &lt;&lt; max;\n}\n","slug":"ã€Œ1040ã€Longest-Symmetric-String","date":"2022-08-20T14:23:27.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"925a25c8e70f189f82f27070d123048d","title":"ã€Œ1039ã€Course List for Student","content":"Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers:Â NÂ (â‰¤40,000), the number of students who look for their course lists, andÂ KÂ (â‰¤2,500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 toÂ K) in the following format: for each courseÂ i, first the course indexÂ iÂ and the number of registered studentsÂ Niâ€‹Â (â‰¤200) are given in a line. Then in the next line,Â Niâ€‹Â student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains theÂ NÂ names of students who come for a query. All the names and numbers in a line are separated by a space.\nOutput Specification:For each test case, print your results inÂ NÂ lines. Each line corresponds to one student, in the following format: first print the studentâ€™s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line.\nSample Input:11 5\n4 7\nBOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\n1 4\nANN0 BOB5 JAY9 LOR6\n2 7\nANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6\n3 1\nBOB5\n5 9\nAMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\nZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9\n\nSample Output:ZOE1 2 4 5\nANN0 3 1 2 5\nBOB5 5 1 2 3 4 5\nJOE4 1 2\nJAY9 4 1 2 4 5\nFRA8 3 2 4 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 2 4 5\nLOR6 4 1 2 4 5\nNON9 0\n\n\nÎ©éš¾å¾—æ°´é¢˜æ”¾æ¾ï¼Œç»™å‡ºæ¯ä¸ªè¯¾ç¨‹çš„é€‰è¯¾åå•ï¼Œä¸ºå‰æ¥æŸ¥è¯¢è¯¾ç¨‹çš„å­¦ç”Ÿå¢åºè¾“å‡ºä»–ä»¬æ‰€é€‰è¯¾ç¨‹å·ã€‚\nmapã€setæ­é…ï¼Œå¹²æ´»ä¸ç´¯ã€‚è¯»å®Œå³è¾“å‡ºã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, set&lt;int&gt;&gt; info;\n    int n, k, idx, m;\n    string name;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; idx &gt;&gt; m;\n        for (int j = 0; j &lt; m; ++j)\n        {\n            cin &gt;&gt; name;\n            info[name].insert(idx);\n        }\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name;\n        cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; info[name].size();\n        for (auto &amp;c: info[name])\n            cout &lt;&lt; \" \" &lt;&lt; c;\n        cout &lt;&lt; endl;\n    }\n}\n","slug":"ã€Œ1039ã€Course-List-for-Student","date":"2022-08-20T13:47:05.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set","author_index":"Starlit Rover"},{"id":"5e05676005a67b187c728a6e49c065fb","title":"é—ä¼ ç®—æ³•","content":"â€œç‰©ç«å¤©æ‹©ï¼Œé€‚è€…ç”Ÿå­˜â€œï¼Œè¿›åŒ–ç•Œçš„åè¨€æ²¡æƒ³åˆ°ä¹Ÿèƒ½ç”¨åœ¨ç®—æ³•é‡Œï¼Œä¸å¾—ä¸æ‰¿è®¤æ¯ä¸ªç®—æ³•å·¥ç¨‹å¸ˆä¹Ÿæ˜¯å¤©é©¬è¡Œç©ºçš„é­”æ³•å¸ˆã€‚ç”±äºç»å¸¸å‚åŠ æ•°å­¦ç…é¦ç¾é£Ÿçƒ¹é¥ªå¤§èµ›ï¼Œå› æ­¤æ—¶ä¸æ—¶éœ€è¦å’Œå¯å‘å¼ç®—æ³•æ‰“äº¤é“ï¼Œè¿™äº›æ™ºèƒ½ç®—æ³•çš„æ€æƒ³å……æ»¡ç€æ´»åŠ›å’Œå¼€æ‹“æ€§ï¼Œcodingçš„æ—¶å€™ç”šè‡³æ„Ÿè§‰è‡ªå·±åƒä¸Šå¸ä¸€æ ·ä¸ºè‡ªå·±çš„ä¸–ç•Œåˆ¶å®šç€è§„åˆ™ï¼Œä¸ç¦è¿è¿æ„Ÿå¹ã€‚\nä»Šå¤©å¼€å¯æ™ºèƒ½ç®—æ³•ç¯‡ç« ï¼Œé¦–å…ˆä¸Šåœºçš„æ˜¯é—ä¼ å¤§æ³•ã€‚\n\n\n\n\nÎ©å¯å‘å¼ç®—æ³•çš„ç›®çš„å¾€å¾€æ˜¯å¯»æ±‚ä¸€ä¸ªä¼˜åŒ–æ¨¡å‹çš„æœ€ä¼˜è§£ï¼Œä½†ç”±äºæ¨¡å‹çš„è¿‡äºåºå¤§æˆ–æ˜¯å¤æ‚ï¼Œæƒ³è¦æŠŠç²¾ç¡®çš„æœ€ä¼˜è§£æªå‡ºæ¥éœ€è¦èŠ±è´¹å¤§é‡çš„æ—¶é—´å’Œç®—åŠ›ã€‚é‚£ä¹ˆæˆ‘ä»¬é€€è€Œæ±‚å…¶æ¬¡ï¼Œäº‰å–å°½å¯èƒ½é€¼è¿‘æœ€ä¼˜è§£ï¼Œæ¥å—ä¸€å®šèŒƒå›´çš„è¯¯å·®ï¼Œä»è€Œæœ‰äº†å„ç§å¯å‘å¼ç®—æ³•å…«ä»™è¿‡æµ·ã€‚\né—ä¼ ç®—æ³•ï¼Œé¡¾åæ€ä¹‰ï¼Œæˆ‘ä»¬å°†æ¯ä¸€ä¸ªå¯è¡Œè§£çœ‹ä½œä¸ºä¸€ä¸ªä¸ªä½“ï¼Œè®©è¿™äº›ä¸ªä½“ç”Ÿå­˜ç¹è¡ï¼Œæˆ‘ä»¬ä½œä¸ºä¸Šå¸åˆ¶å®šå‡ºå¦‚ä½•è®¡ç®—ä¸ªä½“å¯¹äºç¯å¢ƒé€‚åº”å€¼ï¼ˆç›®æ ‡å‡½æ•°ï¼‰çš„è§„åˆ™ã€‚æ¥ä¸‹æ¥å°±äº¤ç»™å¤§è‡ªç„¶å»é€‰æ‹©ï¼Œç»è¿‡ä¸€ä»£ä¸€ä»£çš„æ·˜æ±°è¿›åŒ–ï¼Œæœ€ç»ˆå‡ºç°åœ¨æˆ‘ä»¬é¢å‰å°±æ˜¯é€‚åº”åº¦æœ€é«˜çš„ä¸ªä½“ä»¬ã€‚\né‚£ä¹ˆç¹è¡æ·˜æ±°è¿™ä¹ˆå¤æ‚çš„ç”Ÿç†è¿‡ç¨‹å¦‚ä½•åœ¨è®¡ç®—æœºå†…è¡¨è¾¾å‘¢ï¼Œæˆ‘ä»¬çŸ¥é“ç¹è¡çš„æœ¬è´¨å°±æ˜¯åŸºå› çš„äº¤æ¢é‡ç»„ï¼Œè€ŒåŸºå› çš„æœ¬è´¨æ˜¯å¯¹é—ä¼ ä¿¡æ¯çš„ç¼–ç ï¼Œè®¡ç®—æœºæœ€æ“…é•¿çš„è«è¿‡äºæ­¤ã€‚å› æ­¤æˆ‘ä»¬é¦–å…ˆéœ€è¦å°†æ¯ä¸ªä¸ªä½“ï¼ˆå¯è¡Œè§£ï¼‰è¿›è¡Œç¼–ç ä¸ºåŸºå› ä¸²ï¼Œä¸ºäº†è´´åˆè®¡ç®—æœºå¹¶æ–¹ä¾¿èµ·è§ä¸€èˆ¬éƒ½æ˜¯è½¬æ¢ä¸ºäºŒè¿›åˆ¶ç¼–ç ï¼Œé‚£ä¹ˆç¹è¡çš„è¿‡ç¨‹å¾ˆæ˜¾ç„¶å°±æ˜¯å¯¹åŸºå› è¿›è¡Œåˆ‡ç‰‡é‡ç»„ã€‚é—®é¢˜æ˜¯å¤§è‡ªç„¶å¦‚æœåªé å•çº¯çš„åŸºå› é‡ç»„ç¹è¡åä»£ï¼Œé‚£ä¹ˆç‰©ç§çš„å¤šæ ·æ€§å°†è¢«é™åˆ¶ï¼Œä¹‹æ‰€ä»¥ç‰©ç§èƒ½å¤Ÿè¿›åŒ–ä¸€æ–¹é¢æ˜¯è‡ªç„¶é€‰æ‹©ï¼Œå¦å¤–ä¸€ä¸ªé‡è¦çš„æœºåˆ¶æ˜¯å˜å¼‚ï¼Œå˜å¼‚ä½¿å¾—åŸæœ¬çš„åŸºå› ç‰‡æ®µå¾—ä»¥æ”¹å˜ï¼Œä»è€Œç‰©ç§æœç€ä¸åŒçš„æ–¹å‘å‘å±•ï¼ˆæœç´¢ï¼‰ï¼Œå¤§å¤§å¢åŠ äº†ç®—æ³•çš„é²æ£’æ€§ã€‚\nä¸‹é¢æ˜¯ä¸€ä¸ªæ•°æ¨¡æ¯”èµ›ä¸­é‡åˆ°çš„ç®€åŒ–ç‰ˆæ¡ˆä¾‹ã€‚\n\nÆºç®€å•åœ°è¯´ï¼Œæœ‰ä¸€äº›äº¤æ˜“è®¢å•ï¼Œé¦–å…ˆæ ¹æ®æ¯ä¸ªè®¢å•çš„è®¡ç®—ç»“æœå¯¹æ‰€æœ‰è®¢å•è¿›è¡Œé™åºæ’åºï¼Œå…¶ä¸­ä¸¤ä¸ªä¸è®¢å•æ— å…³çš„å¾…å®šæƒé‡ï¼Œç„¶åæ’åºç»“æœä¼šé€å…¥ä¸€ä¸ªè´ªå¿ƒç®—æ³•ä¸­ï¼Œæœ€ç»ˆè¾“å‡ºä¸€ä¸ªç»“æœã€‚é‚£ä¹ˆå¾ˆæ˜¾ç„¶ä¸åŒçš„ä¼šå½±å“è®¢å•çš„æ’åºç»“æœï¼Œä»è€Œå½±å“åˆ°æœ€ç»ˆçš„è¾“å‡ºç»“æœã€‚æ­¤æ—¶æˆ‘å¸Œæœ›å¾—åˆ°æœ€å¤§ç»“æœï¼Œä½†å¯¹äºæƒé‡çš„å–å€¼æ— ä»ä¸‹æ‰‹ã€‚é‚£ä¹ˆå°±è®©å¤§è‡ªç„¶çš„é—ä¼ å¤§æ³•æ¥ç­›é€‰å§ã€‚\nâš¤ ç¼–ç è§£ç åœ¨æ­¤æˆ‘ä»¬éœ€è¦å…ˆç¡®å®šçš„å–å€¼èŒƒå›´ï¼Œä»è€Œæ‰èƒ½å¯¹æœ‰é™çš„åŸºå› è¿›è¡Œç¼–ç è§£ç ã€‚æ ¹æ®åˆæ­¥çš„ä¼°è®¡å¯ä»¥å¾—å‡ºä¸¤è€…æœ€ä¼˜è§£çš„åˆ†å¸ƒèŒƒå›´\n\né‚£ä¹ˆä¸€ç»„å¯è¡Œè§£å³ä¸º7ä½åè¿›åˆ¶æ•°ï¼Œæ ¹æ®å¯çŸ¥éœ€è¦24ä½{0,1}äºŒè¿›åˆ¶ä¸²æ¥ç¼–ç \n\nå‰16ä½ä¸ºÎ±ï¼Œå8ä½ä¸ºÎ²ï¼Œé‚£ä¹ˆå¯ä»¥å†™å‡ºè§£ç å‡½æ•°ï¼š\ndef decode(gene):\n    alpha = eval(gene[0:16]) * 0.0001\n    beta = eval('0b' + gene[16:]) * 0.00001\n    return [alpha, beta]\n\nâš¤ åˆå§‹åŒ–ç§ç¾¤ä¸ªä½“ä¸èƒ½æ— ä¸­ç”Ÿæœ‰ï¼Œæˆ‘ä»¬å¿…ç„¶éœ€è¦å…ˆéšæœºç”Ÿæˆä¸€ä¸ªç¥–å…ˆç§ç¾¤ï¼Œå³ç¬¬ä¸€ä»£ä¸ªä½“ï¼Œè¿™äº›ä¸ªä½“æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«è¦æ±‚ï¼Œåªè¦æ»¡è¶³çº¦æŸæ¡ä»¶å³å¯ï¼ˆå¯è¡Œè§£ï¼‰ã€‚åœ¨æˆ‘ä»¬è¿™ä¸ªé—®é¢˜ä¸­å¯¹æ²¡æœ‰çº¦æŸï¼Œåªè¦åœ¨ä¸Šè¿°èŒƒå›´å†…å³å¯ã€‚\næ³¨æ„è¿™é‡Œç”±äºäºŒè¿›åˆ¶è¡¨ç¤ºèŒƒå›´å¤§äºæˆ‘ä»¬çš„ä¸Šè¿°èŒƒå›´ï¼Œå› æ­¤è¿˜æ˜¯å…ˆåˆ†åˆ«ç”Ÿæˆåè¿›åˆ¶æ•°ç„¶åè½¬åŒ–ä¸ºäºŒè¿›åˆ¶ï¼Œæœ€åæ‹¼æ¥åœ¨ä¸€èµ·çš„ã€‚\nimport random as rd\ndef init(num):\n    pop = []\n    for i in range(num):\n        b1 = bin(rd.randint(0, 10000))\n        b2 = bin(rd.randint(0, 1000))\n        if len(b1) &lt; 16:\n            b1 = list(b1)\n            b1.insert(2, '0' * (16 - len(b1)))\n            b1 = ''.join(b1)\n        if len(b2) &lt; 12:\n            b2 = list(b2)\n            b2.insert(2, '0' * (12 - len(b2)))\n            b2 = ''.join(b2)\n        pop.append(b1 + b2[2:])\n    return pop\n\nâš¤ é€‚åº”æ€§è¯„ä»·åœ¨å¼€å¯å¤§è‡ªç„¶çš„é€‰æ‹”æœºåˆ¶å‰ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰æ¯ä¸ªä¸ªä½“çš„é€‚åº”åº¦ï¼Œæœ¬è´¨ä¸Šæ¥è¯´å°±æ˜¯æœ‰å¤šåˆæˆ‘ä»¬çš„å¿ƒæ„ï¼Œåœ¨è¿è¡Œè¿‡ç¨‹ä¸­ä»£è¡¨ç€å­˜æ´»ç‡ã€‚å¦‚æœç›®æ ‡å‡½æ•°æ˜¯æœ€å¤§åŒ–ï¼Œé‚£ä¹ˆå¾€å¾€æ˜¯ç›´æ¥å°†ç›®æ ‡å‡½æ•°ä½œä¸ºé€‚åº”æ€§å‡½æ•°ï¼›è‹¥æ˜¯æœ€å°åŒ–ï¼Œåˆ™å¯ä»¥è¿›è¡Œå–è´Ÿå¹³ç§»æˆ–æ˜¯å–å€’æ•°ç­‰æ“ä½œã€‚\nå¦å¤–é€‚åº”æ€§è®¡ç®—ä¸éœ€è¦æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåœ¨æœ¬ä¾‹ä¸­å°±æ˜¯ä¸€ä¸ªè´ªå¿ƒç®—æ³•æ¥è®¡ç®—ä¸ªä½“é€‚åº”æ€§çš„ã€‚\nå¯¹äºä¸ªä½“å‡è®¾å…¶é€‚åº”æ€§ä¸ºï¼Œé‚£ä¹ˆå…¶ç”Ÿå­˜ç‡ä¸º\n\nâš¤ è½®ç›˜èµŒé€‰æ‹©è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒç»å…¸å¸¸ç”¨çš„ä¼˜èƒœåŠ£æ±°æ–¹å¼ï¼Œæ ¹æ®æ·˜æ±°ç‡ç”Ÿæˆä¸ªéšæœºæ•°ï¼Œæ¯ä¸ªéšæœºæ•°é€‰æ‹©æ»¡è¶³ä¸‹åˆ—æ¡ä»¶çš„ç¬¬ä¸ªä¸ªä½“ï¼Œæœªè¢«é€‰æ‹©çš„ä¸ªä½“å°†è¢«æ·˜æ±°\n\næœ‰ç‚¹åƒä¸Šå¸æ·éª°å­ã€‚è¿™é‡Œä¸ç›´æ¥é€‰æ‹©ç”Ÿå­˜ç‡æœ€é«˜çš„ä¸ªä½“ä¹Ÿæ˜¯åœ¨æ¨¡æ‹Ÿç°å®ä¸–ç•Œä¸­çš„æ„å¤–ï¼Œç»™ç®—æ³•åŠ å…¥äº†æ›´å¤§çš„éšæœºæ€§ï¼Œæ¯•ç«Ÿæœªå¿…ä¼˜è‰¯ä¸ªä½“ç¹è¡çš„åä»£å°±ä¸€å®šè¿˜æ˜¯ä¼˜è‰¯çš„ï¼Œç›¸ååŠ£åŠ¿ä¸ªä½“ä¹Ÿæ˜¯ä¸€æ ·ã€‚è¿™æ ·çš„å¤„ç†æ–¹å¼å¤§å¤§å¢åŠ äº†ç®—æ³•çš„çµæ´»æ€§ã€‚\njdg = np.array(list(map(adpt, pop)))\nout_num = int(out_rate * len(pop))\nnext_pop = []\nin_num = len(pop) - out_num\nfor i in range(in_num):\n    dice = rd.random() * jdg.sum()\n    sum = 0\n    for j in range(len(pop)):\n        sum += jdg[j]\n        if sum &gt; dice:\n            next_pop.append(pop[j])\n            break\n\nâš¤ äº¤å‰é‡ç»„å¯¹ä¸Šä¸€æ­¥ä¸­å¹¸å­˜ä¸‹æ¥çš„ä¸ªä½“ï¼Œéšæœºé€‰å–ä¸¤è€…è¿›è¡Œäº¤å‰é‡ç»„ã€‚é¦–å…ˆéšæœºç”Ÿæˆä¸€ä¸ªäº¤å‰ä½ç‚¹ï¼Œç„¶åå°†ä¸¤ä¸ªä¸ªä½“çš„åŸºå› åœ¨äº¤å‰ä½ç‚¹å¤„æ‹†åˆ†é‡ç»„åå½¢æˆçš„ä¸¤ä¸ªæ–°ä¸ªä½“åŠ å…¥å½“å‰çš„ç§ç¾¤ä¸­ã€‚æˆ‘åœ¨è¿™é‡Œçš„å¤„ç†æ–¹å¼æ˜¯ä¸æ–­ç¹è¡è‡³ç§ç¾¤ä¸ªä½“æ•°é‡æ¢å¤å¦‚åˆï¼Œå¦‚æœæŒ‰æŒ‡æ•°æ–¹å¼å¢åŠ ç§ç¾¤æ•°é‡çš„è¯ï¼Œè¿­ä»£æ¬¡æ•°ç¨å¾®ä¸€å¤§å°±ä¼šå¾ˆæ…¢ã€‚\nfor i in range(round(out_num / 2)):\n       x = rd.randint(0, in_num - 1)\n       y = rd.randint(0, in_num - 1)\n       node = rd.randint(3, 25)\n       next_pop.append(next_pop[x][0:node] + next_pop[y][node:])\n       next_pop.append(next_pop[y][0:node] + next_pop[x][node:])\n\nâš¤ ä¸ªä½“å˜å¼‚å¯¹æ–°ä¸€ä»£ç§ç¾¤ä¸­çš„æ¯ä¸ªä¸ªä½“ç”Ÿæˆä¸€ä¸ªéšæœºæ•°ï¼Œè‹¥ï¼ˆæ˜¯å˜å¼‚æ¦‚ç‡ï¼Œä¸€èˆ¬è¾ƒå°ï¼‰åˆ™éšæ„ç”Ÿæˆä¸€ä¸ªå˜å¼‚ä½ç‚¹ï¼Œå°†è¯¥ä½ç‚¹å¤„çš„ç¼–ç è¿›è¡ŒäºŒè¿›åˆ¶åè½¬ï¼ˆ0â†’1,1â†’0ï¼‰ã€‚è¿‡å¤§ä¼šå¯¼è‡´è¿›åŒ–æ”¶æ•›åˆ°æœ€åçš„ä¼˜è‰¯ç§ç¾¤åŸºå› ä¸ç¨³å®šï¼Œå³ä½¿è¿­ä»£æ¬¡æ•°è¾ƒå¤§ä¹Ÿéš¾ä»¥æ”¶æ•›ã€‚\nğŸ§Ÿâ€â™€ï¸ä¸§å°¸å°±æ˜¯å˜å¼‚è¿‡çŒ›çš„ç»“æœğŸ§Ÿâ€â™‚ï¸\nBUTï¼Œå¦‚æœè¯´æœç´¢èŒƒå›´éå¸¸å¤§çš„è¯ï¼Œæˆ‘ä»¬å°†é€‚å½“è°ƒå¤§å¯èƒ½ä¼šæœ‰ç€æ„æƒ³ä¸åˆ°çš„ç»“æœï¼Œä½†å‰ææ˜¯æ¯æ¬¡è¿­ä»£åéƒ½è¦æ›´æ–°å½“å‰æœ€ä¼˜ä¸ªä½“åŸºå› å’Œé€‚åº”æ€§ï¼Œè¿™æ ·å°±ç›¸å½“äºä¸€ç§å˜ç›¸çš„éšæœºæœç´¢ã€‚å½“ç„¶å¯ä»¥ä¸¤è€…ç›¸ç»“åˆï¼Œé‚£ä½ å°†é¢å‘æœç´¢ã€‚\nfor i in range(len(next_pop)):\n    if rd.random() &lt; pm:\n        node = rd.randint(2, 25)\n        next_pop[i] = next_pop[i][0:node] + ('1' if next_pop[i][node] == '0' else '0') + next_pop[i][node + 1:]\n\nâš¤ é‡å¤è¿­ä»£ä¸€èˆ¬è®¾ç½®300-500è½®è¿­ä»£ï¼Œæ›´é‡è¦çš„æ˜¯è§‚å¯Ÿé€‚åº”æ€§æ˜¯å¦é€æ¸æ”¶æ•›ã€‚\n\n\n\né‚£ä¹ˆä¸Šå¸æ˜¯ä¸æ˜¯ä¹Ÿåœ¨è¿è¡Œç€é«˜é˜¶çš„é—ä¼ ç®—æ³•å‘¢ï¼Ÿ\n","slug":"é—ä¼ ç®—æ³•","date":"2022-08-19T16:37:41.000Z","categories_index":"æ™ºèƒ½ç®—æ³•","tags_index":"python,æ•°å­¦ç…é¦","author_index":"Starlit Rover"},{"id":"f0575046ba6429b64e77d36d9af8e107","title":"ã€Œ1038ã€Recover the Smallest Number","content":"Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, 87 }, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.\n\n\nInput Specification:Each input file contains one test case. Each case gives a positive integerÂ NÂ () followed byÂ NÂ number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the smallest number in one line. Notice that the first digit must not be zero.\nSample Input:5 32 321 3214 0229 87\n\nSample Output:22932132143287\n\n\nÎ©æœ‰ç‚¹æ„æ€ï¼Œç»™å‡ºå‡ ä¸ªé•¿åº¦ä¸ä¸€çš„æ•°å­—åˆ‡ç‰‡ï¼Œå¸Œæœ›ä½ é‡ç»„ä¸ºä¸€ä¸ªæœ€å°çš„æ•°ã€‚\nåˆšå¼€å§‹æ²¡æƒ³åˆ°è´ªå¿ƒç®—æ³•ï¼Œæ€»æ˜¯æƒ³ç€å…¨éƒ¨è¯»å…¥ç„¶åæ„å»ºä¸€æ£µæ’åºæ ‘ï¼Œä½†å¤„ç†èµ·æ¥æ€»æ˜¯ç›¸å¯¹éº»çƒ¦ã€‚åæ¥çªç„¶çµå…‰ä¸€ç°ï¼Œå®Œå…¨å¯ä»¥ä¸€è¾¹è¯»å…¥ä¸€è¾¹æ’åºï¼Œæ‰¾åˆ°é€‚å½“çš„ä½ç½®æ’å…¥åæˆä¸ºå½“å‰æœ€å°çš„æ•°å­—ï¼Œè¿™æ˜¯å¾ˆç»å…¸çš„è´ªå¿ƒç®—æ³•ã€‚\né‚£ä¹ˆå¦‚ä½•è¯æ˜è¿™ä¸ªè´ªå¿ƒç®—æ³•å¾—å‡ºçš„ç»“æœä¸€å®šæ˜¯é¢˜ç›®æ‰€æ±‚å‘¢ã€‚æˆ‘ä»¬åªéœ€è¯æ˜æ¯ä¸€æ¬¡çš„æœ€ä¼˜è§£èƒ½é€šè¿‡æ’åºæ’å…¥çš„æ–¹å¼æ‰¾åˆ°ä¸‹ä¸€æ¬¡çš„æœ€ä¼˜è§£å³å¯ã€‚å¦‚æœå¯¹äºä¸€ä¸ªæœ€å°æ’åˆ—ï¼Œæˆ‘ä»¬éšæœºä»ä¸­æŠ½èµ°ä¸€ä¸ªåˆ‡ç‰‡åçš„ç»“æœä¸æ˜¯æœ€å°æ’åˆ—ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸€å®šèƒ½å¤Ÿå°†æŠ½èµ°çš„åˆ‡ç‰‡ä¸å‰©ä½™åˆ‡ç‰‡çš„æœ€å°æ’åˆ—æ„é€ å‡ºä¸€ä¸ªæ¯”åŸæ’åˆ—æ›´å°çš„æ–°æ’åˆ—ï¼ŒçŸ›ç›¾ã€‚è¿™è¯´æ˜æ‰€æœ‰æœ€å°æ’åˆ—éƒ½å¯æ‹†åˆ†æˆä¸€ä¸ªåˆ‡ç‰‡å’Œå¦ä¸€ä¸ªæœ€å°æ’åˆ—ï¼Œä»è€Œå½’çº³è¯æ˜äº†è´ªå¿ƒçš„æ­£ç¡®æ€§ã€‚\næ’åºæ’å…¥çš„æµç¨‹æ˜¯ä»å½“å‰æœ€å·¦è¾¹çš„åˆ‡ç‰‡å¼€å§‹æ¯”è¾ƒæ”¾ç½®åœ¨å‰é¢å’Œåé¢çš„å¤§å°ï¼Œè‹¥æ”¾ç½®åœ¨å‰é¢æ›´å°åˆ™åœæ­¢æ¯”è¾ƒå¹¶å°†å…¶æ’å…¥åˆ°è¯¥åˆ‡ç‰‡çš„å‰é¢ï¼Œå¦åˆ™ç»§ç»­ä¸ä¸‹ä¸€ä¸ªåˆ‡ç‰‡è¿›è¡Œæ¯”è¾ƒã€‚ä¹‹æ‰€ä»¥å¯ä»¥è¿™ä¹ˆæ¯”è¾ƒæ˜¯å› ä¸ºå½“å‰çš„åˆ‡ç‰‡åºåˆ—ä¹Ÿæ˜¯æœ‰åºçš„ï¼Œè€Œè¿™ç§æ¯”è¾ƒæ–¹å¼ç±»ä¼¼äºå†’æ³¡æ’åºã€‚\nä¼—æ‰€å‘¨çŸ¥ï¼Œæ’åºå†’æ³¡åœ¨æ’åˆ—é€†åºæ•°æ®æ—¶ä¼šè€—æ—¶å·¨å¤§ï¼Œè¿™ä¹Ÿå¯¼è‡´æœ€åä¸€ä¸ªæµ‹è¯•ç‚¹æ— æ³•é€šè¿‡ã€‚ç”±äºæ˜¯åœ¨æœ‰åºåˆ‡ç‰‡å†…è¿›è¡Œæ’å…¥ï¼Œå› æ­¤å¯ä»¥é‡‡å–äºŒåˆ†çš„æ–¹å¼ã€‚ä½†æ›´ä¸ºç®€ä¾¿çš„æ–¹å¼æ˜¯é‡‡ç”¨&lt;algorithm&gt;åº“ä¸­çš„sortå‡½æ•°ï¼ŒæŒ‡å®šcmpå‡½æ•°ä¸ºreturn a+b&lt;b+a;ã€‚\næœ€åéœ€è¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªéé›¶æ•°å­—ï¼Œæ³¨æ„å‰é¢çš„0ä¸è¦è¾“å‡ºï¼Œå¦å¤–åˆ«å¿˜äº†å…¨0å¤§å‘ã€‚\n\nC â˜º D Eâ¢ äºŒåˆ†æ³•#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nchar r[10];\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    string s;\n    vector&lt;string&gt; arrange;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s\", r);\n        s = r;\n        if (i == 0)\n            arrange.push_back(s);\n        else\n        {\n            string x, y;\n            int left = 0, right = arrange.size();\n            while (left &lt; right)\n            {\n                int mid = (left + right) / 2;\n                x = s + arrange[mid];\n                y = arrange[mid] + s;\n                if (x &gt; y)\n                    left = mid + 1;\n                else\n                    right = mid;\n            }\n            arrange.insert(arrange.begin() + left, s);\n        }\n    }\n\n    bool flag = false;\n\n    for (auto &amp;k: arrange)\n    {\n        if (flag)\n            printf(\"%s\", k.c_str());\n        else\n        {\n            flag = !(k == string(k.size(), '0')) || flag;\n            for (int i = 0; i &lt; k.size(); ++i)\n                if (k[i] != '0')\n                {\n                    printf(\"%s\", k.substr(i, k.size() - i).c_str());\n                    break;\n                }\n        }\n    }\n    if (!flag)\n        printf(\"0\");\n}\n\nâ£ sort#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;string&gt; arrange(n);\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; arrange[i];\n\n    sort(arrange.begin(), arrange.end(), [](string &amp;a, string &amp;b) { return a + b &lt; b + a; });\n\n    bool flag = false;\n    for (auto &amp;k: arrange)\n    {\n        if (flag)\n            printf(\"%s\", k.c_str());\n        else\n        {\n            flag = !(k == string(k.size(), '0')) || flag;\n            for (int i = 0; i &lt; k.size(); ++i)\n                if (k[i] != '0')\n                {\n                    printf(\"%s\", k.substr(i, k.size() - i).c_str());\n                    break;\n                }\n        }\n    }\n    if (!flag)\n        printf(\"0\");\n}\n","slug":"ã€Œ1038ã€Recover-the-Smallest-Number","date":"2022-08-19T04:22:22.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search,sort,vector","author_index":"Starlit Rover"},{"id":"0738eb06f86d646ed22a63acbd8bab64","title":"ã€Œ1037ã€Magic Coupon","content":"The magic shop in Mars is offering some magic coupons. Each coupon has an integerÂ NÂ printed on it, meaning that when you use this coupon with a product, you may getÂ NÂ times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positiveÂ NÂ to this bonus product, you will have to pay the shopÂ NÂ times the value of the bonus productâ€¦ but hey, magically, they have some coupons with negativeÂ Nâ€™s!\nFor example, given a set of coupons , and a set of product values  (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (withÂ NÂ being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop.\nEach coupon and each product may be selected at most once. Your task is to get as much money back as possible.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains the number of couponsÂ â€‹, followed by a line withÂ Â coupon integers. Then the next line contains the number of productsÂ â€‹, followed by a line withÂ â€‹Â product values. HereÂ ,  and it is guaranteed that all the numbers will not exceedÂ .\nOutput Specification:For each test case, simply print in a line the maximum amount of money you can get back.\nSample Input:4\n1 2 4 -1\n4\n7 6 -2 -3\n\nSample Output:43\n\n\nÎ©ç«æ˜Ÿè¶…å¸‚ï¼Œå—¯ï¼Œæˆ‘æ•…å±…ï¼Œå‘ä¼˜æƒ åˆ¸ï¼Œä¸€å¼ ä¼˜æƒ åˆ¸åªèƒ½å’Œä¸€ä»¶äº§å“æ­é…ä½¿ç”¨ï¼Œç»™å‡ºä¸€ç³»åˆ—ä¼˜æƒ åˆ¸å’Œå•†å“ä»·æ ¼ï¼ˆå‡å¯ä¸ºè´Ÿï¼‰ï¼Œä¼˜æƒ åˆ¸å’Œå•†å“ä»·æ ¼çš„ä¹˜ç§¯ä¸ºå¯ä»¥è¿”è¿˜çš„ç«æ˜Ÿå¸æ•°ï¼Œè¦æ±‚ä½ è®¡ç®—å‡ºæœ€å¤§çš„è¿”è¿˜å¸æ•°ã€‚ï¼ˆå°±æ˜¯æ’åˆ—ç»„åˆæœ€å¤§åŒ–ç›®æ ‡å‡½æ•°ï¼ŒèƒŒæ™¯æ•´çš„èŠ±é‡Œèƒ¡å“¨ï¼‰\nä¸éš¾ï¼Œæ³¨æ„ä¼˜æƒ åˆ¸å’Œäº§å“å¹¶ä¸æ˜¯è¦å…¨éƒ¨ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦æ‰¾åŒå·çš„æ•°ç›¸ä¹˜å³å¯ã€‚æ ¹æ®æ’åºä¸ç­‰å¼ï¼Œä¸¤ç»„ç›¸åŒä¸ªæ•°çš„æ•°å”¯æœ‰ã€å¤§æ•°ä¹˜å¤§æ•°ï¼Œå°æ•°ä¹˜å°æ•°ã€‘æ—¶ä¹˜ç§¯ä¹‹å’Œæœ€å¤§ã€‚ç¬¬ä¸€æƒ³æ³•å°±æ˜¯ï¼Œå…ˆå¯¹ä¸¤ç»„æ•°è¿›è¡Œæ’åºï¼Œç„¶åå‡ä»ç¬¬ä¸€ä¸ªæ•°å¼€å§‹ç›¸ä¹˜ç´¯åŠ ï¼Œç›´åˆ°é‡è§å¼‚å·æ•°ï¼›ç„¶åå†ä»æœ€åä¸€ä¸ªå¼€å§‹ç›¸ä¹˜ç´¯åŠ ï¼ŒåŒæ ·ç›´åˆ°å¼‚å·æ•°ã€‚\nè¿™é‡Œæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š\n\nå¦‚æœä»å¤´å’Œä»å°¾å¼€å§‹éƒ½ä¸ä¼šé‡åˆ°å¼‚å·æ•°ï¼Œé‚£ä¹ˆéƒ¨åˆ†ä¼˜æƒ åˆ¸å’Œäº§å“ä¼šè¢«è®¡ç®—ä¸¤æ¬¡\n\nå¦‚æœæ‰€æœ‰ä¼˜æƒ åˆ¸å’Œäº§å“ä»·æ ¼éƒ½æ˜¯åŒå·çš„ï¼Œé‚£ä¹ˆå…ˆä»å¤´å¼€å§‹çš„æ—¶å€™å°±ä¼šæŠŠä¼˜æƒ åˆ¸ç”¨åœ¨ä»·æ ¼æœ€å°çš„äº§å“ä¸Š\n\n\nQ1åªè¦è®°ä½ç¬¬ä¸€æ¬¡æŠŠä¼˜æƒ åˆ¸ç”¨åˆ°ç¬¬å‡ å¼ äº†å³å¯ï¼ŒQ2å…¶å®æ¢ä¸€ä¸‹éå†é¡ºåºå°±å¥½äº†ï¼Œå³å…ˆä»æœ€åä¸€ä¸ªå¼€å§‹ç´¯ä¹˜ç›¸åŠ ï¼Œç„¶åå†ä»ç¬¬ä¸€ä¸ªå¼€å§‹ã€‚Q2æ¯”è¾ƒå®¹æ˜“è¢«å¿½è§†ï¼Œä½†åªè¦è‡ªå·±å¤šæ„é€ å‡ ä¸ªæµ‹è¯•ç”¨ä¾‹å°±ä¼šå‘ç°ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n;\n    cin &gt;&gt; m;\n    vector&lt;int&gt; c(m);\n    for (auto &amp;k: c)\n        cin &gt;&gt; k;\n    sort(c.begin(), c.end());\n    cin &gt;&gt; n;\n    vector&lt;int&gt; p(n);\n    for (auto &amp;k: p)\n        cin &gt;&gt; k;\n    sort(p.begin(), p.end());\n    int sum = 0;\n    for (m -= 1, n -= 1; m &gt;= 0 &amp;&amp; n &gt;= 0; --m, --n)\n    {\n        if ((c[m] ^ p[n]) &gt;= 0)\n            sum += c[m] * p[n];\n        else\n            break;\n    }\n    for (int i = 0; i &lt; min(m, n); ++i)\n    {\n        if ((c[i] ^ p[i]) &gt;= 0)\n            sum += c[i] * p[i];\n        else\n            break;\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n}\n\na^bâ‰¥0ç”¨äºåˆ¤æ–­ä¸¤æ•°æ˜¯å¦åŒå·ï¼Œæœ¬è´¨æ˜¯åˆ¤æ–­ç¬¦å·ä½æ˜¯å¦ä¸€è‡´ã€‚\n","slug":"ã€Œ1037ã€Magic-Coupon","date":"2022-08-05T15:10:40.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,vector","author_index":"Starlit Rover"},{"id":"26c80e72f01819f2ff80ad4c0899d687","title":"ã€Œ1036ã€Boys vs Girls","content":"This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students.\n\n\nInput Specification:Each input file contains one test case. Each case contains a positive integerÂ N, followed byÂ NÂ lines of student information. Each line contains a studentâ€™sÂ name,Â gender,Â IDÂ andÂ grade, separated by a space, whereÂ nameÂ andÂ IDÂ are strings of no more than 10 characters with no space,Â genderÂ is eitherÂ FÂ (female) orÂ MÂ (male), andÂ gradeÂ is an integer between 0 and 100. It is guaranteed that all the grades are distinct.\nOutput Specification:For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the differenceÂ â€‹. If one such kind of student is missing, outputÂ AbsentÂ in the corresponding line, and outputÂ NAÂ in the third line instead.\nSample Input 1:3\nJoe M Math990112 89\nMike M CS991301 100\nMary F EE990830 95\n\nSample Output 1:Mary EE990830\nJoe Math990112\n6\n\nSample Input 2:1\nJean M AA980920 60\n\nSample Output 2:Absent\nJean AA980920\nNA\n\n\nÎ©éš¾å¾—æ°´é¢˜ï¼Œæ‰“ä¸ªéœå®³ã€‚\næ‰¾å‡ºåˆ†æ•°æœ€é«˜çš„å¥³ç”Ÿå’Œåˆ†æ•°æœ€ä½çš„ç”·ç”Ÿï¼Œå¹¶è¾“å‡ºåˆ†æ•°å·®ã€‚å¥‡æ€ªçš„æ„å›¾ï¼Œï¼Œï¼Œå¯èƒ½æ˜¯æƒ³è¯´æ˜å¥³ç”Ÿä¸æ¯”ç”·ç”Ÿå·®å§ã€‚\nç”±äºåªéœ€è¦æ‰¾å‡ºæœ€é«˜å’Œæœ€ä½ï¼Œå› æ­¤ä¸éœ€è¦ä¿å­˜æ‰€æœ‰äººçš„æˆç»©ï¼Œä¸€è¾¹è¯»å…¥ä¸€è¾¹æ¯”è¾ƒæ›´æ–°å³å¯ã€‚ä¸€è·¯ä¸‰å…ƒè¿ç®—ä¸‹æ¥ï¼Œæ‡’ç™Œæ™šæœŸäº†ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, s, Fmax = -1, Mmin = 101;\n    pair&lt;string, string&gt; m, f;\n    cin &gt;&gt; n;\n    string name, gender, id;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; gender &gt;&gt; id &gt;&gt; s;\n        (gender == \"M\" &amp;&amp; s &lt; Mmin) ? (m = {name, id}, Mmin = s) : NULL;\n        (gender == \"F\" &amp;&amp; s &gt; Fmax) ? (f = {name, id}, Fmax = s) : NULL;\n    }\n    cout &lt;&lt; (Fmax == -1 ? \"Absent\" : (f.first + \" \" + f.second)) &lt;&lt; endl;\n    cout &lt;&lt; (Mmin == 101 ? \"Absent\" : (m.first + \" \" + m.second)) &lt;&lt; endl;\n    cout &lt;&lt; (Fmax == -1 || Mmin == 101 ? \"NA\" : to_string(Fmax - Mmin)) &lt;&lt; endl;\n}\n","slug":"ã€Œ1036ã€Boys-vs-Girls","date":"2022-08-05T13:45:26.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"a53e7c68139d24254c9d824823f3fbc3","title":"ã€Œ1035ã€Password","content":"To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguishÂ 1Â (one) fromÂ lÂ (LÂ in lowercase), orÂ 0Â (zero) fromÂ OÂ (oÂ in uppercase). One solution is to replaceÂ 1Â (one) byÂ @,Â 0Â (zero) byÂ %,Â lÂ byÂ L, andÂ OÂ byÂ o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords.\n\n\nInput Specification:Each input file contains one test case. Each case contains a positive integerÂ NÂ (â‰¤1000), followed byÂ NÂ lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space.\nOutput Specification:For each test case, first print the numberÂ MÂ of accounts that have been modified, then print in the followingÂ MÂ lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one lineÂ There are N accounts and no account is modifiedÂ whereÂ NÂ is the total number of accounts. However, ifÂ NÂ is one, you must printÂ There is 1 account and no account is modifiedÂ instead.\nSample Input 1:3\nTeam000002 Rlsp0dfa\nTeam000003 perfectpwd\nTeam000001 R1spOdfa\n\nSample Output 1:2\nTeam000002 RLsp%dfa\nTeam000001 R@spodfa\n\nSample Input 2:1\nteam110 abcdefg332\n\nSample Output 2:There is 1 account and no account is modified\n\nSample Input 3:2\nteam110 abcdefg222\nteam220 abcdefg333\n\nSample Output 3:There are 2 accounts and no account is modified\n\n\nÎ©ç®€å•çš„å­—ç¬¦æ›¿æ¢ï¼Œæ³¨æ„ä¸€ä¸‹å•å¤æ•°è¯­æ³•ï¼Œä¸€è·¯switchã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;string, string&gt;&gt; acc;\n    string user, pass;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; user &gt;&gt; pass;\n        bool flag = false;\n        for (auto &amp;k: pass)\n            switch (k)\n            {\n                case '1':\n                    k = '@';\n                    flag = true;\n                    break;\n                case '0':\n                    k = '%';\n                    flag = true;\n                    break;\n                case 'l':\n                    k = 'L';\n                    flag = true;\n                    break;\n                case 'O':\n                    k = 'o';\n                    flag = true;\n                    break;\n                default:\n                    continue;\n            }\n        if (flag)\n            acc.emplace_back(user, pass);\n    }\n    if (acc.size() == 0)\n    {\n        switch (n)\n        {\n            case 1:\n                printf(\"There is 1 account and no account is modified\\n\");\n                break;\n            default:\n                printf(\"There are %d accounts and no account is modified\\n\", n);\n        }\n        return 0;\n    }\n    cout &lt;&lt; acc.size() &lt;&lt; endl;\n    for (auto &amp;k: acc)\n        cout &lt;&lt; k.first &lt;&lt; \" \" &lt;&lt; k.second &lt;&lt; endl;\n}\n","slug":"ã€Œ1035ã€Password","date":"2022-08-02T06:09:39.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,vector","author_index":"Starlit Rover"},{"id":"f5b9a425a8b15196437bbb108fb7f4af","title":"ã€Œ1034ã€Head of a Gang","content":"One way that the police finds the head of a gang is to check peopleâ€™s phone calls. If there is a phone call betweenÂ AÂ andÂ B, we say thatÂ AÂ andÂ BÂ is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A â€œGangâ€ is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given thresholdÂ K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two positive numbersÂ NÂ andÂ KÂ (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. ThenÂ NÂ lines follow, each in the following format:\nName1 Name2 Time\n\nwhereÂ Name1Â andÂ Name2Â are the names of people at the two ends of the call, andÂ TimeÂ is the length of the call. A name is a string of three capital letters chosen fromÂ A-Z. A time length is a positive integer which is no more than 1000 minutes.\nOutput Specification:For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.\nSample Input 1:8 59\nAAA BBB 10\nBBB AAA 20\nAAA CCC 40\nDDD EEE 5\nEEE DDD 70\nFFF GGG 30\nGGG HHH 20\nHHH FFF 10\n\nSample Output 1:2\nAAA 3\nGGG 3\n\nSample Input 2:8 70\nAAA BBB 10\nBBB AAA 20\nAAA CCC 40\nDDD EEE 5\nEEE DDD 70\nFFF GGG 30\nGGG HHH 20\nHHH FFF 10\n\nSample Output 2:0\n\n\nÎ©è­¦å¯Ÿè¦é€šè¿‡é€šè¯è®°å½•æ¥ç¡®å®šå¸®æ´¾å›¢ä¼™ï¼Œè®¤ä¸ºä¸¤ä¸ªæœ‰é€šè¯è®°å½•çš„äººæ˜¯æœ‰è”ç³»çš„ï¼Œé‚£ä¹ˆå¦‚æœæœ‰è”ç³»çš„äººæ‰€æ„æˆçš„è¿é€šå›¾äººæ•°&gt;2ä¸”å…¶ä¸­æ‰€æœ‰é€šè¯æ—¶é•¿ä¹‹å’Œè¶…è¿‡ç»™å®šé˜ˆå€¼K å°±è¢«è®¤å®šä¸ºä¸€ä¸ªå›¢ä¼™ï¼Œè€Œé€šè¯æ—¶é•¿æœ€é•¿çš„äººåˆ™è®¤ä¸ºæ˜¯å›¢ä¼™å¤´ç›®ã€‚ç°åœ¨ç»™å‡ºé˜ˆå€¼Kå’Œä¸€äº›é€šè¯è®°å½•ï¼Œéœ€è¦ä½ è¾“å‡ºå›¢ä¼™ä¸ªæ•°ã€å›¢ä¼™å¤´ç›®ã€å›¢ä¼™äººæ•°ã€‚\nä¸æ˜¯å¾ˆéš¾ï¼Œéƒ½æ˜¯å¯¹å›¾è®ºåŸºç¡€çš„è€ƒå¯Ÿã€‚çœ‹ä¼¼æœ¬é¢˜æ˜¯ä¸€é“æœ‰æƒå›¾ï¼Œå®åˆ™é€šè¯è®°å½•å¯ä»¥å•ç‹¬æ”¾ä¸€è¾¹ï¼Œç„¶åå°†é€šè¯å…³ç³»ç½‘çœ‹æˆæ— æƒæ— å‘å›¾ã€‚å› ä¸ºæƒé‡åªæ¶‰åŠå›¢ä¼™åˆ¤å®šï¼Œè·Ÿä¸ªä½“è”ç³»æ— å…³ï¼Œæˆ‘ä»¬åªéœ€å°†ä¸€ä¸ªè¿é€šå›¾å†…æ¯ä¸ªäººçš„é€šè¯æ—¶é•¿å…¨éƒ¨ç›¸åŠ /2å°±èƒ½å¾—åˆ°è¯¥åˆ†å›¾çš„æƒé‡ä¹‹å’Œï¼Œé¡ºä¾¿æ‰¾å‡ºé€šè¯è®°å½•æœ€é•¿çš„å¤´å¤´å³å¯ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, t;\n    cin &gt;&gt; n &gt;&gt; k;\n    map&lt;string, set&lt;string&gt;&gt; adj;\n    map&lt;string, bool&gt; visited;\n    map&lt;string, int&gt; weight, otc;\n    string a, b;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t;\n        adj[a].insert(b);\n        adj[b].insert(a);\n        weight[a] += t;\n        weight[b] += t;\n        visited[a] = visited[b] = false;\n    }\n    for (auto &amp;u: visited)\n    {\n        if (u.second) continue;\n        set&lt;string&gt; gang{u.first}, tmp1{u.first}, tmp2;\n        visited[u.first] = true;\n        while (!tmp1.empty())\n        {\n            for (auto &amp;v: tmp1)\n                for (auto &amp;w: adj[v])\n                    if (!visited[w])\n                    {\n                        tmp2.insert(w);\n                        visited[w] = true;\n                    }\n            gang.insert(tmp2.begin(), tmp2.end());\n            tmp1 = tmp2;\n            tmp2.clear();\n        }\n\n        if (gang.size() &gt; 2)\n        {\n            int sum = 0, max = weight[*gang.begin()];\n            string head = *gang.begin();\n            for (auto &amp;h: gang)\n            {\n                if (weight[h] &gt; max)\n                {\n                    max = weight[h];\n                    head = h;\n                }\n                sum += weight[h];\n            }\n            if (sum / 2 &gt; k)\n                otc[head] = gang.size();\n        }\n    }\n    cout &lt;&lt; otc.size() &lt;&lt; endl;\n    for (auto &amp;r: otc)\n        cout &lt;&lt; r.first &lt;&lt; \" \" &lt;&lt; r.second &lt;&lt; endl;\n}\n\nä¸€éå°±è¿‡ï¼Œçˆ½\n","slug":"ã€Œ1034ã€Head-of-a-Gang","date":"2022-08-02T03:50:15.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set","author_index":"Starlit Rover"},{"id":"75a7b4e5def88b644c70f785b7585976","title":"ã€Œ1033ã€To Fill or Not to Fill","content":"With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 positive numbers:Â Cmaxâ€‹Â (â‰¤Â 100), the maximum capacity of the tank;Â DÂ (â‰¤30000), the distance between Hangzhou and the destination city;Â Davgâ€‹Â (â‰¤20), the average distance per unit gas that the car can run; andÂ NÂ (â‰¤Â 500), the total number of gas stations. ThenÂ NÂ lines follow, each contains a pair of non-negative numbers:Â , the unit gas price, andÂ Â (â‰¤D), the distance between this station and Hangzhou, forÂ . All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, printÂ The maximum travel distance = XÂ whereÂ XÂ is the maximum possible distance the car can run, accurate up to 2 decimal places.\nSample Input 1:50 1300 12 8\n6.00 1250\n7.00 600\n7.00 150\n7.10 0\n7.20 200\n7.50 400\n7.30 1000\n6.85 300\n\nSample Output 1:749.17\n\nSample Input 2:50 1300 12 2\n7.10 0\n7.00 600\n\nSample Output 2:The maximum travel distance = 1200.00\n\n\nÎ©ç»ˆäºè§åˆ°éœ€è¦åŠ¨ç‚¹è„‘å­çš„é¢˜ç›®äº†ï¼ˆç„¶è€Œè„‘å­å·²ç”Ÿé”ˆã€‚\nä¸€æ¡ç›´çº¿ä¸Šæœ‰å¤šä¸ªåŠ æ²¹ç«™ï¼Œæ¯ä¸ªåŠ æ²¹ç«™çš„æ²¹ä»·ä¸åŒï¼Œç»™å‡ºå››å…ƒç»„ï¼ˆæœ€å¤§æ²¹é‡ï¼Œæ€»è·¯ç¨‹é•¿åº¦ï¼Œå•ä½æ²¹è€—èƒ½è·‘çš„é‡Œç¨‹æ•°ï¼ŒåŠ æ²¹ç«™ä¸ªæ•°ï¼‰ï¼Œä»¥åŠæ¯ä¸ªåŠ æ²¹ç«™è·ç¦»èµ·ç‚¹çš„è·ç¦»å’Œæ²¹ä»·ï¼Œè®¡ç®—åˆ°è¾¾ç»ˆç‚¹æ—¶æ‰€éœ€çš„æœ€ä¾¿å®œæ€»æ²¹è´¹ï¼Œè‹¥æ— æ³•åˆ°è¾¾åˆ™è¾“å‡ºæœ€è¿œé‡Œç¨‹ã€‚\næœ¬è´¨ä¸Šæ˜¯è€ƒè™‘åˆ°è¾¾æ¯ä¸€ä¸ªåŠ æ²¹ç«™æ—¶åšå‡ºæ˜¯å¦åŠ æ²¹çš„å†³ç­–ï¼Œå¦‚æœè¦åŠ åˆ™åŠ å¤šå°‘ã€‚\n\né—®é¢˜â¶ï¼šåŠ ä¸åŠ ã€‚å¾ˆæ˜¾ç„¶ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¼€åˆ°å‰é¢ä¸€ä¸ªæ²¹ä»·æ›´ä¾¿å®œçš„åŠ æ²¹ç«™å°±å¯ä»¥ä¸åŠ ï¼Œä½†å¦‚æœæˆ‘ä»¬å‰é¢èƒ½å¼€åˆ°çš„åŠ æ²¹ç«™æ²¹ä»·éƒ½æ¯”å½“å‰è¿™å®¶é«˜ï¼Œé‚£æ²¡åŠæ³•æˆ‘ä»¬å¿…é¡»åŠ ã€‚\n\né—®é¢˜â·ï¼šåŠ å¤šå°‘ã€‚å¾ˆæ˜¾ç„¶ï¼Œå¦‚æœåœ¨åŠ æ»¡æ²¹çš„é‡Œç¨‹èŒƒå›´å†…æœ‰ä¸€å®¶æ²¹ä»·æ›´ä½çš„åŠ æ²¹ç«™ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦åŠ åˆ°èƒ½å¤Ÿè¾¾åˆ°è¿™å®¶åŠ æ²¹ç«™çš„æ²¹é‡å³å¯ã€‚å¦å¤–æˆ‘ä»¬æ‰¾çš„ä¸æ˜¯é‡Œç¨‹èŒƒå›´å†…æ²¹ä»·æœ€ä½çš„é‚£å®¶Pï¼Œè€Œæ˜¯ç¬¬ä¸€å®¶æ²¹ä»·æ¯”å½“å‰æ²¹ç«™Kä½çš„æ²¹ç«™Qï¼Œå¦åˆ™QPï¼ˆPæ¯”Qè¿œï¼‰è·¯ç¨‹æ‰€ä»˜çš„æ²¹ä»·å°±ä¸åˆ’ç®—äº†ã€‚å¦‚æœè¯¥èŒƒå›´å†…æ²¡æœ‰ä»·æ ¼æ›´ä½çš„æ²¹ç«™ï¼Œé‚£ä¹ˆç›´æ¥æŠŠæ²¹åŠ æ»¡å°†æ˜¯æœ€ä¼˜é€‰æ‹©ï¼Œå› ä¸ºåŠ æ»¡æ²¹çš„è¿™æ®µè·¯ä¸Šæ²¡æœ‰æ›´åˆ’ç®—çš„åŠ æ²¹ç«™ã€‚\n\n\nçœ‹é€æœ¬è´¨åä¸€åˆ‡éƒ½æ˜äº†äº†èµ·æ¥ï¼Œæˆ‘ä»¬é¦–å…ˆå¯¹å¾—åˆ°çš„æ²¹ç«™ä¿¡æ¯æ ¹æ®åˆ°èµ·ç‚¹çš„è·ç¦»è¿›è¡Œæ’åºï¼Œç„¶åä¾æ¬¡ä¾¿åˆ©æ‰€æœ‰æ²¹ç«™ï¼Œå³å¯¹æ¯ä¸ªæ²¹ç«™éƒ½è¿›è¡Œæ˜¯å¦åŠ æ²¹çš„å†³ç­–ã€‚æ ¹æ®å½“å‰æ²¹é‡è®¡ç®—å¯è¡Œé©¶é‡Œç¨‹ï¼Œåœ¨è¯¥é‡Œç¨‹èŒƒå›´ä¸­å¯»æ‰¾æ²¹ä»·æ›´ä½çš„æ²¹ç«™ï¼Œè‹¥æœ‰åˆ™ä¸åŠ æ²¹ã€‚è‹¥åŠ æ²¹åˆ™åœ¨åŠ æ»¡æ²¹çš„é‡Œç¨‹èŒƒå›´å†…å¯»æ‰¾ç¬¬ä¸€å®¶æ²¹ä»·æ›´ä½çš„æ²¹ç«™ï¼Œæ‰¾åˆ°åè®¡ç®—åˆ°å½“è¯¥æ²¹ç«™è¿˜å·®å¤šå°‘æ²¹ï¼Œæ ¹æ®ç»“æœåŠ æ²¹ä»˜è´¹ã€‚\nå¼¥å¤©å¤§å‘ï¼šç¬¬ä¸€ä¸ªæ²¹ç«™å¦‚æœä¸åœ¨èµ·ç‚¹ï¼Œæ±½è½¦å¼€å±€å°±å—å±äº†ï¼Œæœ€å¤§é‡Œç¨‹ï¼š0ã€‚ï¼ˆcase 2ï¼‰\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;double, double&gt; pdd;\n\nint main()\n{\n    int t, d, da, n;\n    double gas = 0, price = 0;\n    cin &gt;&gt; t &gt;&gt; d &gt;&gt; da &gt;&gt; n;\n    vector&lt;pdd&gt; stations(n);\n    for (auto &amp;k: stations)\n        cin &gt;&gt; k.second &gt;&gt; k.first;\n    stations.emplace_back(d, 0);\n    sort(stations.begin(), stations.end(), [](pdd &amp;a, pdd &amp;b) { return a.first &lt; b.first; });\n    // ï¼ï¼ï¼\n    if (stations[0].first != 0)\n    {\n        printf(\"The maximum travel distance = 0.00\");\n        return 0;\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        double crt_d = stations[i].first, gas_d = crt_d + gas * da;\n        int k = i + 1;\n        bool flag = false;\n        while (k &lt; (n + 1) &amp;&amp; stations[k].first &lt;= gas_d)\n        {\n            if (stations[k].second &lt; price)\n            {\n                flag = true;\n                break;\n            }\n            ++k;\n        }\n        if (!flag)\n        {\n            int idx = i;\n            while (k &lt; (n + 1) &amp;&amp; stations[k].first &lt;= crt_d + t * da)\n            {\n                flag = true;\n                if (stations[k].second &lt; stations[idx].second)\n                {\n                    idx = k;\n                    break;\n                }\n                ++k;\n            }\n            if (!flag)\n            {\n                printf(\"The maximum travel distance = %.2lf\", crt_d + t * da);\n                return 0;\n            }\n            else if (idx == i)\n            {\n                price += (t - gas) * stations[i].second;\n                gas = t;\n            }\n            else\n            {\n                gas += (stations[idx].first - gas_d) / da;\n                price += (stations[idx].first - gas_d) / da * stations[i].second;\n            }\n        }\n        gas -= (stations[i + 1].first - crt_d) / da;\n    }\n    printf(\"%.2lf\", price);\n}\n\nTips\nåœ¨æ²¹ç«™å‘é‡stationsçš„æœ€ååŠ å…¥äº†ç»ˆç‚¹ä½œä¸ºä¸€ä¸ªè™šæ²¹ç«™ï¼Œæ–¹ä¾¿æœ€åä¸€ä¸ªæ²¹ç«™çš„å†³ç­–\n\ncrt_dè¡¨ç¤ºå½“å‰é‡Œç¨‹ï¼Œgas_dè¡¨ç¤ºå½“å‰æ²¹é‡æœ€å¤§é‡Œç¨‹\n\nflagäºŒæ¬¡åˆ©ç”¨ï¼Œç¬¬äºŒæ¬¡æ˜¯æ£€éªŒå½“å‰ç«™ç‚¹åŠ æ»¡æ²¹åèƒ½å¦è¡Œé©¶åˆ°ä¸‹ä¸€ä¸ªç«™ç‚¹\n\næ¯æ¬¡å¾ªç¯çš„ç»“æŸéƒ½å°†è¡Œé©¶åˆ°ä¸‹ä¸€ä¸ªç«™ç‚¹çš„æ²¹é‡è¿›è¡Œæ‰£é™¤\n\n\n","slug":"ã€Œ1033ã€To-Fill-or-Not-to-Fill","date":"2022-08-01T14:04:54.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,vector","author_index":"Starlit Rover"},{"id":"2aa4f707763887fd968ccc8e9446d574","title":"ã€Œ1032ã€Sharing","content":"To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example,Â loadingÂ andÂ beingÂ are stored as showed in Figure 1.\n\nFigure 1\n\nYou are supposed to find the starting position of the common suffix (e.g. the position ofÂ iÂ in Figure 1).\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positiveÂ NÂ (â‰¤105), where the two addresses are the addresses of the first nodes of the two words, andÂ NÂ is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented byÂ âˆ’1.\nThenÂ NÂ lines follow, each describes a node in the format:\nAddress Data Next\n\nwhereAddressÂ is the position of the node,Â DataÂ is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, andÂ NextÂ is the position of the next node.\nOutput Specification:For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, outputÂ -1Â instead.\nSample Input 1:11111 22222 9\n67890 i 00002\n00010 a 12345\n00003 g -1\n12345 D 67890\n00002 n 00003\n22222 B 23456\n11111 L 00001\n23456 e 67890\n00001 o 00010\n\nSample Output 1:67890\n\nSample Input 2:00001 00002 4\n00001 a 10001\n10001 s -1\n00002 a 10002\n10002 t -1\n\nSample Output 2:-1\n\n\nÎ©è¿™é¢˜åºŸè¯çœŸå¤šï¼Œè¾“å…¥ä¹Ÿæ˜¯ã€‚ä¸€ç§å°†å­—æ¯åŒ–ä¸ºèŠ‚ç‚¹æ¥å­˜å‚¨å•è¯çš„æœºåˆ¶ï¼Œä¸ºäº†èŠ‚çœç©ºé—´å°±éœ€è¦å¯»æ‰¾å…¬å…±åç¼€ï¼Œç°åœ¨ç»™ä½ ä¸€å¨èŠ‚ç‚¹ä»¥åŠè¿æ¥å…³ç³»ï¼Œè¿˜æœ‰ä¸¤ä¸ªå•è¯çš„å¤´èŠ‚ç‚¹ï¼Œéœ€è¦ä½ ç»™å‡ºå…¬å…±åç¼€çš„é¦–åœ°å€ï¼Œè‹¥æ— åˆ™è¾“å‡º-1ã€‚\né¦–å…ˆç”¨mapå­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹åœ°å€çš„è¿æ¥å…³ç³»ï¼Œç„¶åå°†ç¬¬ä¸€ä¸ªå•è¯æ‰€æœ‰çš„èŠ‚ç‚¹è¿›è¡Œæ ‡è®°ï¼Œéšåéå†ç¬¬äºŒä¸ªå•è¯ï¼Œé‡åˆ°çš„ç¬¬ä¸€ä¸ªæ ‡è®°è¿‡çš„èŠ‚ç‚¹åœ°å€å³ä¸ºæ‰€æ±‚ã€‚\næœ‰ä»¥ä¸‹å‡ ä¸ªæ³¨æ„ç‚¹ï¼š\n\nä¸¤ä¸ªå•è¯å¯èƒ½æ˜¯åŒä¸€ä¸ª\n\nå…¶ä¸­ä¸€ä¸ªå•è¯å¯èƒ½ä¸å­˜åœ¨ï¼ˆå¼€å¤´å³ä¸º-1ï¼‰\n\nç»™å‡ºçš„èŠ‚ç‚¹å¹¶éæ˜¯ä¸¤ä¸ªå•è¯ä¸­çš„\n\n\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b, e, f;\n    int n;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;\n    map&lt;string, pair&lt;string, bool&gt;&gt; next;\n    char c;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; e &gt;&gt; c &gt;&gt; f;\n        next[e] = {f, false};\n    }\n    while (a != \"-1\")\n    {\n        next[a].second = true;\n        a = next[a].first;\n    }\n    while (b != \"-1\")\n    {\n        if (next[b].second)\n        {\n            cout &lt;&lt; b;\n            return 0;\n        }\n        b = next[b].first;\n    }\n    cout &lt;&lt; \"-1\";\n}\n","slug":"ã€Œ1032ã€Sharing","date":"2022-08-01T07:30:35.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map","author_index":"Starlit Rover"},{"id":"786aa9c8aedf18362cb4846354e16ec2","title":"ã€Œ1031ã€Hello World for U","content":"Given any string ofÂ NÂ (â‰¥5) characters, you are asked to form the characters into the shape ofÂ U. For example,Â helloworldÂ can be printed as:\nh  d\ne  l\nl  r\nlowo\n\nThat is, the characters must be printed in the original order, starting top-down from the left vertical line withÂ â€‹Â characters, then left to right along the bottom line withÂ Â characters, and finally bottom-up along the vertical line withÂ â€‹Â characters. And more, we would likeÂ UÂ to be as squared as possible â€”â€” that is, it must be satisfied thatÂ  with .\n\n\nInput Specification:Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space.\nOutput Specification:For each test case, print the input string in the shape of U as specified in the description.\nSample Input:helloworld!\n\nSample Output:h   !\ne   d\nl   l\nlowor\n\n\nÎ©éš¾å¾—æ¥ä¸€é“ç”»ç”»é¢˜æ”¾æ¾æ”¾æ¾ã€‚ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œéœ€è¦ä½ å°½å¯èƒ½ç”»æˆã€Uã€‘çš„æ ·å­ï¼Œè€Œä¸”è¿™ä¸ªUå°½å¯èƒ½è´´è¿‘æ­£æ–¹å½¢ï¼Œå¦å¤–é«˜åº¦ä¸èƒ½è¶…è¿‡å®½åº¦ã€‚é‚£ä¹ˆå¾ˆæ˜¾ç„¶\n\näºæ˜¯ä¹ï¼Œæ„é€ ä¸€ä¸ªçš„ç©ºæ ¼å­—ç¬¦ä¸²ï¼Œç¨å¾®æ“ä½œä¸€ä¸‹ï¼Œå°±ç”»å®Œäº†ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin &gt;&gt; s;\n    int m = (s.size() + 2) / 3, n = s.size() - 2 * m + 2;\n    string blank(n - 2, ' ');\n    for (int i = 0; i &lt; m - 1; ++i)\n        cout &lt;&lt; s[i] &lt;&lt; blank &lt;&lt; s[s.size() - i - 1] &lt;&lt; endl;\n    cout &lt;&lt; s.substr(m - 1, n);\n}\n\nstring.substr(m,n)å¯ä»¥æˆªå–å­—ç¬¦ä¸²ç¬¬mä¸ªä½ç½®ï¼ˆ0æ˜¯ç¬¬ä¸€ä¸ªä½ç½®ï¼‰èµ·nä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚\n","slug":"ã€Œ1031ã€Hello-World-for-U","date":"2022-07-21T09:30:51.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,string","author_index":"Starlit Rover"},{"id":"ed8d01651cc47c3cf52012b240c9dde7","title":"ã€Œ1030ã€Travel Plan","content":"â³ENTRY\nA travelerâ€™s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integersÂ N,Â M,Â S, andÂ D, whereÂ NÂ (â‰¤500) is the number of cities (and hence the cities are numbered from 0 toÂ Nâˆ’1);Â MÂ is the number of highways;Â SÂ andÂ DÂ are the starting and the destination cities, respectively. ThenÂ MÂ lines follow, each provides the information of a highway, in the format:\nCity1 City2 Distance Cost\n\nwhere the numbers are all integers no more than 500, and are separated by a space.\nOutput Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.\nSample Input:4 5 0 3\n0 1 1 20\n1 3 2 30\n0 3 4 10\n0 2 2 20\n2 3 1 20\n\nSample Output:0 2 3 3 40\n\n\nÎ©ä¸€ä¸ªæ— å‘æœ‰ï¼ˆåŒï¼‰æƒå›¾ï¼Œç»™å®šèµ·ç‚¹å’Œç»ˆç‚¹ï¼Œè¿˜æœ‰æ¯ä¸€æ¡è·¯çš„é•¿åº¦ä¸èŠ±è´¹ï¼Œæ±‚å‡ºæœ€çŸ­çš„è·¯å¾„ï¼Œå¦‚æœæœ‰å¤šæ¡æœ€çŸ­è·¯å¾„ï¼Œé‚£ä¹ˆé€‰æ‹©å…¶ä¸­èŠ±è´¹æœ€å°‘çš„è·¯å¾„ï¼Œé¢˜ç›®ä¿è¯è¯¥è·¯å¾„å”¯ä¸€ã€‚\nå¦‚æœåªéœ€è€ƒè™‘å•ä¸€æƒé‡é‚£ä¹ˆå°±æ˜¯ä¸€é“ç»å…¸çš„Dijkstraç®—æ³•é¢˜ï¼Œè€ŒåŒæƒé‡çš„æœ¬è´¨æ€æƒ³å…¶å®ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯å°†ç®—æ³•ä¸­æ‰€æœ‰æƒé‡æ¯”è¾ƒå˜æˆå…ˆæ¯”è¾ƒè·¯å¾„é•¿åº¦è‹¥é•¿åº¦ç›¸ç­‰åˆ™å†æ¯”è¾ƒèŠ±è´¹çš„æ–¹å¼ï¼Œç®€å•åœ°æ¦‚æ‹¬å°±æ˜¯\n(distance1 &lt; distance2) ? true : ((distance1 == distance2) ? (cost1 &lt; cost2) : false)\n\nç„¶åå¯¹äºè·¯å¾„çš„è®°å½•åˆ™é‡‡å–è®°å½•æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸­å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ç¼–å·ï¼Œé‚£ä¹ˆæœ€åå°±å¯ä»¥ä»ç»ˆç‚¹å›æº¯å‡ºæ•´æ¡è·¯å¾„ã€‚\né‡‡ç”¨vector&lt;map&lt;city(int),pair&lt;dist(int),cost(int)&gt;&gt;&gt;çš„æ•°æ®ç»“æ„æ¥å­˜å‚¨è·¯å¾„é•¿åº¦å’ŒèŠ±è´¹ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n#define MAXDIST 100000000\n\nint main()\n{\n    int m, n, s, d, p, q;\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s &gt;&gt; d;\n    vector&lt;map&lt;int, pair&lt;int, int&gt;&gt;&gt; path(m);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; p &gt;&gt; q;\n        cin &gt;&gt; path[p][q].first &gt;&gt; path[p][q].second;\n        path[q][p] = path[p][q];\n    }\n    vector&lt;pair&lt;int, int&gt;&gt; dist(m, {MAXDIST, 0});\n    vector&lt;int&gt; pre(m, -1);\n    for (auto &amp;k: path[s])\n    {\n        dist[k.first] = k.second;\n        pre[k.first] = s;\n    }\n    vector&lt;bool&gt; visited(m, false);\n    visited[s] = true;\n    while (!visited[d])\n    {\n        int min_dist = MAXDIST + 1, cost = 0, min_idx = -1;\n        for (int i = 0; i &lt; m; ++i)\n            if (!visited[i] &amp;&amp; dist[i].first &lt;= min_dist)\n            {\n                min_idx = (dist[i].first &lt; min_dist) ? i : min_idx;\n                cost = (dist[i].first &lt; min_dist) ? dist[i].second : cost;\n                min_dist = dist[i].first;\n            }\n        visited[min_idx] = true;\n        for (auto &amp;k: path[min_idx])\n        {\n            // å·²ç¡®å®šèŠ‚ç‚¹å¿…é¡»è·³è¿‡ï¼Œå¦åˆ™ä¼šå¹²æ‰°pre\n            if (visited[k.first]) continue;\n            auto &amp;single = path[min_idx][k.first];\n            int flag1 = (dist[k.first].first - dist[min_idx].first - single.first), flag2 = (dist[k.first].second - dist[min_idx].second - single.second);\n            if (flag1 &gt; 0 || flag1 == 0 &amp;&amp; flag2 &gt; 0)\n            {\n                pre[k.first] = min_idx;\n                dist[k.first] = {dist[min_idx].first + single.first, dist[min_idx].second + single.second};\n            }\n        }\n    }\n    vector&lt;int&gt; way;\n    while (d != -1)\n    {\n        way.push_back(d);\n        d = pre[d];\n    }\n    for (auto k = way.rbegin(); k != way.rend(); ++k)\n        cout &lt;&lt; *k &lt;&lt; \" \";\n    cout &lt;&lt; dist[way[0]].first &lt;&lt; \" \" &lt;&lt; dist[way[0]].second &lt;&lt; endl;\n}\n","slug":"ã€Œ1030ã€Travel-Plan","date":"2022-07-21T08:23:49.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,pair,vector,Dijkstra","author_index":"Starlit Rover"},{"id":"8cee37557b0d2d5a2b6286881eecf21d","title":"ã€Œ1029ã€Median","content":"â³ENTRY\nGiven an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1 = { 11, 12, 13, 14 } is 12, and the median of S2 = { 9, 10, 15, 16, 17 } is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13.\nGiven two increasing sequences of integers, you are asked to find their median.\n\n\nInput Specification:Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N () is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range ofÂ long int.\nOutput Specification:For each test case you should output the median of the two given sequences in a line.\nSample Input:4 11 12 13 14\n5 9 10 15 16 17\n\nSample Output:13\n\n\nÎ©ä¸¤ä¸ªå‡åºåºåˆ—ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä»–ä»¬åˆå¹¶åæœ‰åºæ•°åˆ—é‡Œçš„ä¸­ä½æ•°ã€‚\nä¸éš¾ï¼Œç¬¬ä¸€ä¸ªæƒ³æ³•å°±æ˜¯æŠŠä»–ä»¬éƒ½æ”¾åˆ°ä¸€ä¸ªseté‡Œï¼Œç„¶åç”¨è¿­ä»£å™¨æ‰¾åˆ°ä¸­ä½æ•°ã€‚äº‹å®è¯æ˜å¯ä»¥å®ç°ï¼Œä¸è¿‡å¦‚æœä½¿ç”¨cinã€coutæœ€åä¸€ä¸ªæµ‹è¯•ç‚¹ä¼šè¶…æ—¶ï¼Œè¿™ä½å·²ç»æ˜¯è€é’‰å­æˆ·äº†ï¼Œæ¢æˆscanfå’Œprintfå³å¯ã€‚\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, k;\n    scanf(\"%d\", &amp;m);\n    set&lt;int&gt; s;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        s.insert(k);\n    }\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        s.insert(k);\n    }\n    auto median = s.begin();\n    for (int i = 0; i &lt; (m + n - 1) / 2; ++i, ++median);\n    printf(\"%d\", *median);\n}\n\nâš ï¸ç”±äºsetçš„è¿­ä»£å™¨æ²¡æœ‰é‡è½½è¿‡+ä½†é‡è½½è¿‡++ï¼Œå› æ­¤éœ€è¦ç”¨å¾ªç¯åŠ åˆ°ä¸­ä½æ•°çš„ä½ç½®ã€‚\n\n\nå½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥å…ˆè¯»å…¥ç¬¬ä¸€ä¸ªåºåˆ—ï¼Œç„¶ååœ¨è¯»å…¥ç¬¬äºŒä¸ªåºåˆ—çš„ä¸ªæ•°æ—¶å·²ç»å¯ä»¥æ¨ç®—å‡ºä¸­ä½æ•°åœ¨æ€»åºåˆ—ä¸­çš„åºå·äº†ï¼Œé‚£ä¹ˆæ¯è¯»å…¥ç¬¬äºŒåºåˆ—ä¸­çš„ä¸€ä¸ªæ•°æ—¶å°±è®¡ç®—è¯¥æ•°ä»¥åŠç¬¬ä¸€åºåˆ—ä¸­æ¯”è¯¥æ•°å°çš„æ•°åœ¨æ€»åºåˆ—ä¸­çš„ä½ç½®ï¼Œä¸€æ—¦åˆ°äº†ä¸­ä½æ•°çš„ä½ç½®å³å¯åœæ­¢è¯»å…¥ï¼Œç›´æ¥è¾“å‡ºã€‚å¦‚æœç¬¬äºŒåºåˆ—è¯»å®Œè¿˜æ˜¯æ²¡åˆ°ä¸­ä½æ•°çš„ä½ç½®ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡æœ€åä¸€ä¸ªæ•°åœ¨æ€»åºåˆ—ä¸­çš„ä½ç½®è®¡ç®—å‡ºä¸­ä½æ•°åœ¨ç¬¬ä¸€åºåˆ—ä¸­çš„åºå·ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n\nint main()\n{\n    int m, n, k;\n    scanf(\"%d\", &amp;m);\n    int a[m];\n    for (int i = 0; i &lt; m; ++i)\n        scanf(\"%d\", &amp;a[i]);\n    scanf(\"%d\", &amp;n);\n    int mid = (m + n + 1) / 2, cnt = 0, idx = 0;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;k);\n        while (idx &lt; m &amp;&amp; a[idx] &lt;= k)\n        {\n            ++idx; ++cnt;\n            if (cnt == mid) break;\n        }\n        cnt += 1;\n        if (cnt &gt;= mid)\n        {\n            printf(\"%d\", (cnt == mid) ? k : a[idx - 1]);\n            break;\n        }\n    }\n    if (cnt &lt; mid)\n        printf(\"%d\", a[idx + mid - cnt - 1]);\n}\n","slug":"ã€Œ1029ã€Median","date":"2022-07-20T07:58:20.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort","author_index":"Starlit Rover"},{"id":"0267edd43b1463151f0a6cef88e4adee","title":"ã€Œ1028ã€List Sorting","content":"â³ENTRY\nExcel can sort records according to any column. Now you are supposed to imitate this function.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains two integersÂ NÂ (â‰¤105) andÂ C, whereÂ NÂ is the number of records andÂ CÂ is the column that you are supposed to sort the records with. ThenÂ NÂ lines follow, each contains a record of a student. A studentâ€™s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive).\nOutput Specification:For each test case, output the sorting result inÂ NÂ lines. That is, ifÂ CÂ = 1 then the records must be sorted in increasing order according to IDâ€™s; ifÂ CÂ = 2 then the records must be sorted in non-decreasing order according to names; and ifÂ CÂ = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their IDâ€™s in increasing order.\nSample Input 1:3 1\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n\nSample Output 1:000001 Zoe 60\n000007 James 85\n000010 Amy 90\n\nSample Input 2:4 2\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n000002 James 98\n\nSample Output 2:000010 Amy 90\n000002 James 98\n000007 James 85\n000001 Zoe 60\n\nSample Input 3:4 3\n000007 James 85\n000010 Amy 90\n000001 Zoe 60\n000002 James 9\n\nSample Output 3:000002 James 9\n000001 Zoe 60\n000007 James 85\n000010 Amy 90\n\n\nÎ©æ ¹æ®Cå€¼è¾“å‡ºå¯¹ç¬¬Cåˆ—å¢åºæ’åºçš„ç»“æœï¼Œå€¼ç›¸åŒçš„è®°å½•åˆ™æŒ‰ç…§IDå¢åºæ’åˆ—ã€‚æ°´é¢˜ã€‚\nå…ˆå¯¹æ‰€æœ‰è®°å½•çš„IDè¿›è¡Œæ’åºï¼Œç„¶åæ ¹æ®Cå€¼å†è¿›è¡Œä¸åŒçš„åˆ—æ’åºã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass record\n{\npublic:\n    int id, score;\n    string name;\n};\n\nint main()\n{\n    int n, c;\n    cin &gt;&gt; n &gt;&gt; c;\n    vector&lt;record&gt; r(n);\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; r[i].id &gt;&gt; r[i].name &gt;&gt; r[i].score;\n    sort(r.begin(), r.end(), [](record &amp;a, record &amp;b) { return a.id &lt; b.id; });\n    switch (c)\n    {\n        case 2:\n            sort(r.begin(), r.end(), [](record &amp;a, record &amp;b) { return a.name &lt; b.name; });\n            break;\n        case 3:\n            sort(r.begin(), r.end(), [](record &amp;a, record &amp;b) { return a.score &lt; b.score; });\n            break;\n        default:\n            break;\n    }\n    for (auto &amp;k: r)\n        printf(\"%06d %s %d\\n\", k.id, k.name.c_str(), k.score);\n}\n","slug":"ã€Œ1028ã€List-Sorting","date":"2022-07-20T04:16:09.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,vector","author_index":"Starlit Rover"},{"id":"410d655c4b8c89722b8e2a9076e1f7ed","title":"ã€Œ1026ã€Table Tennis","content":"â³ENTRY\nA table tennis club has N tables available to the public. The tables are numbered from 1 to N. For any pair of players, if there are some tables open when they arrive, they will be assigned to the available table with the smallest number. If all the tables are occupied, they will have to wait in a queue. It is assumed that every pair of players can play for at most 2 hours.\nYour job is to count for everyone in queue their waiting time, and for each table the number of players it has served for the day.\nOne thing that makes this procedure a bit complicated is that the club reserves some tables for their VIP members. When a VIP table is open, the first VIP pair in the queue will have the privilege to take it. However, if there is no VIP in the queue, the next pair of players can take it. On the other hand, if when it is the turn of a VIP pair, yet no VIP table is available, they can be assigned as any ordinary players.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains an integerÂ NÂ (â‰¤10000) - the total number of pairs of players. ThenÂ NÂ lines follow, each contains 2 times and a VIP tag:Â HH:MM:SSÂ - the arriving time,Â PÂ - the playing time in minutes of a pair of players, andÂ tagÂ - which is 1 if they hold a VIP card, or 0 if not. It is guaranteed that the arriving time is between 08:00:00 and 21:00:00 while the club is open. It is assumed that no two customers arrives at the same time. Following the playersâ€™ info, there are 2 positive integers:Â KÂ (â‰¤100) - the number of tables, andÂ MÂ (&lt;Â K) - the number of VIP tables. The last line containsÂ MÂ table numbers.\nOutput Specification:For each test case, first print the arriving time, serving time and the waiting time for each pair of players in the format shown by the sample. Then print in a line the number of players served by each table. Notice that the output must be listed in chronological order of the serving time. The waiting time must be rounded up to an integer minute(s). If one cannot get a table before the closing time, their information must NOT be printed.\nSample Input:10\n20:52:00 10 0\n08:00:00 20 0\n08:02:00 30 0\n20:51:00 10 0\n08:10:00 30 0\n08:12:00 10 1\n20:40:00 13 0\n08:01:30 15 1\n20:53:00 10 1\n20:54:00 10 0\n3 1\n2\n\nSample Output:08:00:00 08:00:00 0\n08:01:30 08:01:30 0\n08:02:00 08:02:00 0\n08:12:00 08:16:30 5\n08:10:00 08:20:00 10\n20:40:00 20:40:00 0\n20:51:00 20:51:00 0\n20:52:00 20:52:00 0\n20:53:00 20:53:00 0\n4 3 2\n\n\nÎ©éº»äº†ï¼Œè¿™é¢˜ç›®åˆè®©æˆ‘è§‰å¾—è‡ªå·±æ˜¯ä¸ªå¤å¥ç—…äººï¼Œè¸©å‘è¾¾äººæ˜¯æˆ‘æ²¡é”™äº†ï¼Œè„‘å­åƒè¢«åŒ…å­å¡ä½äº†ä¸€æ ·ã€‚ã€‚ã€‚\nä¸è€çƒ¦çš„æç®€ç¿»è¯‘ï¼Œä¸€å®¶ä¹’ä¹“çƒé¦†é‡Œé¢æœ‰å¥½å‡ å¼ çƒæ¡Œï¼Œæ¯ä¸€å¯¹ç©å®¶åˆ°è¾¾æ—¶ä¼šè‡ªåŠ¨é€‰æ‹©ç¼–å·æœ€å°çš„ç©ºé—²çƒæ¡Œï¼Œæ²¡æœ‰ç©ºé—²çƒæ¡Œæ—¶åªèƒ½æ’é˜Ÿç­‰å€™ï¼Œä½ ä»¥ä¸ºè¿™å°±ç»“æŸäº†å—ï¼Ÿå“ˆå“ˆæˆ‘ä»¬è¿˜æœ‰VIPæœºåˆ¶ï¼Œæ²¡æƒ³åˆ°å§ï¼Œæœ‰å‡ å¼ çƒæ¡Œè¢«æŒ‡å®šä¸ºVIPçƒæ¡Œï¼Œå½“è¿™äº›çƒæ¡Œç©ºé—²æ—¶é˜Ÿä¼ä¸­çš„VIPç”¨æˆ·å¯çœå»æ¯ç‡¥æ— å‘³çš„æ’é˜Ÿç›´æ¥å¼€æ‰“ï¼ˆå’³å’³ï¼Œå½“ç„¶æ™®é€šç”¨æˆ·åœ¨ç”¨VIPçƒæ¡Œæ—¶ä¸èƒ½æŠŠäººå®¶èµ¶èµ°ï¼‰ã€‚å½“ç„¶åœ¨æ²¡æœ‰VIPç”¨æˆ·æ—¶å¯ä»¥æä¾›ç»™æ™®é€šç”¨æˆ·ï¼ŒVIPç”¨æˆ·åœ¨æ²¡æœ‰VIPçƒæ¡Œæ—¶ä¹Ÿå¯ä»¥ç”¨æ™®é€šçƒæ¡Œã€‚ä¸€å¯¹ç©å®¶æœ€é•¿åªèƒ½ç©2hï¼Œæ€ä¹ˆæ ·ï¼Œå¿ƒåŠ¨äº†å—ï¼Œèµ¶ç´§æ‹¨æ‰“VIPçƒ­çº¿ï¼ˆæ‰“ä½\nçƒ¦èºçš„å¤æ—¥ï¼Œé¸¡è¡€çš„è‰é¸£ï¼Œé•¿çš„è·Ÿå‚¬çœ ç¬¦ä¸€æ ·çš„é¢˜ç›®ï¼Œçœ‹åˆ°æœ€åä¸€å¥å·²ç»å¿˜äº†å‰é¢çš„æ¡ä»¶ï¼Œåˆä¸æ˜¯ä¸€ä¸ªå–„èŒ¬ã€‚æ¡ä»¶å¤šäº†ï¼Œç†æ¸…æƒ…å†µå°±éœ€è¦ä¸€ç‚¹æ—¶é—´ã€‚æˆ‘ä»¬å¯ä»¥ç çƒæ¡Œï¼Œç»™æ¯ä¸ªçƒæ¡Œè®¾ç½®ä¸€æ¡æ—¶é—´çº¿ï¼Œè€ƒè™‘æœ€å…ˆç©ºé—²ä¸‹æ¥çš„çƒæ¡Œï¼šå¦‚æœæ˜¯ä¸€å¼ VIPçƒæ¡Œï¼Œæˆ‘ä»¬å°±å¿…é¡»ç…ç…é˜Ÿä¼é‡Œæœ‰æ²¡æœ‰VIPï¼Œæ²¡æœ‰å°±å¯ä»¥æŠŠå®ƒå½“æ™®é€šçƒæ¡Œå¤„ç†ï¼›å¯¹äºæ™®é€šçƒæ¡Œï¼Œåˆ™ç›´æ¥åˆ†é…ç»™é˜Ÿä¼ä¸­çš„ç¬¬ä¸€å¯¹ç©å®¶ã€‚ç¬¬ä¸€ä¸ªå‘ç‚¹å·²æ‚„ç„¶å‡ºç°ï¼Œå¯¹äºVIPç”¨æˆ·ä¼šä¼˜å…ˆé€‰æ‹©ç¼–å·æœ€å°çš„VIPçƒæ¡Œï¼ˆè¿˜æŒºæœ‰ä¼˜è¶Šæ„Ÿå“ˆï¼‰ã€‚å› æ­¤åœ¨åˆ†é…çƒæ¡Œæ—¶ï¼Œå¦‚æœæ˜¯VIPç”¨æˆ·ï¼Œæˆ‘ä»¬éœ€è¦ç…ç…æœ‰æ²¡æœ‰ç©ºçš„VIPçƒæ¡Œã€‚\nè¿™ç§åœ°é›·é¢˜ï¼ŒçœŸå°±æ‘¸é»‘è¸©é›·ï¼Œæˆ‘æ¢³ç†äº†ä»¥ä¸‹å‡ ä¸ªé›·ç‚¹ï¼š\n\nè¾“å…¥æœ€åä¸€è¡Œä¸­çš„Mä¸ªæ•°æ˜¯VIPçƒæ¡Œç¼–å·ï¼Œä¸€å¼€å§‹çœ‹äº†åŠå¤©\n\nVIPç”¨æˆ·ä¼˜å…ˆé€‰æ‹©ç¼–å·æœ€å°çš„VIPçƒæ¡Œï¼Œå³ä½¿æœ‰ç¼–å·æ›´å°çš„æ™®é€šçƒæ¡Œ\n\n21:00æ¥ç©çš„ç©å®¶ä¸æä¾›æœåŠ¡ï¼ˆä¸èƒ½è¾“å‡ºï¼‰\n\nä¸€å¯¹ç©å®¶æœ€å¤šåªèƒ½ç©ä¸¤å°æ—¶ï¼Œè¶…è¿‡ä¸¤å°æ—¶æŒ‰ä¸¤å°æ—¶ç®—\n\nå¦‚æœç©å®¶æ¥çš„æ—¶å€™å¾ˆå¤šçƒæ¡Œéƒ½æ˜¯ç©ºé—²çš„ï¼Œæ­¤æ—¶ä¸èƒ½åˆ†é…æœ€æ—©ç©ºé—²çš„çƒæ¡Œï¼ˆå¯¹è¯¥ç©å®¶æ¥è¯´æ²¡æœ‰æ„ä¹‰ï¼‰ï¼Œè€Œæ˜¯éœ€è¦æŠŠè¿™äº›çƒæ¡Œçš„æ—¶é—´çº¿éƒ½æ‹‰åˆ°ç©å®¶åˆ°è¾¾çš„æ—¶é—´\n\næŒ‰ç…§æä¾›æœåŠ¡çš„æ—¶é—´é¡ºåºè¾“å‡ºç”¨æˆ·è®°å½•ï¼ˆVIPå¯ä»¥æ™šåˆ°æ—©ç©ï¼‰\n\næœ€åçš„ç­‰å¾…æ—¶é—´éœ€è¦æŒ‰åˆ†é’Ÿå››èˆäº”å…¥ï¼ˆâ‰¥ 30s å…¥ï¼Œ&lt; 30s èˆï¼‰\n\n\nå¦‚æœä¸Šè¿°é›·éƒ½å¿ƒçŸ¥è‚šæ˜ï¼Œç§’è¿™ç©æ„è½»è½»æ¾æ¾å§ï½\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nclass customer\n{\npublic:\n    bool isVIP = false, isAssigned = false;\n    int arrival;\n    int playing;\n    int serving;\n};\n\ninline void printRecord(customer &amp;c)\n{\n    int a = c.arrival, s = c.serving, w = s - a;\n    printf(\"%02d:%02d:%02d \", a / 3600, (a % 3600) / 60, a % 60);\n    printf(\"%02d:%02d:%02d \", s / 3600, (s % 3600) / 60, s % 60);\n    // å››èˆäº”å…¥\n    printf(\"%d\\n\", w / 60 + ((w % 60 &lt; 30) ? 0 : 1));\n}\n\nint main()\n{\n    int n, h, m, s;\n    cin &gt;&gt; n;\n    vector&lt;customer&gt; cus(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d:%d:%d\", &amp;h, &amp;m, &amp;s);\n        cus[i].arrival = h * 3600 + m * 60 + s;\n        cin &gt;&gt; cus[i].playing &gt;&gt; cus[i].isVIP;\n        // playing time &lt;= 2h\n        cus[i].playing = (cus[i].playing &gt; 120) ? 7200 : cus[i].playing * 60;\n    }\n    // éœ€è¦å…ˆæŒ‰åˆ°è¾¾æ—¶é—´è¿›è¡Œæ’åº\n    sort(cus.begin(), cus.end(), [](customer &amp;a, customer &amp;b) { return a.arrival &lt; b.arrival; });\n    int table, vip, v;\n    cin &gt;&gt; table &gt;&gt; vip;\n    vector&lt;int&gt; time(table, 28800), total(table, 0), list;\n    vector&lt;bool&gt; isVIP(table, false);\n    for (int i = 0; i &lt; vip; ++i)\n    {\n        cin &gt;&gt; v;\n        isVIP[v - 1] = true;\n    }\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (cus[i].isAssigned) continue;\n        // å°†æ—¶é—´çº¿éƒ½æ‹‰åˆ°ç©å®¶åˆ°è¾¾çš„æ—¶é—´\n        for (int j = 0; j &lt; table; ++j)\n            if (time[j] &lt; cus[i].arrival)\n                time[j] = cus[i].arrival;\n        auto crt = min_element(time.begin(), time.end());\n        //ã€&gt;=ã€‘21ï¼š00ä¸æä¾›æœåŠ¡\n        if (*crt &gt;= 21 * 3600) break;\n        // VIPçƒæ¡Œéœ€æŸ¥æ‰¾ã€ä¹‹å‰ã€‘æœ€æ—©åˆ°è¾¾çš„VIPç”¨æˆ·\n        if (isVIP[crt - time.begin()])\n        {\n            int j = i;\n            bool flag = false;\n            // j &lt; n !!!\n            while (j &lt; n &amp;&amp; cus[j].arrival &lt;= *crt)\n            {\n                if (cus[j].isVIP &amp;&amp; !cus[j].isAssigned)\n                {\n                    cus[j].serving = *crt;\n                    *crt += cus[j].playing;\n                    cus[j].isAssigned = flag = true;\n                    list.push_back(j);\n                    total[crt - time.begin()] += 1;\n                    // åˆ«å¿˜å½“å‰æ™®é€šç©å®¶è¿˜åœ¨æ’é˜Ÿï¼\n                    i -= 1;\n                    break;\n                }\n                ++j;\n            }\n            if (flag) continue;\n        }\n        // VIPç”¨æˆ·ä¼˜å…ˆé€‰æ‹©VIPçƒæ¡Œ\n        if (cus[i].isVIP)\n            for (int k = 0; k &lt; table; ++k)\n                if (time[k] == *crt &amp;&amp; isVIP[k])\n                {\n                    crt = time.begin() + k;\n                    break;\n                }\n        cus[i].serving = *crt;\n        *crt += cus[i].playing;\n        total[crt - time.begin()] += 1;\n        cus[i].isAssigned = true;\n        list.push_back(i);\n    }\n    for (auto &amp;k: list)\n        printRecord(cus[k]);\n    cout &lt;&lt; total[0];\n    for (int i = 1; i &lt; table; ++i)\n        cout &lt;&lt; \" \" &lt;&lt; total[i];\n}\n","slug":"ã€Œ1026ã€Table-Tennis","date":"2022-07-19T14:49:11.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,vector,min_element","author_index":"Starlit Rover"},{"id":"9d68ae743a5d7221c7dc3eed3cb529a9","title":"ã€Œ1025ã€PAT Ranking","content":"â³ENTRY\nProgramming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive numberÂ NÂ (â‰¤100), the number of test locations. ThenÂ NÂ ranklists follow, each starts with a line containing a positive integerÂ KÂ (â‰¤300), the number of testees, and thenÂ KÂ lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space.\nOutput Specification:For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format:\nregistration_number final_rank location_number local_rank\n\nThe locations are numbered from 1 toÂ N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers.\nSample Input:2\n5\n1234567890001 95\n1234567890005 100\n1234567890003 95\n1234567890002 77\n1234567890004 85\n4\n1234567890013 65\n1234567890011 25\n1234567890014 100\n1234567890012 85\n\nSample Output:9\n1234567890005 1 1 1\n1234567890014 1 2 1\n1234567890001 3 1 2\n1234567890003 3 1 2\n1234567890004 5 1 4\n1234567890012 5 2 2\n1234567890002 7 1 5\n1234567890013 8 2 3\n1234567890011 9 2 4\n\n\nÎ©PATè€ƒè¯•æœ‰å¤šä¸ªè€ƒåœºï¼Œç°ç»™å‡ºè€ƒåœºä¸ªæ•°ä»¥åŠæ¯ä¸ªè€ƒåœºå†…è€ƒç”Ÿçš„è€ƒå·ä¸æˆç»©ï¼Œéœ€è¦ä½ è¾“å‡ºè€ƒç”Ÿæ€»æ•°å¹¶æŒ‰åæ¬¡ä»é«˜åˆ°ä½è¾“å‡ºè€ƒç”Ÿçš„è€ƒå·ã€æ€»æ’åã€è€ƒåœºå·ã€è€ƒåœºæ’åï¼Œåˆ†æ•°ç›¸åŒåˆ™æŒ‰å­¦å·å‡åºæ’åˆ—ã€‚\næ³¨æ„åˆ°è€ƒåœºå†…æ’åå’Œæ€»æ’åè®¡ç®—æ–¹å¼æ˜¯ä¸€è‡´çš„ï¼Œåªéœ€è¦è€ƒè™‘æ•°æ®ç»“æ„å¦‚ä½•è®¾è®¡ã€‚æœ€åæ—¢ç„¶æ˜¯æŒ‰ç…§åˆ†æ•°é™åºæ’åˆ—ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç”¨map&lt;score(int),set&lt;registration number(string)&gt; &gt;æ¥å­˜å‚¨ï¼Œå³ä»¥åˆ†æ•°ä¸ºé”®å€¼ç´¢å¼•å¾—åˆ°è·å¾—è¯¥åˆ†æ•°çš„è€ƒç”Ÿå­¦å·é›†åˆã€‚å¯¹äºè€ƒåœºå†…æ’åçš„è·å–ï¼Œæˆ‘ä»¬åªéœ€å…ˆå­˜åœ¨ä¸€ä¸ªå°mapä¸­ï¼Œè®¡ç®—å‡ºæ’ååå°†å…¶åŠ å…¥å¤§mapä¸­ï¼Œæœ€ååœ¨å¤§mapä¸­è®¡ç®—æ€»æ’åå³å¯ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, r, sum = 0, rank;\n    string s;\n    cin &gt;&gt; n;\n    map&lt;int, set&lt;string&gt;, greater&lt;&gt;&gt; score, loc_score;\n    map&lt;string, int&gt; loc, loc_rank;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; k;\n        sum += k;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; s &gt;&gt; r;\n            loc[s] = i + 1;\n            loc_score[r].insert(s);\n        }\n        rank = 1;\n        for (auto &amp;u: loc_score)\n        {\n            for (auto &amp;v: u.second)\n                loc_rank[v] = rank;\n            rank += u.second.size();\n        }\n        for (auto &amp;m: loc_score)\n            score[m.first].insert(m.second.begin(), m.second.end());\n        loc_score.clear();\n    }\n    cout &lt;&lt; sum &lt;&lt; endl;\n    rank = 1;\n    for (auto &amp;u: score)\n    {\n        for (auto &amp;v: u.second)\n            cout &lt;&lt; v &lt;&lt; \" \" &lt;&lt; rank &lt;&lt; \" \" &lt;&lt; loc[v] &lt;&lt; \" \" &lt;&lt; loc_rank[v] &lt;&lt; endl;\n        rank += u.second.size();\n    }\n}\n\nâˆ… Tips\nmap&lt;key,value,greater&lt;&gt;&gt;å¯ä»¥ä½¿mapä¸­çš„é”®å€¼æŒ‰ç…§é™åºå­˜å‚¨\n\nmap1.insert(map2.begin(),map2.end())å¯ä»¥å°†ä¸¤ä¸ªmapåˆå¹¶ï¼Œæœ¬è´¨åªä¼šå°†map2ä¸­å­˜åœ¨map1ä¸­ä¸å­˜åœ¨çš„é”®å€¼è¡¥å……åˆ°map1ï¼Œå¯¹äºä¸¤è€…å…±æœ‰çš„é”®å€¼ï¼Œmap1ä¿æŒåŸå€¼ã€‚\nè¿™é‡Œæˆ‘ä»¬éœ€è¦åˆå¹¶é”®å€¼ç›¸åŒçš„ä¸¤ä¸ªé›†åˆï¼Œå› æ­¤ä¸èƒ½ç›´æ¥ç”¨insert\n\n\n","slug":"ã€Œ1025ã€PAT-Ranking","date":"2022-07-17T15:53:20.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set","author_index":"Starlit Rover"},{"id":"0aa37f9889d7930f068072177d0f0eba","title":"ã€Œ1024ã€Palindromic Number","content":"â³ENTRY\nA number that will be the same when it is written forwards or backwards is known as aÂ Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers.\nNon-palindromic numbers can be paired with palindromic ones via a series of operations. First, the non-palindromic number is reversed and the result is added to the original number. If the result is not a palindromic number, this is repeated until it gives a palindromic number. For example, if we start from 67, we can obtain a palindromic number in 2 steps: 67 + 76 = 143, and 143 + 341 = 484.\nGiven any positive integerÂ N, you are supposed to find its paired palindromic number and the number of steps taken to find it.\n\n\nInput Specification:Each input file contains one test case. Each case consists of two positive numbersÂ NÂ andÂ K, whereÂ NÂ (â‰¤) is the initial numer andÂ KÂ (â‰¤100) is the maximum number of steps. The numbers are separated by a space.\nOutput Specification:For each test case, output two numbers, one in each line. The first number is the paired palindromic number ofÂ N, and the second number is the number of steps taken to find the palindromic number. If the palindromic number is not found afterÂ KÂ steps, just output the number obtained at theÂ Kth step andÂ KÂ instead.\nSample Input 1:67 3\n\nSample Output 1:484\n2\n\nSample Input 2:69 3\n\nSample Output 2:1353\n3\n\n\nÎ©æç®€ç¿»è¯‘ï¼Œç»™å®šä¸€ä¸ªä»¥å†…çš„æ­£æ•´æ•°Nå’Œä¸€ä¸ª100ä»¥å†…çš„æ•´æ•°Kï¼Œåœ¨Kæ¬¡å¾ªç¯å†…ï¼Œå¦‚æœNæ˜¯ä¸€ä¸ªå›æ–‡æ•°å°±é€€å‡ºå¹¶è¾“å‡ºè¯¥å›æ–‡æ•°å’Œç›¸åº”çš„æ¬¡æ•°ï¼Œå¦åˆ™å°†è¯¥æ•°çš„é€†åºæ•°åŠ ä¸ŠNå†èµ‹å€¼ç»™Nã€‚è‹¥Kæ¬¡ä¹‹åNè¿˜ä¸æ˜¯å›æ–‡æ•°ï¼Œåˆ™è¾“å‡ºå½“å‰Nä¸Kã€‚\nä¹ä¸€çœ‹ï¼Œso easyã€‚è™½ç„¶è¯´ï¼ŒNæœ€å¤§æ˜¯11ä½ï¼Œæœ‰å¯èƒ½è¶…å‡ºintçš„èŒƒå›´ï¼Œé‚£æˆ‘æ¢ä¸ªlong long intä¸å°±å®Œäº‹äº†ã€‚å°æ‰‹ä¸€ç‚¹ï¼Œæœ‰ä¸¤ä¸ªç»¿çš„ã€‚å¹²ï¼Œå¿˜è®°è€ƒè™‘è¿ç®—è¿‡ç¨‹ä¸­çš„Näº†ã€‚è€ƒè™‘æç«¯æƒ…å†µï¼Œå¦‚æœNæ˜¯ä¸€ä¸ª11ä½æ•°Kå–20è€Œä¸”æ¯æ¬¡å’Œé€†åºæ•°ç›¸åŠ éƒ½ä¼šå¢åŠ ä¸€ä½ï¼Œé‚£ä¹ˆKæ¬¡ä¹‹åNæ—©å°±è¶…å‡º100ä½äº†ã€‚å¥½å§ï¼Œå›å½’å­—ç¬¦ä¸²ã€‚\næˆ‘ä»¬åªéœ€å®ç°ä¸¤ä¸ªå­—ç¬¦ä¸²å¤§æ•°çš„ç›¸åŠ å³å¯ï¼Œéå¸¸easyä¸èµ˜è¿°äº†ã€‚æ¯æ¬¡å¾ªç¯å¼€å§‹çš„æ—¶å€™åˆ¤æ–­ä¸€ä¸‹Næ˜¯å¦æ˜¯å›æ–‡ä¸²ï¼Œæ˜¯åˆ™é€€å‡ºå¾ªç¯ã€‚\n\nC â˜º D E#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ninline bool isPalindromic(string s)\n{\n    string r = s;\n    reverse(r.begin(), r.end());\n    return s == r;\n}\n\nstring addReverse(string &amp;s)\n{\n    int len = s.size(), flag = 0, single;\n    string otc = \"\";\n    for (int i = 0; i &lt; len; ++i)\n    {\n        single = (s[i] - '0') + (s[len - 1 - i] - '0') + flag;\n        otc = to_string(single % 10) + otc;\n        flag = single / 10;\n    }\n    if (flag)\n        otc = to_string(flag) + otc;\n    return otc;\n}\n\nint main()\n{\n    string n;\n    int k, i;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (i = 0; i &lt; k &amp;&amp; !isPalindromic(n); ++i)\n        n = addReverse(n);\n    cout &lt;&lt; n &lt;&lt; endl &lt;&lt; i &lt;&lt; endl;\n}\n\nreverseå‡½æ•°å¯ä»¥ç›´æ¥åœ¨å®¹å™¨å†…å®ç°é€†åºï¼Œè¿˜æŒºç¥å¥‡ã€‚\n","slug":"ã€Œ1024ã€Palindromic-Number","date":"2022-07-17T11:27:49.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,reverse,string","author_index":"Starlit Rover"},{"id":"9b81a29ab125985da823773d07744634","title":"ã€Œ1023ã€Have Fun with Numbers","content":"â³ENTRY\nNotice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!\nNow you are suppose to check if there are more numbers with this property. That is, double a given number withÂ kÂ digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.\n\n\nInput Specification:Each input contains one test case. Each case contains one positive integer with no more than 20 digits.\nOutput Specification:For each test case, first print in a line â€œYesâ€ if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or â€œNoâ€ if not. Then in the next line, print the doubled number.\nSample Input:1234567899\n\nSample Output:Yes\n2469135798\n\n\nÎ©è¶£å‘³æ•°ï¼Œæ˜¯æŒ‡ä¹˜2åçš„æ•°æ˜¯åŸæ•°ä¸­æ‰€æœ‰æ•°å­—çš„ä¸€ä¸ªæ’åˆ—çš„æ•°ã€‚ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡20ä½çš„æ•°ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­è¯¥æ•°æ˜¯å¦ä¸ºè¶£å‘³æ•°ï¼ŒåŒæ—¶è¾“å‡ºä¹˜2åçš„æ•°ã€‚\nç”±äºæœ€å¤§æ˜¯20ä½æ•°ï¼Œå› æ­¤ä¸èƒ½ç›´æ¥ç”¨æ•´å‹å‚ä¸è¿ç®—ï¼Œéœ€è¦è‡ªå·±å®ç°å¤§æ•°ä¹˜2ç®—æ³•ï¼Œç„¶åç”¨ä¸€ä¸ªæ•°å­—è®¡æ•°vectorç»Ÿè®¡åŸæ•°ä¸­0-9å„æ•°å­—ä¸ªæ•°ï¼Œåœ¨è¿›è¡Œä¹˜2è¿ç®—æ¯äº§ç”Ÿä¸€ä½éƒ½åœ¨è®¡æ•°å™¨ä¸­å‡å»ç›¸åº”æ•°å­—çš„ä¸ªæ•°ï¼Œæœ€åè®¡æ•°å™¨ä¸­è‹¥éƒ½ä¸º0åˆ™è¯´æ˜ä¸ºè¶£å‘³æ•°ï¼Œåä¹‹åˆ™ä¸æ˜¯ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    string num, num2 = \"\";\n    cin &gt;&gt; num;\n    vector&lt;int&gt; check(10, 0);\n    for (auto &amp;c: num)\n        ++check[c - '0'];\n    int flag = 0, single;\n    for (auto i = num.rbegin(); i != num.rend(); ++i)\n    {\n        single = 2 * (*i - '0') + flag;\n        flag = single / 10;\n        num2 = to_string(single % 10) + num2;\n        --check[single % 10];\n    }\n    if (flag)\n    {\n        num2 = to_string(flag) + num2;\n        --check[flag];\n    }\n    bool isFun = true;\n    for (auto k: check)\n        if (k != 0)\n        {\n            isFun = false;\n            break;\n        }\n    cout &lt;&lt; (isFun ? \"Yes\" : \"No\") &lt;&lt; endl &lt;&lt; num2 &lt;&lt; endl;\n}\n","slug":"ã€Œ1023ã€Have-Fun-with-Numbers","date":"2022-07-07T02:33:40.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set","author_index":"Starlit Rover"},{"id":"8e6bb31e56ec41155c96a89b29398eaf","title":"ã€Œ1022ã€Digital Library","content":"â³ENTRY\nA Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their IDâ€™s.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ  which is the total number of books. ThenÂ NÂ blocks follow, each contains the information of a book in 6 lines:\n\nLine #1: the 7-digit ID number;\nLine #2: the book title â€“ a string of no more than 80 characters;\nLine #3: the author â€“ a string of no more than 80 characters;\nLine #4: the key words â€“ each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;\nLine #5: the publisher â€“ a string of no more than 80 characters;\nLine #6: the published year â€“ a 4-digit number which is in the range [1000, 3000].\n\nIt is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers.\nAfter the book information, there is a line containing a positive integerÂ MÂ (â‰¤1000) which is the number of userâ€™s search queries. ThenÂ MÂ lines follow, each in one of the formats shown below:\n\n1: a book title\n2: name of an author\n3: a key word\n4: name of a publisher\n5: a 4-digit number representing the year\n\nOutput Specification:For each query, first print the original query in a line, then output the resulting book IDâ€™s in increasing order, each occupying a line. If no book is found, printÂ Not FoundÂ instead.\nSample Input:3\n1111111\nThe Testing Book\nYue Chen\ntest code debug sort keywords\nZUCS Print\n2011\n3333333\nAnother Testing Book\nYue Chen\ntest code sort keywords\nZUCS Print2\n2012\n2222222\nThe Testing Book\nCYLL\nkeywords debug book\nZUCS Print2\n2011\n6\n1: The Testing Book\n2: Yue Chen\n3: keywords\n4: ZUCS Print\n5: 2011\n3: blablabla\n\nSample Output:1: The Testing Book\n1111111\n2222222\n2: Yue Chen\n1111111\n3333333\n3: keywords\n1111111\n2222222\n3333333\n4: ZUCS Print\n1111111\n5: 2011\n1111111\n2222222\n3: blablabla\nNot Found\n\n\nÎ©è¾“å…¥æ¯æœ¬ä¹¦çš„ç¼–å·ï¼Œä¹¦åï¼Œä½œè€…ï¼Œå…³é”®è¯ï¼Œå‡ºç‰ˆç¤¾å’Œå¹´ä»½ï¼Œç„¶åæ ¹æ®ä¸åŒçš„æŸ¥è¯¢æ–¹å¼ç»™å‡ºç›¸åº”çš„æŸ¥è¯¢ç»“æœã€‚\næœ¬é¢˜çœ‹ç€å¾ˆå¤æ‚ï¼Œä½†æ˜¯ç”¨mapå®¹å™¨å¯ä»¥ç›´æ¥ç§’æ€ã€‚å¯¹äºå…³é”®è¯ï¼Œæˆ‘ä»¬å¹¶ä¸æ¸…æ¥šä¸€è¡Œæœ‰å‡ ä¸ªï¼Œä½†é¢˜ç›®æ˜ç¡®å‘ŠçŸ¥æ˜¯ä»¥å•ä¸ªç©ºæ ¼åˆ†éš”çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å…ˆè¯»å–ä¸€è¡Œç„¶åå•ä¸ªå­—ç¬¦åœ°åŠ å…¥wordå˜é‡é‡åˆ°ç©ºæ ¼åå†åŠ å…¥mapå¹¶æ¸…ç©ºwordã€‚\nå¤§æ¦‚æœ‰ä¸¤ä¸ªæ³¨æ„äº‹é¡¹ï¼š\n\nä¸€è¡Œä¸­æœ€åä¸€ä¸ªå…³é”®è¯æ˜¯æ²¡æœ‰ç©ºæ ¼çš„\n\nå¦‚æœå°†ä¹¦æœ¬çš„IDç”¨intç±»å‹æ¥å­˜å‚¨ï¼Œé‚£ä¹ˆéœ€è¦æ³¨æ„æœ‰å‰ç½®0çš„IDï¼Œè¾“å‡ºçš„æ—¶å€™éœ€è¦æ ¼å¼åŒ–ï¼Œå¦åˆ™æµ‹è¯•ç‚¹3ã€4å°†è¿‡ä¸å»\n\n\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    map&lt;string, set&lt;int&gt;&gt; title, author, publisher, keyword, year;\n    string str;\n    int id;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id;\n        cin.get();\n        getline(cin, str);\n        title[str].insert(id);\n        getline(cin, str);\n        author[str].insert(id);\n        getline(cin, str);\n        string word = \"\";\n        for (auto c: str)\n        {\n            if (c != ' ')\n                word += c;\n            else\n            {\n                keyword[word].insert(id);\n                word = \"\";\n            }\n        }\n        keyword[word].insert(id);\n        getline(cin, str);\n        publisher[str].insert(id);\n        getline(cin, str);\n        year[str].insert(id);\n    }\n\n    int m, format;\n    cin &gt;&gt; m;\n    cin.get();\n    for (int i = 0; i &lt; m; ++i)\n    {\n        getline(cin, str);\n        cout &lt;&lt; str &lt;&lt; endl;\n        format = str[0] - '0';\n        str.erase(0, 3);\n        switch (format)\n        {\n            case 1:\n                if (title[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: title[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 2:\n                if (author[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: author[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 3:\n                if (keyword[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: keyword[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 4:\n                if (publisher[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: publisher[str])\n                        printf(\"%07d\\n\", k);\n                break;\n            case 5:\n                if (year[str].size() == 0)\n                    cout &lt;&lt; \"Not Found\" &lt;&lt; endl;\n                else\n                    for (auto &amp;k: year[str])\n                        printf(\"%07d\\n\",k);\n                break;\n        }\n    }\n}\n","slug":"ã€Œ1022ã€Digital-Library","date":"2022-07-06T10:55:03.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set","author_index":"Starlit Rover"},{"id":"984c45eac2cbd15ed424e46306609be5","title":"ã€Œ1021ã€Deepest Root","content":"â³ENTRY\nA graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is calledÂ the deepest root.\nInput Specification:Each input file contains one test case. For each case, the first line contains a positive integerÂ  which is the number of nodes, and hence the nodes are numbered from 1 toÂ . ThenÂ Â lines follow, each describes an edge by given the two adjacent nodesâ€™ numbers.\n\n\nOutput Specification:For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, printÂ Error: K componentsÂ whereÂ KÂ is the number of connected components in the graph.\nSample Input 1:5\n1 2\n1 3\n1 4\n2 5\n\nSample Output 1:3\n4\n5\n\nSample Input 2:5\n1 3\n1 4\n2 5\n3 4\n\nSample Output 2:Error: 2 components\n\n\nÎ©ç»™å‡ºèŠ‚ç‚¹ä¸ªæ•°å’Œæ¡è¾¹ï¼Œé¦–å…ˆåˆ¤æ–­è¯¥æ— å‘å›¾æ˜¯å¦æ„æˆæ ‘ï¼Œç„¶åæŒ‰å‡åºè¾“å‡ºä½œä¸ºæ ¹èŠ‚ç‚¹æ—¶èƒ½ä½¿æ ‘é«˜åº¦æœ€é«˜çš„èŠ‚ç‚¹ç¼–å·ã€‚\né¦–å…ˆè¾¹çš„ä¸ªæ•°å·²ç»æ»¡è¶³æ ‘çš„è¦æ±‚ï¼Œå› æ­¤å¦‚æœä¸æ˜¯æ ‘çš„è¯å°±ä¸€å®šä¸æ˜¯è¿é€šçš„ã€‚æ‰€ä»¥é¦–å…ˆéœ€è¦æ±‚å–è¿é€šåˆ†å›¾æ•°ï¼Œè¿™é‡Œç”¨DFSå’ŒBFSçš†å¯ã€‚ç„¶åå¦‚æœè¿é€šåˆ†å›¾æ•°ä¸º1ï¼Œå†å¯»æ‰¾ä½œä¸ºæ ¹èŠ‚ç‚¹å¯ä»¥ä½¿é«˜åº¦æœ€é«˜çš„èŠ‚ç‚¹ã€‚\nè™½è¯´æ‰¾çš„æ˜¯é«˜åº¦æœ€é«˜ï¼Œä½†æœ¬è´¨ä¸Šæ˜¯åœ¨æ ‘ä¸­æ‰¾ä¸€æ¡æœ€é•¿ä¸”èŠ‚ç‚¹ä¸é‡å¤çš„è·¯å¾„ï¼Œæœ€ç»ˆè¾“å‡ºçš„åˆ™æ˜¯æ‰€æœ‰æœ€é•¿è·¯å¾„çš„å·¦å³ä¸¤ä¸ªèŠ‚ç‚¹ç¼–å·ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶ä¸­ä¸€æ¡æœ€é•¿è·¯å¾„æ‹‰æˆç›´çº¿ï¼Œå…¶ä»–ä¸å±äºè¯¥è·¯å¾„çš„è¾¹å¯ä»¥è§†ä½œè¯¥ç›´çº¿çš„åˆ†æ”¯ï¼Œé‚£ä¹ˆæ˜¾ç„¶åœ¨è¯¥ç›´çº¿ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹éƒ½å±äºè‡³å°‘ä¸€æ¡æœ€é•¿è·¯å¾„ï¼ˆå³ç›´çº¿æœ¬èº«ï¼‰ï¼Œè€Œä¸”æ‰€æœ‰æœ€é•¿è·¯å¾„å¿…ç„¶ä¼šç»è¿‡ç›´çº¿ä¸Šçš„è‡³å°‘ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦å¤–ç›´çº¿ä¸Šæ¯ä¸ªèŠ‚ç‚¹å¯¹æœ€é•¿è·¯å¾„çš„é•¿åº¦åˆ’åˆ†éƒ½æ˜¯å›ºå®šçš„ï¼ˆå¦åˆ™å¿…ç„¶ä¼šäº§ç”Ÿæ›´é•¿çš„ï¼‰ã€‚ä¸ç®¡ä»å“ªä¸ªèŠ‚ç‚¹å¼€å§‹BFSéƒ½è¿Ÿæ—©ä¼šè¾¾åˆ°ç›´çº¿ä¸Šçš„æŸä¸ªèŠ‚ç‚¹ï¼Œä¸å¤±ä¸€èˆ¬æ€§ï¼Œæˆ‘ä»¬å‡è®¾èŠ‚ç‚¹å°†æœ€é•¿è·¯å¾„åˆ’åˆ†åçš„å·¦ç«¯&gt;å³ç«¯ï¼Œé¦–å…ˆå¯ä»¥è‚¯å®šæœ€ç»ˆå¿…ç„¶ä¼šåˆ°è¾¾ç›´çº¿æœ€å·¦ç«¯èŠ‚ç‚¹ï¼Œå¦å¤–å¿…ç„¶å¯ä»¥åˆ°è¾¾ç»è¿‡å·¦è¾¹èŠ‚ç‚¹ä»¬çš„æœ€é•¿è·¯å¾„çš„ä¸€ç«¯ï¼ˆå› ä¸ºç›´çº¿ä¸Šæ¯ä¸ªèŠ‚ç‚¹å¯¹æœ€é•¿è·¯å¾„é•¿åº¦åˆ’åˆ†éƒ½æ˜¯ä¸€è‡´çš„ï¼Œå› æ­¤åˆ°è¾¾çš„å…¶ä»–ç«¯ç‚¹åˆ°è·å…¶æœ€è¿‘çš„ç›´çº¿ä¸ŠèŠ‚ç‚¹çš„è·ç¦»=åˆ°ç›´çº¿æœ€å·¦ç«¯èŠ‚ç‚¹çš„è·ç¦»ï¼‰ã€‚ç„¶è€Œå³ä¾§çš„ç«¯ç‚¹è¢«å¿½ç•¥äº†ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦ä»ç¬¬ä¸€æ¬¡BFSå¾—åˆ°çš„ç«¯ç‚¹ä¸­é€‰ä¸€ä¸ªé‡æ–°å¼€å§‹BFSï¼ˆæ³¨æ„ç›´çº¿ä¸Šåˆ†æ”¯çš„æœ€å¤§é•¿åº¦å¿…ç„¶â‰¤æœ€é•¿è·¯å¾„/2ï¼Œå› æ­¤è·ç¦»ç¬¬ä¸€æ¬¡BFSå¾—åˆ°çš„ä»»æ„ç«¯ç‚¹æœ€è¿‘çš„ç›´çº¿èŠ‚ç‚¹å°†æœ€é•¿è·ç¦»åˆ’åˆ†çš„ç»“æœä¼šæ˜¯ å³ç«¯&gt;å·¦ç«¯ï¼Œä»è€Œå¯ä»¥äº’è¡¥ï¼‰ï¼Œæœ€åå–å¹¶é›†å¾—åˆ°æ‰€æœ‰ç«¯ç‚¹ã€‚\nè¿™äº›è¯æ˜åªæ˜¯ä¸ºäº†è¯´æ˜è¯¥ç®—æ³•çš„åˆç†æ€§ï¼Œåœ¨ä»£ç ä¸­å¹¶ä¸ä½“ç°ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    map&lt;int, set&lt;int&gt;&gt; path;\n    for (int i = 0; i &lt; n - 1; ++i)\n    {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        path[x].insert(y);\n        path[y].insert(x);\n    }\n    vector&lt;bool&gt; flag(n + 1, false);\n    int cnt = 0;\n\n    for (int k = 1; k &lt;= n; ++k)\n    {\n        if(flag[k]) continue;\n        set&lt;int&gt; next{k}, tmp;\n        while (!next.empty())\n        {\n            for (auto i: next)\n            {\n                if (flag[i]) continue;\n                flag[i] = true;\n                tmp.insert(path[i].begin(), path[i].end());\n            }\n            next = tmp;\n            tmp.clear();\n        }\n        cnt += 1;\n    }\n\n    set&lt;int&gt; deepestA, deepestB, tmp{1};\n    if (cnt &gt; 1)\n        printf(\"Error: %d components\", cnt);\n    else\n    {\n        flag.assign(n + 1, false);\n        while (!tmp.empty())\n        {\n            deepestA = tmp;\n            tmp.clear();\n            for (auto i: deepestA)\n            {\n                for (auto &amp;k: path[i])\n                    if (!flag[k]) tmp.insert(k);\n                flag[i] = true;\n            }\n        }\n        tmp.insert(*deepestA.begin());\n        flag.assign(n + 1, false);\n        while (!tmp.empty())\n        {\n            deepestB = tmp;\n            tmp.clear();\n            for (auto i: deepestB)\n            {\n                for (auto &amp;k: path[i])\n                    if (!flag[k]) tmp.insert(k);\n                flag[i] = true;\n            }\n        }\n    }\n    deepestA.insert(deepestB.begin(), deepestB.end());\n    for (auto &amp;k: deepestA)\n        cout &lt;&lt; k &lt;&lt; endl;\n}\n\nTips\nå…ˆç”¨BFSè®¡ç®—è¿é€šåˆ†å›¾ä¸ªæ•°\n\nåœ¨BFSæ±‚æœ€å¤§æ·±åº¦æ—¶å‹¿å°†çˆ¶èŠ‚ç‚¹åŠ å…¥ä¸‹ä¸€è½®éå†èŠ‚ç‚¹ä¸­\n\n\n","slug":"ã€Œ1021ã€Deepest-Root","date":"2022-07-05T03:27:49.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,set,BFS,vector","author_index":"Starlit Rover"},{"id":"ecd0b7f9610ba01de460fb7fa358ee35","title":"ã€Œ1020ã€Tree Traversals","content":"â³ENTRY\nSuppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.\nInput Specification:Each input file contains one test case. For each case, the first line gives a positive integerÂ NÂ (â‰¤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.\n\n\nOutput Specification:For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.\nSample Input:7\n2 3 1 5 7 6 4\n1 2 3 4 5 6 7\n\nSample Output:4 1 6 3 5 7 2\n\n\nÎ©é¢˜æ„ç®€å•æ˜äº†ï¼Œå°±æ˜¯é€šè¿‡äºŒå‰æ ‘çš„ååºéå†åºåˆ—å’Œä¸­åºéå†åºåˆ—æ±‚å‡ºå±‚æ¬¡éå†åºåˆ—ã€‚\næˆ‘ä»¬åªéœ€æŠ“ä½ååºå’Œä¸­åºçš„é‡è¦ç‰¹å¾å³å¯ï¼Œååºçš„ä¸­é—´èŠ‚ç‚¹æ˜¯åœ¨æœ€åçš„ï¼Œä¸­åºçš„ä¸­é—´èŠ‚ç‚¹åˆ™æ˜¯åœ¨å·¦å³å­æ ‘çš„ä¸­é—´ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥é‡‡å–å¦‚ä¸‹ç®—æ³•æ„å»ºäºŒå‰æ ‘ï¼š\n\nå…ˆå–å‡ºååºçš„æœ€åä¸€ä¸ªæ•°å­—å³å¯çŸ¥å½“å‰èŠ‚ç‚¹çš„ç¼–å·\n\nåœ¨ä¸­åºåºåˆ—ä¸­æ‰¾åˆ°è¯¥ç¼–å·æ‰€å¤„çš„ä½ç½®ï¼Œé‚£ä¹ˆä¸­åºåºåˆ—å°±è¢«è¯¥èŠ‚ç‚¹åˆ’åˆ†æˆäº†å·¦å³ä¸¤æ£µå­æ ‘çš„ä¸­åºåºåˆ—ï¼ŒåŒæ—¶æˆ‘ä»¬ä¹Ÿå¾—åˆ°äº†ä¸¤æ£µå­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°\n\næ ¹æ®å¾—åˆ°çš„å·¦å³å­æ ‘èŠ‚ç‚¹ä¸ªæ•°ä¹Ÿå¯ä»¥å°†ååºåºåˆ—åˆ’åˆ†æˆå·¦å³ä¸¤æ£µå­æ ‘çš„ååºåºåˆ—\n\nå¦‚æ­¤ä¸€æ¥æˆ‘ä»¬å°±åˆ†åˆ«å¾—åˆ°äº†å·¦å³å­æ ‘çš„ååºå’Œä¸­åºéå†åºåˆ—ï¼Œä»è€Œåˆ’åˆ†æˆäº†ä¸¤ä¸ªå­é—®é¢˜å†é‡å¤ä¸Šè¿°è¿‡ç¨‹è¿›è¡Œè§£å†³\n\n\nå¾ˆæ˜¾ç„¶ï¼Œåˆ’åˆ†ä¸ºå­é—®é¢˜æ˜¯é€’å½’çš„æ€æƒ³ï¼Œå› æ­¤åªéœ€ç ä¸€ä¸ªé€’å½’æ„å»ºäºŒå‰æ ‘çš„å‡½æ•°å³å¯ï¼Œä¼ å…¥å½“å‰å­æ ‘çš„ååºå’Œä¸­åºåºåˆ—åœ¨åŸåºåˆ—ä¸­çš„ä½ç½®å³å¯ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\nmap&lt;int, pair&lt;int, int&gt;&gt; tree;\nvector&lt;int&gt; post, in;\n\nvoid build(int in_start, int in_end, int post_start, int post_end)\n{\n    if (in_start &gt;= in_end)\n        return;\n    int crt = post[post_end], in_pos = find(in.begin() + in_start, in.begin() + in_end, crt) - in.begin() - in_start;\n    tree[crt].first = (in_pos == 0) ? 0 : post[post_start + in_pos - 1];\n    build(in_start, in_start + in_pos - 1, post_start, post_start + in_pos - 1);\n    tree[crt].second = (in_pos == in_end - in_start) ? 0 : post[post_end - 1];\n    build(in_start + in_pos + 1, in_end, post_start + in_pos, post_end - 1);\n}\n\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    post.resize(n);\n    in.resize(n);\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; post[i];\n    for (int i = 0; i &lt; n; ++i)\n        cin &gt;&gt; in[i];\n    build(0, n - 1, 0, n - 1);\n    vector&lt;int&gt; level, tmp;\n    cout &lt;&lt; post[n - 1];\n    if (tree[post[n - 1]].first != 0)\n        level.push_back(tree[post[n - 1]].first);\n    if (tree[post[n - 1]].second != 0)\n        level.push_back(tree[post[n - 1]].second);\n    while (!level.empty())\n    {\n        for (auto &amp;k: level)\n        {\n            cout &lt;&lt; \" \" &lt;&lt; k;\n            if (tree[k].first != 0)\n                tmp.push_back(tree[k].first);\n            if (tree[k].second != 0)\n                tmp.push_back(tree[k].second);\n        }\n        level = tmp;\n        tmp.clear();\n    }\n}\n\nTips\nç”¨map&lt;int,pair&lt;int,int&gt;&gt;æ¥è¡¨ç¤ºäºŒå‰æ ‘ï¼Œé€šè¿‡èŠ‚ç‚¹ç¼–å·å¯ä»¥ç›´æ¥å¾—çŸ¥å·¦å³èŠ‚ç‚¹ï¼Œè‹¥èŠ‚ç‚¹ç¼–å·ä¸º0åˆ™ä»£è¡¨è¯¥èŠ‚ç‚¹ä¸ºç©º\n\næ³¨æ„å·¦å³å­æ ‘ä¸ºç©ºçš„æƒ…å†µï¼Œä¹Ÿæ˜¯é€’å½’ç»“æŸçš„æ—¶å€™\n\nåœ¨æœ¬é¢˜ä¸­å…¶å®å¯ä»¥æ— éœ€æ„å»ºå‡ºå®Œæ•´çš„äºŒå‰æ ‘ï¼Œå› ä¸ºåªéœ€è¾“å‡ºå±‚æ¬¡éå†åºåˆ—ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç»™æ¯ä¸ªç¼–å·éƒ½ç»™äºˆä¸€ä¸ªå±‚æ¬¡éå†çš„ç´¢å¼•ï¼Œæœ€åæŒ‰ç´¢å¼•è¾“å‡ºç¼–å·å³å¯ï¼Œè¯¦è§æŸ³å©¼ ã® blog\n\n\n","slug":"ã€Œ1020ã€Tree-Traversals","date":"2022-07-04T03:51:27.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,vector","author_index":"Starlit Rover"},{"id":"1a8f64477679eeab68479d654eb4e8ee","title":"<11> Left Factoring","content":"æœ¬æ–‡å®ç°äº†ä¸€ä¸ªè¾ƒä¸ºç®€å•çš„ç®—æ³•â€”â€”æ–‡æ³•çš„å·¦å…¬å› å­æå–ã€‚ummå…¶å®ä¹Ÿç§°ä¸ä¸Šæ˜¯ç®—æ³•ã€‚\n\n\n\n\n\n\næˆ‘ä»¬çš„ç›®æ ‡éå¸¸æ˜ç¡®ï¼Œå°±æ˜¯å°†æ–‡æ³•äº§ç”Ÿå¼çš„å·¦å…¬å› å¼éƒ½æå‡ºæ¥ï¼Œéœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š\n\nåœ¨ä¸€ä¸ªäº§ç”Ÿå¼ä¸­éœ€è¦æå–èŒƒå›´æœ€å¤§çš„å…¬å› å¼ï¼Œå³æ‹¥æœ‰è¯¥å·¦å…¬å› å¼çš„å³éƒ¨åº”è¯¥å°½å¯èƒ½å¾—å¤š\n\næå–å·¦å…¬å› å­ä¹‹åä¼šäº§ç”Ÿæ–°çš„äº§ç”Ÿå¼ï¼Œè¯¥äº§ç”Ÿå¼ä¹Ÿå¯èƒ½å­˜åœ¨å·¦å…¬å› å­ï¼Œéœ€è¦ä¸€å¹¶æå–ï¼Œå› æ­¤æ˜¯ä¸€ç§é€’å½’çš„æ€æƒ³\n\nå¥½åƒä¹Ÿå°±è¿™ä¸¤ç‚¹â€¦\n\n\né‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦ä»å¹¿åº¦å’Œæ·±åº¦è¿›è¡Œç¡®å®šå³å¯ã€‚é¦–å…ˆç¡®å®šå·¦å…¬å› å­å¹¿åº¦ï¼Œå³æœ€å¤šçš„å«æœ‰å·¦å…¬å› å­çš„å³éƒ¨ä¸ªæ•°ã€‚å¾ˆæ˜¾ç„¶ï¼Œå¯¹äºæœ€å¤§çš„å¹¿åº¦ï¼Œåªè¦æ‰¾ç¬¬ä¸€ä¸ªç¬¦å·ç›¸ç­‰çš„å³éƒ¨å³å¯ã€‚ç¡®å®šæœ€å¤§å¹¿åº¦åï¼Œæˆ‘ä»¬å†æ±‚è¿™äº›é¦–å­—ç¬¦ç›¸ç­‰å³éƒ¨çš„æœ€å¤§æ·±åº¦ï¼ˆæœ€é•¿çš„å·¦å…¬å› å­ï¼‰å³å¯ï¼Œé‚£ä¹ˆå°±ä¸€éä¸€éåœ°éå†ï¼Œç›´åˆ°å‘ç°å…¶ä¸­ä¸€ä¸ªå³éƒ¨å’Œå…¶ä»–å³éƒ¨çš„ç¬¬ä½å­—ç¬¦ä¸åŒæ—¶ï¼Œé€€å‡ºå¾ªç¯ã€‚æ„é€ æ–°äº§ç”Ÿå¼ï¼Œç„¶åå¯¹æ–°äº§ç”Ÿå¼è¿›è¡Œå·¦å…¬å› å­æå–å³å¯ã€‚\n\nC â˜º D Edef extract(gen, left):\n    gen[left].sort()\n    k = 0\n    flag = True\n    next_str = left + \"'\"\n    while k &lt; len(gen[left]) - 1:\n        kk = k + 1\n        # ç¡®å®šæ¨ªå‘æœ€å¤§è·ç¦»\n        while kk &lt; len(gen[left]) and gen[left][kk][0] == gen[left][kk - 1][0]:\n            kk += 1\n        if kk == k + 1:\n            k += 1\n            continue\n        # ç¡®å®šçºµå‘æœ€å¤§æ·±åº¦\n        common = gen[left][k][0]\n        depth = 0\n        for depth in range(1, len(gen[left][k])):\n            flag = True\n            for i in range(k + 1, kk):\n                if depth &gt;= len(gen[left][i]) or gen[left][i][depth] != gen[left][i - 1][depth]:\n                    flag = False\n                    break\n            if flag:\n                common += gen[left][k][depth]\n            else:\n                break\n        # å½“æ•´ä¸ªgen[left][k]å‡ä¸ºå·¦å…¬å› å¼ï¼ˆflagå§‹ç»ˆä¸ºTrueï¼‰æ—¶å¿…é¡»å°†depth+=1ï¼Œå› ä¸ºdepthæŒ‡çš„æ˜¯å·¦å…¬å› å¼çš„åä¸€ä½\n        depth += (1 if flag else 0)\n        # extract common part\n        gen[next_str] = ([gen[left][k][depth:]] if depth &lt; len(gen[left][k]) else ['Îµ'])\n        gen[left][k] = common + next_str\n        for i in range(k + 1, kk):\n            gen[next_str].append((gen[left][k + 1][depth:] if depth &lt; len(gen[left][k + 1]) else ['Îµ']))\n            gen[left].pop(k + 1)\n        # é€’å½’è°ƒç”¨\n        extract(gen, next_str)\n        next_str += \"'\"\n        k = k + 1\n\n\nn = eval(input('è¯·è¾“å…¥æ–‡æ³•äº§ç”Ÿå¼çš„ä¸ªæ•°ï¼š'))\nprint('è¯·è¾“å…¥æ–‡æ³•äº§ç”Ÿå¼ï¼š')\ngen = dict()\nfor i in range(n):\n    g = input().replace(' ', '')\n    assert g[1:3] == '-&gt;'\n    gen.setdefault(g[0], [])\n    start = 3\n    for i in range(3, len(g)):\n        if g[i] == '|' or i == len(g) - 1:\n            i += (1 if i == len(g) - 1 else 0)\n            assert start &lt; i\n            gen[g[0]].append(g[start:i])\n            start = i + 1\n    extract(gen, g[0])\n\nprint(\"\\nAfter left factoring:\")\nfor key in gen:\n    print(key + ' -&gt; ', end='')\n    print(*gen[key], sep=' | ')\n\n\nTips\næ•°æ®ç»“æ„ä¸ NO Left Recursion\">&lt;10&gt; NO Left Recursionçš„ç±»ä¼¼ï¼Œåªæ˜¯åˆ—è¡¨ä¸­æ— éœ€åˆ†ç»ˆç»“ç¬¦å¼€å¤´è¿˜æ˜¯éç»ˆç»“ç¬¦å¼€å¤´ï¼Œæå–å·¦å…¬å› å­ä¸€è§†åŒä»\n\nç”±äºç›¸åŒå­—ç¬¦å¼€å¤´çš„å³éƒ¨å¯èƒ½å¾ˆåˆ†æ•£ï¼Œä¸å¤ªå¥½ç›´æ¥æ‰¾ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æå–ä¹‹å‰å¯ä»¥å¯¹ä¸€ä¸ªäº§ç”Ÿå¼çš„å³éƒ¨å…ˆæŒ‰ç…§å­—ç¬¦åºè¿›è¡Œæ’åº\n\nç”¨[k,kk)æ¥è¡¨ç¤ºæœ€å¤§å¹¿åº¦èŒƒå›´ï¼Œdepthæ˜¯æœ€å¤§æ·±åº¦ï¼Œnext_stræ˜¯ä¸‹ä¸€ä¸ªæ–°äº§ç”Ÿå¼å·¦éƒ¨çš„åç§°ï¼ˆå°±æ˜¯æ¯æ¬¡åŠ ä¸€ä¸ªã€â€˜ã€‘ï¼‰\n\næ³¨æ„æœ‰æ—¶å…¶ä¸­ä¸€ä¸ªå³éƒ¨æœ¬èº«å°±æ˜¯å·¦å…¬å› å¼çš„ç‰¹æ®Šæƒ…å†µï¼Œæ­¤æ—¶æå–åçš„æ–°äº§ç”Ÿå¼å³éƒ¨éœ€è¦åŠ ä¸Šã€Îµã€‘\n\n\n\nOutcome","slug":"11-Left-Factoring","date":"2022-06-06T15:29:06.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"python,èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"e7d5cd857c1aa61505680c49d614561a","title":"Lexerï¼ˆVer. Handï¼‰","content":"æœ¬æ–‡ä»‹ç»å¦‚ä½•æ‰‹æ’•è¯æ³•åˆ†æå™¨ï¼Œæ•´ä½“æ¥è¯´éš¾åº¦ä¸å¤§ï¼Œè¿˜æ˜¯æ–‡ä»¶è¯»å–éº»çƒ¦ã€‚\n\n\n\n\nlexer.h#ifndef LEXER_H\n#define LEXER_H\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nenum token_type\n{\n    INT,\n    VOID,\n    CONST,\n    IF,\n    ELSE,\n    WHILE,\n    BREAK,\n    CONTINUE,\n    RETURN,\n    ID,\n    NUM,\n    ASSIGN,\n    OR,\n    AND,\n    CMP,\n    LPARENT,\n    RPARENT,\n    LBRACKET,\n    RBRACKET,\n    LBRACE,\n    RBRACE,\n    SEMICN,\n    COMMA,\n    BINOPP,\n    PLUSSUB,\n    NOT\n};\n\nvector&lt;string&gt; token_name =\n{\n    \"INT\\t\\t\",\n    \"VOID\\t\",\n    \"CONST\\t\",\n    \"IF\\t\\t\",\n    \"ELSE\\t\",\n    \"WHILE\\t\",\n    \"BREAK\\t\",\n    \"CONTINUE\",\n    \"RETURN\\t\",\n    \"ID\\t\\t\",\n    \"NUM\\t\\t\",\n    \"ASSIGN\\t\",\n    \"OR\\t\\t\",\n    \"AND\\t\\t\",\n    \"CMP\\t\\t\",\n    \"LPARENT\\t\",\n    \"RPARENT\\t\",\n    \"LBRACKET\",\n    \"RBRACKET\",\n    \"LBRACE\\t\",\n    \"RBRACE\\t\",\n    \"SEMICN\\t\",\n    \"COMMA\\t\",\n    \"BINOPP\\t\",\n    \"PLUSSUB\\t\",\n    \"NOT\\t\\t\"\n};\n\nint lineno = 1;\nvector&lt;pair&lt;token_type, string&gt;&gt; tokens;\nstring token_str;\n\nbool isHexDigit(char ch)    //è¿”å›æ˜¯å¦æ˜¯16è¿›åˆ¶çš„å­—ç¬¦ï¼Œå³0~9,a~f,A~F\n{\n    if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') return true;\n    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') return true;\n    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') return true;\n    return false;\n}\n\nbool isIdentifierChar(char ch)    //è¿”å›æ˜¯å¦æ˜¯ç»„æˆæ ‡è¯†ç¬¦çš„å­—ç¬¦\n{\n    return isalpha(ch) || isdigit(ch) || ch == '_';\n}\n\n// token identifiers\nbool Number(ifstream &amp;fin)\n{\n    char ch;\n    //ä»£è¡¨æ˜¯å¦æ˜¯éæ³•åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶ã€åè¿›åˆ¶æ•°\n    bool isInvalidHex = 0, isInvalidOct = 0, isInvalidDec = 0;\n\n    //ç¬¬ä¸€ä½çš„å¤„ç†ï¼Œæ ¹æ®0ä¸é0åˆ†åˆ«è€ƒè™‘\n    if (token_str == \"0\")            //OCT or HEX or ZERO\n    {\n        int decnum = 0;\n        if (fin.peek() == 'x' || fin.peek() == 'X')    //HEX\n        {\n            fin.get(ch);\n            token_str += ch;\n            bool is0x = 1;     //åˆ¤æ–­æ˜¯å¦æ˜¯å•ä¸ªçš„0xï¼Œèƒ½è¿›å…¥ä¸‹é¢çš„whileå°±è¯æ˜ä¸æ˜¯\n            while (isHexDigit(fin.peek()))\n            {\n                is0x = 0;\n                fin.get(ch);\n                token_str += ch;\n                decnum &lt;&lt;= 4;\n                if (isdigit(ch))\n                {\n                    decnum += ch - '0';\n                }\n                else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')\n                {\n                    decnum += ch - 'a' + 10;\n                }\n                else\n                {\n                    decnum += ch - 'A' + 10;\n                }\n            }\n            if (isIdentifierChar(fin.peek()) || is0x)//æ··å…¥äº†ä¸æ˜¯16è¿›åˆ¶çš„å…¶å®ƒå­—æ¯\n            {\n                isInvalidHex = 1;\n            }\n            else\n            {\n                token_str = to_string(decnum);\n            }\n        }\n        else if (fin.peek() &gt;= '1' &amp;&amp; fin.peek() &lt;= '7') //OCT\n        {\n            while (fin.peek() &gt;= '0' &amp;&amp; fin.peek() &lt;= '7')\n            {\n                fin.get(ch);\n                token_str += ch;\n                decnum &lt;&lt;= 3;\n                decnum += ch - '0';\n            }\n            if (isIdentifierChar(fin.peek()))         //æ··å…¥äº†8ä»¥ä¸Šçš„æ•°å­—æˆ–å­—æ¯\n            {\n                isInvalidOct = 1;\n            }\n            else\n            {\n                token_str = to_string(decnum);\n            }\n        }\n        else if (isIdentifierChar(fin.peek()))        //invalid oct\n        {\n            isInvalidOct = 1;\n        }\n        else                                        //ZERO\n        {\n            token_str = \"0\";\n        }\n    }\n    else                            //DEC\n    {\n        while (isdigit(fin.peek()))\n        {\n            fin.get(ch);\n            token_str += ch;\n        }\n        if (isIdentifierChar(fin.peek()))    //æ··å…¥äº†å­—æ¯\n        {\n            isInvalidDec = 1;\n        }\n    }\n\n    if (isInvalidHex || isInvalidOct || isInvalidDec) //æ˜¯éæ³•æ•°å­—ï¼Œå°±æŠŠå‰©ä¸‹çš„å­—æ¯æ•°å­—è¯»å®Œ\n    {\n        while (isIdentifierChar(fin.peek()))\n        {\n            fin.get(ch);\n            token_str += ch;\n        }\n        if (isInvalidHex) printf(\"\\033[1;31mInvalid Hex number at Line %d: %s\\033[0m\\n\", lineno, token_str.c_str());\n        if (isInvalidOct) printf(\"\\033[1;31mInvalid Oct number at Line %d: %s\\033[0m\\n\", lineno, token_str.c_str());\n        if (isInvalidDec) printf(\"\\033[1;31mInvalid Dec number at Line %d: %s\\033[0m\\n\", lineno, token_str.c_str());\n        return false;\n    }\n    else                                               //æ˜¯åˆæ³•æ•°å­—ï¼Œæ­£å¸¸è¿”å›\n    {\n        tokens.emplace_back(token_type::NUM, token_str);\n        return true;\n    }\n}\n\nbool Identifier(ifstream &amp;fin)\n{\n    char ch;\n    string st;\n    st = token_str;\n    while (ch = fin.peek(), (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || ch == '_' || ch &gt;= '0' &amp;&amp; ch &lt;= '9')\n    {\n        fin.get(ch);\n        st += ch;\n    }\n\n    if (st == \"int\")\n    {\n        tokens.emplace_back(INT, st);\n    }\n    else if (st == \"void\")\n    {\n        tokens.emplace_back(VOID, st);\n    }\n    else if (st == \"const\")\n    {\n        tokens.emplace_back(CONST, st);\n    }\n    else if (st == \"if\")\n    {\n        tokens.emplace_back(IF, st);\n    }\n    else if (st == \"else\")\n    {\n        tokens.emplace_back(ELSE, st);\n    }\n    else if (st == \"while\")\n    {\n        tokens.emplace_back(WHILE, st);\n    }\n    else if (st == \"break\")\n    {\n        tokens.emplace_back(BREAK, st);\n    }\n    else if (st == \"continue\")\n    {\n        tokens.emplace_back(CONTINUE, st);\n    }\n    else if (st == \"return\")\n    {\n        tokens.emplace_back(RETURN, st);\n    }\n    else\n    {\n        tokens.emplace_back(ID, st);\n    }\n    return 1;\n}\n\nbool Annotation(ifstream &amp;fin)\n{\n    char ch;\n    if (token_str == \"/\")\n    {\n        if (fin.peek() == '/')\n        {\n            while (fin.peek() != EOF)\n            {\n                fin.get(ch);\n                if (ch == '\\n')\n                {\n                    ++lineno;\n                    break;\n                }\n            }\n            if (ch == '\\n' || fin.peek() == EOF) return true;\n            else return false;\n        }\n        else if (fin.peek() == '*')\n        {\n            int lineno2 = lineno;\n            while (fin.peek() != EOF)\n            {\n                fin.get(ch);\n                if (ch == '\\n') ++lineno;\n                if (ch == '*' &amp;&amp; fin.peek() == '/') break;\n            }\n            if (ch == '*' &amp;&amp; fin.peek() == '/')\n            {\n                fin.get(ch);\n                return true;\n            }\n            else\n            {\n                printf(\"\\033[1;31mUnterminated %s comment at line %d.\\033[0m\\n\", \"/*\", lineno2);\n                return false;\n            }\n        }\n        else return false;\n    }\n    else return false;\n}\n\nbool And(ifstream &amp;fin)\n{\n    tokens.emplace_back(AND, \"&amp;&amp;\");\n    if (fin.peek() == '&amp;')\n        return true;\n    else\n    {\n        printf(\"\\033[1;31mInvalid token \\\"&amp;\\\" at Line %d: Do you mean \\\"&amp;&amp;\\\" ?\\033[0m\\n\", lineno);\n        return false;\n    }\n}\n\nbool Or(ifstream &amp;fin)\n{\n    tokens.emplace_back(OR, \"||\");\n    if (fin.peek() == '|')\n        return true;\n    else\n    {\n        printf(\"\\033[1;31mInvalid token \\\"|\\\" at Line %d: Do you mean \\\"||\\\" ?\\033[0m\\n\", lineno);\n        return false;\n    }\n}\n\n#endif //LEXER_H\n\nmain.cppp#include \"lexer.h\"\n\nint main()\n{\n    // read file\n    ifstream fin;\n    fin.open(\"../sample.c\");\n    if (!fin)\n    {\n        cout &lt;&lt; \"File not found\" &lt;&lt; endl;\n        return 0;\n    }\n\n    char ch;\n    while (fin.get(ch))\n    {\n        token_str = move(string(1, ch));\n        switch (ch)\n        {\n            case '\\n':\n                ++lineno;\n                continue;\n            case ' ':\n            case '\\t':\n                continue;\n            case '{':\n                tokens.emplace_back(token_type::LBRACE, \"{\");\n                continue;\n            case '}':\n                tokens.emplace_back(token_type::RBRACE, \"}\");\n                continue;\n            case '(':\n                tokens.emplace_back(token_type::LPARENT, \"(\");\n                continue;\n            case ')':\n                tokens.emplace_back(token_type::RPARENT, \")\");\n                continue;\n            case '[':\n                tokens.emplace_back(token_type::LBRACKET, \"[\");\n                continue;\n            case ']':\n                tokens.emplace_back(token_type::RBRACKET, \"]\");\n                continue;\n            case ';':\n                tokens.emplace_back(token_type::SEMICN, \";\");\n                continue;\n            case ',':\n                tokens.emplace_back(token_type::COMMA, \",\");\n                continue;\n            case '+':\n            case '-':\n                tokens.emplace_back(token_type::PLUSSUB, string(1, ch));\n                continue;\n            case '*':\n            case '%':\n                tokens.emplace_back(token_type::BINOPP, string(1, ch));\n                continue;\n            case '/':\n                if (fin.peek() == '*' || fin.peek() == '/')\n                    Annotation(fin);\n                else\n                    tokens.emplace_back(token_type::BINOPP, string(1, ch));\n                continue;\n            case '!':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"!=\");\n                }\n                else\n                    tokens.emplace_back(token_type::NOT, \"!\");\n                continue;\n            case '&amp;':\n                And(fin);\n                continue;\n            case '|':\n                Or(fin);\n                continue;\n            case '=':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"==\");\n                }\n                else\n                    tokens.emplace_back(token_type::ASSIGN, \"=\");\n                continue;\n            case '&gt;':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"&gt;=\");\n                }\n                else\n                    tokens.emplace_back(token_type::CMP, \"&gt;\");\n                continue;\n            case '&lt;':\n                if (fin.peek() == '=')\n                {\n                    fin.get(ch);\n                    tokens.emplace_back(token_type::CMP, \"&lt;=\");\n                }\n                else\n                    tokens.emplace_back(token_type::CMP, \"&lt;\");\n                continue;\n            default:\n                if (isdigit(ch))\n                    Number(fin);\n                else if (isalpha(ch) || ch == '_')\n                    Identifier(fin);\n                else if (!Annotation(fin))\n                    printf(\"\\033[1;31mUnexpected character \\\"%c\\\" at Line %d.\\033[0m\\n\", ch, lineno);\n        }\n    }\n\n    for (auto &amp;t: tokens)\n        cout &lt;&lt; token_name[t.first] &lt;&lt; \"\\t\\t\" &lt;&lt; t.second &lt;&lt; endl;\n}\n\n\nTips\nfinæ˜¯ä¸€ä¸ªæ–‡ä»¶è¾“å…¥æµï¼Œæˆ‘ä»¬ä»ä¸­è¯»å–éœ€è¦è¯†åˆ«çš„ç¨‹åºä»£ç \n\né¡¶å±‚é€»è¾‘æ˜¯è¯»å–å½“å‰æ–‡ä»¶æŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦chï¼Œæ ¹æ®chç”¨switchåˆ†é…åˆ°å„ä¸ªtokenè¯†åˆ«å­å‡½æ•°ï¼Œç”¨å­å‡½æ•°è¯»å–ä¸€ä¸ªå®Œæ•´çš„tokenï¼ˆä¸€ä¸¤ä¸ªå­—ç¬¦çš„tokenå°±ä¸è®¾ç½®å‡½æ•°äº†ï¼‰\n\nå•ä¸ªå’ŒåŒä¸ªå­—ç¬¦çš„tokenè¯†åˆ«å·²ç»åœ¨é¡¶å±‚ä¸­å®Œæˆï¼Œå³â€™\\nâ€™ã€â€˜\\tâ€™ã€ç©ºæ ¼ã€æ‰€æœ‰æ‹¬å·ã€é€—å·åˆ†å·ã€æ‰€æœ‰è¿ç®—ç¬¦å’Œæ¯”è¾ƒç¬¦ï¼Œå¯ä»¥å‚ç…§è¿™éƒ¨åˆ†ä»£ç  \n\ntokençš„æ•°æ®ç»“æ„æ˜¯ vector&lt;pair&lt;token_type,string&gt;&gt;Â·ï¼Œå…¶ä¸­token_typeæ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œè¡¨ç¤ºè¯¥tokençš„ç±»å‹ï¼›stringåˆ™æ˜¯å­˜å‚¨è¯¥tokençš„å†…å®¹ï¼Œä¸€èˆ¬ä¸ºå…¶å­—é¢å€¼\n\nç”¨tokens.emplace_back(TYPE,Str)æ·»åŠ tokenï¼Œå‚è§switchä¸­çš„è¯­å¥\n\næ¯ä¸ªtokenè¯†åˆ«å‡½æ•°éƒ½ä¼šè¿”å›ä¸€ä¸ªboolÂ·å€¼æ¥è¡¨æ˜è¯¥ç±»å‹çš„tokenæ˜¯å¦è¯†åˆ«æˆåŠŸï¼Œå¦‚æœè¯†åˆ«æˆåŠŸåˆ™è¿”å›trueï¼Œå¹¶éœ€è¦å°†ç›¸åº”çš„token pairæ·»åŠ åˆ°tokensï¼›è‹¥è¯†åˆ«å¤±è´¥åˆ™è¿”å›falseï¼Œå¹¶ç»™å‡ºç›¸åº”çš„é”™è¯¯æç¤º.   \n\né”™è¯¯æç¤ºè§„èŒƒï¼š\n printf(â€œ\\033[1;31mã€Error Typeã€‘ at Line %dï¼šã€infoã€‘\\033[0m\\nâ€,lineno);\n ã€Error Typeã€‘æ˜¯é”™è¯¯ç±»å‹ï¼›ã€infoã€‘æ˜¯é™„åŠ ä¿¡æ¯ï¼Œå¯ä»¥çœç•¥\n\næ³¨æ„å¦‚æœè¯†åˆ«å¤±è´¥ï¼Œå°†æœ‰ä¸¤ç§ç­–ç•¥\n\nå°†æ–‡ä»¶è¯»æŒ‡é’ˆé€€å›å»ï¼šæ¯”å¦‚è¯´åœ¨è¯†åˆ«å…³é”®å­—tokençš„å‡½æ•°Keyword(fin)ä¸­å‘ç°è¿™å…¶å®æ˜¯ä¸€ä¸ªå˜é‡åï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦å°†æ–‡ä»¶æŒ‡é’ˆé€€å›åˆ°è°ƒç”¨å‡½æ•°ä¹‹å‰\nå°†é”™å°±é”™ï¼šå¯¹äºä¸€äº›å¾ˆå¥½ç†è§£çš„é”™è¯¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥å¸®ä»–è¿›è¡Œä¿®å¤ï¼Œæ¯”å¦‚è¯´è¯»å…¥ä¸€ä¸ªâ€™&amp;â€™ç»“æœå‘ç°ä¸‹ä¸€ä¸ªå­—ç¬¦ä¸æ˜¯â€™&amp;â€™ï¼Œå¾ˆæ˜æ˜¾æ˜¯ç”¨æˆ·å°‘æ‰“äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¾ç„¶å¯ä»¥é‡‡å–tokens.emplace_back(AND, \"&amp;&amp;\");ï¼Œå¹¶ç»™å‡ºé”™è¯¯æç¤ºâ€œDo you mean â€œ&amp;&amp;â€ ?â€ï¼ˆAndå’ŒOrå‡½æ•°é‡‡ç”¨çš„å°±æ˜¯è¿™ä¸ªç­–ç•¥ï¼‰\n\n\ntokenè¯†åˆ«å‡½æ•°å¯ä»¥å‚ç…§ bool And(ifstream &amp;fin)å’Œbool Or(ifstream &amp;fin)\n\néœ€è¦åœ¨æœ¬åœ°è¿è¡Œæ—¶ï¼Œåªéœ€åœ¨main.cppåŒç›®å½•ä¸‹åˆ›å»ºsample.cå³å¯\n\næ¯ä¸ªtokenè¯†åˆ«å‡½æ•°çš„å½¢å‚éƒ½æ˜¯æ–‡ä»¶è¾“å…¥æµå˜é‡finçš„å¼•ç”¨ï¼Œä¸»è¦ä½¿ç”¨finçš„ä»¥ä¸‹ä¸‰ä¸ªå‡½æ•°\n\n\n\n\n\nå‡½æ•°\nä½œç”¨\n\n\n\nfin.get(ch)\nè·å–æ–‡ä»¶çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ç»™chï¼Œå¹¶å°†æ–‡ä»¶è¯»æŒ‡é’ˆå¾€ä¸‹ç§»åŠ¨ä¸€ä½\n\n\nch=fin.peek()\nè·å–æ–‡ä»¶çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ç»™chï¼Œä½†ä¸ç§»åŠ¨æ–‡ä»¶è¯»æŒ‡é’ˆï¼ˆpeek v. çª¥è§†ï¼›çª¥è§ï¼‰\n\n\nfin.seekg(-k, ios::cur)\nå°†æ–‡ä»¶è¯»æŒ‡é’ˆå›é€€kä½ï¼Œä¸€èˆ¬ç”¨äºè¯»å…¥ä¸€è¿ä¸²å­—ç¬¦åå‘ç°è¯†åˆ«å¤±è´¥ï¼Œé‚£ä¹ˆéœ€è¦å°†æ–‡ä»¶æŒ‡é’ˆé€€å›å»\n\n\n\nå‡ ä¸ªå…¨å±€å˜é‡åŠå…¶å«ä¹‰\n\n\n\n\nå…¨å±€å˜é‡\nå«ä¹‰\n\n\n\ntoken_name\né€šè¿‡token_name[token_type] å¯ä»¥è·å–token_typeçš„å­—é¢å­—ç¬¦ä¸²ï¼ˆå› ä¸ºæšä¸¾ç±»å‹çš„æœ¬è´¨æ˜¯æ•´æ•°ï¼‰\n\n\nlineno\nå½“å‰æ–‡ä»¶è¯»æŒ‡é’ˆçš„è¡Œæ•°ï¼ŒæŠ¥é”™æ—¶éœ€è¦æ˜¾ç¤º\n\n\ntokens\nå­˜å–æ‰€æœ‰token pairçš„vector\n\n\ntoken_str\nå­˜å–å½“å‰tokençš„å­—ç¬¦ä¸²å€¼ï¼Œä¸€æ–¹é¢æ ¹æ®è¯¥å˜é‡çš„é•¿åº¦å¯ä»¥ç¡®å®šå›é€€ä½æ•°ï¼Œå¦ä¸€æ–¹é¢ä½œä¸ºtokençš„å†…å®¹   âš ï¸è¯»å…¥çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¼šå­˜åœ¨è¿™ä¸ªå˜é‡ä¸­\n\n\n\nå®ç°çš„tokenè¯†åˆ«å‡½æ•°\n\n\n\n\nå‡½æ•°å\nè¯†åˆ«å¯¹è±¡\nå¤‡æ³¨\n\n\n\nNumber\nå…«è¿›åˆ¶ã€åè¿›åˆ¶ã€åå…­è¿›åˆ¶\ntoken.emplace_back(token_type::NUM,è½¬æˆåè¿›åˆ¶æ•°å€¼åçš„å­—ç¬¦ä¸²)éœ€è¦å…·å¤‡è¯†åˆ«éæ³•æ•°å€¼çš„èƒ½åŠ›\n\n\nIdentifier\nå˜é‡å\ntoken.emplace_back(token_type::ID,å˜é‡å)âš ï¸é‡å¤çš„å˜é‡åä¸æ·»åŠ \n\n\nKeyword\nå…³é”®å­—\ntoken.emplace_back(token_type::å…³é”®å­—ç›¸åº”çš„TYPE,å…³é”®å­—å­—ç¬¦ä¸²)\n\n\nAnnotation\næ³¨é‡Š\næ— éœ€ç”Ÿæˆtokenï¼Œä¸¤ç±»æ³¨é‡Šï¼š1.//Â·Â·Â·\\n 2./*Â·Â·Â·*/\n\n\n\n\n\nSample.cint main()\n{\n    int abc = 0123;\n    const 123abc;\n    if(xxx != yyy)\n    {\n        _do_something(); //wow\n    }\n    else if(xxx / yyy == zzz)\n    {\n        _hello_world_123() //haha\n    }\n    else\n    {\n        HAhaHa0000__ = 3;\n    }\n    void hello0 =0world;\n    while(1)\n    {\n        i = i-1;\n        if(0+1==2)    break;\n        else        continue;\n    }\n    /*\n        qwertyuiop;\n        HAHAHAHAH;\n        aaaaaaaaaaaaaaaaaa;\n        return 0;\n    */\n    intvoidconstbreakwhilecontinueifelse;\n    return 0xff; /**/\n}\n/*\n * sdadsdda/*/","slug":"Lexerï¼ˆVer-Handï¼‰","date":"2022-05-29T16:39:19.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"èµ°ç è§‚èŠ±,Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"27d8ddbd7db795b00aa745f14f40ef75","title":"Apply ANN in MNIST","content":"çœ‹å®Œäº†3Blue1Brownçš„ç¥ç»ç½‘ç»œä¸‰éƒ¨æ›²ï¼Œæ„Ÿè§‰çœ¼ç›æ˜äº®äº†ï¼Œå†…å¿ƒæ›´é€šé€äº†ï¼Œæ‰‹æŒ‡æ§åˆ¶ä¸ä½åœ°å°±å¼€å§‹è·³åŠ¨ã€‚\næ¥ä¸‹æ¥è¯·æ¬£èµå¯¿å¸ç¥ç»ç½‘ç»œâ€”â€”æ‰‹å†™æ•°å­—é›†MNISTç™»åœºï¼\nimport numpy as np\nimport pandas as pd\nimport joblib as jb\n\n\næ¿€æ´»å‡½æ•°åŠå¯¼æ•°å®šä¹‰def Activater(x,option='sigmoid'):\n    if option=='relu':\n        return np.maximum(0,x)\n    elif option=='sigmoid':\n        return 1/(1+np.exp(-x))\n    else:\n        print(\"WRONG TYPE!!!\")\n        exit(0)\n\n\n\ndef Derivative(x,option='sigmoid'):\n    if option=='relu':\n        x[x&gt;0] = 1\n        x[x&lt;=0] = 0\n        return x\n    elif option=='sigmoid':\n        return np.exp(-x)/((1+np.exp(-x))**2)\n    else:\n        print(\"WRONG TYPE!!!\")\n        exit(0)\n\n\n\nå‰å‘ä¼ æ’­def forward_propagation(X, W, b, option='sigmoid'):\n    Z = []\n    A = [X]\n    for i in range(len(W)):\n        Z.append(np.dot(W[i], A[i]) + b[i])\n        A.append(Activater(Z[i],option))\n    return Z, A\n\n\nåå‘ä¼ æ’­def backward_propagation(Y, Z, A, W, b, option='sigmoid'):\n    dZ = [[] for i in range(len(Z))]\n    dW = [np.zeros(W[i].shape) for i in range(len(W))]\n    db = [[] for i in range(len(b))]\n    dA = [[] for i in range(len(A)-1)]\n    dA[-1] = 2*(A[-1] - Y)\n    for i in range(len(W) - 1, -1, -1):\n        dZ[i] = dA[i] * Derivative(Z[i],option)\n        for j in range(dZ[i].shape[1]):\n            dW[i] += dZ[i][:,j:(j+1)].dot(A[i][:,j:(j+1)].T)\n        dW[i] /= dZ[i].shape[1]\n        db[i] = np.sum(dZ[i], axis=1, keepdims=True) / dZ[i].shape[1]\n        if i&gt;0:\n            dA[i-1] = np.dot(W[i].T, dZ[i])\n    return dW, db\n\nè¯¯å·®å‡½æ•°\nåå‘ä¼ æ’­é“¾å¼æ³•åˆ™\n\n\n\ndef update_parameters(W, b, dW, db, learning_rate=1e-3):\n    W = [W[i] - learning_rate * dW[i] for i in range(len(W))]\n    b = [b[i] - learning_rate * db[i] for i in range(len(b))]\n    return W, b\n\ndef Train(X, Y, W, b, epochs=300, option='sigmoid'):\n    print(\"Training...\")\n    sum_10epoches=0\n    for i in range(epochs):\n        sum=0\n        for j in range(len(X)):\n            Z, A = forward_propagation(X[j], W, b, option)\n            sum += np.sum(np.square(A[-1]-Y[j]))\n            dW, db = backward_propagation(Y[j], Z, A, W, b, option)\n            W, b = update_parameters(W, b, dW, db)\n\n        sum_10epoches += sum/len(X)\n        if (i+1) % 10 == 0:\n            print(\"Epoch %d DONE , average loss: %f\"%((i+1), sum_10epoches/10))\n            sum_10epoches = 0\n            # save outcome\n            jb.dump(W, 'weight.pkl')\n            jb.dump(b, 'b.pkl')\n\n    return W, b\n\n\né¢„æµ‹å‡½æ•°def predict(X, W, b, option='sigmoid'):\n    Z, A = forward_propagation(X, W, b, option)\n    return [np.argmax(A[-1][:,i]) for i in range(A[-1].shape[1])]\n\næŒ‡å®šæ¯å±‚ç¥ç»å…ƒä¸ªæ•°ï¼Œå¹¶åˆå§‹åŒ–æƒé‡Wå’Œbias# intialize W &amp; b\nlayers_dims = [784,100,16,10]\nW=[]\nb=[]\n# He initialization\nfor i in range(1,len(layers_dims)):\n    W.append(np.random.randn(layers_dims[i], layers_dims[i - 1]) * np.sqrt(2 / layers_dims[i - 1]))\n    b.append(np.zeros((layers_dims[i], 1)))\n\nTrainï¼# Train\ndata=pd.read_csv(\"../input/ml2021-2022-2-nn/train.csv\")\ntrain=np.array(data.iloc[:,1:]) / 255\nlabel=data.iloc[:,0]\nbatches=[]\nbatch_size=10\nvals=[]\nfor i in range(0,int(data.shape[0]/batch_size)):\n    batches.append(train[i*batch_size:(i+1)*batch_size].T)\n    vals.append(np.zeros((layers_dims[-1],batch_size)))\n    for j in range(batch_size):\n        vals[i][label[i*batch_size+j],j]=1\n\nW,b=Train(batches,vals,W,b)\n\nTraining...\nEpoch 10 DONE , average loss: 9.178379\nEpoch 20 DONE , average loss: 8.475545\nEpoch 30 DONE , average loss: 7.614375\nEpoch 40 DONE , average loss: 6.724141\nEpoch 50 DONE , average loss: 5.594986\nEpoch 60 DONE , average loss: 4.538067\nEpoch 70 DONE , average loss: 3.720301\nEpoch 80 DONE , average loss: 3.125564\nEpoch 90 DONE , average loss: 2.718955\nEpoch 100 DONE , average loss: 2.435576\nEpoch 110 DONE , average loss: 2.230198\nEpoch 120 DONE , average loss: 2.075574\nEpoch 130 DONE , average loss: 1.954850\nEpoch 140 DONE , average loss: 1.857425\nEpoch 150 DONE , average loss: 1.776534\nEpoch 160 DONE , average loss: 1.707753\nEpoch 170 DONE , average loss: 1.648106\nEpoch 180 DONE , average loss: 1.595520\nEpoch 190 DONE , average loss: 1.548511\nEpoch 200 DONE , average loss: 1.505992\nEpoch 210 DONE , average loss: 1.467156\nEpoch 220 DONE , average loss: 1.431390\nEpoch 230 DONE , average loss: 1.398221\nEpoch 240 DONE , average loss: 1.367273\nEpoch 250 DONE , average loss: 1.338241\nEpoch 260 DONE , average loss: 1.310877\nEpoch 270 DONE , average loss: 1.284973\nEpoch 280 DONE , average loss: 1.260356\nEpoch 290 DONE , average loss: 1.236881\nEpoch 300 DONE , average loss: 1.214426\n\nPredict !!# predict\ntest=np.array(pd.read_csv(\"../input/ml2021-2022-2-nn/test.csv\")).T / 255\npre_otc=predict(test,W,b,'sigmoid')\nsub=np.array([range(test.shape[1]),pre_otc]).T\nsub=pd.DataFrame(sub,columns=['id','label'])\nsub.to_csv('submission.csv',index=False, header=True)\n","slug":"Apply-ANN-in-MNIST","date":"2022-05-20T03:44:06.000Z","categories_index":"Machine Learning","tags_index":"python,èµ°ç è§‚èŠ±,ANN","author_index":"Starlit Rover"},{"id":"0ec694a906049225d6d529b78f724448","title":"<10> NO Left Recursion","content":"æœ¬æ–‡ä»‹ç»æ¶ˆé™¤æ–‡æ³•å·¦é€’å½’çš„ç®—æ³•ï¼Œå¹¶è¾“å‡ºæ–°æ–‡æ³•äº§ç”Ÿå¼ã€‚\n\n\n\n\n\n\n\næ¶ˆé™¤å·¦é€’å½’åœ¨è¯­æ³•åˆ†æé˜¶æ®µæ˜¯æ¯”è¾ƒé‡è¦çš„ä¸€ä¸ªè¿‡ç¨‹ï¼Œå°¤å…¶åœ¨è‡ªé¡¶å‘ä¸‹çš„åˆ†æè¿‡ç¨‹ä¸­ï¼Œç¼–è¯‘å™¨ä¼šå°è¯•å„ä¸ªæ¨å¯¼å¼ï¼Œå¦‚æœå­˜åœ¨å·¦é€’å½’ï¼Œé‚£ä¹ˆæ¨å¯¼è¿‡ç¨‹å°†ä¼šç”¨æ°¸æ— æ­¢å¢ƒã€‚\næ¯”è¾ƒæ˜¾å¼çš„å·¦é€’å½’æˆ‘ä»¬ç§°ä¹‹ä¸ºç›´æ¥å·¦é€’å½’ï¼Œæ¯”å¦‚è¯´\n\nå…¶ä¸­è¡¨ç¤ºéç©ºçš„è¡¨è¾¾å¼ï¼Œè¡¨ç¤ºä¸ä»¥éç»ˆç»“ç¬¦Aå¼€å¤´çš„è¡¨è¾¾å¼ã€‚\né‚£ä¹ˆæˆ‘ä»¬çŸ¥é“å¯¹äºéç»ˆç»“ç¬¦Aæ¥è¯´ï¼Œæœ€ç»ˆåªèƒ½ä»¥åˆ°æ¥ç»“æŸï¼Œå¦åˆ™ä¾ç„¶ä¼šå«æœ‰éç»ˆç»“ç¬¦Aï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†æ–‡æ³•ç›´æ¥æ”¹ä¸º\n\nç„¶è€Œå¹¶éæ‰€æœ‰çš„å·¦é€’å½’éƒ½è¿™ä¹ˆæ˜¾è€Œæ˜“è§ï¼Œè¿˜æ˜¯ä¼šå­˜åœ¨å¾ˆå¤šé—´æ¥å·¦é€’å½’\n\né‚£ä¹ˆæˆ‘ä»¬å°±éœ€è¦ä¸€ä¸ªé€šç”¨çš„ç®—æ³•æ¥æ¶ˆé™¤æ‰€æœ‰çš„ç›´æ¥å·¦é€’å½’å’Œé—´æ¥å·¦é€’å½’ã€‚\n\nâ«¸ Algorithmç®—æ³•ä¹Ÿä¸éš¾ç†è§£ï¼Œå¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š\n\nå°†æ‰€æœ‰éç»ˆç»“ç¬¦å…ˆè¿›è¡Œæ•´ç†ç¼–å·ï¼Œå³æ‰€æœ‰éç»ˆç»“ç¬¦è½¬æ¢ä¸º\n\n\nå¯¹æ¯ä¸€ä¸ªï¼Œæˆ‘ä»¬å°†å…¶æ‰€æœ‰æ»¡è¶³çš„äº§ç”Ÿå¼æ›¿æ¢ä¸ºï¼Œå…¶ä¸­\n\nä»å¼€å§‹è‡³ï¼Œä¾æ¬¡æ‰§è¡Œæ­¥éª¤2ï¼Œæ¯å®Œæˆä¸€ä¸ªçš„æ›¿æ¢å°±æ¶ˆé™¤å½“å‰è¯¥çš„æ‰€æœ‰ç›´æ¥å·¦é€’å½’\n\n\nè¯¥ç®—æ³•çš„ä¼ªä»£ç å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š\n\n\næˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ï¼Œæ¯ä¸€ä¸ªå®Œæˆæ›¿æ¢åï¼Œé‚£ä¹ˆæ‰€æœ‰äº§ç”Ÿå¼å³è¾¹çš„ç¬¬ä¸€ä¸ªç¬¦å·è¦ä¹ˆæ˜¯ç»ˆç»“ç¬¦ï¼Œè¦ä¹ˆæ˜¯ç¼–å·çš„éç»ˆç»“ç¬¦ï¼Œåœ¨æ¶ˆé™¤æ­¤æ—¶äº§ç”Ÿå¼ä¸­çš„ç›´æ¥å·¦é€’å½’åï¼Œå°±åªå‰©ä¸‹ç»ˆç»“ç¬¦å’Œç¼–å·éç»ˆç»“ç¬¦æ‰“å¤´çš„å³éƒ¨äº†ã€‚è¿™æ ·ä¸€æ¥ï¼Œæœ€ç»ˆçš„æ–‡æ³•ä¸€æ–¹é¢ä¸å¯èƒ½æœ‰ç›´æ¥å·¦é€’å½’ï¼Œå¦ä¸€æ–¹é¢ä¸å¯èƒ½æœ‰é—´æ¥å·¦é€’å½’ï¼ˆå› ä¸ºåªèƒ½å°ç¼–å·çš„éç»ˆç»“ç¬¦æ¨å‡ºå¤§ç¼–å·çš„éç»ˆç»“ç¬¦ï¼‰ã€‚\n\nC â˜º D Efrom copy import deepcopy\n\nn = eval(input('è¯·è¾“å…¥æ–‡æ³•äº§ç”Ÿå¼çš„ä¸ªæ•°ï¼š'))\nprint('è¯·è¾“å…¥æ–‡æ³•äº§ç”Ÿå¼ï¼š')\ngen = dict()\nleft = dict()\nnum = 0\nfor i in range(n):\n    g = input().replace(' ', '')\n    assert g[1:3] == '-&gt;'\n    gen.setdefault(g[0], [[], []])\n    left[g[0]] = num\n    num += 1\n    start = 3\n    for i in range(3, len(g)):\n        if g[i] == '|' or i == len(g) - 1:\n            i += (1 if i == len(g) - 1 else 0)\n            assert start &lt; i\n            if g[0].isupper():\n                gen[g[0]][0].append(g[start:i])\n            elif g[0].islower():\n                gen[g[0]][1].append(g[start:i])\n            start = i + 1\n\n# å°†æ²¡æœ‰å‡ºç°åœ¨äº§ç”Ÿå¼å·¦éƒ¨çš„éç»ˆç»“ç¬¦å½“ä½œç»ˆç»“ç¬¦\nfor key in gen:\n    nonterminal = deepcopy(gen[key][0])\n    for item in nonterminal:\n        if item[0] not in left.keys():\n            gen[key][0].remove(item)\n            gen[key][1].append(item)\n    assert gen[key][1] != []\n\n# æ›¿æ¢Ai-&gt;AjÎ² (j&lt;i)\nmore_gen = dict()\nfor key in gen:\n    rmv = []\n    for item in gen[key][0]:\n        if left[item[0]] &lt; left[key]:\n            rmv.append(item)\n            for k in gen[item[0]][1]:\n                gen[key][1].append(k + item[1:])\n            for k in gen[item[0]][0]:\n                gen[key][0].append(k + item[1:])\n    for r in rmv:\n        gen[key][0].remove(r)\n\n   # æ¶ˆé™¤ç›´æ¥å·¦é€’å½’\n    nonterminal = deepcopy(gen[key][0])\n    flag = True\n    terminal = deepcopy(gen[key][1])\n    for item in nonterminal:\n        if item[0] == key:\n            sym = '[' + key + '\\']'\n            more_gen.setdefault(sym, []).extend([item[1:], (item[1:]) + sym])\n            if flag:\n                for k in terminal:\n                    gen[key][1].append(k + sym)\n            gen[key][0].remove(item)\n            flag = False\n\nfor key in gen:\n    gen[key][0].extend(gen[key][1])\n    gen[key] = gen[key][0]\ngen.update(more_gen)\n\nprint(\"\\nAfter Remove Left Recursion:\")\nfor key in gen:\n    print(key + ' -&gt; ', end='')\n    print(*gen[key], sep=' | ')\n\nâ· Tips\nè¯»å…¥è¾“å…¥æ—¶å…ˆé™¤å»æ‰€æœ‰ç©ºæ ¼ï¼Œå¹¶è§„å®šç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦ä»…èƒ½ä¸ºå•ä¸ªå­—æ¯ï¼Œå°å†™å­—æ¯ä»£è¡¨ç»ˆç»“ç¬¦ï¼Œå¤§å†™å­—æ¯ä»£è¡¨éç»ˆç»“ç¬¦\n\næ‰€æœ‰äº§ç”Ÿå¼ç”¨ä¸€ä¸ªå­—å…¸å­˜å‚¨ï¼Œæ¯ä¸ªäº§ç”Ÿå¼å·¦è¾¹çš„éç»ˆç»“ç¬¦ä½œä¸ºé”®å€¼ï¼Œæ¯ä¸ªé”®å€¼å¯¹åº”ä¸€ä¸ªåˆ—è¡¨ï¼Œåˆ—è¡¨é‡Œæœ‰ä¸¤ä¸ªå­åˆ—è¡¨ï¼ˆè§3ï¼‰\n\nå¯¹æ¯ä¸€ä¸ªäº§ç”Ÿå¼çš„å³éƒ¨è¿›è¡Œåˆ†ç±»ï¼Œéç»ˆç»“ç¬¦æ‰“å¤´çš„ä¸€ç±»ï¼Œç»ˆç»“ç¬¦æ‰“å¤´çš„ä¸€ç±»\n\nè¿™é‡Œå°†æ²¡æœ‰å‡ºç°åœ¨äº§ç”Ÿå¼å·¦éƒ¨çš„éç»ˆç»“ç¬¦å½“ä½œç»ˆç»“ç¬¦ï¼Œä»è€Œæ— éœ€å¯¹è¿™äº›éç»ˆç»“ç¬¦è¿›è¡Œç¼–å·\nâš ï¸ Pythonä¸­å¯è¿­ä»£å¯¹è±¡çš„ç›´æ¥èµ‹å€¼æ˜¯å¼•ç”¨ï¼Œå¤åˆ¶èµ‹å€¼åˆ™éœ€è¦deepcopy()\n\n\n\nOutcome\n","slug":"10-NO-Left-Recursion","date":"2022-05-17T07:58:36.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"python,èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"876685c2961fc61a4c5638eee32e520e","title":"<01> NFA2DFA","content":"æœ¬æ–‡å€ŸåŠ©Graphvizåº“å®ç°äº†NFAè½¬DFAï¼Œå¹¶è¾“å‡ºDFAçš„çŠ¶æ€è½¬ç§»å›¾ã€‚\n\n\n\n\n\n\n\nâˆ… Graphvizåº“ä»‹ç»ä½ ä¸€å®šå¾ˆç–‘æƒ‘æˆ‘æ˜¨å¤©åˆšä»‹ç»å®ŒTransitionsåº“ä»Šå¤©æ€ä¹ˆå°±å°±æ¢äº†ä¸€ä¸ªç»˜åˆ¶åº“ã€‚ummmâ€¦Transitionsåº“å…¶å®æ›´æ³¨é‡äºçŠ¶æ€æœºæœ¬èº«çš„å®ç°ï¼Œå½“ä½ æƒ³ç”¨çŠ¶æ€æœºæ¥å®ç°æŸäº›åŠŸèƒ½æ—¶ï¼ŒTransitionsåº“æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ï¼Œè€Œç»˜åˆ¶çŠ¶æ€è½¬ç§»å›¾åªæ˜¯å…¶ä¸­çš„ä¸€ä¸ªå­åŠŸèƒ½ï¼Œæ›´é‡è¦çš„æ˜¯æ— æ³•ï¼ˆæˆ‘ä¸çŸ¥é“å¯ä¸å¯ä»¥ï¼‰æ˜¾ç¤ºå¤šä¸ªæ¥æ”¶çŠ¶æ€ï¼ˆGraphMachineä¸­çš„initialé€‰é¡¹åªèƒ½æŒ‡å®šä¸€ä¸ªèŠ‚ç‚¹ï¼‰ã€‚è¿½æ ¹æº¯æºï¼Œæˆ‘ä»¬ä¸éš¾å‘ç°Transitionsåº“å…¶å®æ˜¯ç”¨Graphvizåº“æ¥ç»˜åˆ¶çŠ¶æ€è½¬ç§»å›¾çš„ï¼Œé‚£æˆ‘ä»¬ä¸ºä½•ä¸ç›´æ¥ç”¨å®ƒæ¥ç»˜åˆ¶å‘¢ï¼Ÿ\nè¿˜æ˜¯ç›´æ¥ç”¨ä¸€ä¸ªç®€å•ç›´è§‚çš„æ —å­æ¥è¯´æ˜ï¼Œ\nfrom graphviz import Digraph\n\n# Graph()--Undirected Graph ; Digraph()--Directed Graph\n# engine: choose layout patterns\nDot = Digraph(engine='circo')\n# add nodes: you can specify color and shape of nodes\nDot.node('A')\nDot.node('B', style='filled', fillcolor='red', shape='circle')\nDot.node('C', style='filled', fillcolor='green', shape='rectangle')\n# add single edge: (source,destination,label)\nDot.edge('A', 'B', 'Hello')\nDot.edge('B', 'A', 'Hola')\nDot.edge('C', 'B', 'Bye')\n# add edges\nDot.edges(['AC', 'BC'])\n# specify save format\nDot.format = 'png'\n# save output\nDot.render('First Demo', view=True)\n\nè¾“å‡ºé™¤äº†æœ‰ç‚¹uglyæœ‰ç‚¹é‡åˆå¤–å…¶å®ä¹Ÿè¿˜å¥½ï¼Œè‡³å°‘å¯ä»¥è‡ªå·±æŒ‡å®šé¢œè‰²å’Œå½¢çŠ¶ï¼š\n\nåˆå§‹åŒ–çš„æ—¶å€™å¯ä»¥æŒ‡å®šæ¸²æŸ“å¼•æ“ï¼Œå¸¸è§çš„æ¸²æŸ“å¼•æ“æœ‰\n\nDotï¼šé»˜è®¤å¼•æ“ï¼Œä¸»è¦ç”¨äºæœ‰å‘å›¾ã€‚å¸ƒå±€ç®—æ³•å°†è¾¹ç¼˜æŒ‡å‘ç›¸åŒæ–¹å‘ï¼ˆä»ä¸Šåˆ°ä¸‹æˆ–ä»å·¦åˆ°å³ï¼‰ï¼Œç„¶åå°è¯•é¿å…è¾¹ç¼˜äº¤å‰å¹¶å‡å°‘è¾¹é•¿ã€‚\nNeatoï¼šè¿™æ˜¯ä¸€ç§â€œå¼¹ç°§æ¨¡å‹â€çš„å¸ƒå±€ï¼ŒåŸºäºspring-modelï¼ˆnamely force-basedï¼‰ç®—æ³•ï¼Œè¾“å‡ºç¼ºä¹æ–¹å‘æ€§ã€‚\nFdpï¼šè¿™æ˜¯ä¸€ç§ç±»ä¼¼äºneatoçš„å¸ƒå±€ï¼Œæ˜¯é€šè¿‡å‡å°‘åŠ›è€Œä¸æ˜¯ä½¿ç”¨èƒ½é‡æ¥å®ç°çš„ï¼Œå¤šç”¨äºæ— å‘å›¾ã€‚\nSfdpï¼šæ¸²æŸ“å¤§å‹å›¾ï¼Œç¼ºä¹æ–¹å‘æ€§ã€‚\nTwopiï¼šæ”¾å°„æ€§å¸ƒå±€ï¼ŒèŠ‚ç‚¹æ ¹æ®å®ƒä»¬ä¸ç»™å®šæ ¹èŠ‚ç‚¹çš„è·ç¦»æ”¾ç½®åœ¨åŒå¿ƒåœ†ä¸Šã€‚\nCircoï¼šé€‚åˆç»˜åˆ¶æŸäº›å¤šå¾ªç¯ç»“æ„çš„å›¾è¡¨ï¼Œä¾‹å¦‚æŸäº›ç”µä¿¡ç½‘ç»œã€‚\n\næœ‰å…´è¶£è¿›ä¸€æ­¥äº†è§£å¯ä»¥å‚é˜…å®˜æ–¹æ–‡æ¡£ã€‚\n\nâ„µ NFA 2 DFADFAå…·æœ‰ç¡®å®šæ€§ï¼Œæ— Îµè¾¹ï¼Œæ‰€æœ‰çŠ¶æ€å¯¹äºæ¯ä¸€ä¸ªè¾“å…¥å­—ç¬¦éƒ½æœ‰å”¯ä¸€çš„è·³è½¬æ–¹å‘ã€‚æ˜¾ç„¶ï¼ŒDFAçš„æ¯ä¸€ä¸ªçŠ¶æ€éƒ½æ˜¯è‹¥å¹²ä¸ªNFAçŠ¶æ€çš„é›†åˆã€‚\nåŸºæœ¬ç®—æ³•æ€æƒ³å¦‚ä¸‹ï¼š\n\nå…ˆæ±‚å‡ºNFAä¸­æ¯ä¸€ä¸ªçŠ¶æ€çš„ï¼ˆå¯ä»¥é€šè¿‡Îµè¾¹åˆ°è¾¾çš„çŠ¶æ€é›†ï¼ŒåŒ…æ‹¬è‡ªå·±ï¼‰å¹¶ç¡®å®šè¾“å…¥å­—ç¬¦é›†ï¼ˆå¯èƒ½å‡ºç°çš„å­—ç¬¦ï¼‰ï¼›\n\nå°†å¼€å§‹çŠ¶æ€çš„æ”¾å…¥å¾…æ›´æ–°çŠ¶æ€é›†å’Œå†å²çŠ¶æ€é›†ï¼›\n\nä»å¾…æ›´æ–°çŠ¶æ€é›†é‡Œå–å‡ºä¸€ä¸ªçŠ¶æ€ï¼Œè®¡ç®—è¯»å…¥æ¯ä¸€ä¸ªå­—ç¬¦ï¼ˆï¼‰æ—¶è·³è½¬åˆ°çš„ç›®çš„çŠ¶æ€\n\nå…¶ä¸­è¡¨ç¤ºNFAä¸­çŠ¶æ€è¯»å…¥å­—ç¬¦åè·³è½¬åˆ°çš„çŠ¶æ€ï¼›\n\nè‹¥ç›®çš„çŠ¶æ€æœªå‡ºç°åœ¨å†å²çŠ¶æ€ä¸­ï¼Œé‚£ä¹ˆå°†å…¶åŠ å…¥å¾…æ›´æ–°çŠ¶æ€åˆ—è¡¨ï¼ŒåŒæ—¶åŠ å…¥å†å²çŠ¶æ€é›†ã€‚æ¯æ¬¡éƒ½ä»å¾…æ›´æ–°çŠ¶æ€é›†ä¸­å–å‡ºä¸€ä¸ªçŠ¶æ€é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´è‡³å¾…æ›´æ–°çŠ¶æ€é›†ä¸ºç©ºã€‚\n\n\n\n\nå¯ä»¥å‚é˜…è¿™ä¸€ä¸ªä¾‹å­ï¼šConverting an NFA to a DFA - Example\n\nCâ˜ºDEfrom graphviz import Digraph\n\nnum = eval(input('è¯·è¾“å…¥çŠ¶æ€è½¬ç§»å‡½æ•°çš„ä¸ªæ•°ï¼š'))\nstart = input('è¯·è¾“å…¥åˆå§‹çŠ¶æ€åºå·ï¼š')\n# end is a list\nend = set(input('è¯·è¾“å…¥æ‰€æœ‰æ¥æ”¶çŠ¶æ€åºå·ï¼š').split())\nsymbols = set()\n# transfer[sym][source]=dest â‡” (source)--sym--&gt;(dest)\ntransfer = dict()\nclosure = dict()\nprint('è¯·ä¾æ¬¡è¾“å…¥ã€triggerã€‘ã€sourceã€‘ã€destinationã€‘:')\nfor i in range(num):\n    a, b, c = input().split()\n    closure.setdefault(b, {b})\n    closure.setdefault(c, {c})  # é˜²æ­¢ç»ˆç»“èŠ‚ç‚¹æ²¡æœ‰å…¥åº¦\n    # '#' is equivalent with 'Îµ'\n    if a != '#':\n        symbols.add(a)\n        transfer.setdefault(a, dict()).setdefault(b, {c}).add(c)\n    else:\n        closure[b].add(c)\n\n# ä¸Šè¿°ä»£ç å¾—åˆ°çš„closureåªæ˜¯é‚»æ¥ÎµèŠ‚ç‚¹ï¼Œè¿˜éœ€è¦è¿­ä»£è®¡ç®—çœŸæ­£çš„Îµ-closure\nfor state in closure:\n    upd = closure[state]\n    # updæ˜¯æ¯ä¸€è½®æ–°å¢èŠ‚ç‚¹çš„é›†åˆ\n    # å½“updä¸ä¸ºç©ºæ—¶éœ€è¦ç»§ç»­è¿­ä»£æ›´æ–°\n    while upd:\n        closure[state] |= upd\n        nxt = set()\n        for n in upd:\n            nxt |= closure[n]\n        upd = nxt - closure[state]\n\n# å†å²çŠ¶æ€é›†\nDFA_states = [closure[start]]\n# å¾…æ›´æ–°çŠ¶æ€é›†\nto_update = [closure[start]]\ntransitions = []\nwhile to_update:\n    status = to_update.pop()\n    # statusçš„çŠ¶æ€è½¬ç§»åˆ—è¡¨\n    single_trans = []\n    for sym in symbols:\n        new = set()\n        tmp = set()\n        for s in status:\n            tmp |= transfer[sym].setdefault(s, set())\n        for s in tmp:\n            new |= closure[s]\n        if new not in DFA_states:\n            to_update.append(new)\n            DFA_states.append(new)\n        # å°†å…·æœ‰ç›¸åŒsourceå’Œdestçš„æœ‰å‘è¾¹labelè¿›è¡Œåˆå¹¶\n        flag = True\n        for t in single_trans:\n            if t[2] == str(new):\n                t[0] = t[0] + '|' + sym\n                flag = False\n                break\n        if flag:\n            single_trans.append([sym, str(status), str(new)])\n\n    transitions.extend(single_trans)\n\nDFA = Digraph(engine='dot')\nDFA.edge('start', str(DFA_states[0]))\nfor n in DFA_states:\n    if n &amp; end:\n        DFA.node(str(n), style='filled', fillcolor='green', shape='rectangle')\n    else:\n        DFA.node(str(n), shape='rectangle')\nfor t in transitions:\n    DFA.edge(t[1], t[2], label=t[0])\nDFA.format = 'png'\nDFA.render('DFA', view=True)\n\n\nâ‰¯ INPUTæˆ‘ä»¬å°±ç”¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æœ€åçš„DEMOæ¥ä½œä¸ºè¾“å…¥ï¼Œå…¶ä¸­ã€#ã€‘ä»£è¡¨Îµï¼š\nè¯·è¾“å…¥çŠ¶æ€è½¬ç§»å‡½æ•°çš„ä¸ªæ•°ï¼š23\nè¯·è¾“å…¥åˆå§‹çŠ¶æ€åºå·ï¼š6\nè¯·è¾“å…¥æ‰€æœ‰æ¥æ”¶çŠ¶æ€åºå·ï¼š17\nè¯·ä¾æ¬¡è¾“å…¥ã€triggerã€‘ã€sourceã€‘ã€destinationã€‘:\na 0 1\na 2 3\n# 1 2\nb 4 5\n# 6 4\n# 6 0\n# 5 7\n# 3 7\n# 6 7\n# 7 6\na 8 9\n# 7 8\na 10 11\nb 12 13\nb 14 15\n# 13 14\n# 16 12\n# 16 10\n# 15 17\n# 11 17\n# 16 17\n# 17 16\n# 9 16\n\n\n\n\n\nâ‰® OUTPUT\n\nä¸Šå›¾ä¸­çš„set()å…¶å®æ˜¯ç©ºé›†ï¼Œå¯ä»¥çœ‹åˆ°ä¸€æ—¦åˆ°è¾¾ç©ºé›†çŠ¶æ€å°±æ— æ³•å†å‡ºå»ï¼Œä»¥è‡³äºæ°¸è¿œæ— æ³•è¢«æ¥æ”¶ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿç§°ä¹‹ä¸ºé™·é˜±ï¼ˆtrapï¼‰ã€‚å¦å¤–æ¥æ”¶çŠ¶æ€å…¨éƒ¨ç”¨ç»¿è‰²æ ‡æ³¨å‡ºæ¥äº†ï¼Œéå¸¸æ¸…æ™°æ˜äº†ã€‚\n\nã€ŒReferenceã€\n[1] Graphvizå…¥é—¨ï¼Œhttps://www.cnblogs.com/born2run/p/9581386.html\n[2] æ¢ç´¢Graphvizï¼Œhttps://zhuanlan.zhihu.com/p/81853828\n\n","slug":"01-NFA2DFA","date":"2022-05-11T03:07:43.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"python,èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"6fcdc9dd323137269ea9dcabb8b1efc8","title":"<00> REG2NFA","content":"æœ¬æ–‡å€ŸåŠ©transitionsåº“åŸºäºé€†æ³¢å…°è¡¨ç¤ºæ³•ï¼ˆReverse Polish Notationï¼ŒRPNï¼‰å®ç°äº†æ­£åˆ™è¡¨è¾¾å¼è½¬NFAï¼Œå¹¶ç”»å‡ºç›¸å…³çš„çŠ¶æ€è½¬ç§»å›¾ã€‚\n\n\n\n\n\n\n\nâˆ… Transitionsåº“ä»‹ç»å¼•ç”¨å®˜ç½‘ä¸­çš„ä¸€å¥è¯â€œThey say a good example is worth 100 pages of API documentation, a million directives, or a thousand words.â€\nHere is an example:\nfrom transitions.extensions import GraphMachine\n\n# The states\nstates = ['solid', 'liquid', 'gas', 'plasma']\n\n# The transitions\ntransitions = [\n                {'trigger': 'melt', 'source': 'solid', 'dest': 'liquid'},\n                ['evaporate', 'liquid', 'gas'],\n                ['sublimate', 'solid', 'gas']\n              ]\n\n# Initialize\nmachine = GraphMachine(states=states, transitions=transitions, initial='liquid', title='my STD')\nmachine.add_transition('ionize', 'gas', 'plasma')\nmachine.get_graph().draw('my_state_diagram.png', prog='dot')\n\nHere is the output:\n\n\nä¸Šé¢çš„æ —å­åŸºæœ¬åŒ…å«äº†æœ¬æ–‡æ‰€ç”¨åˆ°çš„æ‰€æœ‰æ“ä½œï¼Œå¦å¤–è¯´æ˜å‡ ç‚¹ï¼š\n\ntransitionsåˆ—è¡¨ä¸­æ—¢å¯ä»¥æ˜¯å­—å…¸ï¼Œä¹Ÿå¯ä»¥æ˜¯åˆ—è¡¨ï¼Œç”šè‡³æ˜¯ä¸¤è€…çš„ç»“åˆï¼Œä½†éƒ½éœ€è¦æŒ‰ç…§[trigger , source , destination]çš„é¡ºåºå†™\nadd_transition()å‡½æ•°å¢åŠ è½¬ç§»å‡½æ•°ï¼Œè¾“å…¥å‚æ•°ä¹Ÿéœ€è¦æŒ‰ç…§ä¸Šè¿°é¡ºåº\nGraphMachineå‡½æ•°ä¸­çš„initialå‚æ•°æŒ‡å®šåˆå§‹çŠ¶æ€ï¼Œå¹¶æ ‡æ³¨ä¸ºä¸åŒçš„é¢œè‰²ï¼Œç„¶è€Œæˆ‘ä»¬åœ¨ç”»çŠ¶æ€è½¬ç§»å›¾æ—¶æ ‡æ³¨çš„å¾€å¾€ä¸æ˜¯åˆå§‹çŠ¶æ€è€Œæ˜¯æ¥æ”¶çŠ¶æ€ï¼Œå› æ­¤æˆ‘ä¸€èˆ¬å°†initialå‚æ•°èµ‹ä¸ºæ¥æ”¶çŠ¶æ€\næ›´å¤šä½¿ç”¨æ–¹å¼è¯·å‚è§transitions/README.md\n\n\nâˆ‡ é€†æ³¢å…°è¡¨ç¤ºæ³•RPNé€†æ³¢å…°è¡¨ç¤ºæ³•ï¼Œæ˜¯ä¸€ç§æ˜¯ç”±æ³¢å…°æ•°å­¦å®¶æ‰¬Â·æ­¦å¡è°¢ç»´å¥‡äº1920å¹´å¼•å…¥çš„æ•°å­¦è¡¨è¾¾å¼å½¢å¼ï¼Œåœ¨é€†æ³¢å…°è®°æ³•ä¸­ï¼Œæ‰€æœ‰æ“ä½œç¬¦ç½®äºæ“ä½œæ•°çš„åé¢ï¼Œå› æ­¤ä¹Ÿè¢«ç§°ä¸ºåç¼€è¡¨ç¤ºæ³•ã€‚é€†æ³¢å…°è®°æ³•ä¸éœ€è¦æ‹¬å·æ¥æ ‡è¯†æ“ä½œç¬¦çš„ä¼˜å…ˆçº§ã€‚\næ¯”å¦‚è¯´\n$$5\\ +\\ ((1\\ +\\ 2)\\ \\ 4)\\ -\\ 3\\  ==\\mathbf{RPN}=â‡’\\ 5\\ 1\\ 2\\ +\\ 4\\ \\ +\\ 3\\ -$$\né¦–å…ˆé˜è¿°ä¸€ä¸‹é€†æ³¢å…°è¡¨è¾¾å¼æ˜¯å¦‚ä½•å¾—åˆ°çš„ï¼Œæˆ‘ä»¬é‡‡å–å¦‚ä¸‹ç®—æ³•ï¼š\n\néœ€è¦ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜æ•°ï¼Œä¸€ä¸ªå­˜ç¬¦å·ï¼Œä¸‹é¢åˆ†åˆ«ç§°ä¹‹ä¸ºæ•°æ ˆå’Œç¬¦å·æ ˆ\n\né¡ºåºè¯»å…¥ä¸­ç¼€è¡¨è¾¾å¼ï¼ˆæ­£å¸¸çš„è¿ç®—å¼ï¼‰\n\né‡åˆ°æ•°ï¼ˆå®Œæ•´çš„æ•°ï¼Œä¸æ˜¯é€ä½ï¼‰æ—¶å‹å…¥æ•°æ ˆ\n\né‡åˆ°è¿ç®—ç¬¦æ—¶ï¼Œé¦–å…ˆä»ç¬¦å·æ ˆæ ˆé¡¶å¼€å§‹æ£€æŸ¥ï¼Œå¦‚æœæ ˆé¡¶ç¬¦å·ä¼˜å…ˆçº§&gt;(=)è¯»å…¥è¿ç®—ç¬¦ï¼Œåˆ™å°†æ ˆé¡¶ç¬¦å·å¼¹å‡ºå‹å…¥æ•°æ ˆä¸­ï¼Œç„¶åæ£€æŸ¥ç¬¦å·æ ˆä¸‹ä¸€ä¸ªç¬¦å·ï¼Œå¾ªç¯å¾€å¤ï¼Œç›´åˆ°ç¬¦å·æ ˆæ ˆé¡¶ç¬¦å·ä¼˜å…ˆçº§&lt;è¯»å…¥è¿ç®—ç¬¦æ—¶ï¼Œå°†è¯»å…¥è¿ç®—ç¬¦å‹å…¥ç¬¦å·æ ˆ\nâš ï¸ç”±äºè¿ç®—ç¬¦åŸºæœ¬æ˜¯å·¦ç»“åˆçš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥è®¤ä¸ºå·¦è¾¹ï¼ˆç¬¦å·æ ˆå†…ï¼‰çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§&gt;å³è¾¹ï¼ˆè¯»å…¥ï¼‰çš„åŒçº§è¿ç®—ç¬¦\n\nå½“è¯»å…¥ã€(ã€‘æ—¶ï¼Œç›´æ¥å‹å…¥ç¬¦å·æ ˆï¼Œä¸”åªæœ‰è¯»å…¥ã€)ã€‘æ—¶æ‰å¯ä»¥å¼¹å‡º\n\nå½“è¯»å…¥ã€)ã€‘æ—¶ï¼Œå°†ç¬¦å·æ ˆå†…çš„ç¬¦å·ä¾æ¬¡å¼¹å‡ºå‹å…¥æ•°æ ˆï¼Œç›´åˆ°é‡åˆ°ç¬¬ä¸€ä¸ªã€(ã€‘ï¼Œæ³¨æ„ã€(ã€‘ç›´æ¥å¼¹å‡ºä¸å‹å…¥æ•°æ ˆ\n\nè¯»å®Œè¿ç®—å¼åï¼Œä¾æ¬¡å¼¹å‡ºç¬¦å·æ ˆå¹¶å‹å…¥æ•°æ ˆï¼Œé‚£ä¹ˆæ•°æ ˆã€æ ˆåº•â†’æ ˆé¡¶ã€‘å³ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼\n\n\né‚£ä¹ˆé€†æ³¢å…°è¡¨è¾¾å¼æœ‰ä»€ä¹ˆä¼˜ç‚¹å‘¢ï¼Œæ—¢ç„¶æ˜¯å…³äºè¿ç®—å¼çš„é‚£å¿…ç„¶æ¶‰åŠåˆ°è®¡ç®—ã€‚å¯¹äºé€†æ³¢å…°è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬åªéœ€é¡ºåºè¯»å…¥ï¼Œé‡åˆ°æ•°å­—å‹å…¥æ ˆä¸­ï¼Œé‡åˆ°è¿ç®—ç¬¦åˆ™å¼¹å‡ºæ ˆé¡¶çš„ä¸¤ä¸ªæ•°å­—ç›´æ¥è®¡ç®—å†å‹å…¥æ ˆä¸­ï¼Œæœ€ç»ˆçš„æ ˆé‡Œåªä¼šå‰©ä½™ä¸€ä¸ªæ•°ï¼Œå³ä¸ºè¿ç®—ç»“æœã€‚\n$$$\\ 5\\ 1\\ 2\\ +\\ 4\\ \\ +\\ 3\\ -â†’ \\ 5\\ 3\\ $\\ 4\\ \\ +\\ 3\\ -â†’ \\ 5\\ \\ 12\\ $+\\ 3\\ -â†’ \\ 17\\ $3\\ -â†’ 14$ $$\n\nâ„µ Regular Expression 2 NFAè¿™é‡Œçš„æ­£åˆ™è¡¨è¾¾å¼æˆ‘ä»¬è®¤ä¸ºä»…æœ‰ä¸‰ç§ç¬¦å·ï¼šKleeneé—­åŒ…ã€*ã€‘ï¼Œè¿æ¥è¿ç®—ç¬¦ã€Â·ã€‘ï¼ˆä¸€èˆ¬çœç•¥ï¼‰ï¼Œæˆ–è¿ç®—ç¬¦ã€ï½œã€‘ï¼ˆä¸‰è€…çš„ä¼˜å…ˆçº§ä¾æ¬¡é™ä½ï¼‰ã€‚é‚£ä¹ˆæ­£åˆ™è¡¨è¾¾å¼è½¬ä¸ºNFAçš„è§„åˆ™åŸºæœ¬å¯ä»¥ç”±ä¸‹å›¾æ¦‚æ‹¬ï¼Œ\n\n\n\n\nåŸºæœ¬æ€æƒ³æ˜¯å…ˆå°†æ­£åˆ™è¡¨è¾¾å¼è½¬ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼ï¼Œç„¶åç”¨å¼€å§‹èŠ‚ç‚¹å’Œæœ€ç»ˆèŠ‚ç‚¹çš„ç¼–å·å¯¹[start node num , end node num]æ¥è¡¨ç¤ºæ­£åˆ™è¡¨è¾¾å¼çš„è¿ç®—ç»“æœï¼Œåœ¨ç”¨é€†æ³¢å…°è¡¨è¾¾å¼è®¡ç®—çš„åŒæ—¶ç”Ÿæˆåˆ—è¡¨transitionsï¼Œæœ€åç»˜åˆ¶ç›¸åº”çš„çŠ¶æ€è½¬ç§»å›¾ã€‚\n\nCâ˜ºDEfrom transitions.extensions import GraphMachine\n\nrpn = []\npriority = {'|': 0, '*': 2, '.': 1, '(': -1}\n\n# è¡¥å…¨æ­£åˆ™è¡¨è¾¾å¼çš„è¿æ¥è¿ç®—ç¬¦\ndef dotREG(s):\n    i = 1\n    while i &lt; len(s):\n        if s[i].islower() or s[i] == '(':\n            if s[i - 1] == '*' or s[i - 1].islower() or s[i - 1] == ')':\n                s = s[:i] + '.' + s[i:]\n                i += 1\n        i += 1\n    return s\n\n# è®¡ç®—æ­£åˆ™è¡¨è¾¾å¼çš„é€†æ³¢å…°è¡¨è¾¾å¼rpn\ndef REG2RPN(r):\n    global rpn\n    i = 0\n    ops = []\n    while i &lt; len(r):\n        if r[i].islower():\n            rpn.append(r[i])\n        elif r[i] in ['.', '|', '*']:\n            while ops:\n                if priority[ops[-1]] &gt;= priority[r[i]]:\n                    rpn.append(ops.pop())\n                else:\n                    break\n            ops.append(r[i])\n        elif r[i] == '(':\n            ops.append('(')\n        elif r[i] == ')':\n            while ops[-1] != '(':\n                rpn.append(ops.pop())\n            ops.pop()\n        i += 1\n\n    while ops:\n        rpn.append(ops.pop())\n\n\nr = input(\"Input regular expression: \")\nr = dotREG(r)\nREG2RPN(r)\nstatus = 0\ncrt_stt = []\ntransitions = []\nfor i in range(len(rpn)):\n    if rpn[i].islower():\n        crt_stt.append([status, status + 1])\n        transitions.append([rpn[i], str(status), str(status + 1)])\n        status += 2\n    elif rpn[i] == '*':\n        transitions.append(['Îµ', str(crt_stt[-1][0]), str(crt_stt[-1][1])])\n        transitions.append(['Îµ', str(crt_stt[-1][1]), str(crt_stt[-1][0])])\n    elif rpn[i] == '.':\n        stt1 = crt_stt.pop()\n        stt2 = crt_stt.pop()\n        transitions.append(['Îµ', str(stt2[1]), str(stt1[0])])\n        crt_stt.append([stt2[0], stt1[1]])\n    elif rpn[i] == '|':\n        stt1 = crt_stt.pop()\n        stt2 = crt_stt.pop()\n        crt_stt.append([status, status + 1])\n        transitions.append(['Îµ', str(status), str(stt1[0])])\n        transitions.append(['Îµ', str(status), str(stt2[0])])\n        transitions.append(['Îµ', str(stt1[1]), str(status + 1)])\n        transitions.append(['Îµ', str(stt2[1]), str(status + 1)])\n        status += 2\n\ntransitions.append(['Îµ', 'start', str(crt_stt[0][0])])\nstates = list(map(str, range(status))).append('start')\n\nNFA = GraphMachine(states=states,\n                   transitions=transitions,\n                   initial=str(crt_stt[0][1]), title='REG2NFA')\nNFA.get_graph().draw('REG2NFA.png', prog='dot')\n\nâŠˆ Few Tips\nè™½ç„¶ã€(ã€‘çš„ä¼˜å…ˆçº§æœ€é«˜ï¼Œä½†ç”±äºã€(ã€‘åœ¨é‡åˆ°ã€)ã€‘ä¹‹å‰ä¸èƒ½å¼¹å‡ºï¼Œå› æ­¤æˆ‘ä»¬å°†å…¶ä¼˜å…ˆçº§ç½®ä¸ºæœ€ä½ \npythonçš„listè‡ªå¸¦pop()å‡½æ•°ï¼Œä¸ä»…å¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ ï¼ŒåŒæ—¶è¿”å›å…¶å€¼ï¼Œè¿™ä¸C++çš„&lt;stack&gt;ä¸åŒ\nNFAèµ·ç‚¹æ˜¯â€™startâ€™ï¼Œæ¥æ”¶çŠ¶æ€ä¸ºåºå·æœ€å¤§çš„çŠ¶æ€ï¼Œé¢œè‰²ä¸å…¶ä»–çŠ¶æ€ä¸åŒ\nrpnä¸ºæ•°æ ˆï¼Œopsä¸ºç¬¦å·æ ˆ\n\n(aa|b)*a(a|bb)*\n\n\n\n\n\n\nã€ŒReferenceã€\né€†æ³¢å…°è¡¨ç¤ºæ³•. (2021, September 24). Retrieved from ç»´åŸºç™¾ç§‘, è‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦\n\n","slug":"00-REG2NFA","date":"2022-05-09T15:49:12.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"python,èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"4eb946cc0edf20ceda9a686ce0927f5a","title":"YOLOv5è¯´æ˜ä¹¦","content":"YOLO çš„å…¨ç§°æ˜¯ You Only Look Onceï¼ŒæŒ‡åªéœ€è¦æµè§ˆä¸€æ¬¡å°±å¯ä»¥è¯†åˆ«å‡ºå›¾ä¸­çš„ç‰©ä½“çš„ç±»åˆ«å’Œä½ç½®ã€‚YOLOv5 æ˜¯ç”± Ultralytics LLC å…¬å¸äº 2020 å¹´ 5 æœˆæ‰€æå‡ºï¼Œå…¶å›¾åƒæ¨ç†é€Ÿåº¦æœ€å¿«è¾¾ 0.007 sï¼Œå³æ¯ç§’å¯å¤„ç† 140 å¸§ï¼Œæ»¡è¶³è§†é¢‘å›¾åƒå®æ—¶æ£€æµ‹éœ€æ±‚ï¼ŒåŒæ—¶ç»“æ„æ›´ä¸ºå°å·§ã€‚\næœ¬æ–‡ä»‹ç»YOLOv5çš„æ‰“å¼€æ–¹å¼åŠä¸€äº›æ³¨æ„äº‹é¡¹ã€‚\n\n\n\n\n\n\n\nâ¨‡ Prefaceäº”ä¸€å‰å‚åŠ äº†ä¸€ä¸ªåå«æ³°è¿ªæ¯çš„æ¯”èµ›ï¼Œåå­—å¬ç€åƒä¸ªé‡é¸¡æ¯”èµ›ï¼Œå…¶å®æ˜¯ä¸ªæœºå™¨å­¦ä¹ æ¯”èµ›ï¼Œä¹ŸåŠäº†æŒºå¤šå±Šã€‚è¿™å­¦æœŸæœ‰é€‰æœºå™¨å­¦ä¹ ï¼ˆå¤§åŠä¸ªå­¦æœŸè¿‡å»äº†ï¼Œæˆ‘åªä¼šKNNå’Œé€»è¾‘æ–¯è’‚å›å½’ï¼‰å’Œæ•°æ®æŒ–æ˜ï¼ˆè€å¸ˆè®²çš„æŒºè®¤çœŸï¼Œä½†æˆ‘ç»å¸¸ä¸Šè¯¾moé±¼ï¼‰ï¼Œå› æ­¤å°±å’ŒåŒå­¦æŠ¥åå‚åŠ äº†ã€‚\næˆ‘ä»¬é€‰æ‹©çš„æ˜¯å†œç”°å®³è™«è¯†åˆ«èµ›é¢˜ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ç»™å‡ºå®³è™«ç…§ç‰‡é›†ä¸ç›¸åº”çš„å®³è™«æ ‡ç­¾åŠä½ç½®æ¡†åæ ‡ï¼Œéœ€è¦æˆ‘ä»¬è®­ç»ƒæ¨¡å‹æ¥è¯†åˆ«å›¾ç‰‡ä¸­çš„å®³è™«ä½ç½®ä¸ç§ç±»ã€‚ç¬¬ä¸€æ¬¡å‚åŠ æœºå™¨å­¦ä¹ æ¯”èµ›ï¼Œæ²¡ä»€ä¹ˆç»éªŒï¼ŒåŸºç¡€ä¹Ÿä¸å¤ªè¡Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸»è¦çš„æ—¶é—´éƒ½èŠ±åœ¨æ•°æ®é›†å¤„ç†ä¸Šé¢äº†ã€‚è®­ç»ƒæ¨¡å‹ç›´æ¥é‡‡ç”¨äº†æ¯”èµ›åŸ¹è®­ä¸­è®²çš„YOLOv5ï¼Œåœ¨æµè§ˆäº†å¤§é‡åšå®¢ä¹‹åç®—æ˜¯ä¸Šæ‰‹äº†ï¼Œæœ¬æ–‡å°±åˆ†äº«ä¸€ä¸‹ä½¿ç”¨æ–¹å¼ä»¥åŠä¸€äº›tipsã€‚\n\n\n\nâš ï¸ä¸‹æ–‡ä¸­æ‰€æœ‰çš„ç›¸å¯¹è·¯å¾„éƒ½é»˜è®¤åœ¨ä¸‹è½½çš„æ–‡ä»¶å¤¹yolov5/ä¸‹\n\n\n\nÎ©\né¦–å…ˆä»githubä¸Šå°†è¿™ä¸ªå®˜æ–¹ä»“åº“cloneä¸‹æ¥ï¼ˆæˆ–ç›´æ¥åœ¨å®˜ç½‘Codeâ†’Download zipï¼‰\ngit clone https://github.com/ultralytics/yolov5.git\n\né€Ÿåº¦å¤ªæ…¢çš„è¯å°±ç”¨é•œåƒ\ngit clone https://gitee.com/monkeycc/yolov5.git\n\nåœ¨ä¸‹è½½çš„æ–‡ä»¶å¤¹ä¸­æ‰“å¼€terminalï¼Œå®‰è£…è¿è¡Œç¯å¢ƒæ‰€éœ€è¦çš„ä¾èµ–åŒ…\npip install -r requirements.txt\n\nåˆ›å»ºè®­ç»ƒé…ç½®æ–‡ä»¶ï¼šdata/*.yaml ï¼Œæ ¼å¼ç¤ºä¾‹å¦‚ä¸‹\n# path of training and validation set\ntrain: dataset/images/train\nval: dataset/images/val\n\n# Classes\nnc: 8  # number of classes\nnames: ['6','apple','7','dog','cat','485','pear','673'] \n\n\ntrainå’Œvalæ˜¯è®­ç»ƒé›†å’ŒéªŒè¯é›†ï¼ˆè‡ªè¡Œåˆ’åˆ†ï¼‰çš„å›¾ç‰‡æ–‡ä»¶å¤¹ç›®å½•ï¼Œç›¸å¯¹è·¯å¾„å’Œç»å¯¹è·¯å¾„å‡å¯\nncæ˜¯ç±»æ•°ï¼Œnamesåˆ™æ˜¯åŒ…å«æ‰€æœ‰ç±»åçš„åˆ—è¡¨\n\n\nä½¿ç”¨é¢„è®­ç»ƒæƒé‡å¯ä»¥ç¼©çŸ­è®­ç»ƒæ—¶é—´ï¼Œå¹¶æé«˜è®­ç»ƒç²¾åº¦ï¼Œé¢„è®­ç»ƒè§„æ¨¡è¶Šå¤§ï¼Œè®­ç»ƒç²¾åº¦ç›¸å¯¹æ›´é«˜ï¼Œä½†æ£€æµ‹æ—¶é—´æ›´é•¿.\n åœ¨æ­¤ä¸‹è½½é¢„è®­ç»ƒæƒé‡ï¼Œå¹¶å°†ä¸‹è½½çš„ptæ–‡ä»¶ç½®äºmodels/ä¸‹ï¼Œä¸€èˆ¬é€‰æ‹©yolov5s.ptå³å¯ï¼Œæƒé‡å¤§å°å³ä»£è¡¨äº†æƒé‡è§„æ¨¡\n\n\nä¸‹è½½çš„é¢„è®­ç»ƒæƒé‡ä¸ºyolov5*.ptï¼Œé‚£ä¹ˆå°±ä¿®æ”¹ç›¸å¯¹åº”çš„models/yolov5*.yamlæ–‡ä»¶ï¼Œåªéœ€å°†å…¶ä¸­çš„ncæ”¹ä¸ºä½ è‡ªå·±çš„ç±»æ•°å³å¯\n\nè®­ç»ƒæ•°æ®é›†ä¸€èˆ¬å­˜æ”¾äºdataset/ï¼Œä¸”datasetçš„æ–‡ä»¶æ ‘ç»“æ„éœ€è¦å¦‚ä¸‹æ‰€ç¤º\ndataset\nâ”œâ”€â”€ images\nâ”‚   â”œâ”€â”€ train\nâ”‚   â””â”€â”€ val\nâ””â”€â”€ labels\n    â”œâ”€â”€ train\n    â””â”€â”€ val\n\n\ndatasetä¸‹åˆ†ä¸ºä¸¤ä¸ªæ–‡ä»¶å¤¹images/å’Œlabels/ï¼Œå‰è€…å­˜æ”¾å›¾åƒï¼Œåè€…å­˜æ”¾æ¯å¼ å›¾åƒçš„txtæ–‡ä»¶\n\ntxtä¸­å­˜æ”¾å›¾ç‰‡ä¸­å«æœ‰çš„ç±»åˆ«å’Œç›¸åº”çš„æ–¹æ¡†åæ ‡ï¼Œæ ¼å¼ä¸º\nclass_num boxä¸­å¿ƒæ¨ªåæ ‡ä¸å›¾åƒå®½åº¦æ¯”å€¼ boxä¸­å¿ƒçºµåæ ‡ä¸å›¾åƒé«˜åº¦æ¯”å€¼ boxå®½åº¦ä¸å›¾åƒå®½åº¦æ¯”å€¼ boxé«˜åº¦ä¸å›¾åƒé«˜åº¦æ¯”å€¼\n\n\nclass_numæ˜¯ã€3ã€‘ä¸­yamlæ–‡ä»¶é‡Œçš„namesç´¢å¼•ï¼ˆä»0å¼€å§‹è®¡æ•°ï¼‰ï¼Œå¦‚class_num=2ï¼Œé‚£ä¹ˆè¡¨ç¤ºçš„å°±æ˜¯â€˜7â€™\n\nåæ ‡çš„åŸç‚¹åœ¨å›¾åƒçš„å·¦ä¸Šè§’ï¼Œå‘å³æ˜¯è½´æ­£æ–¹å‘ï¼Œå‘ä¸‹æ˜¯è½´æ­£æ–¹å‘ï¼Œåæ ‡å•ä½æ˜¯åƒç´ \n\nï¼Œåé¢å››ä¸ªå€¼å‡\n\nä¸€ä¸ªè¯†åˆ«ç›®æ ‡ä¸€è¡Œï¼Œè‹¥è¯¥å›¾ç‰‡ä¸­æ²¡æœ‰ç›®æ ‡åˆ™ä¸ºç©ºå³å¯\n\n\n\nimages/å’Œlabels/ä¸‹åˆåˆ†åˆ«å«æœ‰ä¸¤ä¸ªæ–‡ä»¶å¤¹ï¼Œè®­ç»ƒé›†train/å’ŒéªŒè¯é›†val/\n\nimages/train/å’Œlabels/train/ï¼Œimages/val/å’Œlabels/val/ ä¸‹çš„æ–‡ä»¶é™¤åç¼€å¤–æ•°é‡å’Œæ–‡ä»¶åå¿…é¡»å®Œå…¨ä¸€è‡´ï¼Œå³å›¾ç‰‡å’Œtxtå¿…é¡»ä¸€ä¸€å¯¹åº”ï¼ˆæ²¡æœ‰ç›®æ ‡ä¹Ÿå¿…é¡»æœ‰ç›¸åº”çš„txtï¼‰ï¼Œå¦åˆ™è®­ç»ƒæ—¶ä¼šæŠ¥é”™\n\n\n\nå¦‚æœæƒ³æ‰‹åŠ¨ç”»æ¡†å¹¶ç”ŸæˆYOLOæ ¼å¼çš„txtï¼Œå¯ä»¥ä½¿ç”¨labelimgå·¥å…·\npip install labelimg\n\nå®‰è£…å®Œæˆåç›´æ¥åœ¨terminalä¸­è¾“å…¥labelimgå³å¯ä½¿ç”¨ï¼ˆæ³¨æ„ä½¿ç”¨æ—¶å…ˆå°†ã€PascalVOCã€‘æ ¼å¼ æ”¹ä¸ºã€YOLOã€‘æ ¼å¼ï¼‰\n\ntrain.pyæ˜¯è®­ç»ƒä»£ç ï¼Œå…¶ä¸­åªéœ€ä¿®æ”¹parse_opt(known=False) å‡½æ•°çš„å®šä¹‰éƒ¨åˆ†\n\n--weightséƒ¨åˆ†æ˜¯é¢„è®­ç»ƒæƒé‡çš„åœ°å€ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©ä¸Šä¸€æ¬¡è®­ç»ƒä¸­æ•ˆæœæœ€å¥½çš„æƒé‡ï¼šruns/train/exp/weights/best.pt\n\n--cfgæ˜¯ã€3ã€‘ä¸­çš„yamlæ–‡ä»¶åœ°å€\n\n--dataæ˜¯ã€5ã€‘ä¸­çš„yamlæ–‡ä»¶åœ°å€\n\n--epochså¯ä»¥è®¾ç½®è®­ç»ƒçš„è½®æ•°ï¼Œä¸€èˆ¬è®¾ç½®300è½®è¾ƒä¸ºåˆé€‚\n\n--resumeå°†defaultæ”¹ä¸ºTrueå¯ä»¥ç»§ç»­ä¸Šä¸€æ¬¡æœªå®Œæˆçš„è®­ç»ƒï¼ˆå¦‚æœå‰ä¸€æ¬¡è®­ç»ƒæ„å¤–ä¸­æ–­æˆ–è€…äººä¸ºç»ˆæ­¢ï¼‰ï¼Œæ­¤æ—¶å°†å¿½ç•¥--weightsè®¾ç½®çš„é¢„è®­ç»ƒæƒé‡\n\nå…¶ä»–ä¸€èˆ¬æ— éœ€ä¿®æ”¹\n\n\n\nç”¨è®­ç»ƒæƒé‡æ¥è¯†åˆ«å›¾ç‰‡ï¼ˆä¸€èˆ¬å°†éœ€è¦è¯†åˆ«çš„å›¾ç‰‡æ”¾ç½®åœ¨data/images/ä¸‹ï¼‰\n\nç”Ÿæˆè¯†åˆ«ç»“æœçš„å›¾ç‰‡å’Œtxt\npython detect.py --weights path_weight --source path_images --device cpu --save-txt\n\nä»…ç”Ÿæˆè¯†åˆ«ç»“æœå›¾ç‰‡\npython detect.py --weights path_weight --source path_iamges --device cpu --img 640\n\nå…¶ä¸­path_weightæ˜¯æƒé‡çš„åœ°å€ï¼Œpath_imagesæ˜¯è¯†åˆ«å›¾ç‰‡æ‰€åœ¨æ–‡ä»¶å¤¹åœ°å€\n\nå¦‚æœå¯ä»¥è°ƒç”¨GPUï¼Œè¯·å°†--device cpuå»æ‰\n\nExpï¼š\npython detect.py --weights runs/train/exp13/weights/best.pt --source data/images/ --device cpu --save-txt\n\n\nruns/train/ä¸‹å­˜æ”¾ç€æ¯ä¸€æ¬¡çš„è®­ç»ƒç»“æœï¼›runs/detect/ä¸‹å­˜æ”¾ç€æ¯ä¸€æ¬¡çš„è¯†åˆ«ç»“æœ. expè¡¨ç¤ºç¬¬æ¬¡ç»“æœ.\n\n\n\nâš¡ï¸ training âš¡ï¸\n\n\n\nâ‰« Outcome â‰ª","slug":"Yolov5è¯´æ˜ä¹¦","date":"2022-05-07T03:54:21.000Z","categories_index":"Machine Learning","tags_index":"python,èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"1ebcc2044e1859de323771c4cf459a30","title":"Bison^Flex=è¯­æ³•åˆ†æç”Ÿæˆä¸­","content":"ä¸Šå¤æ—¶ä»£çš„æ—¶å€™ï¼ˆå‰ä¸€æ®µæ—¶é—´å‚åŠ äº†äº›äº›å°ç«èµ›ï¼ŒçŠ¶æ€æœ‰ç‚¹è¿·ç³Šï¼Œäº”ä¸€åˆæµªé‡Œä¸ªæµªï¼Œæ‰€ä»¥â€¦è™½è¿Ÿä½†åˆ°ï¼ï¼‰ï¼Œæˆ‘ä»¬æœ‰è®²è§£è¿‡å€ŸåŠ©Flexå®ç°SysYè¯æ³•åˆ†æã€‚è¯æ³•åˆ†ææ˜¯ç¼–è¯‘çš„ç¬¬ä¸€é˜¶æ®µï¼Œä»…ä»…åªæ˜¯å°†ä»£ç è¿›è¡Œåˆ‡å—å½’ç±»ï¼Œå¾—åˆ°çš„åªæ˜¯äº›é›¶æ•£çš„tokensã€‚ç°åœ¨æˆ‘ä»¬è¿›å…¥ç¬¬äºŒé˜¶æ®µï¼Œå¯¹è¿™äº›tokenè¿›è¡Œæ•´ç†æ’åºï¼Œä»¥ä¾¿åé¢å¯ä»¥æ–¹ä¾¿åœ°è§£è¯»æ¯å¥codeçš„å«ä¹‰ï¼Œå³è¯­ä¹‰åˆ†æâ€”â€”æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ASTã€‚\næœ¬æ–‡å°†é˜è¿°å¦‚ä½•ä½¿ç”¨Bisonè”åˆFlexæ¥ç”Ÿæˆè¯­æ³•åˆ†æå™¨ï¼Œå¹¶è¾“å‡ºæŠ½è±¡è¯­æ³•æ ‘ã€‚\n\n\n\næŠ½è±¡è¯­æ³•æ ‘ç”¨æ ‘çš„æ•°æ®ç»“æ„å°†tokenä»¬è¿›è¡Œå…³è”ï¼Œéå¸¸æŠ½è±¡åœ°å±•ç°äº†æ•´ä½“ä¸éƒ¨åˆ†çš„å…³ç³»ï¼Œå°±å¥½ä¼¼ä¸ºä¸€å¥è¯æ–­å¥ï¼Œä½¿å…¶ç»“æ„ä¸€è§ˆæ— ä½™ã€‚æ—¢ç„¶è¦ä¸ºä»£ç å—è¿›è¡Œâ€œæ–­å¥â€ï¼Œé‚£ä¹ˆæˆ‘ä»¬åŠ¿å¿…éœ€è¦å…ˆæ¸…æ¥šä»£ç å—æ‹¥æœ‰å“ªäº›ç»“æ„å±‚æ¬¡ã€‚ä½†ç»“æ„å±‚æ¬¡å¹¶ä¸æ˜¯æ­»æ¿çš„ï¼Œä¾‹å¦‚è‹±è¯­ä¸­æ­£å¸¸çš„å¥å­ç»“æ„éƒ½æ˜¯ä¸»è°“å®¾ï¼Œä½†å¹¶ä¸æ˜¯æ‰€æœ‰å¥å­åªæœ‰è¿™ç§æ¨¡å¼ï¼Œå¥å­ä¸­è¿˜å¯ä»¥æœ‰çŠ¶è¯­ã€è¡¥è¯­ç­‰ã€‚ä»£ç ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œé‚£ä¹ˆå¦‚ä½•æ¥æè¿°ä¸€ç§ç¼–ç¨‹è¯­è¨€æ‰€æœ‰å¯èƒ½çš„ç»“æ„å±‚æ¬¡å‘¢ï¼Œå°±æ˜¯æ‰€è°“çš„æ–‡æ³•ã€‚\n\n\næ —å­èƒœåƒè¨€ï¼Œä¾‹å¦‚ä¸‹é¢è¿™ä¸ªç®€å•çš„æ–‡æ³•\nS â†’ aSb | aAb\nA â†’ bAa | ba\n\nå…¶ä¸­æ˜¯å¼€å§‹ç¬¦å·ï¼Œå³æ–‡æ³•æ¨å¯¼ä¸­çš„ç¬¬ä¸€ä¸ªéç»ˆç»“ç¬¦ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæ–‡æ³•æè¿°çš„æ‰€æœ‰å¥å­éƒ½å¯ä»¥ç”±æ¨å¯¼è€Œæ¥ã€‚ä¸€èˆ¬å¤§å†™å­—æ¯è¡¨ç¤ºçš„éƒ½æ˜¯éç»ˆç»“ç¬¦ï¼Œå³è¿˜å¯ä»¥ç»§ç»­æ¨å¯¼çš„ç¬¦å·ï¼Œå°å†™å­—æ¯å°±ç›¸å¯¹åº”çš„ç»ˆç»“ç¬¦ã€‚é‚£ä¹ˆå¾ˆæ˜¾ç„¶ï¼Œè¿™ä¸ªæ–‡æ³•æè¿°çš„æ‰€æœ‰å¥å­å¯ä»¥ç”¨é›†åˆæ¥è¡¨ç¤ºã€‚\nå¯ä»¥çœ‹åˆ°æœ‰é™çš„æ¨å¯¼å¼è¶³ä»¥æè¿°æ— ç©·çš„å¥å­ï¼Œä½†è¿™äº›å¥å­æ˜¯å…·æœ‰ä¸€å®šè¯­æ³•è§„åˆ™çš„ã€‚è€Œä¸€ç§ç¼–ç¨‹è¯­è¨€æœ¬èº«å°±æ˜¯ä¸€äº›å…·æœ‰ç‰¹å®šè¯­æ³•è§„åˆ™çš„å¥å­ï¼Œå› æ­¤ä¹Ÿå¯ä»¥ç”¨ä¸€ä¸ªæ–‡æ³•æ¥è¡¨ç¤ºï¼Œåªä¸è¿‡æ¨å¯¼å¼çš„æ•°é‡ç¨å¾®å¤šäº†äº¿äº›ã€‚\nåœ¨ä¸å€ŸåŠ©ä»»ä½•å·¥å…·çš„æƒ…å†µä¸‹ï¼Œè¦å®ç°ä¸€ä¸ªè¯­æ³•åˆ†æå™¨å°±ä¼šæœ‰ä¸¤ç§æ€è·¯ï¼Œå…¶ä¸€æ˜¯è‡ªåº•å‘ä¸Šï¼Œå°±æ˜¯å°†è¯»å…¥çš„tokenä¸æ–­å½’çº¦ï¼ˆæ¨å¯¼çš„é€†è¿‡ç¨‹ï¼‰ä¸ºéç»ˆç»“ç¬¦ï¼Œç›´åˆ°å‰©ä¸‹å¼€å§‹ç¬¦å·ï¼›å¦ä¸€ç§åˆ™æ˜¯è‡ªé¡¶å‘ä¸‹ï¼Œå³ä»å¼€å§‹ç¬¦å·æ‰¾åˆ°ç”Ÿæˆå½“å‰ä»£ç çš„æ¨å¯¼è¿‡ç¨‹ï¼Œè¿™é‡Œå…¶å®å°±æ˜¯é€‰æ‹©å“ªä¸€æ¡äº§ç”Ÿå¼çš„é—®é¢˜ã€‚ä¸¤ç§æ€è·¯æœ¬è´¨ä¸Šå°±æ˜¯é€‰æ‹©æ ‘çš„æ ¹è¿˜æ˜¯å¶å­ç»“ç‚¹ä½œä¸ºåˆ†æçš„èµ·ç‚¹æ¥è€ƒè™‘çš„ï¼Œä½†è¿™å¹¶ä¸æ˜¯æœ¬æ–‡çš„é‡ç‚¹ï¼Œä½ åªéœ€çŸ¥é“Bisonç”Ÿæˆçš„è¯­æ³•åˆ†æå™¨ä»£ç é‡‡ç”¨çš„æ˜¯è‡ªåº•å‘ä¸Šçš„æ€è·¯ï¼Œè€Œæˆ‘ä»¬åªè¦æä¾›ç»™Bisonç›¸åº”çš„æ–‡æ³•å³å¯å¾—åˆ°è¯¥æ–‡æ³•å¯¹åº”è¯­è¨€çš„è¯­æ³•åˆ†æå™¨ã€‚\nä¸è¿‡ï¼Œå¸¦ç€ä¸€ç‚¹è¯­æ³•åˆ†æåŸç†çš„å­¦ä¹ æ¥é˜…è¯»æœ¬æ–‡ä½“éªŒä¼šæ›´å¥½å“¦\n\nGNU Bisonæ˜¯ä¸€æ¬¾ç”¨äºè‡ªåŠ¨ç”Ÿæˆè¯­æ³•åˆ†æå™¨çš„ç¨‹åºï¼ŒåŸºäºå¹¶å…¼å®¹yaccï¼Œå¯ç”¨äºæ‰€æœ‰å¸¸è§çš„æ“ä½œç³»ç»Ÿã€‚BisonæŠŠLALRå½¢å¼çš„ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æè¿°è½¬æ¢ä¸ºå¯åšè¯­æ³•åˆ†æçš„Cæˆ–C++ç¨‹åºã€‚\nBisonçš„è¾“å…¥æ–‡ä»¶*.yçš„åŸºæœ¬æ ¼å¼å¦‚ä¸‹ï¼Œä½¿ç”¨è€…éœ€è¦å°†æ–‡æ³•çš„ä¸€äº›åŸºæœ¬ä¿¡æ¯å†™å…¥è¯¥æ–‡ä»¶\n%start CompUnit\n%expect 1\n\n%{\n    #include \"parser.h\"\n    ...\n%}\n\n%union\n{\n    int     num;\n    char*   str;\n}\n\n/*å£°æ˜Flexäº§ç”Ÿçš„tokenæœ‰ä¸‰ç§æ ¼å¼ï¼Œå…¶ä¸­&lt;type&gt;ä¸æ˜¯å¿…é¡»çš„*/\n%token &lt;type1&gt; tokens1 /*ç±»å‹ä¸ºtype1çš„tokenä»¬*/\n%right &lt;type2&gt; tokens2 /*ç±»å‹ä¸ºtype2çš„å³ç»“åˆtokenä»¬*/\n%left &lt;type3&gt; tokens3  /*ç±»å‹ä¸ºtype3çš„å·¦ç»“åˆtokenä»¬*/\n\n/*å£°æ˜éç»ˆç»“ç¬¦çš„ç±»å‹*/\n%type&lt;num&gt; Number CompUnit Decl ...\n\n%%\n/*Grammar Productions and Corresponding Actions*/\nCompUnit:       CompUnit Decl                     {$$=$1+$2;}\n                | CompUnit FuncDef                {$$=$1-$2;}\nDecl:           ConstDecl    %prec    token3      {$$=$1*10;}\n                | /*Îµ*/                                {}\n...\n%%\n\nint main()\n{\n    yyparse();\n    ...\n}\n\n\nç¬¬ä¸€å¥%start ...æ˜¯å£°æ˜æ–‡æ³•çš„å¼€å§‹ç¬¦å·ï¼Œåé¢ç´§è·Ÿä¸€ä¸ªéç»ˆç»“ç¬¦\n\n%expect nè¡¨ç¤ºä½ çŸ¥é“è¿™ä¸ªæ–‡æ³•ä¸­å­˜åœ¨nä¸ªç§»å…¥/å½’çº¦å†²çªï¼ˆåœ¨æŸä¸€ä¸ªæ—¶åˆ»æ—¢å¯ä»¥é€‰æ‹©å½’çº¦ä¸ºéç»ˆç»“ç¬¦ä¹Ÿå¯ä»¥é€‰æ‹©è¯»å…¥ä¸‹ä¸€ä¸ªtokenï¼‰ï¼Œå¹¶ä¸”è®¤åŒBisoné»˜è®¤çš„å¤„ç†æ–¹å¼ï¼Œé‚£ä¹ˆåœ¨ç”Ÿæˆè¯­æ³•åˆ†æå™¨æ—¶è‹¥Bisonç¡®å®å‘ç°äº†nä¸ªå†²çªå°±ä¸ä¼šæé†’ä½ ï¼Œå¦åˆ™ä¼šæœ‰æç¤ºï¼ˆä¸åŠ ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œè¿™å¥ä¸æ˜¯å¿…è¦çš„ï¼‰\n*.y: conflicts: n shift/reduce\n\n%{...}%ä¸­é—´åˆ™å’ŒFlexç±»ä¼¼ï¼Œå¯ä»¥æ”¾ä¸€äº›å¤´æ–‡ä»¶ï¼Œè¿™ä¸€éƒ¨åˆ†ä¼šè¢«ç›´æ¥æ·»å…¥ç”Ÿæˆä»£ç çš„é å‰éƒ¨åˆ†\n\n%union{...}åˆ™æ˜¯å¯¹ä¹‹åéœ€è¦ç”¨åˆ°çš„ç±»å‹å£°æ˜ï¼Œå³åé¢tokenå’Œéç»ˆç»“ç¬¦çš„ç±»å‹éƒ½åªèƒ½å–è‡ªunionä¸­å£°æ˜çš„ç¬¦å·ï¼Œåœ¨ä¸Šé¢çš„æ–‡ä»¶ä¸­åªèƒ½ç”¨numã€stræ¥å£°æ˜ç±»å‹\n\nå¯¹Flexç”Ÿæˆçš„tokenè¿›è¡Œå£°æ˜ï¼Œä½¿BisonçŸ¥é“æœ‰å“ªäº›tokenå­˜åœ¨ï¼Œå¦å¤–å¯ä»¥é€šè¿‡&lt;type&gt;å¯¹tokençš„ç±»å‹è¿›è¡Œå£°æ˜ï¼ˆé»˜è®¤ä¸ºintï¼‰ï¼Œè¿™æ ·å½“Flexè¿”å›tokenæ—¶æˆ‘ä»¬å¯ä»¥è®¤ä¸ºè¿”å›çš„æ˜¯ä¸€ä¸ªtypeç±»å‹çš„å˜é‡ï¼Œè€Œå¯¹äºtokençš„èµ‹å€¼åˆ™æ˜¯åœ¨Flexä¸­å®Œæˆçš„ï¼Œå¦‚æ­¤å¯ä»¥ä½¿Bisonå’ŒFlexä¹‹é—´å­˜åœ¨ä¿¡æ¯äº¤äº’\n\n%rightå’Œ%leftä¹Ÿæ˜¯tokençš„ä¸€ç§å£°æ˜æ–¹å¼ï¼Œåˆ†åˆ«è¡¨ç¤ºå³ç»“åˆå’Œå·¦ç»“åˆï¼Œå¤šç”¨äºè¿ç®—ç¬¦tokençš„å£°æ˜ä¸Š\n\ntokençš„å£°æ˜é¡ºåºå†³å®šäº†è¯­æ³•ä¼˜å…ˆçº§ï¼Œä»ä¸Šè‡³ä¸‹ä¼˜å…ˆçº§é€æ¸å‡é«˜ï¼ŒåŒä¸€è¡Œçš„tokenä¼˜å…ˆçº§ç›¸åŒï¼Œå¤šç”¨äºè¿ç®—ç¬¦tokençš„å£°æ˜ï¼Œä¼˜å…ˆçº§é«˜çš„tokenå…ˆè¿›è¡Œå½’çº¦\n\n%type&lt;&gt; ...åˆ™æ˜¯å£°æ˜éç»ˆç»“ç¬¦çš„ç±»å‹ï¼Œç±»å‹ä¾ç„¶åªèƒ½å–è‡ª%union{...}ä¸­ï¼Œtokençš„å€¼æ˜¯åœ¨Flexä¸Bisonä¹‹é—´ä¼ é€’ï¼Œè€Œéç»ˆç»“ç¬¦çš„å€¼åˆ™æ˜¯åœ¨äº§ç”Ÿå¼ä¹‹é—´ä¼ é€’ï¼Œå³å½“ä¸€ä¸ªéç»ˆç»“ç¬¦Aè¢«å½’çº¦å‡ºæ¥åï¼Œæˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡Œç›¸åº”ç±»å‹çš„èµ‹å€¼ï¼Œéšååœ¨Aè¢«å½’çº¦æ—¶åˆ™ä¼šå¸¦ç€ä¹‹å‰çš„èµ‹å€¼ä»äº§ç”Ÿå¼å·¦éƒ¨è½¬ç§»åˆ°å¦ä¸€ä¸ªäº§ç”Ÿå¼çš„å³éƒ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç”¨Açš„å€¼æ¥å®šä¹‰æ–°å½’çº¦å‡ºæ¥çš„éç»ˆç»“ç¬¦çš„å€¼\n\n%%...%%ä¹‹é—´åˆ™æ˜¯æœ€é‡è¦çš„è¯­æ³•è§„åˆ™ä»¥åŠç›¸åº”çš„åŠ¨ä½œï¼Œåªä¸è¿‡äº§ç”Ÿå¼ä¸­çš„ã€â†’ã€‘å˜æˆäº†ã€:ã€‘\n\næ¯ä¸€ä¸ªäº§ç”Ÿå¼çš„å³éƒ¨å¯èƒ½æœ‰å¥½å‡ ç§æ¨å¯¼ç»“æœï¼ˆç”±ã€ï½œã€‘è¿›è¡Œåˆ†éš”ï¼‰ï¼Œæˆ‘ä»¬è®¤ä¸ºä¸åŒçš„å³éƒ¨ä»£è¡¨ç€ä¸åŒçš„äº§ç”Ÿå¼ï¼Œè€Œæ¯ä¸€ä¸ªäº§ç”Ÿå¼åé¢éƒ½å¯ä»¥è·Ÿç›¸åº”çš„ä¸€ç³»åˆ—æ“ä½œã€{â€¦}ã€‘ï¼Œè¡¨ç¤ºå‘ç”Ÿè¿™ä¸€ä¸ªäº§ç”Ÿå¼çš„å½’çº¦æ—¶ä¼šæ‰§è¡Œçš„ç›¸åº”åŠ¨ä½œ\n\næ“ä½œä¸­æˆ‘ä»¬å¯ä»¥ç”¨ã€$ã€‘æ¥å¼•ç”¨äº§ç”Ÿå¼ä¸­çš„æ¯ä¸€ä¸ªtokenä»¥åŠç»ˆç»“ç¬¦ï¼Œå…¶ä¸­ã€$$ã€‘è¡¨ç¤ºäº§ç”Ÿå¼å·¦éƒ¨çš„éç»ˆç»“ç¬¦ï¼ˆå†’å·å·¦è¾¹çš„éç»ˆç»“ç¬¦ï¼‰ï¼Œã€$nã€‘è¡¨ç¤ºäº§ç”Ÿå¼å³éƒ¨ç¬¬nä¸ªéç»ˆç»“ç¬¦/token/å­—ç¬¦ä¸²çš„å€¼\nâš ï¸å½“ã€$nã€‘æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å¸¸é‡æ—¶ï¼ŒBisonä¼šæç¤ºè¿™ä¸ªã€$nã€‘æ²¡æœ‰å£°æ˜ç±»å‹ï¼Œä½†ä¸ä¼šå½±å“ç¨‹åºçš„è¿è¡Œï¼Œå½“ç„¶ä½ è§‰å¾—éš¾å—çš„è¯å¯ä»¥ç›´æ¥å°†å…¶æ›¿æ¢æˆå­—ç¬¦ä¸²çš„å­—é¢å€¼\n\näº§ç”Ÿå¼çš„å³éƒ¨æ˜¯å¯ä»¥ä¸ºç©ºçš„ï¼Œè¿™å°±ç›¸å½“äºæ–‡æ³•ä¸­çš„ç©ºä¸²\n\näº§ç”Ÿå¼ä¸­%prec token_nameå¯ä»¥ä½¿%precå·¦è¾¹çš„äº§ç”Ÿå¼å…·æœ‰å’Œtoken_nameç›¸åŒçš„ä¼˜å…ˆçº§\n\næœ€ä¸‹é¢çš„éƒ¨åˆ†ä¹Ÿè·ŸFlexç±»ä¼¼ï¼Œä¼šè¢«ç›´æ¥å¤åˆ¶åˆ°ç”Ÿæˆä»£ç çš„åº•éƒ¨ï¼Œå‡½æ•°yyparse()ä¼šæ‰§è¡Œè¯­æ³•åˆ†æè¿‡ç¨‹ï¼Œæ¥ä¸‹æ¥ä½ å¯ä»¥å¢åŠ ä¸€äº›è¾“å‡ºåˆ†æç»“æœçš„ä»£ç \n\nä»¥ä¸Šåªæ˜¯Bisonæœ€åŸºç¡€çš„è§„åˆ™ï¼Œå¸Œæœ›æ›´åŠ å…¨é¢ç³»ç»Ÿåœ°å­¦ä¹ å¯ä»¥å‚é˜…ã€Šflexä¸bisonã€‹.\n\n\n\nâˆ«  â€œparser.hâ€#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdarg.h&gt;\n\nextern int yylineno;\nextern char* yytext;\nextern int yylex();\n\ntypedef enum {NUM,TEXT} TYPE;\n\nvoid yyerror(const char* msg)\n{\n    printf(\"\\033[1;31m%s at line %d\\033[0m: %s\\n\",msg,yylineno,yytext);\n}\n\nint OCT2DEC(char* text)\n{\n    int sum=0;\n    for(int i=1;i&lt;strlen(text);++i)\n        sum=sum*8+(text[i]-'0');\n    return sum;\n}\n\nint HEX2DEC(char* text)\n{\n    int sum=0;\n    for(int i=2;i&lt;strlen(text);++i)\n    {\n        if(text[i]&gt;='0'&amp;&amp;text[i]&lt;='9')\n            sum=sum*16+(text[i]-'0');\n        else if(text[i]&gt;='a'&amp;&amp;text[i]&lt;='f')\n            sum=sum*16+(text[i]-'a'+10);\n        else\n            sum=sum*16+(text[i]-'A'+10);\n    }\n    return sum;\n}\n\ntypedef struct ASTnode\n{\n    TYPE type;\n    char* text;\n    int num;\n    struct ASTnode* next;\n    struct ASTnode* child;\n}ASTnode;\n\nASTnode* ASThead=NULL;\n\n//generate new node\nASTnode* newASTnode(TYPE type, char* text, int num, ASTnode* nxt, ASTnode* child)\n{\n    ASTnode* node=(ASTnode*)malloc(sizeof(ASTnode)); //ä¸æ˜¯sizeof(ASTnode*)!!!\n    node-&gt;type=type;\n    if(type==TEXT)\n        node-&gt;text=strdup(text);\n    else\n        node-&gt;num=num;\n    node-&gt;next=nxt;\n    node-&gt;child=child;\n    return node;\n}\n\n//connect sibling nodes\nvoid connectASTnode(int num,...)\n{\n    va_list valist;\n    va_start(valist,num);\n    ASTnode* node=va_arg(valist,ASTnode*);\n    for(int i=1;i&lt;num;++i)\n    {\n        ASTnode* next=va_arg(valist,ASTnode*);\n        node-&gt;next=next;\n        node=next;\n    }\n    node-&gt;next=NULL;\n    va_end(valist);\n}\n\nvoid outputAST(ASTnode* head,int tab)\n{\n    switch (head-&gt;type)\n    {\n        case NUM:\n            printf(\"\\033[1;35m%d\\033[0m\\n\",head-&gt;num);\n            break;\n        case TEXT:\n            if(head-&gt;child!=NULL)\n                printf(\"\\033[1;32m%s\\033[0m\\n\",head-&gt;text);\n            else\n                printf(\"\\033[1;34m%s\\033[0m\\n\",head-&gt;text);\n            break;\n    }\n    ASTnode* node=head-&gt;child;\n    while(node!=NULL)\n    {\n        for(int i=0;i&lt;tab;++i)\n            printf(\"\\t\");\n        printf(\"â””â”€â”€â”€â”€â”€â”€â”€\");\n        outputAST(node,tab+1);\n        node=node-&gt;next;\n    }\n}\n\nvoid freeAST(ASTnode *head)\n{\n    ASTnode *node=head-&gt;child;\n    while (node!=NULL)\n    {\n        freeAST(node);\n        node=node-&gt;next;\n    }\n    if(head-&gt;type==TEXT)\n        free(head-&gt;text);\n    free(head);\n}\n\n\nè¿™ä¸ªå¤´æ–‡ä»¶ä¸­ä¸»è¦åŒ…æ‹¬äº†ASTçš„æ„å»ºã€è¾“å‡ºã€é‡Šæ”¾ç­‰å‡½æ•°ï¼Œè¿˜æœ‰8è¿›åˆ¶ã€16è¿›åˆ¶è½¬åè¿›åˆ¶æ•°çš„å‡½æ•°\n\nèŠ‚ç‚¹ASTnodeä¸­æ—¢å¯ä»¥å­˜å­—ç¬¦ä¸²ä¹Ÿå¯ä»¥å­˜æ•´å‹ï¼ŒTYPE typeæŒ‡æ˜äº†è¿™ä¸ªèŠ‚ç‚¹å­˜å‚¨çš„æ•°æ®ç±»å‹ï¼Œå…¶ä¸­TYPEæ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹\n\nå‰é¢3ä¸ªexternå£°æ˜äº†Flexï¼ˆlex.yy.cï¼‰ä¸­è‡ªå¸¦çš„ä¸‰ä¸ªå˜é‡ï¼Œä»è€Œå¯ä»¥åœ¨Bisonä¸­ä½¿ç”¨\n\nyyerroræ˜¯Bisonæ— æ³•å½’çº¦æ—¶ä¼šè°ƒç”¨çš„æŠ¥é”™å‡½æ•°ï¼Œè¿™é‡Œå®ƒä¼šè¾“å‡ºå‡ºé”™ä¿¡æ¯ã€å‡ºé”™è¡Œæ•°ä»¥åŠå‡ºé”™å­—ç¬¦ä¸²\n\nconnectASTnodeå‡½æ•°ä½¿ç”¨äº†Cè¯­è¨€ä¸­å¤šå‚æ•°å‡½æ•°çš„æœºåˆ¶ï¼Œå¯ä»¥è¿æ¥ä»»æ„ä¸ªæ•°çš„å…„å¼ŸèŠ‚ç‚¹ï¼Œæ¯å¤©ä¸€ä¸ªmake bugå°é­”æ³•\n#include &lt;stdarg.h&gt;\n// num is number of parameters in ...\ntype func_name(int num,...)\n{\n  // å£°æ˜å‚æ•°åˆ—è¡¨\n    va_list valist;\n    va_start(valist,num);\n  // ä»¥TYPEç±»å‹å–å‡ºå‚æ•°\n    TYPE val=va_arg(valist,TYPE);\n    for(int i=1;i&lt;num;++i)\n    {\n        TYPE next=va_arg(valist,TYPE);\n        ...\n    }\n    va_end(valist);\n}\n\nCè¯­è¨€ä¸çŸ¥é“æ€ä¹ˆè¾“å‡ºæ ‘ï¼Œæ‰€ä»¥é‡‡ç”¨äº†æ–‡ä»¶æ ‘çš„å½¢å¼ï¼Œä»¥tabæ•°è¡¨ç¤ºè¯¥èŠ‚ç‚¹æ‰€å¤„çš„æ·±åº¦ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹éƒ½æ˜¯å…¶ä¸Šæ–¹æœ€è¿‘çš„tab-1èŠ‚ç‚¹\n\nç”¨å…¨å±€å˜é‡ASTheadæ¥å­˜å‚¨ASTçš„å¤´èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨æ¯æ¬¡æ‰§è¡Œå½’çº¦åˆ°å¼€å§‹ç¬¦å·ï¼ˆå³å·¦éƒ¨æ˜¯å¼€å§‹ç¬¦å·ï¼‰çš„äº§ç”Ÿå¼æ—¶å°†å¼€å§‹ç¬¦å·çš„èŠ‚ç‚¹èµ‹å€¼ç»™ASTheadï¼Œé‚£ä¹ˆæœ€åä¸€æ¬¡èµ‹å€¼ï¼ˆå³æœ€åä¸€æ¬¡å½’çº¦ï¼‰çš„å¿…ç„¶æ˜¯ASTçš„å¤´èŠ‚ç‚¹\n\n\n\nâˆ¬ SysY.l%option yylineno\n\n%{\n    #include \"SysY.tab.h\"\n    #define UNEXPECTED 0\n%}\n\nINT                 int\nVOID                void\nCONST               const\nIF                  if\nELSE                else\nWHILE               while\nBREAK               break\nCONTINUE            continue\nRETURN              return\nMULDIVSUR           \"*\"|\"/\"|\"%\"\nADDSUB              \"+\"|\"-\"\nCMP                 \"&lt;\"|\"&gt;\"|\"&lt;=\"|\"&gt;=\"\nEQNEQ               \"==\"|\"!=\"\nASSIGN              \"=\"\nNONZERO             [1-9]\nDIGIT               [0-9]\nLETTER              [A-Za-z]\nOCTAL_DIGIT         [0-7]\nOCTAL_CONST         0{OCTAL_DIGIT}*\nILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z]({LETTER}|{DIGIT})*\nHEX_PREFIX          0x|0X\nHEX_DIGIT           [0-9a-fA-F]\nHEX_CONST           {HEX_PREFIX}{HEX_DIGIT}+\nILLEGAL_HEX_CONST   {HEX_PREFIX}({LETTER}|{DIGIT})*\nNONDIGIT            {LETTER}|\"_\"\nID                  {NONDIGIT}({DIGIT}|{NONDIGIT})*\nDEC_CONST           {NONZERO}{DIGIT}*  \nCOMMENT1            \"/*\"[^*]*\"*\"+([^*/][^*]*\"*\"+)*\"/\"\nCOMMENT2            \"//\".*                                                                                \n\n%%\n\n{INT}                   { yylval.str=strdup(yytext); return INT; }\n{VOID}                  { yylval.str=strdup(yytext); return VOID; }\n{OCTAL_CONST}           { yylval.str=strdup(yytext); return OCTAL_CONST; }\n{ILLEGAL_OCTAL_CONST}   { yylval.str=strdup(yytext); return HEX_CONST; }\n{HEX_CONST}             { yylval.str=strdup(yytext); return HEX_CONST; }\n{ILLEGAL_HEX_CONST}     { yylval.str=strdup(yytext); return DEC_CONST; }\n{DEC_CONST}             { yylval.str=strdup(yytext); return DEC_CONST; }\n{CONST}                 { yylval.str=strdup(yytext); return CONST; }\n{IF}                    { yylval.str=strdup(yytext); return IF; }\n{ELSE}                  { yylval.str=strdup(yytext); return ELSE; }\n{WHILE}                 { yylval.str=strdup(yytext); return WHILE; }\n{BREAK}                 { yylval.str=strdup(yytext); return BREAK; }\n{CONTINUE}              { yylval.str=strdup(yytext); return CONTINUE; }\n{RETURN}                { yylval.str=strdup(yytext); return RETURN; }\n{MULDIVSUR}             { yylval.str=strdup(yytext); return MULDIVSUR; } \n{ADDSUB}                { yylval.str=strdup(yytext); return ADDSUB; } \n{CMP}                   { yylval.str=strdup(yytext); return CMP; } \n{EQNEQ}                 { yylval.str=strdup(yytext); return EQNEQ; } \n{ASSIGN}                { yylval.str=strdup(yytext); return ASSIGN; }\n{ID}                    { yylval.str=strdup(yytext); return ID; }\n\"(\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\")\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"[\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"]\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"{\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"}\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\";\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\",\"                     { yylval.str=strdup(yytext); return yytext[0]; }\n\"&amp;&amp;\"                    { yylval.str=strdup(yytext); return AND; }\n\"||\"                    { yylval.str=strdup(yytext); return OR; }\n{COMMENT1}|{COMMENT2}   { }\n[ \\t\\n]                 { }\n.                       { yylval.str=strdup(yytext); return UNEXPECTED; }\n%%\n\nint yywrap(void) \n{ \n    return 1;\n}\n\n\nâ€œSysY.tab.hâ€æ˜¯bison -d SysY.yäº§ç”Ÿçš„ï¼ŒBisonä¼šå°†ä½ å£°æ˜çš„tokenè¿›è¡Œenumæ”¾åœ¨ç”Ÿæˆçš„å¤´æ–‡ä»¶â€SysY.tab.hâ€ä¸­ï¼Œæ‰€ä»¥ä½ æ— éœ€è‡ªå·±å†å†™ä¸€ä¸ªâ€translator.hâ€\næ³¨æ„åœ¨Flexä¸­éœ€è¦å®Œæˆå¯¹tokençš„èµ‹å€¼ï¼Œå¦‚æœtokençš„ç±»å‹ä¸ºTYPEï¼ˆå–è‡ª%unionï¼‰ï¼Œé‚£ä¹ˆä½ éœ€è¦ä»¥yylval.TYPE=...çš„å½¢å¼è¿›è¡Œèµ‹å€¼ï¼Œç„¶åreturn token_name;\nchar* strdup(char *s)å‡½æ•°ä¼šå¼€è¾Ÿä¸€æ®µæ–°çš„ç©ºé—´å¹¶å¤åˆ¶å­—ç¬¦ä¸²sçš„å€¼ï¼Œç„¶åè¿”å›æ–°ç©ºé—´çš„æŒ‡é’ˆï¼ˆéœ€è¦freeï¼‰\n\n\nâˆ­ SysY.y%start CompUnit\n%expect 1\n\n%{\n    #include \"parser.h\"\n%}\n\n%union\n{\n    int     num;\n    char*   str;\n    struct ASTnode* node; /*\"struct\" is indispensable*/\n}\n\n%token &lt;str&gt; INT VOID CONST IF ELSE WHILE BREAK CONTINUE RETURN ID OCTAL_CONST HEX_CONST DEC_CONST\n%right &lt;str&gt; ASSIGN\n%left &lt;str&gt; OR\n%left &lt;str&gt; AND\n%left &lt;str&gt; EQNEQ\n%left &lt;str&gt; CMP\n%left &lt;str&gt; ADDSUB\n%left &lt;str&gt; MULDIVSUR\n\n%type&lt;node&gt; Number CompUnit Decl FuncDef ConstDecl VarDecl ConstDef ConstDefBlock ConstExpBlock ConstInitVal ConstExp ConstInitFlag ConstValBlock VarDef\n    VarDefFlag InitVal Exp InitValFlag InitValBlock FuncFParams Block FuncFParam FuncFParamBlock ExpBlockFlag ExpBlock BlockItemBlock BlockItem \n    Stmt LVal ExpFlag StmtFlag Cond AddExp LOrExp PrimaryExp UnaryExp FuncFParamsFlag FuncRParams UNARYOP CommaExpBlock MulExp RelExp EqExp LAndExp\n\n%%\nCompUnit:       CompUnit Decl                           {\n                                                            connectASTnode(2,$1,$2);\n                                                            ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);\n                                                        }\n                | CompUnit FuncDef                      {\n                                                            connectASTnode(2,$1,$2);\n                                                            ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);\n                                                        }\n                | Decl                                  {ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);}\n                | FuncDef                               {ASThead=$$=newASTnode(TEXT,\"CompUnit\",0,NULL,$1);}\nDecl:           ConstDecl                               {$$=newASTnode(TEXT,\"Decl\",0,NULL,$1);}\n                | VarDecl                               {$$=newASTnode(TEXT,\"Decl\",0,NULL,$1);}\nConstDecl:      CONST INT ConstDef ConstDefBlock ';'    {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n5=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(5,n1,n2,$3,$4,n5);\n                                                            $$=newASTnode(TEXT,\"ConstDecl\",0,NULL,n1);\n                                                        }\nConstDefBlock:  ConstDefBlock ',' ConstDef              {\n                                                            ASTnode *n=newASTnode(TEXT,\",\",0,$3,NULL);\n                                                            connectASTnode(3,$1,n,$3);\n                                                            $$=newASTnode(TEXT,\"ConstDefBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstDefBlock\",0,NULL,n);\n                                                        }\nConstDef:       ID ConstExpBlock ASSIGN ConstInitVal    {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,$3,0,NULL,NULL);\n                                                            connectASTnode(4,n1,$2,n3,$4);\n                                                            $$=newASTnode(TEXT,\"ConstDef\",0,NULL,n1);\n                                                        }\nConstExpBlock:  ConstExpBlock '[' ConstExp ']'          {\n                                                            ASTnode *n2=newASTnode(TEXT,\"[\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\"]\",0,NULL,NULL);\n                                                            connectASTnode(4,$1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"ConstExpBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstExpBlock\",0,NULL,n);\n                                                        }\nConstInitVal:   ConstExp                                {$$=newASTnode(TEXT,\"ConstInitVal\",0,NULL,$1);}\n                |'{'ConstInitFlag'}'                    {\n                                                            ASTnode *n1=newASTnode(TEXT,\"{\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"}\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"ConstInitVal\",0,NULL,n1);\n                                                        }\nConstInitFlag:  ConstInitVal ConstValBlock              {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"ConstInitFlag\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstInitFlag\",0,NULL,n);\n                                                        }\nConstValBlock:  ConstValBlock ',' ConstInitVal          {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"ConstValBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ConstValBlock\",0,NULL,n);\n                                                        }\nVarDecl:        INT VarDef VarDefFlag ';'               {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(4,n1,$2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"VarDecl\",0,NULL,n1);\n                                                        }\nVarDefFlag:    ',' VarDef VarDefFlag                    {\n                                                            ASTnode *n1=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,$3);\n                                                            $$=newASTnode(TEXT,\"VarDefFlag\",0,NULL,n1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"VarDefFlag\",0,NULL,n);\n                                                        }\nVarDef:         ID ConstExpBlock                        {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            connectASTnode(2,n1,$2);\n                                                            $$=newASTnode(TEXT,\"VarDef\",0,NULL,n1);\n                                                        }\n                | ID ConstExpBlock ASSIGN InitVal       {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,$3,0,NULL,NULL);\n                                                            connectASTnode(4,n1,$2,n3,$4);\n                                                            $$=newASTnode(TEXT,\"VarDef\",0,NULL,n1);\n                                                        }\nInitVal:          Exp                                   {$$=newASTnode(TEXT,\"InitVal\",0,NULL,$1);}\n                | '{'InitValFlag'}'                     {\n                                                            ASTnode *n1=newASTnode(TEXT,\"{\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"}\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"InitVal\",0,NULL,n1);\n                                                        }\nInitValFlag:    InitVal InitValBlock                    {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"InitValFlag\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"InitValFlag\",0,NULL,n);\n                                                        }\nInitValBlock:   InitValBlock ',' InitVal                {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"InitValBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"InitValFlag\",0,NULL,n);\n                                                        }\nFuncDef:        INT ID '(' FuncFParams')' Block         {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n5=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(6,n1,n2,n3,$4,n5,$6);\n                                                            $$=newASTnode(TEXT,\"FuncDef\",0,NULL,n1);\n                                                        }\n                | VOID ID '(' FuncFParams')' Block      {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n5=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(6,n1,n2,n3,$4,n5,$6);\n                                                            $$=newASTnode(TEXT,\"FuncDef\",0,NULL,n1);\n                                                        }\nFuncFParams:    FuncFParam FuncFParamBlock              {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"FuncFParams\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"FuncFParams\",0,NULL,n);\n                                                        }\nFuncFParamBlock:FuncFParamBlock ',' FuncFParam          {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"FuncFParamBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"FuncFParamBlock\",0,NULL,n);\n                                                        }\nFuncFParam:     INT ID ExpBlockFlag                     {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,n1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"FuncFParam\",0,NULL,n1);\n                                                        }\nExpBlockFlag:   '['']' ExpBlock                         {\n                                                            ASTnode *n1=newASTnode(TEXT,\"[\",0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"]\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"ExpBlockFlag\",0,NULL,n1);\n                                                        }\nExpBlock:       ExpBlock '['Exp']'                      {\n                                                            ASTnode *n2=newASTnode(TEXT,\"[\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\"]\",0,NULL,NULL);\n                                                            connectASTnode(4,$1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"FuncDef\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ExpBlock\",0,NULL,n);\n                                                        }\nBlock:          '{' BlockItemBlock '}'                  {\n                                                            ASTnode *n1=newASTnode(TEXT,\"{\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\"}\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"Block\",0,NULL,n1);\n                                                        }\nBlockItemBlock: BlockItemBlock BlockItem                {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"BlockItemBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"BlockItemBlock\",0,NULL,n);\n                                                        }\nBlockItem:        Decl                                  {$$=newASTnode(TEXT,\"BlockItem\",0,NULL,$1);}\n                | Stmt                                  {$$=newASTnode(TEXT,\"BlockItem\",0,NULL,$1);}\nStmt:           LVal ASSIGN Exp ';' %prec ASSIGN        {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(4,$1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,$1);\n                                                        }\n                | ExpFlag';'                            {\n                                                            ASTnode *n2=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(2,$1,n2);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,$1);\n                                                        }\n                | Block                                 {$$=newASTnode(TEXT,\"Stmt\",0,NULL,$1);}\n                | IF'('Cond')' Stmt StmtFlag            {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(6,n1,n2,$3,n4,$5,$6);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | WHILE'('Cond')' Stmt                  {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(5,n1,n2,$3,n4,$5);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | BREAK';'                              {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(2,n1,n2);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | CONTINUE';'                           {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(2,n1,n2);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\n                | RETURN ExpFlag';'                     {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\";\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"Stmt\",0,NULL,n1);\n                                                        }\nExpFlag:          Exp                                   {$$=newASTnode(TEXT,\"ExpFlag\",0,NULL,$1);}\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"ExpFlag\",0,NULL,n);\n                                                        }\nStmtFlag:       ELSE Stmt                               {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            connectASTnode(2,n1,$2);\n                                                            $$=newASTnode(TEXT,\"StmtFlag\",0,NULL,n1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"StmtFlag\",0,NULL,n);\n                                                        }\nExp:            AddExp                                  {$$=newASTnode(TEXT,\"Exp\",0,NULL,$1);}\nCond:           LOrExp                                  {$$=newASTnode(TEXT,\"Cond\",0,NULL,$1);}\nLVal:           ID ExpBlock                             {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            connectASTnode(2,n1,$2);\n                                                            $$=newASTnode(TEXT,\"LVal\",0,NULL,n1);\n                                                        }\nPrimaryExp:     '('Exp')'                               {\n                                                            ASTnode *n1=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n3=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(3,n1,$2,n3);\n                                                            $$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,n1);\n                                                        }\n                | LVal                                  {$$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,$1);}\n                | Number                                {$$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,$1);}\nNumber:         OCTAL_CONST                             {\n                                                            ASTnode *n=newASTnode(NUM,NULL,OCT2DEC($1),NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"Number\",0,NULL,n);\n                                                        }\n                | HEX_CONST                             {\n                                                            ASTnode *n=newASTnode(NUM,NULL,HEX2DEC($1),NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"Number\",0,NULL,n);\n                                                        }\n                | DEC_CONST                             {\n                                                            ASTnode *n=newASTnode(NUM,NULL,atoi($1),NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"Number\",0,NULL,n);\n                                                        }\nUnaryExp:       PrimaryExp                              {$$=newASTnode(TEXT,\"UnaryExp\",0,NULL,$1);}\n                | ID '(' FuncFParamsFlag ')'            {\n                                                            ASTnode *n1=newASTnode(TEXT,$1,0,NULL,NULL),\n                                                                    *n2=newASTnode(TEXT,\"(\",0,NULL,NULL),\n                                                                    *n4=newASTnode(TEXT,\")\",0,NULL,NULL);\n                                                            connectASTnode(4,n1,n2,$3,n4);\n                                                            $$=newASTnode(TEXT,\"PrimaryExp\",0,NULL,n1);\n                                                        }\n                | UNARYOP UnaryExp                      {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"UnaryExp\",0,NULL,$1);\n                                                        }\nFuncFParamsFlag:FuncRParams                             {$$=newASTnode(TEXT,\"FuncFParamsFlag\",0,NULL,$1);}\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"FuncFParamsFlag\",0,NULL,n);\n                                                        }\nFuncRParams:    Exp CommaExpBlock                       {\n                                                            connectASTnode(2,$1,$2);\n                                                            $$=newASTnode(TEXT,\"FuncRParams\",0,NULL,$1);\n                                                        }\nCommaExpBlock:  CommaExpBlock ',' Exp                   {\n                                                            ASTnode *n2=newASTnode(TEXT,\",\",0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"CommaExpBlock\",0,NULL,$1);\n                                                        }\n                | /*Îµ*/                                 {\n                                                            ASTnode *n=newASTnode(TEXT,\"Îµ\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"CommaExpBlock\",0,NULL,n);\n                                                        }\nUNARYOP:        ADDSUB                                  {\n                                                            ASTnode *n=newASTnode(TEXT,$1,0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"UNARYOP\",0,NULL,n);\n                                                        }\n                | '!'                                   {\n                                                            ASTnode *n=newASTnode(TEXT,\"!\",0,NULL,NULL);\n                                                            $$=newASTnode(TEXT,\"UNARYOP\",0,NULL,n);\n                                                        }\nMulExp:         UnaryExp                                {$$=newASTnode(TEXT,\"MulExp\",0,NULL,$1);}\n                | MulExp MULDIVSUR UnaryExp             {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"MulExp\",0,NULL,$1);\n                                                        }\nAddExp:         MulExp                                  {$$=newASTnode(TEXT,\"AddExp\",0,NULL,$1);}\n                | AddExp ADDSUB MulExp                  {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"MulExp\",0,NULL,$1);\n                                                        }\nRelExp:         AddExp                                  {$$=newASTnode(TEXT,\"RelExp\",0,NULL,$1);}\n                | RelExp CMP AddExp                     {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"RelExp\",0,NULL,$1);\n                                                        }\nEqExp:          RelExp                                  {$$=newASTnode(TEXT,\"EqExp\",0,NULL,$1);}\n                | EqExp EQNEQ RelExp                    {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"EqExp\",0,NULL,$1);\n                                                        }\nLAndExp:        EqExp                                   {$$=newASTnode(TEXT,\"LAndExp\",0,NULL,$1);}\n                | LAndExp AND EqExp                     {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"LAndExp\",0,NULL,$1);\n                                                        }\nLOrExp:         LAndExp                                 {$$=newASTnode(TEXT,\"LOrExp\",0,NULL,$1);}\n                | LOrExp OR LAndExp                     {\n                                                            ASTnode *n2=newASTnode(TEXT,$2,0,NULL,NULL);\n                                                            connectASTnode(3,$1,n2,$3);\n                                                            $$=newASTnode(TEXT,\"LOrExp\",0,NULL,$1);\n                                                        }\nConstExp:       AddExp                                  {$$=newASTnode(TEXT,\"ConstExp\",0,NULL,$1);}\n%%\n\nint main()\n{\n    yyparse();\n    outputAST(ASThead,0);\n    freeAST(ASThead);\n    return 0;\n}\n\n\nTest.cint main()\n{\n    int bb = 0x12d23;\n    if (abc &gt;= bb) // hello\n            return 8;\n    /*This is a test\n    */\n}\n\nCast Magic ğŸª„flex SysY.l\nbison -d SysY.y\nclang SysY.tab.c lex.yy.c\ncat test.c|./a.out\n\nOutput\n","slug":"Bison-Flex-è¯­æ³•åˆ†æç”Ÿæˆä¸­","date":"2022-05-05T14:23:51.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"f49316d46cb145f81e643476c18ee695","title":"ã€Œ1018ã€Public Bike Management","content":"There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.\nThe Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.\n\n\nWhen a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.\n\nThe above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex  is the current number of bikes stored at . Given that the maximum capacity of each station is 10. To solve the problem at , we have 2 different shortest paths:\n\nPBMC -&gt;  -&gt; . In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from  and then take 5 bikes to , so that both stations will be in perfect conditions.\nPBMC -&gt;  -&gt; . This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 4 numbers: , always an even number, is the maximum capacity of each station; , the total number of stations; , the index of the problem station (the stations are numbered from 1 to , and PBMC is represented by the vertex 0); and , the number of roads. The second line contains  non-negative numbers  where each  is the current number of bikes at  respectively. Then  lines follow, each contains 3 numbers: , , and  which describe the time  taken to move betwen stations  and . All the numbers in a line are separated by a space.\nOutput Specification:For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0âˆ’&gt;âˆ’&gt;â‹¯âˆ’&gt;. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of  is adjusted to perfect.\nNote that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judgeâ€™s data guarantee that such a path is unique.\nSample Input:10 3 3 5\n6 7 0\n0 1 1\n0 2 1\n0 3 3\n1 3 1\n2 3 1\n\nSample Output:3 0-&gt;2-&gt;3 0\n\n\nÎ©æç¹ç¿»è¯‘ï¼šPBMCæ˜¯æ­å·å…¬å…±è‡ªè¡Œè½¦ç®¡ç†éƒ¨é—¨ï¼Œè´Ÿè´£ç®¡ç†å¹³è¡¡å„ä¸ªè‡ªè¡Œè½¦ç§Ÿå‡­ç‚¹çš„è‡ªè¡Œè½¦æ•°é‡ã€‚å½“ä¸€ä¸ªç§Ÿå‡­ç‚¹çš„è‡ªè¡Œè½¦æ•°é‡åˆšå¥½æ˜¯æœ€å¤§æ•°é‡çš„ä¸€åŠæ—¶ï¼Œæˆ‘ä»¬è®¤ä¸ºæ˜¯æ°å¥½çš„ã€‚å½“ä¸€ä¸ªç«™ç‚¹ä¸ŠæŠ¥è‡³PBMCéœ€è¦è°ƒæ•´å…¶è‡ªè¡Œè½¦æ•°é‡æ—¶ï¼ŒPBMCä¼šé€‰æ‹©ä¸€æ¡è€—æ—¶æœ€çŸ­çš„è·¯å‰å¾€ï¼ŒåŒæ—¶å°†æ²¿é€”ç«™ç‚¹çš„è‡ªè¡Œè½¦æ•°é‡ä¹Ÿè°ƒæ•´è‡³æ°å¥½çš„çŠ¶æ€ã€‚åœ¨å‰å¾€çš„é€”ä¸­ï¼Œé€”ç»ç«™ç‚¹å¤šå‡ºæ¥çš„è‡ªè¡Œè½¦å¯ä»¥å¡«è¡¥åˆ°åé¢éœ€è¦çš„ç«™ç‚¹ï¼Œè¿™æ ·å¸¦å›PBMCçš„è‡ªè¡Œè½¦å°±ä¼šå°‘ä¸€äº›ã€‚æ³¨æ„ï¼Œè¿”å›é€”ä¸­ä¸è°ƒæ•´ä»»ä½•ç«™ç‚¹ã€‚å¦‚æœæœ‰å¤šæ¡è€—æ—¶ç›¸åŒçš„è·¯å¾„åˆ™é€‰æ‹©å¸¦ä¸Šè‡ªè¡Œè½¦æ•°é‡æœ€å°‘çš„è·¯ï¼Œå¦‚æœè¿˜æ˜¯æœ‰ç›¸åŒçš„ï¼Œåˆ™é€‰æ‹©å¸¦å›è‡ªè¡Œè½¦æœ€å°‘çš„è·¯ã€‚ç°ç»™å‡ºç«™ç‚¹çš„æœ€å¤§å®¹é‡ã€ç«™ç‚¹æ•°é‡ã€ä¸ŠæŠ¥çš„ç«™ç‚¹ç¼–å·ã€å„æ¡è·¯å¾„çš„è€—æ—¶æƒ…å†µï¼Œéœ€è¦è¾“å‡ºæœ€ä¼˜è·¯çº¿ä»¥åŠéœ€è¦å¸¦ä¸Šå’Œå¸¦å›çš„è‡ªè¡Œè½¦æ•°ã€‚é¢˜ç›®ä¿è¯æœ€ä¼˜è·¯å¾„å”¯ä¸€ã€‚\nè¿™é¢˜ç›®ï¼Œæœ‰æ¯’ã€‚æ·±åˆ»ç†è§£ä»€ä¹ˆå«ï¼Œæœ‰å‘çš„åœ°æ–¹å°±æœ‰æˆ‘ã€‚\nç†è§£é”™é¢˜æ„ï¼Œé‡æ„äº†å‡ æ¬¡ä»£ç ï¼ŒåºŸäº†å¥½å¤šæ—¶é—´ã€‚åšå®Œå†ä»”ç»†é˜…è¯»é¢˜ç›®ï¼Œæ„Ÿè§‰è¿˜æ˜¯æ²¡getåˆ°é‚£å‡ ä¸ªå‘ï¼š\n\nå›å»çš„è·¯ä¸Šä¸èƒ½è°ƒæ•´å„ç«™ç‚¹è‡ªè¡Œè½¦ï¼Œåªèƒ½åœ¨æ¥çš„è·¯ä¸Šç”¨å‰é¢ç«™ç‚¹å¤šå‡ºæ¥çš„è‡ªè¡Œè½¦å¡«è¡¥åé¢çš„ç«™ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´åé¢ç«™ç‚¹å¤šå‡ºæ¥ä¸èƒ½å¡«è¡¥å‰é¢çš„ç«™ç‚¹ï¼Œåªèƒ½å¸¦å›å»ã€‚è¿™æ˜¯ä»€ä¹ˆäººå·¥æ™ºéšœï¼ŸPBMCæ—©å°±çŸ¥é“å„ä¸ªç«™ç‚¹çš„è‡ªè¡Œè½¦æ•°é‡ï¼Œä¸ºä»€ä¹ˆä¸èƒ½åšåˆ°å…¨å±€è§„åˆ’å‘¢ï¼ˆæ ¼å±€å°äº†ï¼Œé”»ç‚¼ç¼–ç¨‹èƒ½åŠ›è€Œå·²ï¼Œä»¥åè¿˜è¦é¢å¯¹å„ç§ç”²æ–¹çˆ¸çˆ¸å‘¢\nè¾“å‡ºè¦æ±‚é‡Œè¯´ï¼Œå¦‚æœè·¯å¾„ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºå¸¦å›æ•°é‡æœ€å°‘çš„è·¯å¾„ã€‚å½“æ—¶æˆ‘ä¹Ÿçº³é—·ï¼Œå› ä¸ºå‰é¢ä¸¾çš„é‚£ä¸ªä¾‹å­é‡Œé¢é€‰æ‹©çš„æ˜¯å¸¦ä¸Šæ•°é‡æœ€å°‘çš„è·¯ã€‚ç»“æœå…¶å®æ˜¯å…ˆé€‰æ‹©å¸¦ä¸Šæœ€å°‘çš„ï¼Œå†é€‰æ‹©å¸¦å›æœ€å°‘çš„ã€‚ã€‚ï¼ˆè¯·æ‰“å¼€éº¦å…‹é£å¥½å¥½äº¤æµ\n\næ€»ä¹‹ï¼Œä¸æ‡‚ã€‚\n\n\næ˜¾ç„¶ï¼Œè¿™ä¸æ˜¯ä¸€é“å•çº¯çš„Dijkstraç®—æ³•é¢˜ï¼ŒDijkstraçš„åŸºæœ¬æ€æƒ³æœ¬è´¨ä¸Šæ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢BFSï¼Œä½†åªèƒ½æ‰¾åˆ°ä¸€æ¡æœ€çŸ­è·¯ï¼Œè€Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°æ‰€æœ‰æœ€çŸ­è·¯ï¼Œå› æ­¤éœ€è¦åŠ ä»¥æ”¹è¿›ã€‚\nDijkstraç®—æ³•ä¸­ï¼Œå½“ä¸€ä¸ªæ–°ç‚¹è¢«çº³å…¥èµ·ç‚¹æ‰€åœ¨çš„é›†åˆä¸­æ—¶ï¼Œæˆ‘ä»¬ä¼šæ›´æ–°ä¸è¯¥ç‚¹ç›¸è¿çš„ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»ï¼Œå¦‚æœæ›´æ–°çš„è·ç¦»â‰¥ åŸè·ç¦»çš„è¯å°±ä¸éœ€è¦æ›´æ–°ã€‚é‚£ä¹ˆåœ¨è¿™ä¸ªé—®é¢˜ä¸­ï¼Œå¦‚æœæ›´æ–°çš„è·ç¦»==åŸè·ç¦»ï¼Œæˆ‘ä»¬ä¾ç„¶éœ€è¦è®°å½•ï¼Œä»è€Œä¿ç•™æ‰€æœ‰é•¿åº¦ç›¸åŒçš„è·¯å¾„ä¿¡æ¯ã€‚\né¦–å…ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ªvectoræ¥è®°å½•æ‰€æœ‰ç«™ç‚¹åˆ°PBMCï¼ˆç¼–å·ä¸º0ï¼‰çš„æœ€çŸ­è·ç¦»ï¼ˆè¿™é‡Œçš„è·ç¦»æ˜¯æ—¶é—´ï¼‰ï¼Œå¹¶åˆå§‹åŒ–æ‰€æœ‰è·ç¦»ä¸ºæœ€å¤§å€¼INFï¼š\nvector&lt;int&gt; dist(n + 1, INF); // #define INF INT32_MAX\n\nç„¶ååˆå§‹åŒ–çš„æ—¶å€™éœ€è¦å°†æ‰€æœ‰ä¸PBMCç›¸è¿çš„ç«™ç‚¹distä¿®æ”¹ä¸ºä»–ä»¬ä¹‹é—´çš„è·ç¦»ã€‚\nå¦å¤–è¿˜éœ€è¦æ ‡è®°å„ä¸ªç«™ç‚¹æ˜¯å¦å·²è¢«çº³å…¥é›†åˆï¼Œå…¶ä¸­è¡¨ç¤ºæ‰€æœ‰å·²ç»æ±‚å‡ºæœ€çŸ­è·ç¦»çš„ç«™ç‚¹ç¼–å·ï¼Œåˆå§‹æƒ…å†µä¸‹åªå«0ã€‚\nvector&lt;bool&gt; isVisited(n + 1, false);\nisVisited[0] = true;\n\næœ€é‡è¦çš„æˆ‘ä»¬è¿˜éœ€è¦å­˜å‚¨è·¯å¾„ï¼Œç”±äºæœ€åæ˜¯æ ¹æ®å¸¦ä¸Šå’Œå¸¦å›çš„è‡ªè¡Œè½¦æ•°è¿›è¡Œæœ€ä¼˜é€‰æ‹©ï¼Œå› æ­¤ä¹Ÿä¸€å¹¶å­˜äº†ï¼Œå› æ­¤è¯ç”Ÿäº†ä¸€ä¸ªç©¶æå¤æ‚çš„ç±»å‹ï¼š\n// vector&lt;vector&lt;pair&lt;pair&lt;send num,take back num&gt;,path points&gt;&gt;&gt;\nvector&lt;vector&lt;pair&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt;&gt;&gt; track(n + 1);\n\nç®€å•åœ°è¯´ï¼Œå°±æ˜¯æ‰€æœ‰ç«™ç‚¹éƒ½æ‹¥æœ‰ä¸€ä¸ªvectorï¼Œé‡Œé¢å­˜å‚¨äº†PBMCåˆ°è¯¥ç«™ç‚¹æ‰€æœ‰æœ€çŸ­è·¯å¾„çš„ä¿¡æ¯ï¼Œæ¯ä¸ªæœ€çŸ­è·¯å¾„ä¿¡æ¯æ˜¯ä¸€ä¸ªpair&lt;pair&lt;int,int&gt;,vector&lt;int&gt;&gt;ï¼Œåé¢çš„vector&lt;int&gt;å°±æ˜¯è¿™æ¡è·¯å¾„ä¸Šä¾æ¬¡çš„ç«™ç‚¹ç¼–å·ï¼Œå‰é¢pair&lt;int,int&gt;åˆ™æ˜¯è¿™æ¡è·¯å¾„åˆ°å½“å‰ç«™ç‚¹æ‰€å¿…é¡»å¸¦ä¸Šå’Œå¸¦å›çš„è‡ªè¡Œè½¦æ•°é‡ã€‚\næ¥ä¸‹æ¥æ¯æ¬¡å¾ªç¯éƒ½ä»distä¸­æ‰¾åˆ°è·ç¦»æœ€å°çš„ç«™ç‚¹min_idxï¼Œå°†è¯¥ç«™ç‚¹ç¼–å·çº³å…¥é›†åˆã€‚åœ¨æ›´æ–°ä¸è¯¥ç‚¹ç›¸è¿çš„ç«™ç‚¹dist[i]æ—¶ï¼Œå¦‚æœæ›´çŸ­äº†ï¼Œé‚£ä¹ˆæ›´æ–°dist[i]å¹¶å°†å…¶track[i]æ¸…ç©ºï¼Œç„¶åè¿›è¡Œâ€œå¦‚æœæ˜¯ç›¸ç­‰çš„â€çš„æ“ä½œï¼›å¦‚æœæ˜¯ç›¸ç­‰çš„ï¼Œè¯´æ˜åˆæ‰¾åˆ°äº†ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œé‚£ä¹ˆå°†track[min_idx]ä¸­çš„æ¯ä¸€æ¡è®°å½•æ›´æ–°ä¹‹åæ¨å…¥track[i]ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œtrack[i]ä¸­å­˜å‚¨çš„è·¯å¾„é•¿åº¦å‡ä¸ºdist[i]ï¼Œå› æ­¤ä¿®æ”¹dist[i]æ—¶å¿…é¡»æ¸…ç©ºtrack[i]ã€‚\nå¦å¤–num_to_perfect[i]å­˜å‚¨ç«™ç‚¹éœ€è¦å¤šå°‘è¾†è‡ªè¡Œè½¦æ‰èƒ½åˆ°è¾¾æ°å¥½çš„çŠ¶æ€ï¼Œä¸ºè´Ÿåˆ™è¡¨ç¤ºå¤šå‡ºæ¥çš„è‡ªè¡Œè½¦æ•°é‡ï¼š\nnum_to_perfect[i] = max_cap / 2 - num_to_perfect[i];\n\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n\n#define INF INT32_MAX\n\nusing namespace std;\ntypedef pair&lt;int, int&gt; info;\ntypedef pair&lt;info, vector&lt;int&gt;&gt; path;\n\nbool cmp(path &amp;a, path &amp;b)\n{return a.first.first &lt; b.first.first || a.first.first == b.first.first &amp;&amp; a.first.second &lt; b.first.second;}\n\nint main()\n{\n    int max_cap, n, sp, m, s1, s2, t;\n    cin &gt;&gt; max_cap &gt;&gt; n &gt;&gt; sp &gt;&gt; m;\n    vector&lt;int&gt; num_to_perfect(n + 1, 0), dist(n + 1, INF);\n    for (int i = 1; i &lt; n + 1; ++i)\n    {\n        cin &gt;&gt; num_to_perfect[i];\n        num_to_perfect[i] = max_cap / 2 - num_to_perfect[i];\n    }\n    map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; road;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; t;\n        road[s1].emplace_back(s2, t);\n        road[s2].emplace_back(s1, t);\n    }\n    vector&lt;vector&lt;path&gt;&gt; track(n + 1);\n    vector&lt;bool&gt; isVisited(n + 1, false);\n    isVisited[0] = true;\n    int min_dist = INF, min_idx = 0;\n  //initialization\n    for (auto &amp;s: road[0])\n    {\n        dist[s.first] = s.second;\n        info tmp = move(num_to_perfect[s.first] &lt; 0 ? info{0, -num_to_perfect[s.first]} : info{num_to_perfect[s.first], 0});\n        track[s.first].emplace_back(tmp, vector&lt;int&gt;{s.first});\n        min_dist = s.second &lt; min_dist ? (min_idx = s.first, s.second) : min_dist;\n    }\n    isVisited[min_idx] = true;\n    while (!isVisited[sp])\n    {\n      // update dist[i] for i in neighbor of min_idx\n        for (auto &amp;d: road[min_idx])\n        {\n            if (isVisited[d.first] || dist[min_idx] + d.second &gt; dist[d.first])\n                continue;\n            else if (dist[min_idx] + d.second &lt; dist[d.first])\n            {\n                track[d.first].clear();\n                dist[d.first] = dist[min_idx] + d.second;\n            }\n          // å°†min_idxçš„è·¯å¾„ä¿¡æ¯å»¶ç»­åˆ°d.first\n            // kä¸èƒ½æ˜¯å¼•ç”¨ï¼Œä¼šç›´æ¥ä¿®æ”¹track[min_idx]\n            for (auto k: track[min_idx])\n            {\n                k.second.push_back(d.first);\n              // åŒ…æ‹¬äº†num_to_perfect[d.first]&lt;0çš„æƒ…å†µ\n                if (num_to_perfect[d.first] &lt;= k.first.second)\n                    k.first.second -= num_to_perfect[d.first];\n                else\n                {\n                    k.first.first += (num_to_perfect[d.first] - k.first.second);\n                    k.first.second = 0;\n                }\n                track[d.first].push_back(k);\n            }\n        }\n      // æ›´æ–°å®Œåmin_idxçš„è·¯å¾„ä¿¡æ¯å¯ä»¥æ¸…ç©ºä»¥å‡å°‘ç©ºé—´æ¶ˆè€—\n        track[min_idx].clear();\n        min_dist = INF, min_idx = 0;\n        for (int i = 1; i &lt; n + 1; ++i)\n            min_dist = (!isVisited[i] &amp;&amp; dist[i] &lt; min_dist) ? (min_idx = i, dist[i]) : min_dist;\n        isVisited[min_idx] = true;\n    }\n\n    sort(track[sp].begin(), track[sp].end(), cmp);\n    cout &lt;&lt; track[sp][0].first.first &lt;&lt; \" 0\";\n    for (auto &amp;s: track[sp][0].second)\n        cout &lt;&lt; \"-&gt;\" &lt;&lt; s;\n    cout &lt;&lt; \" \" &lt;&lt; track[sp][0].first.second;\n}\n","slug":"1018-Public-Bike-Management","date":"2022-04-13T00:42:21.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,sort,pair,vector,Dijkstra","author_index":"Starlit Rover"},{"id":"f28bb9815d595dfd2f2742951bf93359","title":"ã€Œ1017ã€Queueing at Bank","content":"â³ENTRY\nSuppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. All the customers have to wait in line behind the yellow line, until it is his/her turn to be served and there is a window available. It is assumed that no window can be occupied by a single customer for more than 1 hour.\nNow given the arriving time T and the processing time P of each customer, you are supposed to tell the average waiting time of all the customers.\n\n\nInput Specification:Each input file contains one test case. For each case, the first line contains 2 numbers: N (â‰¤104) - the total number of customers, and K (â‰¤100) - the number of windows. Then N lines follow, each contains 2 times: HH:MM:SS - the arriving time, and P - the processing time in minutes of a customer. Here HH is in the range [00, 23], MM and SS are both in [00, 59]. It is assumed that no two customers arrives at the same time.\nNotice that the bank opens from 08:00 to 17:00. Anyone arrives early will have to wait in line till 08:00, and anyone comes too late (at or after 17:00:01) will not be served nor counted into the average.\nOutput Specification:For each test case, print in one line the average waiting time of all the customers, in minutes and accurate up to 1 decimal place.\nSample Input:7 3\n07:55:00 16\n17:00:01 2\n07:59:59 15\n08:01:00 60\n08:00:00 30\n08:00:02 2\n08:03:00 10\n\nSample Output:8.2\n\n\nÎ©æœ¬é¢˜ç®—æ˜¯ä½é…ç‰ˆã€Œ1014ã€Waiting in Lineï¼ŒåŒºåˆ«åœ¨äºæ¯ä¸ªçª—å£å‰ä¸èƒ½æ’é˜Ÿï¼Œæ‰€æœ‰ç­‰å€™çš„äººéƒ½åœ¨é»„çº¿å¤–æ’æˆä¸€æ’ï¼Œå½“æœ‰çª—å£ç©ºäº†æ‰èƒ½è¿›å…¥ã€‚\næç®€ç¿»è¯‘ï¼šé“¶è¡Œæœ‰ä¸ªçª—å£ï¼Œæ¯ä¸ªçª—å£æ¥å¾…ä¸€äººã€‚é¡¾å®¢æŒ‰ç…§åˆ°æ¥çš„å…ˆåé¡ºåºåœ¨é»„çº¿å¤–æ’æˆä¸€æ’ï¼Œå½“æœ‰çª—å£ç©ºé—²æ—¶ä¾æ¬¡è¿›å…¥ã€‚æˆ‘ä»¬å·²çŸ¥æ¯ä¸ªé¡¾å®¢åˆ°è¾¾çš„æ—¶é—´ï¼Œä»¥åŠäº‹åŠ¡æ‰€éœ€çš„å¤„ç†æ—¶é—´ï¼Œæœ€ç»ˆè¾“å‡ºæ‰€æœ‰é¡¾å®¢çš„å¹³å‡ç­‰å¾…æ—¶é—´ã€‚æ³¨æ„ï¼Œé“¶è¡Œè¥ä¸šæ—¶é—´ä¸º8:00-17:00ï¼Œ17:00ååˆ°è¾¾çš„é¡¾å®¢ä¸è®¡å…¥å¹³å‡ç­‰å¾…æ—¶é—´ã€‚\nè¿™ä¸€é¢˜ç›¸æ¯”1014äº‹å®ä¸Šé€€åŒ–äº†å¾ˆå¤šï¼Œä¸€æ–¹é¢æ˜¯æ¯ä¸ªçª—å£å‰ä¸èƒ½æ’é˜Ÿï¼Œæ‰€æœ‰äººæ’åœ¨ä¸€ä¸ªé˜Ÿä¼é‡Œï¼›å¦ä¸€æ–¹é¢ï¼Œæœ€åéœ€è¦è¾“å‡ºçš„ç»“æœå¹¶ä¸æ˜¯é’ˆå¯¹å…·ä½“çš„ä¸ªä½“ï¼Œè€Œæ˜¯åˆ»ç”»æ•´ä½“çš„å¹³å‡ç­‰å¾…æ—¶é—´ã€‚å› æ­¤æˆ‘ä»¬ä¹Ÿæ— éœ€ç»™æ¯ä¸€ä¸ªé¡¾å®¢è¿›è¡Œç¼–å·ï¼Œç›´æ¥ç”¨pairå­˜å‚¨åˆ°è¾¾æ—¶é—´å’Œå¤„ç†æ—¶é•¿å³å¯ï¼š\n# pair&lt;arrival time in second, processing time in second&gt;\nvector&lt;pair&lt;int,int&gt;&gt; info;\n\næ³¨æ„åˆ°ï¼Œé¡¾å®¢ä¿¡æ¯ä¸æ˜¯æŒ‰ç…§åˆ°è¾¾é¡ºåºç»™å‡ºçš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å…ˆå¯¹æ‰€æœ‰é¡¾å®¢çš„åˆ°è¾¾æ—¶é—´è¿›è¡Œsortæ’åºï¼Œç„¶åéå†æ¯ä¸€ä½é¡¾å®¢ï¼Œé€‰æ‹©æ—¶é—´è½´æœ€æ—©çš„çª—å£ï¼Œè®¡ç®—ç›¸åº”çš„ç­‰å¾…æ—¶é—´ï¼ŒåŒæ—¶å°†é¡¾å®¢çš„å¤„ç†æ—¶é•¿åŠ åˆ°è¯¥çª—å£çš„æ—¶é—´è½´ä¸Šã€‚å½“å¾ªç¯åˆ°æŸä½é¡¾å®¢çš„åˆ°è¾¾æ—¶é—´æ™šäº17:00æ—¶åˆ™breaké€€å‡ºå¾ªç¯ï¼Œå¹¶è®°å½•æœ‰æ•ˆé¡¾å®¢æ•°rnã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;int, int&gt; ptt;\n\nint main()\n{\n    int n, k, h, m, s, p, rn, sum = 0;\n    cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;ptt&gt; info;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d:%d:%d %d\", &amp;h, &amp;m, &amp;s, &amp;p);\n        info.push_back(move(ptt(3600 * h + 60 * m + s, p * 60)));\n    }\n    sort(info.begin(), info.end(), [](const ptt &amp;a, const ptt &amp;b) { return a.first &lt; b.first; });\n    vector&lt;int&gt; windows(k, 8 * 3600);\n    for (rn = 0; rn &lt; n; ++rn)\n    {\n        if (info[rn].first &gt; 17 * 3600)\n            break;\n      # Count waiting time\n        sum += (windows[0] &gt; info[rn].first ? (windows[0] - info[rn].first) : (windows[0] = info[rn].first, 0));\n      # Add processing time to time line\n        windows[0] += info[rn].second;\n        sort(windows.begin(), windows.end());\n    }\n    printf(\"%.1f\", (sum % 60 / 60.0 + sum / 60) / rn);\n}\n\n\nâš¡ï¸ ä¸€äº›è¯´æ˜\næ‰€æœ‰æ—¶é—´éƒ½æ¢ç®—æˆç§’\n\nçª—å£çš„åˆå§‹æ—¶é—´è½´éƒ½è®¾ç½®ä¸º8:00å°±æ— éœ€è€ƒè™‘æ—©åˆ°çš„æƒ…å†µäº†\nvector&lt;int&gt; windows(k, 8 * 3600);\n\nå½“å‡ºç°çª—å£ç©ºé—²è€Œæ— é¡¾å®¢çš„æ—¶å€™ï¼Œéœ€è¦å…ˆå°†çª—å£çš„æ—¶é—´è½´æ‹‰åˆ°é¡¾å®¢åˆ°è¾¾æ—¶é—´å†åŠ ä¸Šäº‹åŠ¡å¤„ç†æ—¶é•¿\n(windows[0] = info[rn].first, 0) # é€—å·è¡¨è¾¾å¼è¿”å›åè€…çš„å€¼\n\næ¯æ¬¡å¤„ç†å®Œä¸€ä¸ªé¡¾å®¢éƒ½éœ€è¦å¯¹æ‰€æœ‰çª—å£çš„æ—¶é—´çº¿è¿›è¡Œæ’åºï¼Œé‚£ä¹ˆwindows[0]å³ä¸ºæœ€æ—©ç©ºé—²çª—å£ã€‚\n\n\n","slug":"1017-Queueing-at-Bank","date":"2022-04-08T05:03:29.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,sort,pair,vector","author_index":"Starlit Rover"},{"id":"4cf831a9ea6bfd5b5d2bee7ee829301b","title":"ã€Œ1016ã€Phone Bills","content":"â³ENTRY\nA long-distance telephone company charges its customers by the following rules:\nMaking a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records.\n\n\nInput Specification:Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records.\nThe rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day.\nThe next line contains a positive number N (â‰¤1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (MM:dd:HH:mm), and the word on-line or off-line.\nFor each test case, all dates will be within a single month. Each on-line record is paired with the chronologically next record for the same customer provided it is an off-line record. Any on-line records that are not paired with an off-line record are ignored, as are off-line records not paired with an on-line record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock.\nOutput Specification:For each test case, you must print a phone bill for each customer.\nBills must be printed in alphabetical order of customersâ€™ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:HH:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample.\nSample Input:10 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 10\n10\nCYLL 01:01:06:01 on-line\nCYLL 01:28:16:05 off-line\nCYJJ 01:01:07:00 off-line\nCYLL 01:01:08:03 off-line\nCYJJ 01:01:05:59 on-line\naaa 01:01:01:03 on-line\naaa 01:02:00:01 on-line\nCYLL 01:28:15:41 on-line\naaa 01:05:02:24 on-line\naaa 01:04:23:59 off-line\n\nSample Output:CYJJ 01\n01:05:59 01:07:00 61 $12.10\nTotal amount: $12.10\nCYLL 01\n01:06:01 01:08:03 122 $24.40\n28:15:41 28:16:05 24 $3.85\nTotal amount: $28.25\naaa 01\n02:00:01 04:23:59 4318 $638.80\nTotal amount: $638.80\n\n\nÎ©æœ‰ä¸€é˜µå­æ²¡ç é¢˜ç›®äº†ï¼Œæ„Ÿè§‰è„‘å­å’Œæ‰‹éƒ½ç”Ÿé”ˆäº†ã€‚ç”¨è¿™é“é¢˜æ¥å¤å¥ç€å®æŠ˜ç£¨ã€‚\næç®€ç¿»è¯‘ï¼šé¦–å…ˆç»™å‡ºæ¯å°æ—¶å†…é€šè¯çš„æ”¶è´¹æ ‡å‡†ï¼ˆç¾åˆ†/minï¼‰ã€‚ç„¶åç»™å‡ºåŒä¸€æœˆå†…ä¸åŒç”¨æˆ·çš„é€šè¯è®°å½•ï¼Œé€šè¯è®°å½•çš„çŠ¶æ€åŒ…æ‹¬on-lineå’Œoff-lineï¼Œç„¶è€Œå¯¹äºä¸€ä¸ªç”¨æˆ·è€Œè¨€ä¸¤è€…ä¹Ÿå¹¶éå®Œå…¨åŒ¹é…ï¼Œé‚£ä¹ˆå°±éœ€è¦æ‰¾å‡ºæ¯ä¸ªç”¨æˆ·æ‰€æœ‰åŒ¹é…çš„é€šè¯è®°å½•å¯¹ï¼Œæœ€åæŒ‰å­—æ¯é¡ºåºä¾æ¬¡è¾“å‡ºæœ¬æœˆå†…æ¯ä¸ªç”¨æˆ·ï¼ˆæŒ‰æ—¶é—´é¡ºåºï¼‰çš„æ‰€æœ‰åŒ¹é…è®°å½•å¯¹ï¼Œä»¥åŠæ¯ä¸€å¯¹ç›¸åº”çš„æ—¶é•¿ï¼ˆminï¼‰ä¸æ”¶è´¹ï¼ˆ$ï¼‰ï¼Œæœ€åè¾“å‡ºè¯¥ç”¨æˆ·åœ¨æœ¬æœˆçš„æ€»æ”¶è´¹ã€‚\n\n\nè„‘è¢‹éšéšä½œç—›ï¼Œæœ‰å‡ ä¸ªæ£˜æ‰‹çš„åœ°æ–¹ï¼š\n\nåŒä¸€ä¸ªç”¨æˆ·é€šè¯è®°å½•çš„åŒ¹é…\nä¸€æ¬¡é€šè¯çš„è´¹ç”¨è®¡ç®—\nç”¨æˆ·åå­—å’Œé€šè¯è®°å½•éƒ½è¦æŒ‰é¡ºåºè¾“å‡º\n\né¦–å…ˆå®šä¹‰äº†ä¸€ä¸ªæ—¥æœŸç±»ï¼ŒåŒ…å«äº†æ—¶é—´çš„æ—¥æ—¶åˆ†ï¼Œä»¥åŠè®°å½•çš„çŠ¶æ€å’Œæ˜¯å¦å·²åŒ¹é…ï¼ŒåŒæ—¶é‡è½½äº†&lt;ï¼Œ&lt;&lt;è¿ç®—ç¬¦ï¼Œå®ç°äº†æ¢ç®—æˆåˆ†é’Ÿçš„minutes()\nclass date\n{\npublic:\n    int d, h, m;\n    bool isOnline, isPaired = false;\n\n    inline bool operator&lt;(const date &amp;rhs) const { return this-&gt;minutes() &lt; rhs.minutes(); }\n\n    int minutes() const { return this-&gt;d * 1440 + this-&gt;h * 60 + this-&gt;m; }\n\n    inline friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const date &amp;t)\n    {\n        printf(\"%02d:%02d:%02d\", t.d, t.h, t.m);\n        return os;\n    }\n\n    date(int _d = -1, int _h = -1, int _m = -1, bool flag = true) : d(_d), h(_h), m(_m), isOnline(flag) {};\n};\n\nè¿™é‡Œæˆ‘ç”¨set&lt;date&gt;å®¹å™¨æ¥å­˜å‚¨ä¸€ä¸ªç”¨æˆ·çš„é€šè¯è®°å½•ï¼Œç”±äºæˆ‘é‡è½½äº†dateçš„&lt;ï¼Œå› æ­¤ä¼šè‡ªåŠ¨æŒ‰ç…§æ—¶é—´å…ˆåè¿›è¡Œå­˜å‚¨ï¼Œè€Œç”¨æˆ·ä¸å…¶é€šè¯è®°å½•é›†åˆåˆ™ç”¨map&lt;string,set&lt;date&gt;&gt;è®°å½•ï¼Œmapä¼šè‡ªåŠ¨æŒ‰ç…§åå­—é¡ºåºæ’åºã€‚\nåŒ¹é…çš„è¦æ±‚æ„Ÿè§‰é¢˜ç›®è¯´çš„ä¸æ˜¯å¾ˆæ¸…æ¥šï¼Œç®€å•åœ°è¯´ï¼Œåªæœ‰åŒä¸€ä¸ªç”¨æˆ·åœ¨ç›¸é‚»æ—¶é—´ç‚¹ï¼ˆä¹‹é—´æ²¡æœ‰å…¶ä»–è®°å½•ï¼‰çš„on-lineå’Œoff-lineå¯ä»¥åŒ¹é…æˆåŠŸï¼Œå…¶ä½™æ— æ³•åŒ¹é…çš„è®°å½•ç›´æ¥å¿½ç•¥ã€‚é‚£ä¹ˆæˆ‘åœ¨éå†é›†åˆçš„æ—¶å€™ï¼Œé‡åˆ°on-lineå°±ä¿ç•™å…¶æ—¶é—´ï¼Œé‡åˆ°off-lineå°±æ£€æŸ¥ä¿ç•™çš„on-lineè®°å½•æ˜¯å¦å·²åŒ¹é…ï¼ŒæœªåŒ¹é…å°±è®¡ç®—ç›¸åº”è´¹ç”¨ï¼Œå¹¶æ ‡è®°åŒ¹é…å˜é‡ã€‚\nè®¡ç®—è´¹ç”¨æˆ‘æ˜¯ç›´æ¥åˆ†ç±»è®¡ç®—ï¼Œon-lineå’Œoff-lineçš„å½“å¤©å•ç‹¬è®¡ç®—ï¼Œä¸­é—´çš„å¤©æ•°ç›´æ¥ä¹˜ä»¥é€šè¯ä¸€å¤©çš„æ€»è´¹ç”¨ï¼ˆâš ï¸è¿™æ ·è®¡ç®—çš„è¯è¿˜éœ€è¦å•ç‹¬è€ƒè™‘åŒä¸€å¤©å†…ï¼Œä»¥åŠåŒä¸€å¤©åŒä¸€å°æ—¶å†…çš„é€šè¯è®°å½•ï¼‰ã€‚è¿˜æœ‰ä¸€ç§æ–¹æ³•æ˜¯å…ˆåˆ†åˆ«è®¡ç®—ä¸¤ä¸ªçŠ¶æ€ä»00:00:00å¼€å§‹çš„è´¹ç”¨ï¼Œç„¶åç›´æ¥ç›¸å‡ï¼Œå°±ä¸éœ€è¦è€ƒè™‘è¿™ä¹ˆå¤šäº†ã€‚äº‹å®ä¸Šï¼Œè¿™ä¸ªæ€è·¯é€‚ç”¨æ‰€æœ‰æ¶‰åŠåˆ°æ—¶é—´çš„è®¡ç®—ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n\nusing namespace std;\nvector&lt;int&gt; toll(25);\n\nclass date\n{\npublic:\n    int d, h, m;\n    bool isOnline, isPaired = false;\n\n    inline bool operator&lt;(const date &amp;rhs) const { return this-&gt;minutes() &lt; rhs.minutes(); }\n\n    int minutes() const { return this-&gt;d * 1440 + this-&gt;h * 60 + this-&gt;m; }\n\n    inline friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const date &amp;t)\n    {\n        printf(\"%02d:%02d:%02d\", t.d, t.h, t.m);\n        return os;\n    }\n\n    date(int _d = -1, int _h = -1, int _m = -1, bool flag = true) : d(_d), h(_h), m(_m), isOnline(flag) {};\n};\n\nfloat cost(const date &amp;on, const date &amp;off)\n{ \n    if (on.d == off.d &amp;&amp; on.h == off.h)\n        return (off.m - on.m) * toll[on.h] / 100.0;\n    float sum = (60 - on.m) * toll[on.h] + off.m * toll[off.h];\n    if (on.d &lt; off.d)\n    {\n        for (int i = on.h + 1; i &lt; 24; ++i)\n            sum += 60 * toll[i];\n        for (int i = 0; i &lt; off.h; ++i)\n            sum += 60 * toll[i];\n    }\n    else\n        for (int i = on.h + 1; i &lt; off.h; ++i)\n            sum += 60 * toll[i];\n    for (int i = on.d + 1; i &lt; off.d; ++i)\n        sum += 60 * toll[24];\n\n    return sum / 100.0;\n}\n\nint main()\n{\n    for (int i = 0; i &lt; 24; ++i)\n    {\n        cin &gt;&gt; toll[i];\n        toll[24] += toll[i];\n    }\n    int n, M, d, h, m;\n    cin &gt;&gt; n;\n    string name, flag;\n    map&lt;string, set&lt;date&gt;&gt; record;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name;\n        scanf(\"%d:%d:%d:%d\", &amp;M, &amp;d, &amp;h, &amp;m);\n        cin &gt;&gt; flag;\n        record[name].emplace(d, h, m, (flag == \"on-line\") ? true : false);\n    }\n\n    for (auto &amp;r: record)\n    {\n        name = r.first;\n        float money = 0, sum = 0;\n        date pre_online;\n        for (auto &amp;k: r.second)\n        {\n            if (k.isOnline)\n                pre_online = k;\n            else if (!pre_online.isPaired &amp;&amp; pre_online.d != -1)\n            {\n                if (sum == 0)\n                    printf(\"%s %02d\\n\", name.c_str(), M);\n                money = cost(pre_online, k);\n                pre_online.isPaired = true;\n                cout &lt;&lt; pre_online &lt;&lt; \" \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; (k.minutes() - pre_online.minutes());\n                printf(\" $%.2f\\n\", money);\n                sum += money;\n            }\n        }\n        if (sum != 0)\n            printf(\"Total amount: $%.2f\\n\", sum);\n    }\n}\n\n\nÎ£ Notes\n$1=100ç¾åˆ†ï¼Œ/100.0ï¼\nå¦‚æœä¸€ä¸ªç”¨æˆ·ä¸€å¯¹åŒ¹é…çš„é€šè¯è®°å½•éƒ½æ²¡æœ‰ï¼Œé‚£ä¹ˆå°±æ— éœ€è¾“å‡º\ntoll[24]å­˜æ”¾çš„æ˜¯é€šè¯ä¸€å¤©çš„æ”¶è´¹æ ‡å‡†ï¼ˆç¾åˆ†/minï¼‰\næµ‹è¯•ç‚¹è¯´æ˜ï¼š0-Sampleï¼Œ1ã€2-ä¸è¦è¾“å‡ºæ²¡æœ‰è´¹ç”¨çš„ç”¨æˆ·ï¼Œ3-å«æœ‰åŒä¸€å¤©åŒä¸€å°æ—¶å†…çš„é€šè¯è®°å½•\n\n","slug":"1016-Phone-Bills","date":"2022-04-04T03:35:13.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,set","author_index":"Starlit Rover"},{"id":"9c235338e8419467c57a9cf3dae4161a","title":"ã€ŒSection 8ã€æ§åˆ¶å™¨","content":"\næ§åˆ¶å™¨æ˜¯æ•´ä¸ªè®¡ç®—æœºçš„æŒ‡æŒ¥ä¸­å¿ƒï¼Œåè°ƒè®¡ç®—æœºçš„å„éƒ¨ä»¶è¿›è¡Œå·¥ä½œã€‚å…¶å®è´¨å·¥ä½œå°±æ˜¯è§£é‡Šç¨‹åºï¼Œæ¯æ¬¡ä»å­˜å‚¨å™¨ä¸­è¯»å–ä¸€æ¡æŒ‡ä»¤ï¼Œç»è¿‡åˆ†æè¯‘ç äº§ç”Ÿä¸€ä¸²æ“ä½œå‘½ä»¤ï¼Œå†å‘ç»™å„åŠŸèƒ½éƒ¨ä»¶ï¼Œæ§åˆ¶å„éƒ¨ä»¶çš„åŠ¨ä½œï¼Œä»¥å®ç°æŒ‡ä»¤å’Œç¨‹åºçš„åŠŸèƒ½ã€‚ï¼ˆå–æŒ‡ä»¤â†’åˆ†ææŒ‡ä»¤â†’æ‰§è¡ŒæŒ‡ä»¤â†’å–æŒ‡ä»¤ï¼‰\n\n\n\n\næ€»çº¿ï¼ˆbusï¼‰\n\næ„æˆ\nABï¼ˆå•å‘ï¼‰ï¼šåœ°å€æ€»çº¿ï¼ŒCPUâ†’ABâ†’å­˜å‚¨å™¨æˆ–IOè®¾å¤‡\nDBï¼ˆåŒå‘ï¼‰ï¼šæ•°æ®æ€»çº¿ï¼Œå„éƒ¨ä»¶ä¹‹é—´\nCBï¼ˆå•/åŒçº¿ï¼‰ï¼šæ§åˆ¶æ€»çº¿ï¼ŒåŒ…å«å¤šç§ä¸åŒçš„æ§åˆ¶ä¿¡å·çº¿å’ŒçŠ¶æ€ä¿¡å·çº¿\n\n\nå±‚æ¬¡\nç³»ç»Ÿæ€»çº¿ï¼ˆABï¼ŒDBï¼ŒCBï¼‰ï¼šCPUè®¿é—®å­˜å‚¨å™¨ï¼ŒI/Oæ§åˆ¶å™¨\nå±€éƒ¨æ€»çº¿ / I/Oæ€»çº¿\n\n\n\n\n\nå­˜å‚¨å™¨ç»“æ„\n\næ™®æ—æ–¯é¡¿ç»“æ„\nç¨‹åºå’Œæ•°æ®å…±åŒå­˜æ”¾åœ¨ä¸€ä¸ªå­˜å‚¨å™¨\nä¸€å¥—åœ°å€æ€»çº¿ä¸æ•°æ®æ€»çº¿\nå…¸å‹CPUï¼šIntelå¾®å¤„ç†å™¨ï¼ŒARM7ï¼ŒMIPSå¤„ç†å™¨\n\n\nå“ˆä½›ç»“æ„\nç¨‹åºå’Œæ•°æ®åˆ†å¼€å­˜æ”¾åœ¨ä¸¤ä¸ªå­˜å‚¨å™¨ä¸­\näºŒå¥—åœ°å€æ€»çº¿ä¸æ•°æ®æ€»çº¿\næŒ‡ä»¤å’Œæ•°æ®å®½åº¦å¯ä»¥ä¸åŒ\nå…¸å‹CPUï¼šPICç³»åˆ—ï¼ŒMC68ç³»åˆ—ï¼ŒZ8ç³»åˆ—ï¼ŒAVRç³»åˆ—ï¼ŒARM9ã€10ã€11ï¼Œ51å•ç‰‡æœºï¼ˆæ”¹è¿›å‹å“ˆä½›ç»“æ„ï¼ŒæŒ‡ä»¤å’Œæ•°æ®å­˜å‚¨å™¨åˆ†æ—¶å¤ç”¨åŒä¸€æ¡æ€»çº¿ï¼‰\n\n\n\n\nä¸­å¤®å¤„ç†å™¨CPU\n\nç»„æˆï¼šè¿ç®—å™¨å’Œå¤„ç†å™¨\n\nåŸºæœ¬åŠŸèƒ½\n\næŒ‡ä»¤æ§åˆ¶ï¼šç¡®ä¿è®¡ç®—æœºæŒ‡ä»¤æŒ‰ç¨‹åºçš„é¡ºåºæ‰§è¡Œ\næ“ä½œæ§åˆ¶ï¼šæ§åˆ¶å¾®æ“ä½œçš„äº§ç”Ÿã€ç»„åˆã€ä¼ é€å’Œç®¡ç†\næ—¶é—´æ§åˆ¶ï¼šä¸¥æ ¼æŒ‰ç…§æ—¶é—´åºåˆ—æ‰§è¡Œå¾®æ“ä½œå’ŒæŒ‡ä»¤\næ•°æ®åŠ å·¥ï¼šç®—æœ¯è¿ç®—å’Œé€»è¾‘è¿ç®—\n\n\næœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªå¤æ‚çš„æœ‰é™è‡ªåŠ¨æœº\n\n\n\nï½å››ä¸ªçŠ¶æ€æ˜¯æ‰€æœ‰æŒ‡ä»¤éƒ½éœ€è¦é¢„å…ˆæ‰§è¡Œçš„å…¬æ“ä½œ\nç»“æŸåä¼šæ ¹æ®æŒ‡ä»¤çš„è¯‘ç æƒ…å†µè¿›è¡ŒçŠ¶æ€è½¬æ¢\n\n\næŒ‡ä»¤æ‰§è¡Œçš„ä¸‰ä¸ªé˜¶æ®µ\n\nå–æŒ‡ä»¤é˜¶æ®µï¼šä»å­˜å‚¨å™¨ä¸­å–å‡ºä¸€æ¡æŒ‡ä»¤é€åˆ°CPU\næŒ‡ä»¤è¯‘ç é˜¶æ®µï¼šå¯¹å½“å‰æŒ‡ä»¤è¿›è¡Œè¯‘ç ï¼Œåˆ†ææ˜¯å“ªæ¡æŒ‡ä»¤æ“ä½œæ•°çš„å¯»å€æ–¹å¼ç­‰\nè¯‘ç æ—¶å¯èƒ½ä¸ä¼šå¯¹åº”ä»»ä½•ä¸€ä¸ªçŠ¶æ€ï¼Œä¹Ÿå¯èƒ½åŒ…å«å¥½å‡ ä¸ªçŠ¶æ€\n\n\næ‰§è¡Œé˜¶æ®µï¼šæ‰§è¡Œè¯¥æŒ‡ä»¤ï¼Œæ§åˆ¶ç›¸åº”éƒ¨ä»¶å®ŒæˆæŒ‡ä»¤çš„æ“ä½œ\n\n\n\n\næ§åˆ¶å™¨ç»„æˆ\n\nä¸“ç”¨å¯„å­˜å™¨\nç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ï¼šå­˜æ”¾æŒ‡ä»¤åœ°å€\næŒ‡ä»¤å¯„å­˜å™¨ï¼ˆIRï¼‰ï¼šå­˜æ”¾æŒ‡ä»¤ç¼–ç \nåœ°å€å¯„å­˜å™¨ï¼ˆARï¼‰ï¼šç”¨äºå­˜æ”¾CPUè®¿é—®å­˜å‚¨å™¨æˆ–è€…I/Oè®¾å¤‡çš„åœ°å€ç \næ•°æ®å¯„å­˜å™¨ï¼ˆDRï¼‰ï¼šç”¨äºå­˜æ”¾CPUè®¿é—®å­˜å‚¨å™¨æˆ–è€…I/Oè®¾å¤‡çš„æ•°æ®\n\n\nARå’ŒDRï¼šæ€»çº¿æ¥å£å•å…ƒBIU (Bus Interface Unit)çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼ŒCPUä¸å­˜å‚¨å™¨æˆ–è€…/0ç³»ç»Ÿçš„ä¸€ä¸ªæ€»çº¿æ¥å£\næŒ‡ä»¤è¯‘ç å™¨IDï¼šå¯¹æŒ‡ä»¤æ“ä½œç è¿›è¡Œè¯‘ç ï¼Œä»¥è¯†åˆ«è¯¥æŒ‡ä»¤æ‰€è¦æ±‚çš„æ“ä½œ\næ—¶åºç³»ç»Ÿï¼šè´Ÿè´£æä¾›æ—¶é’ŸåŸºå‡†å’Œå„çº§æ—¶åºä¿¡å·ï¼Œè§„å®šæ¯ä¸ªæ“ä½œçš„æ—¶é—´\næ“ä½œæ§åˆ¶ä¿¡å·å½¢æˆéƒ¨ä»¶ï¼šäº§ç”ŸæŒ‡ä»¤æ‰€éœ€çš„å„ç§æ“ä½œæ§åˆ¶ä¿¡å·ï¼Œä»¥ä¾¿æ­£ç¡®åœ°å»ºç«‹æ•°æ®é€šè·¯ï¼Œå®Œæˆå–æŒ‡ä»¤ã€åˆ†ææŒ‡ä»¤å’Œæ‰§è¡ŒæŒ‡ä»¤çš„æ§åˆ¶\n\n\næ—¶åºç³»ç»ŸåŠå…¶æ§åˆ¶\n\nä¸‰å¤§å‘¨æœŸ\n\næŒ‡ä»¤å‘¨æœŸï¼šæŒ‡è®¡ç®—æœºä»å†…å­˜å–å‡ºä¸€æ¡æŒ‡ä»¤å¹¶å®Œæˆè¯¥æŒ‡ä»¤çš„æ‰§è¡Œæ‰€éœ€è¦çš„æ—¶é—´\næ—¶é’Ÿå‘¨æœŸï¼šèŠ‚æ‹ï¼ˆTï¼‰ï¼ŒæŒ‡CPUæ‰§è¡Œä¸€ä¸ªå¾®æ“ä½œçš„æœ€å°æ—¶é—´å•ä½ï¼Œä¸€èˆ¬æ˜¯CPUä¸»é¢‘è„‰å†²çš„å‘¨æœŸ\næœºå™¨å‘¨æœŸï¼ˆCPUå‘¨æœŸï¼‰ï¼šç”¨äºå®Œæˆ1æ¬¡å†…å­˜çš„è¯»å†™æ“ä½œï¼Œæˆ–è€…1æ¬¡ALUè¿ç®—ï¼Œæˆ–æ˜¯1æ¬¡æ€»çº¿ä¼ è¾“\nä¸€èˆ¬è§„å®šä¸ºCPUä¸å†…å­˜äº¤æ¢1æ¬¡ä¿¡æ¯ï¼ˆè¯»æˆ–å†™å†…å­˜ï¼‰æ‰€éœ€è¦çš„æ—¶é—´\nä¸€ä¸ªæœºå™¨å‘¨æœŸå¯èƒ½åŒ…å«å¤šä¸ªæ—¶é’Ÿå‘¨æœŸ\n\n\n\n\n\næ—¶åºæ§åˆ¶æ–¹å¼ï¼šåŒæ­¥ä¸åŒçš„æ§åˆ¶ä¿¡å·åºåˆ—ï¼Œå¹¶å°†åºåˆ—å·è¡”æ¥èµ·æ¥ï¼Œä»è€Œä¿è¯å„éƒ¨ä»¶æœ‰èŠ‚å¥ä¾æ¬¡æ‰§è¡Œè§„å®šçš„å„ç§æ“ä½œ\n\nåŒæ­¥æ§åˆ¶æ–¹å¼\næ‰€æœ‰æŒ‡ä»¤éƒ½å…·æœ‰ç›¸åŒçš„æœºå™¨å‘¨æœŸæ•°ã€ç›¸åŒçš„èŠ‚æ‹ï¼Œç›¸åŒçš„æ‰§è¡Œæ—¶é—´\nä»¥å¾®æ“ä½œåºåˆ—æœ€é•¿çš„æŒ‡ä»¤ä¸ºæ ‡å‡†ï¼Œç¡®å®šæœºå™¨å‘¨æœŸæ•°å’ŒèŠ‚æ‹æ•°\næ—¶åºç³»ç»Ÿäº§ç”Ÿç»Ÿä¸€çš„ã€é¡ºåºå›ºå®šçš„ã€å‘¨è€Œå¤å§‹çš„æœºå™¨å‘¨æœŸå’ŒèŠ‚æ‹ä¿¡å·\nä¼˜ç‚¹ï¼šç”µè·¯ç®€å•ï¼›ç¼ºç‚¹ï¼šè¿è¡Œæ•ˆç‡ä½ï¼Œé€Ÿåº¦æ…¢\n\n\nå¼‚æ­¥æ§åˆ¶æ–¹å¼\næ²¡æœ‰ä¸¥æ ¼çš„æ—¶åºä¿¡å·å¯¹å¾®æ“ä½œè¿›è¡ŒåŒæ­¥\næ¯æ¡æŒ‡ä»¤éœ€è¦å¤šå°‘èŠ‚æ‹ï¼Œå°±äº§ç”Ÿå¤šå°‘èŠ‚æ‹ï¼›å½“æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•ï¼Œå‘å‡ºåº”ç­”ä¿¡å·ï¼›æ—¶åºéƒ¨ä»¶æ”¶åˆ°åº”ç­”ä¿¡å·åï¼Œæ‰å¼€å§‹ä¸‹æ¡æŒ‡ä»¤çš„æ‰§è¡Œ\næ‰§è¡Œä¸åŒæŒ‡ä»¤æ‰€éœ€çš„æ—¶é—´å®Œå…¨ç”±å®é™…éœ€è¦ç¡®å®šï¼Œä¸å°½ç›¸åŒ\nä¼˜ç‚¹ï¼šæŒ‡ä»¤çš„è¿è¡Œæ•ˆç‡é«˜ï¼›ç¼ºç‚¹ï¼šæ§åˆ¶å™¨ç”µè·¯å¤æ‚\nå¼‚æ­¥æ§åˆ¶æ–¹å¼æ¯”è¾ƒå¥½åœ°åè°ƒäº†ä¸»ä»è®¾å¤‡é€Ÿåº¦ä¸ä¸€è‡´é—®é¢˜ï¼Œåœ¨è®¡ç®—æœºä¸­å¾—åˆ°å¹¿æ³›çš„åº”ç”¨\n\n\nè”åˆæ§åˆ¶æ–¹å¼ï¼šæŠŠåŒæ­¥æ§åˆ¶æ–¹å¼å’Œå¼‚æ­¥æ§åˆ¶æ–¹å¼ç»“åˆä½¿ç”¨\nç°ä»£è®¡ç®—æœºç³»ç»Ÿå¤§å¤šé‡‡ç”¨è”åˆæ§åˆ¶æ–¹å¼ï¼Œä¸€èˆ¬è®¾è®¡æ€æƒ³æ˜¯ï¼šåœ¨åŠŸèƒ½éƒ¨ä»¶å†…éƒ¨é‡‡ç”¨åŒæ­¥æ§åˆ¶æ–¹å¼ï¼Œè€Œåœ¨åŠŸèƒ½éƒ¨ä»¶ä¹‹é—´é‡‡ç”¨å¼‚æ­¥æ§åˆ¶æ–¹å¼ã€‚\n\n\n\n\n\n\n\n","slug":"æ§åˆ¶å™¨","date":"2022-04-02T11:10:12.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"d3ed745153d9df10022e8be01ae8a15a","title":"BÃ©zier Curveï¼šäº¤äº’å¢å¼º","content":"â˜˜ï¸ Prefaceåœ¨å¾ˆä¹…å¾ˆä¹…çš„ä»¥å‰ï¼Œæˆ‘æœ‰ä»‹ç»è¿‡BÃ©zier Curveçš„ç†è®ºæ¨å¯¼ä»¥åŠåŸºæœ¬å®ç°è¿‡ç¨‹ï¼ˆBÃ©zier Curveï¼šå°è¯•ç‰›åˆ€ï¼‰ã€‚ä½†ä¸éš¾çœ‹å‡ºï¼Œè¿™ä¸ªç‰ˆæœ¬çš„BÃ©zier Curveç»˜åˆ¶ç¨‹åºçš„äº¤äº’æ€§æå·®ã€‚ä¸€æ—¦ç¡®å®šå°±ä¸èƒ½æ›´æ”¹ï¼Œæ§åˆ¶ç‚¹è¿˜è¦ä¸€ä¸ªä¸€ä¸ªåœ°è¾“å…¥åæ ‡ï¼Œæ¯æ¬¡è¿è¡Œè¿˜åªèƒ½ç”»ä¸€æ¬¡ï¼Œç”»å®Œä¹‹åå°±ä»€ä¹ˆæ“ä½œéƒ½æ²¡äº†ï¼Œæœ‰æ—¶å€™åªæƒ³çœ‹ä¸ªæ›²çº¿å´åˆå»ä¸æ‰èŠ±é‡Œèƒ¡å“¨çš„ç»˜åˆ¶è¿‡ç¨‹ï¼ˆå®˜æ–¹åæ§½æœ€ä¸ºè‡´å‘½ï¼‰ã€‚ç®€å•åœ°è¯´ï¼Œé™¤äº†ç”»å¾—å¥½çœ‹ç®€ç›´ä¸€æ— æ˜¯å¤„ã€‚\nåœ¨21ä¸–çºªçš„ä»Šå¤©ï¼Œæˆ‘ä»¬æ€èƒ½å®¹å¿è¿™ç§ç©ºæœ‰å…¶è¡¨çš„ç¨‹åºå‘¢ï¼äºæ˜¯version 2.0æ¨ªç©ºå‡ºä¸–ã€‚\n\n\n\nâ˜ˆ README.txtVersion 2.0åœ¨Version 1.0çš„åŸºç¡€ä¸Šæ–°å¢ä»¥ä¸‹åŠŸèƒ½ï¼š\n\næ— éœ€äº‹å…ˆæŒ‡å®šæ›²çº¿çš„é˜¶æ•°ï¼Œæ›´æ— éœ€è¾“å…¥æ§åˆ¶ç‚¹çš„åæ ‡ï¼Œç›´æ¥åœ¨çª—å£å†…ç”¨é¼ æ ‡å·¦å‡»ç¡®å®šæ§åˆ¶ç‚¹ä½ç½®ï¼Œç‚¹å‡»åä¼šå‡ºç°ç›¸åº”çš„ç»¿ç‚¹ï¼Œå¹¶è¾“å‡ºç›¸åº”çš„ä¸–ç•Œåæ ‡ï¼›\nåœ¨ç¡®å®šæ‰€æœ‰æ§åˆ¶é¡¶ç‚¹ä½ç½®åï¼Œé¼ æ ‡å³å‡»ç»˜åˆ¶ç›¸åº”çš„è´å¡å°”æ›²çº¿åŠç»˜åˆ¶è¿‡ç¨‹ï¼›\nç»˜åˆ¶å®Œæˆåé¼ æ ‡å³å‡»éšè—ç»˜åˆ¶è¿‡ç¨‹ï¼Œå†æ¬¡å³å‡»æ˜¾ç¤ºç»˜åˆ¶è¿‡ç¨‹ï¼›\nç»˜åˆ¶å®ŒæˆåæŒ‰ğŸ†ƒå¯ä»¥ä¿®æ”¹å€¼ï¼ˆé»˜è®¤ä¸º0.5ï¼‰ï¼›\nç»˜åˆ¶å®ŒæˆåæŒ‰ä½ğŸ…³å¯ä»¥æ‹–åŠ¨æ”¹å˜å½“å‰é¼ æ ‡æ‰€åœ¨æ§åˆ¶ç‚¹çš„ä½ç½®ï¼ŒåŒæ—¶è´å¡å°”æ›²çº¿åŠç»˜åˆ¶è¿‡ç¨‹ä¹Ÿä¼šç›¸åº”å˜åŒ–ï¼›\nç»˜åˆ¶å®Œæˆåé¼ æ ‡å·¦å‡»åˆ é™¤å½“å‰æ›²çº¿åŠæ§åˆ¶ç‚¹ï¼Œå³æ¸…ç©ºç”»æ¿å›åˆ°ç¬¬1æ­¥ï¼›\næŒ‰â›é€€å‡ºç¨‹åº.\n\n\nâš–ï¸ Tips\nå¯¹äºå®ç°ç‚¹å‡»é€‰æ‹©æ§åˆ¶é¡¶ç‚¹ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦å°†é¼ æ ‡åæ ‡è½¬æ¢ä¸ºç”»å¸ƒä¸Šçš„ä¸–ç•Œåæ ‡ï¼ˆåŸç‚¹åœ¨ä¸­å¿ƒï¼Œï¼‰ï¼Œå‡½æ•°void glfwGetCursorPos(GLFWwindow *window, double *xpos, double *ypos)å¾—åˆ°çš„é¼ æ ‡åæ ‡(xpos,ypos)æ˜¯ä¸€ä¸ªåƒç´ åæ ‡ï¼ŒåŸç‚¹ä½äºçª—å£çš„å·¦ä¸Šè§’ï¼Œyè½´æ­£æ–¹å‘å‘ä¸‹ï¼Œxè½´æ­£æ–¹å‘å‘å³ï¼Œæ ¹æ®çª—å£çš„å®½é«˜åƒç´ å€¼WIDTH,HEIGHTä»¥åŠç®€å•çš„æ˜ å°„å˜æ¢æˆ‘ä»¬å¯ä»¥å¾—åˆ°å…¶ä¸–ç•Œåæ ‡\nglfwGetCursorPos(window, &amp;click_x, &amp;click_y);\nclick_x = (click_x / WIDTH) * 2 - 1;\nclick_y = 1 - (click_y / HEIGHT) * 2;\n\nå¯¹äºè´å¡å°”æ›²çº¿é˜¶æ•°çš„è·å–ï¼Œæˆ‘ä»¬åªè¦åœ¨ç”¨æˆ·é¼ æ ‡å³å‡»æ—¶æŸ¥çœ‹æ§åˆ¶é¡¶ç‚¹çš„ä¸ªæ•°å³å¯\norder = control[0].size() - 1\n\nè‡³äºå¦‚ä½•ä½¿é¼ æ ‡å·¦å‡»å’Œå³å‡»æ—¶å‘æŒ¥ä¸åŒçš„ä½œç”¨ï¼Œå…¶å®æ˜¯å®ç°äº†ä¸€ä¸ªç®€å•çš„DFAã€‚æˆ‘è®¾äº†ä¸¤ä¸ªå¸ƒå°”å˜é‡\nbool start = false, showLine = true;\n\nå…¶ä¸­è¡¨ç¤ºæ˜¯å¦å¼€å§‹ç»˜åˆ¶æ›²çº¿ï¼ˆç”¨æˆ·åœ¨ç¡®å®šæ§åˆ¶ç‚¹ä½ç½®æ—¶ä¸ºfalseï¼‰ï¼Œè¡¨ç¤ºæ˜¯å¦å±•ç¤ºç»˜åˆ¶è¿‡ç¨‹ã€‚æˆ‘ä»¬å°†è‡ªåŠ¨æœºçš„çŠ¶æ€å®šä¹‰ä¸ºæœ‰åºå¯¹ï¼Œå…¶ä¸­1ä»£è¡¨trueï¼Œ0ä»£è¡¨falseï¼Œé‚£ä¹ˆå…¶çŠ¶æ€è½¬ç§»å›¾å¯ä»¥è¡¨ç¤ºä¸º\n\n\nåˆ†åˆ«è¡¨ç¤ºé¼ æ ‡å·¦å‡»ä¸å³å‡»ï¼Œåˆå§‹çŠ¶æ€ä¸ºï¼Œé‚£ä¹ˆä¸Šå›¾æ¸…æ¥šåœ°å±•ç°äº†æ¯ä¸ªçŠ¶æ€ç‚¹å‡»é¼ æ ‡åçš„è·³è½¬æ–¹å¼ã€‚\n\næ¸…ç©ºç”»å¸ƒå°±æ˜¯ä¸Šå›¾ä¸­çš„æƒ…å†µ\n\nä¸ºå…¨å±€å˜é‡ï¼Œå½“start=trueåŒæ—¶ç›‘å¬åˆ°æŒ‰é”®ğŸ†ƒçš„æŒ‰ä¸‹æ—¶ï¼Œå°†è¾“å…¥çš„å€¼ç›´æ¥èµ‹ç»™ï¼Œç„¶åGeneratePointsViaT0()é‡æ–°ç”Ÿæˆç»˜åˆ¶è¿‡ç¨‹\n\nå¯¹äºæŒ‰é”®ğŸ…³çš„ç›‘å¬ï¼Œåªè¦åœ¨æ¯ä¸ªå¾ªç¯ä¸­æŸ¥çœ‹ğŸ…³æ˜¯å¦è¢«æŒ‰ä¸‹ï¼Œè‹¥å¤„äºæŒ‰ä¸‹çŠ¶æ€ï¼Œåˆ™è®¡ç®—è·ç¦»å½“å‰é¼ æ ‡æœ€è¿‘çš„æ§åˆ¶é¡¶ç‚¹ï¼Œå¦å¤–éœ€è¦è®¾å®šä¸€ä¸ªé˜ˆå€¼ï¼ˆDRAG_SENSITIVITYï¼Œå¯ä»¥è®¤ä¸ºæ˜¯æ‹–åŠ¨æ•æ„Ÿåº¦ï¼‰ï¼Œåªæœ‰æœ€è¿‘è·ç¦»å°äºé˜ˆå€¼æ—¶æ‰å°†è¯¥æ§åˆ¶é¡¶ç‚¹ç§»åŠ¨åˆ°é¼ æ ‡ä½ç½®ï¼Œå¹¶æ›´æ–°ç»˜åˆ¶è¿‡ç¨‹ä¸æ›²çº¿ç»†åˆ†ç‚¹ï¼Œè¯¦è§void DragProcess(GLFWwindow *window)\n\nvector.resize()æ–¹æ³•å¯ä»¥åœ¨ä¿ç•™åŸæœ‰æ•°æ®çš„åŸºç¡€ä¸Šæ‰©å……ç©ºé—´\n\n\n\nCâ˜ºDE#include &lt;glew.h&gt;\n#include &lt;glfw3.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n#define WIDTH 800\n#define HEIGHT 600\n#define CURVE_POINTS_NUM 100\n#define DRAG_SENSITIVITY 0.01\n\nusing namespace std;\n\nclass Point\n{\npublic:\n    GLfloat x, y;\n\n    Point(GLfloat _x, GLfloat _y) : x(_x), y(_y) {};\n\n    inline Point operator*(const GLfloat &amp;t) const\n    {\n        return {t * this-&gt;x, t * this-&gt;y};\n    }\n\n    inline Point operator+(const Point &amp;rhs) const\n    {\n        return {this-&gt;x + rhs.x, this-&gt;y + rhs.y};\n    }\n};\n\nint order;\nbool start = false, showLine = true;\ndouble click_x, click_y;\nGLfloat t0 = 0.5;\nvector&lt;vector&lt;Point&gt;&gt; control_points(1, vector&lt;Point&gt;()), middle_points;\n\nvoid GeneratePointsViaT0()\n{\n    order = control_points[0].size() - 1;\n    control_points.resize(order + 1);\n\n    for (int i = 1; i &lt; order + 1; ++i)\n    {\n        control_points[i].clear();\n        for (int j = 0; j &lt; order + 1 - i; ++j)\n            control_points[i].emplace_back(control_points[i - 1][j] * (1 - t0) + control_points[i - 1][j + 1] * t0);\n    }\n}\n\nvoid GenerateMiddlePoints()\n{\n    order = control_points[0].size() - 1;\n    middle_points.clear();\n    middle_points.resize(order + 1);\n    middle_points[0] = control_points[0];\n\n    for (int k = 0; k &lt; CURVE_POINTS_NUM + 1; ++k)\n    {\n        GLfloat t = k / (1.0 * CURVE_POINTS_NUM);\n        for (int i = 1; i &lt; order; ++i)\n        {\n            middle_points[i].clear();\n            for (int j = 0; j &lt; order + 1 - i; ++j)\n                middle_points[i].emplace_back(\n                        middle_points[i - 1][j] * (1 - t) + middle_points[i - 1][j + 1] * t);\n        }\n        middle_points[order].emplace_back(middle_points[order - 1][0] * (1 - t) + middle_points[order - 1][1] * t);\n    }\n}\n\nvoid MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)\n{\n    if (action == GLFW_PRESS)\n        switch (button)\n        {\n            case GLFW_MOUSE_BUTTON_LEFT:\n                if (!start)\n                {\n                    glfwGetCursorPos(window, &amp;click_x, &amp;click_y);\n                    click_x = (click_x / WIDTH) * 2 - 1;\n                    click_y = 1 - (click_y / HEIGHT) * 2;\n                    control_points[0].emplace_back(Point(click_x, click_y));\n                    cout &lt;&lt; \"(\" &lt;&lt; click_x &lt;&lt; \" \" &lt;&lt; click_y &lt;&lt; \")\" &lt;&lt; endl;\n                }\n                else\n                {\n                    order = 0;\n                    control_points = move(vector&lt;vector&lt;Point&gt;&gt;(1, vector&lt;Point&gt;()));\n                    start = false;\n                }\n                break;\n            case GLFW_MOUSE_BUTTON_RIGHT:\n                if (!start)\n                {\n                    if (control_points[0].size() &lt;= 1)\n                    {\n                        cerr &lt;&lt; \"Control points are not enough!\" &lt;&lt; endl;\n                        break;\n                    }\n                    GeneratePointsViaT0();\n                    GenerateMiddlePoints();\n\n                    start = true;\n                    cout &lt;&lt; endl;\n                }\n                else\n                    showLine = !showLine;\n                break;\n        }\n}\n\nvoid KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mode)\n{\n    if (action == GLFW_PRESS)\n        switch (key)\n        {\n            case GLFW_KEY_ESCAPE:\n                glfwSetWindowShouldClose(window, GL_TRUE);\n                break;\n            case GLFW_KEY_T:\n                if (start)\n                {\n//                    showLine = false;\n                    cout &lt;&lt; \"t0(âˆˆ(0,1)) = \";\n                    cin &gt;&gt; t0;\n                    GeneratePointsViaT0();\n//                    showLine = true;\n                }\n                break;\n        }\n}\n\nvoid DragProcess(GLFWwindow *window)\n{\n    if (start &amp;&amp; glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)\n    {\n        int closest_idx = -1;\n        double dist, min_dist = 100;\n        glfwGetCursorPos(window, &amp;click_x, &amp;click_y);\n        click_x = (click_x / WIDTH) * 2 - 1;\n        click_y = 1 - (click_y / HEIGHT) * 2;\n        for (int i = 0; i &lt; order + 1; ++i)\n        {\n            dist = (click_x - control_points[0][i].x) * (click_x - control_points[0][i].x) +\n                   (click_y - control_points[0][i].y) * (click_y - control_points[0][i].y);\n            if (dist &lt; min_dist &amp;&amp; dist &lt; DRAG_SENSITIVITY)\n            {\n                min_dist = dist;\n                closest_idx = i;\n            }\n        }\n        control_points[0][closest_idx] = move(Point(click_x, click_y));\n        GeneratePointsViaT0();\n        GenerateMiddlePoints();\n    }\n}\n\nint main()\n{\n    if (!glfwInit())\n        return -1;\n    GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, \"BÃ©zier Curve\", NULL, NULL);\n    if (!window)\n        glfwTerminate();\n    glfwMakeContextCurrent(window);\n    glfwSetKeyCallback(window, KeyCallback);\n    glfwSetMouseButtonCallback(window, MouseButtonCallback);\n\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n\n        DragProcess(window);\n\n        glClearColor(0.2, 0.1, 0.2, 1);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        if (start)\n        {\n            if (showLine)\n            {\n                glLineWidth(5);\n                for (int i = 0; i &lt; order; ++i)\n                {\n                    glColor3f(1.0 * (order - 1 - i) / (order - 1), 1.0 * i / (order - 1), 0);\n                    glBegin(GL_LINE_STRIP);\n                    for (auto &amp;p: control_points[i])\n                        glVertex2f(p.x, p.y);\n                    glEnd();\n                }\n\n                glColor3f(0, 0.7, 0.7);\n                glPointSize(10);\n                glEnable(GL_POINT_SMOOTH);\n                glBegin(GL_POINTS);\n                glVertex2f(control_points[order][0].x, control_points[order][0].y);\n                glEnd();\n            }\n\n            for (int i = 0; i &lt; control_points[0].size(); ++i)\n            {\n                glColor3f(0, 1, 0);\n                glPointSize(15);\n                glBegin(GL_POINTS);\n                glVertex2f(control_points[0][i].x, control_points[0][i].y);\n                glEnd();\n            }\n\n            glColor3f(0, 0, 1);\n            glBegin(GL_LINE_STRIP);\n            for (auto &amp;p: middle_points[order])\n                glVertex2f(p.x, p.y);\n            glEnd();\n        }\n        else\n        {\n            for (int i = 0; i &lt; control_points[0].size(); ++i)\n            {\n                glColor3f(0, 1, 0);\n                glPointSize(15);\n                glEnable(GL_POINT_SMOOTH);\n                glBegin(GL_POINTS);\n                glVertex2f(control_points[0][i].x, control_points[0][i].y);\n                glEnd();\n            }\n        }\n\n        glfwSwapBuffers(window);\n    }\n\n    glfwTerminate();\n    return 0;\n}\n\n\nâ˜¸ï¸ DEMO \n\n\n\n\n\nâ® Reference â¯\nOpenGLå­¦ä¹ ç¬”è®°â€”â€”å¤„ç†é”®ç›˜è¾“å…¥ï¼Œhttps://www.cnblogs.com/saltedreed/p/12321314.html\nGLFW Documentï¼Œhttps://www.glfw.org/docs/latest/input_guide.html\n\n","slug":"Bezier-Curveï¼šäº¤äº’å¢å¼º","date":"2022-04-01T12:20:10.000Z","categories_index":"è®¡ç®—æœºå›¾å½¢å­¦","tags_index":"èµ°ç è§‚èŠ±,OpenGL","author_index":"Starlit Rover"},{"id":"430d590163d20d4eee403c80b7319692","title":"Naive Bayes","content":"æœ´ç´ è´å¶æ–¯æ˜¯ä¸€ä¸ªéå¸¸ç»å…¸æ˜“æ‡‚çš„åˆ†ç±»æ–¹æ³•ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯ä¸Šå¼å³ä¸ºæ¦‚ç‡è®ºä¸­çš„Bayeså®šç†ï¼Œæè¿°äº†ä¸¤ä¸ªæ¡ä»¶æ¦‚ç‡ä¹‹é—´çš„å…³ç³»ï¼Œé‚£ä¹ˆå…ˆè®©æˆ‘ä»¬æ¥å›é¡¾ä¸€ä¸‹æ¦‚ç‡è®ºçš„çŸ¥è¯†ã€‚\n\n\n\nÎ± Bayesâ€™ theoremå¯¹äºè®¡ç®—ä¸¤ä¸ªäº‹ä»¶Xå’ŒYåŒæ—¶å‘ç”Ÿçš„æ¦‚ç‡ï¼Œå¯ä»¥ç”±Yå‘ç”Ÿçš„æ¦‚ç‡ä¸Yå·²å‘ç”Ÿæ—¶ä¼šå‘ç”ŸXçš„æ¦‚ç‡ç›¸ä¹˜å¾—åˆ°ï¼Œå³æ ¹æ®ä¸Šå¼å³å¯å¾—å¦‚æœYæœ‰å¾ˆå¤šåˆ†å±æ€§ï¼Œä¸”åˆ†å±æ€§ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œé‚£ä¹ˆå¯ä»¥è®¤ä¸ºYæ˜¯å…¶æ‰€æœ‰åˆ†å±æ€§åŒæ—¶å‘ç”Ÿçš„äº‹ä»¶ï¼Œè€Œä¸Šå¼åˆ™å¯ä»¥å˜å½¢ä¸ºåˆ°æ­¤Naive Bayesçš„ç†è®ºéƒ¨åˆ†å°±ç»“æŸäº†ï¼Œéå¸¸çš„ç®€å•ï¼Œä½†ä½ å¯èƒ½è¿˜æ˜¯ä¸€å¤´é›¾æ°´ï¼Œä¸è¦æ…Œï¼Œgo onï½\n\nÎ² Naive Bayesç”¨ä¸€ä¸ªä¾‹å­æ¥è®²è§£ä¼šå¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£ï¼Œä¸‹é¢çš„ä¾‹å­å–è‡ªè¥¿ç“œä¹¦ã€‚\n\n\næˆ‘ä»¬ç°åœ¨æœ‰ä¸€ä¸ªå…³äºè¥¿ç“œçš„æ•°æ®é›†ï¼ˆå—¯ï¼Œè¿™å¾ˆç¬¦åˆè¥¿ç“œä¹¦çš„é…ç½®ï¼‰\n\n\nå¾ˆæ˜¾ç„¶ï¼Œè¿™æ˜¯å…³äºå¦‚ä½•æŒ‘ä¸€ä¸ªå¥½ç“œçš„æ•…äº‹ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸Šé¢æ€»å…±æœ‰17ä¸ªè¥¿ç“œï¼Œè¿™é‡Œåˆ—ä¸¾äº†æ¯ä¸ªè¥¿ç“œçš„å…­å¤§ç‰¹å¾ï¼Œæœ€åä¸€åˆ—å‘¢åˆ™æ˜¯æ ¹æ®æŸäººçš„å“å‘³å¯¹è¿™äº›è¥¿ç“œçš„å¥½åè¿›è¡Œäº†ä¸€ä¸ªä¸»è§‚çš„è¯„åˆ¤ã€‚\né‚£ä¹ˆå½“æˆ‘ä»¬å¾—çŸ¥æŸä¸ªè¥¿ç“œçš„å…­å¤§ç‰¹å¾æ—¶èƒ½å¦è¯„ä¼°å®ƒï¼ˆåœ¨é‚£ä¸ªäººçœ¼é‡Œçš„ï¼‰å¥½åå‘¢ï¼Ÿæ˜¾ç„¶è¿™é‡Œçš„ç»“æœåªä¼šæœ‰ä¸¤ç§ï¼Œè¦ä¹ˆå¥½è¦ä¹ˆåã€‚é‚£ä¹ˆåœ¨æˆ‘ä»¬å®Œå…¨å‡­ä¸»è§‚åˆ¤æ–­æ—¶ï¼Œå…¶å®ä¼šåœ¨æ½œæ„è¯†é‡Œæ¯”è¾ƒä¸¤è€…çš„æ¦‚ç‡ã€‚å¦‚æœç¬¬å…­æ„Ÿå‘Šè¯‰æˆ‘ä»¬è¿™ä¸ªè¥¿ç“œå¤§æ¦‚ç‡æ˜¯åçš„ï¼Œé‚£æˆ‘ä»¬å°±ä¼šæ¨æµ‹å®ƒæ˜¯åçš„ï¼Œè¿™ä¸å¤±ä¸ºä¸€ç§æ„Ÿæ€§çš„åˆ¤æ–­ã€‚\nå¦‚ä½•å°†è¿™ç§æ¨¡ç³Šåˆ¤æ–­ç§»æ¤åˆ°ç¨‹åºä¸Šå‘¢ã€‚è™½ç„¶è®¡ç®—æœºä¸æ„Ÿæ€§ï¼Œä½†å®ƒå¯ä»¥è®¡ç®—æ¦‚ç‡ã€‚å‡è®¾æˆ‘ä»¬ç°æœ‰ä¸€ä¸ªè¥¿ç“œçš„å…­å¤§ç‰¹å¾æ•°æ®æ ¹æ®æ„Ÿæ€§åˆ¤æ–­çš„æ€è·¯ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥éœ€è¦æ¯”è¾ƒçš„å¤§å°ï¼Œå…¶ä¸­æ˜¯ç“œçš„å¥½åäº‹ä»¶ï¼Œæˆ‘ä»¬å‡å®šè¡¨ç¤ºåç“œäº‹ä»¶ï¼Œè¡¨ç¤ºå¥½ç“œäº‹ä»¶ï¼Œé‚£ä¹ˆå°±è¡¨ç¤ºç“œåœ¨å…·æœ‰ç‰¹å¾Xçš„æƒ…å†µä¸‹ä¸ºå¥½/åç“œçš„æ¦‚ç‡ã€‚\næ¥ä¸‹æ¥æˆ‘ä»¬å°±ç”¨Bayeså®šç†è®¡ç®—ï¼Œä½ ä¼šå‘ç°æˆ‘æ²¡æœ‰å°†åˆ†æ¯å±•å¼€ï¼Œå› ä¸ºæ˜¾ç„¶ä¸çš„å–å€¼æ— å…³ã€‚å› æ­¤äº‹å®ä¸Šæˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒåˆ†å­å³å¯ï¼Œäºæ˜¯å¾—åˆ°å’Œçš„ç›¸å¯¹æ¦‚ç‡ä¸Šå¼å°±æ˜¯æ”»å…‹è¿™ä¸ªé—®é¢˜çš„å®ƒå±±ä¹‹çŸ³ï¼Œæˆ‘ä»¬åªéœ€åˆ†åˆ«è®¡ç®—å³è¾¹çš„ä¸¤éƒ¨åˆ†å³å¯ã€‚\n\n\næ˜¯æ˜¾ç„¶çš„ï¼Œ17ä¸ªç”Ÿç“œè›‹å­é‡Œé¢æœ‰8ä¸ªå¥½ç“œï¼Œ9ä¸ªåç“œï¼Œå› æ­¤å¯¹äºæ¯ä¸ªç‰¹å¾çš„ï¼Œæˆ‘ä»¬åªéœ€æ•°ä¸€ä¸‹æ¡ä»¶ä¸‹çš„ç“œé‡Œé¢æœ‰å‡ ä¸ªå³å¯ã€‚æ¯”å¦‚å½“ä¹Œé»‘æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°8ä¸ªå¥½ç“œä¸­æœ‰4ä¸ªæ˜¯ä¹Œé»‘çš„ï¼Œå› æ­¤è®²çš„æœ‰ç‚¹å•°å—¦ï¼Œç›¸ä¿¡ä½ å·²ç»æ‚Ÿäº†ã€‚\n\nÎ³ Laplace Smoothå…¶å®å·²ç»ç»“æŸäº†ï¼Œè¿™åªæ˜¯ä¸€ä¸ªå°è¡¥å……ã€‚åœ¨å®é™…çš„æœ´ç´ è´å¶æ–¯è®¡ç®—è¿‡ç¨‹ä¸­ï¼Œç”±äºæ¯ä¸ªæ¦‚ç‡éƒ½æ˜¯&lt;1çš„ï¼Œå› æ­¤è¿ä¹˜åå¯èƒ½ä¼šå¾—åˆ°ä¸€ä¸ªå¾ˆå°çš„æ•°ä»¥è‡´è®¡ç®—æœºç›´æ¥å½“0ç®—äº†ã€‚ä¸ºé¿å…è¿™ä¸ªé—®é¢˜æˆ‘ä»¬å¯ä»¥å–å¯¹æ•°ç›¸åŠ è§£å†³ã€‚\nå¦å¤–è¿˜æœ‰ä¸€ä¸ªé—®é¢˜â€”â€”0æ¦‚ç‡é—®é¢˜ã€‚æœ‰æ—¶å€™æŸä¸ªç‰¹å¾å€¼åœ¨æˆ‘ä»¬çš„å·²çŸ¥æ•°æ®é›†ä¸­æ²¡æœ‰å‡ºç°ï¼Œä½†æˆ‘ä»¬éœ€è¦å¯¹å…·æœ‰è¿™ä¸ªç‰¹å¾å€¼çš„è¥¿ç“œè¿›è¡Œå½’ç±»ï¼Œè¿™æ—¶å°±ä¼šå¾ˆå°´å°¬åœ°å‘ç°ä¸ç®¡æ˜¯è¿˜æ˜¯ï¼Œã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥æ‹‰æ™®æ‹‰æ–¯å¹³æ»‘ï¼Œåå­—å“äººï¼Œæ“ä½œå¹¶ä¸å¤æ‚ã€‚\nå¯¹äºçš„è®¡ç®—ï¼Œæˆ‘ä»¬æ”¹ç”¨å…¶ä¸­Dä¸ºæ ·æœ¬æ€»æ•°ï¼Œä¸ºæ ·æœ¬çš„æ•°é‡ï¼ŒNä¸ºçš„å–å€¼ä¸ªæ•°ï¼Œå³æœ€ç»ˆå½’çš„ç±»æ•°ã€‚\nå¯¹äºçš„è®¡ç®—ï¼Œæˆ‘ä»¬æ”¹ç”¨å…¶ä¸­ä¸ºç±»åˆ«ä¸‹ç¬¬ä¸ªç‰¹å¾å€¼ä¸ºçš„ä¸ªæ•°ï¼Œåˆ™ä¸ºç¬¬ä¸ªç‰¹å¾å¯èƒ½å–å€¼çš„ä¸ªæ•°ã€‚\n\n\nä¾æœ¬äººæ‹™è§ï¼Œå¯ä»¥è¿™ä¹ˆç†è§£ï¼Œå‡è®¾ä¸€ä¸ªç‰¹å¾çš„æ¯ä¸€ç§å–å€¼éƒ½æ˜¯ç­‰å¯èƒ½çš„ï¼Œé‚£ä¹ˆç†è®ºä¸Šæˆ‘ä»¬æŠ½å–ä¸ªæ ·æœ¬åä¼šå‡ºç°1ä¸ªï¼Œå› æ­¤åˆ†å­çš„+1å¯ä»¥ç†è§£ä¸ºæˆ‘ä»¬åœ¨åŸæ ·æœ¬çš„åŸºç¡€ä¸Šåˆå¦å¤–æŠ½å–äº†ä¸ªæ ·æœ¬ã€‚\n\nCâ˜ºDE@ train.pyimport pandas as pd\nimport numpy as np\nimport joblib as jb\n\ndata = np.array(pd.read_csv('è¥¿ç“œçš„æ•°æ®é›†.csv'))\nsample_num = len(data)\nattribute_num = len(data[0]) - 1\n# the size of value range of each attribute\nvalues_num = []\n# No. corresponding to each value in one attribute\ndic = [{} for i in range(attribute_num)]\n# calculate the number of possible values for each attribute via 'set'\nfor i in range(attribute_num):\n    values = set()\n    for j in range(sample_num):\n        values = values | {data[j][i]}  # union of two set\n    values_num.append(len(values))\n    # number each different value\n    No = 0\n    for v in values:\n        dic[i][v] = No\n        No += 1\n\np1_cnt = [np.zeros(values_num[i]) for i in range(attribute_num)]\np0_cnt = [np.zeros(values_num[i]) for i in range(attribute_num)]\nfor i in range(sample_num):\n    cnt = p1_cnt if data[i][attribute_num] == 'æ˜¯' else p0_cnt\n    for j in range(attribute_num):\n        cnt[j][dic[j][data[i][j]]] += 1\n\np1 = (sum(p1_cnt[0]) + 1) / (sample_num + attribute_num)\np0 = (sum(p0_cnt[0]) + 1) / (sample_num + attribute_num)\n\nfor i in range(attribute_num):\n    p1_cnt[i] = (p1_cnt[i] + 1) / (sum(p1_cnt[i]) + len(dic[i]))\n    p0_cnt[i] = (p0_cnt[i] + 1) / (sum(p0_cnt[i]) + len(dic[i]))\n\n# save outcome\njb.dump(p1_cnt, 'p1_cnt.pkl')\njb.dump(p0_cnt, 'p0_cnt.pkl')\njb.dump(dic, 'dic.pkl')\njb.dump(p1, 'p1.pkl')\njb.dump(p0, 'p0.pkl')\n\n@ test.pyimport joblib as jb\nimport numpy as np\nimport pandas as pd\nimport math\n\n# load trained byes model\np1 = jb.load('p1.pkl')\np0 = jb.load('p0.pkl')\ndic = jb.load('dic.pkl')\np1_cnt = jb.load('p1_cnt.pkl')\np0_cnt = jb.load('p0_cnt.pkl')\n\ntest_data = np.array(pd.read_csv('è¥¿ç“œçš„éªŒè¯é›†.csv'))\nsample_num = len(test_data)\nattribute_num = len(test_data[0]) - 1\n\nright_cnt = 0\n\nfor i in range(sample_num):\n    p1_pred = p0_pred = 0\n    for j in range(attribute_num):\n        p1_pred += math.log(p1_cnt[j][dic[j][test_data[i][j]]])\n        p0_pred += math.log(p0_cnt[j][dic[j][test_data[i][j]]])\n    p1_pred += math.log(p1)\n    p0_pred += math.log(p0)\n    if ('æ˜¯' if p1_pred &gt; p0_pred else 'å¦') == test_data[i][attribute_num]:\n        right_cnt += 1\n\nprint(\"æ­£ç¡®ä¸ªæ•°ï¼š\\t%d\\né¢„æµ‹æ€»æ•°ï¼š\\t%d\\næ­£ç¡®ç‡ï¼š\\t%f\" % (right_cnt, sample_num, right_cnt / sample_num))\n\n\nÎ£ ä¸€äº›è¯´æ˜\né¦–å…ˆç”¨é›†åˆsetæ±‚å‡ºæ¯ä¸ªç‰¹å¾ï¼ˆattributeï¼‰å¯èƒ½å–å€¼çš„ä¸ªæ•°ï¼Œå¹¶å¯¹æ¯ä¸ªç‰¹å¾å†…æ‰€æœ‰å¯èƒ½çš„å–å€¼è¿›è¡Œç¼–å·ï¼ˆdicï¼‰\n\nç„¶ååˆ†åˆ«è®¡æ•°ç»Ÿè®¡å¥½ç“œå’Œåç“œä¸­æ¯ä¸ªç‰¹å¾çš„æ¯ä¸ªå¯èƒ½å–å€¼çš„ä¸ªæ•°\n\næœ€åç”¨æ‹‰æ™®æ‹‰æ–¯å¹³æ»‘æ³•è®¡ç®—å‡ºï¼ˆpiï¼‰å’Œï¼ˆpi_cntï¼‰\n\n\n","slug":"Naive-Bayes","date":"2022-03-29T12:46:48.000Z","categories_index":"Machine Learning","tags_index":"python,èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"d8805cb4c52676259ff97b6383bdfab8","title":"ã€ŒSection 7ã€å¯»å€æ–¹å¼","content":"\nå¯»å€æ–¹å¼ï¼šï¼ˆç”±ç¡¬ä»¶ï¼‰ç¡®å®šæœ¬æ¡æŒ‡ä»¤çš„æ“ä½œæ•°åœ°å€ï¼Œä»¥åŠä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€çš„æ–¹æ³•\n\næŒ‡ä»¤å¯»å€ï¼šæŒ‡ä»¤åœ¨ä¸»å­˜ä¸­æ˜¯æŒ‰é¡ºåºå­˜æ”¾çš„ï¼Œæˆ‘ä»¬ç¡®å®šä¸‹ä¸€æ¡æŒ‡ä»¤åœ¨ä¸»å­˜ä¸­çš„åœ°å€\né¡ºåºå¯»å€ï¼šPCæ°¸è¿œæŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼Œå–å®ŒæŒ‡ä»¤åè‡ªåŠ¨è‡ªå¢æŒ‡å‘ä¸‹ä¸€æ¡å¾…æ‰§è¡ŒæŒ‡ä»¤åœ°å€\n\nè·³è·ƒå¯»å€ï¼šå½“å‰æŒ‡ä»¤å°†ç›®æ ‡æŒ‡ä»¤çš„åœ°å€ç½®å…¥PCä¸­ä»è€Œå®ç°è·³è½¬ï¼ˆæœ¬è´¨ä¸Šä¹Ÿæ˜¯é¡ºåºå¯»å€çš„ç»“æœï¼‰\n\nå¯„å­˜å™¨PCåœ¨å¼€æœºä¸Šç”µåè‡ªåŠ¨åˆå§‹åŒ–ä¸ºç¬¬ä¸€æ¡æŒ‡ä»¤åœ°å€\n\n\n\næ•°æ®å¯»å€ï¼šç¡®å®šæ“ä½œæ•°åœ¨ä¸»å­˜ä¸­çš„åœ°å€\nå½¢å¼åœ°å€ï¼šæŒ‡ä»¤çš„åœ°å€ç å­—æ®µAddrï¼Œé€šå¸¸éƒ½ä¸æ˜¯çœŸå®çš„åœ°å€å€¼\n\næœ‰æ•ˆåœ°å€ï¼šæ“ä½œæ•°åœ¨ä¸»å­˜ä¸­çš„çœŸå®åœ°å€ï¼Œç”±åœ°å€ç å­—æ®µAddrä¸å¯»å€æ–¹å¼å…±åŒç¡®å®šï¼Œè®°ä½œEA\n\n\n\n\n\næ•°æ®å¯»å€æ–¹å¼\n\nç«‹å³å¯»å€ï¼šAddrå³ä¸ºæ“ä½œæ•°æœ¬èº«ï¼Œç«‹å³å¯ç”¨ã€‚ä¸€èˆ¬ç”¨äºå˜é‡èµ‹åˆå€¼ã€‚\nMOV EAX,2008H\n\nç›´æ¥å¯»å€ï¼šæ“ä½œæ•°å­˜å‚¨äºä¸»å­˜ä¸­ï¼ŒAddrä¸ºå…¶åœ¨ä¸»å­˜ä¸­çš„åœ°å€ï¼Œç›´æ¥é€šè¿‡Addrè®¿é—®å³å¯å¾—æ“ä½œæ•°ã€‚\nMOV EAX,[2008H]\n\né—´æ¥å¯»å€ï¼šç›¸å¯¹ç›´æ¥å¯»å€è€Œè¨€ï¼Œä½†Addrä¸æ˜¯å…¶å­˜å‚¨åœ°å€ï¼Œè€Œæ˜¯æ“ä½œæ•°çš„åœ°å€çš„åœ°å€ï¼Œéœ€è¦è®¿é—®ä¸¤æ¬¡ä¸»å­˜æ‰å¯ä»¥å¾—åˆ°æ“ä½œæ•°ã€‚\nMOV EAX,@2008H\n\n\nè§£å†³äº†ç›´æ¥å¯»å€åœ°å€ç é•¿åº¦å—é™çš„é—®é¢˜ï¼Œèƒ½ç”¨è¾ƒçŸ­çš„åœ°å€ç è®¿é—®è¾ƒå¤§çš„ä¸»å­˜åœ°å€\n\næ›´åŠ çµæ´»ï¼Œå½“æ“ä½œæ•°åœ°å€æ”¹å˜æ—¶æ— éœ€æ”¹å˜æŒ‡ä»¤åªéœ€æ”¹å˜AddræŒ‡å‘çš„ä¸»å­˜å•å…ƒå³å¯\n\n\n\nå¯„å­˜å™¨å¯»å€ï¼šæ“ä½œæ•°åœ¨CPUçš„æŸä¸ªé€šç”¨å¯„å­˜å™¨ä¸­ï¼ŒAddrä¸ºå…¶é€šç”¨å¯„å­˜å™¨ç¼–å·ï¼ˆé€šç”¨å¯„å­˜å™¨ç»„å¯ä»¥è§†ä½œæ•°ç»„ï¼Œç¼–å·å³ä¸ºä¸‹æ ‡ï¼‰ï¼Œè®¿é—®ç›¸åº”å¯„å­˜å™¨å³å¯å¾—æ“ä½œæ•°ã€‚\n\nå¯„å­˜å™¨çš„è®¿é—®é€Ÿåº¦è¾ƒè®¿é—®ä¸»å­˜æ›´å¿«\nç¼–å·é•¿åº¦è¾ƒçŸ­ï¼Œæœ‰åˆ©äºç¼©çŸ­æŒ‡ä»¤é•¿åº¦\n\nMOV EAX,ECX\n\nå¯„å­˜å™¨é—´æ¥å¯»å€ï¼šä¸é—´æ¥å¯»å€ä¸åŒçš„æ˜¯ï¼Œæ“ä½œæ•°çš„åœ°å€å­˜å‚¨äºå¯„å­˜å™¨ï¼ŒAddrä¸ºè¯¥å¯„å­˜å™¨ç¼–å·ã€‚\nMOV AL,[EBX]\n\nç›¸å¯¹å¯»å€ï¼šAddræ”¾çš„æ˜¯ç›¸å¯¹PCçš„åç§»é‡ï¼ŒEA=Addr+PCï¼ˆä¸ºä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼‰ä¸ºæ“ä½œæ•°çš„æœ‰æ•ˆåœ°å€ã€‚\n\nåªéœ€å­˜å‚¨æŒ‡ä»¤ä¸æ“ä½œæ•°ä¹‹é—´çš„ç›¸å¯¹è·ç¦»ï¼Œå› æ­¤æœ‰åˆ©äºå®ç°ç¨‹åºçš„æµ®åŠ¨\n\n\nå˜å€å¯»å€ï¼šå˜å€å¯„å­˜å™¨è¢«æŒ‡å®šç”¨æ¥å­˜æ”¾å˜åŒ–çš„åœ°å€ï¼Œæ­¤æ—¶åœ°å€ç å­—æ®µAddrä¼šå¢åŠ ä¸€ä¸ªå˜å€å¯„å­˜å™¨ç¼–å·Xï¼ŒXä¸å½¢å¼åœ°å€Dä¹‹å’Œå³ä¸ºæ“ä½œæ•°çš„æœ‰æ•ˆåœ°å€ï¼Œã€‚\n\n\n\nXæä¾›ä¿®æ”¹é‡ï¼ŒDæä¾›åŸºå‡†é‡ã€‚Xçš„å†…å®¹ä¸€ç›´åœ¨å˜ï¼Œè€ŒDçš„å€¼ä¸€ç»è®¾å®šæ‰§è¡Œè¿‡ç¨‹ä¸­å°†ä¸ä¼šå˜åŒ–\nä¸»è¦åº”ç”¨äºå¯¹çº¿æ€§è¡¨ä¹‹ç±»çš„æ•°ç»„å…ƒç´ è¿›è¡Œé‡å¤çš„è®¿é—®\n\n\nåŸºå€å¯»å€ï¼šåŸºå€å¯„å­˜å™¨è¢«æŒ‡å®šæ¥å­˜æ”¾åŸºåœ°å€ï¼Œä¸å˜å€å¯»å€ç±»ä¼¼ï¼Œå¤šäº†ä¸€æ®µåŸºå€å¯„å­˜å™¨ç¼–å·Bï¼ŒBä¸å½¢å¼åœ°å€Dä¹‹å’Œå³ä¸ºæ“ä½œæ•°çš„æœ‰æ•ˆåœ°å€ã€‚ä¸å˜å€å¯»å€ä¸åŒçš„æ˜¯ï¼ŒåŸºå€å¯„å­˜å™¨çš„å€¼ä¸€ç»è®¾å®šè¿è¡Œè¿‡ç¨‹ä¸­å°†ä¸ä¼šæ”¹å˜ï¼Œæ­¤æ—¶ç”±Dæ¥æä¾›ä¿®æ”¹é‡ã€‚\n\nå †æ ˆå¯»å€ï¼šå¯»æ‰¾å­˜æ”¾åœ¨å †æ ˆä¸­çš„æ“ä½œæ•°ç§°ä¸ºå †æ ˆå¯»å€ã€‚æ ¹æ®å¼€è¾Ÿå †æ ˆçš„ä½ç½®å¯ä»¥å°†å †æ ˆåˆ†ä¸ºå­˜å‚¨å™¨å †æ ˆå’Œå¯„å­˜å™¨å †æ ˆã€‚\n\nå­˜å‚¨å™¨å †æ ˆ\n\n\n\nå †æ ˆæŒ‡é’ˆå¯„å­˜å™¨SPæŒ‡å‘æ ˆé¡¶å•å…ƒ\nå…¥æ ˆï¼šSP=SP-1ï¼ˆä½åœ°å€åœ¨ä¸Šï¼‰ï¼ŒM[SP]=R\nå‡ºæ ˆï¼šR=M[SP]ï¼ŒSP=SP+1\n\n\nå¯„å­˜å™¨å †æ ˆ\n\n\n\nå¯„å­˜å™¨å †æ ˆæ ˆé¡¶å›ºå®šä¸åŠ¨\nå †æ ˆæ“ä½œæ—¶ï¼Œå¯„å­˜å™¨å †æ ˆå†…æ•°æ®æ•´ä½“ç§»åŠ¨\nå¯„å­˜å™¨å †æ ˆé€Ÿåº¦å¿«ï¼Œä½†å®¹é‡æœ‰é™ï¼›å­˜å‚¨å™¨å †æ ˆåˆ™é€Ÿåº¦æ…¢ï¼Œå®¹é‡å¤§\nå¯„å­˜å™¨å †æ ˆå¿…é¡»é‡‡ç”¨ä¸“ç”¨çš„å †æ ˆæŒ‡ä»¤è¿›è¡Œæ§åˆ¶\n\n\n\n\n\n\n\n","slug":"å¯»å€æ–¹å¼","date":"2022-03-23T01:04:09.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"bba1ccc43c803be00dfdf449eaee8924","title":"å€ŸåŠ©Flexå®ç°SysYè¯æ³•åˆ†æ","content":"è¯æ³•åˆ†æï¼ˆlexical analysisï¼‰æ˜¯ç¼–è¯‘å™¨çš„ç¬¬ä¸€é˜¶æ®µï¼Œä¸»è¦æ˜¯å°†ä»£ç çš„å­—ç¬¦åºåˆ—è½¬æ¢ä¸ºtokençš„è¿‡ç¨‹ã€‚ç®€å•åœ°æ¥è¯´ï¼Œå°±æ˜¯å¯¹ä»£ç è¿›è¡Œåˆ‡å—çš„ä¸€ä¸ªè¿‡ç¨‹ï¼Œå¹¶å°†æ¯ä¸€å—æ·»åŠ ä¸Šå…¶æ‰€å±çš„ç±»åˆ«æ ‡ç­¾ã€‚æ¯”å¦‚è¯´int asd=897;ï¼Œå…¶è¯æ³•åˆ†æçš„ç»“æœå³ä¸º\n\nint    ï¼š&lt; TYPE , â€˜intâ€™ &gt;\n\nasd    ï¼š&lt; ID , â€˜astâ€™ &gt;\n\n=        ï¼š&lt; OPERATOR , â€˜=â€™ &gt;\n\n897    ï¼š&lt; DEC_CONST , 897 &gt;\n\n;        ï¼š&lt; SEMICN , â€˜;â€™ &gt;\n\n\ntokençš„ä¸€èˆ¬å½¢å¼ä¸º&lt;type , literal&gt;ï¼Œå…¶ä¸­typeä¸ºè¯¥è¯æ‰€å±ç±»å‹ï¼Œliteralåˆ™ä¸ºå…¶è¡¨å€¼ã€‚è¯æ³•åˆ†æçš„ç†è®ºéƒ¨åˆ†ä¸»è¦æ˜¯è‡ªåŠ¨æœºçš„æ„é€ ä»¥åŠè½¬æ¢ï¼Œå¹¶ä¸æ˜¯å¤ªéš¾ï¼Œè¿™é‡Œä¸åšèµ˜è¿°ã€‚æœ¬ç¯‡æ–‡ç« ä¸»è¦è®²è¿°å¦‚ä½•å€ŸåŠ©Flexå·¥å…·æ¥ç”ŸæˆSysYè¯­è¨€ï¼ˆCè¯­è¨€çš„ä¸€ä¸ªå­é›†ï¼Œå…·ä½“è¯­è¨€å®šä¹‰è§è¿™ï¼‰çš„è¯æ³•åˆ†æã€‚\n\n\n\n\n\n\n\n\n\n\nFlexçš„å‰èº«æ˜¯Lexã€‚Lexæ˜¯1975å¹´ç”±Mike Leskå’Œå½“æ—¶è¿˜åœ¨AT&amp;Tåšæš‘æœŸå®ä¹ çš„Eric Schmidtï¼Œå…±åŒå®Œæˆçš„ä¸€æ¬¾åŸº äºUnixç¯å¢ƒçš„è¯æ³•åˆ†æç¨‹åºç”Ÿæˆå·¥å…·ã€‚è™½ç„¶Lexå¾ˆå‡ºåå¹¶è¢«å¹¿æ³› ä½¿ç”¨ï¼Œä½†å®ƒçš„ä½æ•ˆå’Œè¯¸å¤šé—®é¢˜ä¹Ÿä½¿å…¶é¢‡å—è¯Ÿç—…ã€‚å æ¥ä¼¯å…‹åˆ©å®éªŒå®¤çš„Vern Paxsonä½¿ç”¨Cè¯­è¨€ é‡å†™Lexï¼Œå¹¶å°†è¿™ä¸ªæ–°çš„ç¨‹åºå‘½åä¸ºFlex(æ„ä¸ºFast Lexical Analyzer Generator)ã€‚æ— è®ºåœ¨æ•ˆç‡ä¸Šè¿˜æ˜¯åœ¨ç¨³å®šæ€§ä¸Šï¼ŒFlexéƒ½è¿œè¿œå¥½äºå®ƒçš„å‰è¾ˆLexã€‚æˆ‘ä»¬åœ¨Linuxä¸‹ä½¿ç”¨çš„æ˜¯Flexåœ¨GNU Licenseä¸‹çš„ç‰ˆæœ¬ï¼Œç§°ä½œGNU Flexã€‚\nFlexæ˜¯ä¸€ä¸ªå¸®åŠ©ç”Ÿæˆè¯æ³•åˆ†æä»£ç çš„å·¥å…·ï¼Œä½ åªéœ€å‘Šè¯‰å®ƒç›®æ ‡è¯­è¨€ä¸­å„ä¸ªè¯æ³•çš„æ­£åˆ™è¡¨è¾¾å¼ï¼ŒFlexå°±ä¼šå¸®ä½ ç”Ÿæˆä¸€ä¸ªlex.yy.cçš„Cä»£ç æ–‡ä»¶ã€‚é‚£ä¹ˆé¦–å…ˆä½ éœ€è¦æäº¤ç»™Flexä¸€ä¸ª.læ–‡ä»¶æ¥å‘Šè¯‰å®ƒè¯æ³•è§„åˆ™ï¼Œè¯¥æ–‡ä»¶çš„æ ¼å¼å¦‚ä¸‹ï¼š\n%option xxx\n%{\n    Declarations\n%}\n    Definitions\n%%\n    Rules\n%%\n    User Subroutines\n\nç¬¬ä¸€è¡Œçš„optionæ˜¯æ¥å¼€å¯Flexè‡ªå¸¦çš„ä¸€äº›è¾…åŠ©åŠŸèƒ½ã€‚æ¯”å¦‚è¯´Flexæä¾›è¡Œå·è®°å½•å˜é‡yylinenoï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡è¯¥å˜é‡è¯»å–å½“å‰è¡Œå·è€Œä¸”æ— éœ€ç»´æŠ¤ï¼Œä½†åœ¨é»˜è®¤çŠ¶æ€ä¸‹è¯¥å˜é‡ä¸å¼€æ”¾ç»™ç”¨æˆ·ï¼Œå¦‚éœ€ä½¿ç”¨å°±è¦åœ¨å¼€å¤´åŠ å…¥%option yylinenoã€‚\nç¬¬äºŒéƒ¨åˆ†%{â€¦%}ä¸­çš„Declarationså‘¢ï¼Œæ˜¯ä¼šç›´æ¥åŠ å…¥ç”Ÿæˆä»£ç çš„é å‰éƒ¨åˆ†ï¼Œä¸€èˆ¬æ˜¯å¼•ç”¨å¤´æ–‡ä»¶æˆ–è€…æ˜¯å®šä¹‰åˆå§‹å˜é‡ã€‚\nç¬¬ä¸‰éƒ¨åˆ†%}â€¦%%ä¸­çš„Definitionsåˆ™æ˜¯å®šä¹‰æ®µï¼Œè¿™é‡Œä¸€èˆ¬ä¼šä¸ºæ¯”è¾ƒé•¿çš„æ­£åˆ™è¡¨è¾¾å¼å‘½åä»¥æ–¹ä¾¿ä¸‹ä¸€æ¨¡å—çš„æè¿°ï¼Œç±»ä¼¼äºCè¯­è¨€ä¸­çš„å®å®šä¹‰ã€‚æ­£åˆ™è¡¨è¾¾å¼å…·ä½“çš„è¯­æ³•å¯ä»¥å‚è€ƒFlex æ ¸å¿ƒè§„èŒƒã€‚\nç¬¬å››éƒ¨åˆ†%%â€¦%%çš„Rulesåˆ™æ˜¯è¯¥æ–‡ä»¶çš„æ ¸å¿ƒéƒ¨åˆ†â€”â€”è§„åˆ™æ®µã€‚è§„åˆ™æ®µå°±æ˜¯å®šä¹‰éœ€è¦è¢«è¯†åˆ«å‡ºæ¥çš„è¯æ³•ç±»å‹ï¼ˆå¯ä»¥ç”¨ç¬¬ä¸‰éƒ¨åˆ†ä¸­çš„å®šä¹‰æ¥ç»„åˆï¼‰ï¼Œä»¥åŠè¯†åˆ«åˆ°è¯¥ç±»å‹æ—¶éœ€è¦è¿›è¡Œçš„æ“ä½œã€‚æ¯ä¸€æ¬¡Flexéƒ½ä¼šä½¿ç”¨å°½å¯èƒ½é•¿çš„å­—ç¬¦ä¸²è¿›è¡ŒåŒ¹é…ï¼Œå³é€‰æ‹©æœ€é•¿å­—ç¬¦ä¸²å¯ä»¥åŒ¹é…åˆ°çš„ç±»å‹ã€‚ä½†å½“åŒä¸€ä¸ªé•¿åº¦çš„å­—ç¬¦ä¸²åŒ¹é…äº†å¤šä¸ªç±»å‹æ—¶ï¼Œé»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªåŒ¹é…åˆ°çš„ç±»å‹ï¼Œå› æ­¤Rulesçš„æ’åˆ—ä¹Ÿæœ‰è®²ç©¶ã€‚\nç¬¬äº”éƒ¨åˆ†User Subroutinesåˆ™æ˜¯ç”¨æˆ·è‡ªå·±çš„ä»£ç ï¼Œä¼šç›´æ¥å¤åˆ¶åˆ°ç”Ÿæˆä»£ç çš„æœ€åã€‚å‰é¢è¯æ³•è¯†åˆ«è§„åˆ™ä¼šç›´æ¥è¢«Flexç¿»è¯‘ä¸ºä¸€ä¸ªyylex()å‡½æ•°ï¼Œè¯¥å‡½æ•°å³ä¸ºåŒ¹é…è¯æ³•ç±»å‹çš„å‡½æ•°ã€‚é‚£ä¹ˆå¦‚æœç”¨æˆ·éœ€è¦åšä¸€äº›é”™è¯¯å¤„ç†ï¼ˆæ¯”å¦‚è¯†åˆ«åˆ°è¯¥è¯­è¨€ä¸­ä¸å­˜åœ¨çš„å­—ç¬¦ï¼‰ä»¥åŠéƒ¨åˆ†ç±»å‹è¯†åˆ«åˆ°åéœ€è¦å•ç‹¬å¤„ç†æ—¶ï¼Œå°±å¯ä»¥å°†å¤„ç†ä»£ç å†™åœ¨è¿™ã€‚\nå¦å¤–ï¼ŒFlexè¿˜æä¾›äº†ä¸¤ä¸ªå…¨å±€å˜é‡ yytext å’Œ yylengï¼Œåˆ†åˆ«è¡¨ç¤ºåˆšåˆšåŒ¹é…åˆ°ç±»å‹çš„å­—ç¬¦ä¸²ä¸è¯¥å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚\n\nâ¦ SysY.l%option yylineno\n\n%{\n    #include \"translator.h\"\n%}\n\nTYPE                int|void\nKEYWORD             if|else|while|break|continue|return\nOPERATOR            \"+\"|\"-\"|\"!\"|\"*\"|\"%\"|\"/\"|\"=\"\nCOMPARISON          \"==\"|\"!=\"|\"&gt;\"|\"&lt;\"|\"&gt;=\"|\"&lt;=\"\nNONZERO             [1-9]\nDIGIT               [0-9]\nLETTER              [A-Za-z]\nOCTAL_DIGIT         [0-7]\nOCTAL_CONST         0{OCTAL_DIGIT}*\nILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z]({LETTER}|{DIGIT})*\nHEX_PREFIX          0x|0X\nHEX_DIGIT           [0-9a-fA-F]\nHEX_CONST           {HEX_PREFIX}{HEX_DIGIT}+\nILLEGAL_HEX_CONST   {HEX_PREFIX}({LETTER}|{DIGIT})*\nNONDIGIT            {LETTER}|\"_\"\nID                  {NONDIGIT}({DIGIT}|{NONDIGIT})*\nDEC_CONST           {NONZERO}{DIGIT}*  \nCOMMENT1            \"/*\"[^*]*\"*\"+([^*/][^*]*\"*\"+)*\"/\"\nCOMMENT2            \"//\".*                                                                                \n\n%%\n\n{TYPE}                  { printf(\"\\033[1;32mTYPE\\033[0m\\t\\t%s\\n\",yytext);return TYPE; }\n{OCTAL_CONST}           { printf(\"\\033[1;32mOCTAL_CONST\\033[0m\\t\");return OCTAL_CONST; }\n{ILLEGAL_OCTAL_CONST}   { return ILLEGAL_OCTAL_CONST; }\n{HEX_CONST}             { printf(\"\\033[1;32mHEX_CONST\\033[0m\\t\");return HEX_CONST; }\n{ILLEGAL_HEX_CONST}     { return ILLEGAL_HEX_CONST; }\n{DEC_CONST}             { printf(\"\\033[1;32mDEC_CONST\\033[0m\\t%s\\n\",yytext);return DEC_CONST; }\n{KEYWORD}               { printf(\"\\033[1;32mKEYWORD\\033[0m\\t\\t%s\\n\",yytext);return KEYWORD; }\n{ID}                    { printf(\"\\033[1;32mID\\033[0m\\t\\t%s\\n\",yytext);return ID; }\n{OPERATOR}              { printf(\"\\033[1;32mOPERATOR\\033[0m\\t%s\\n\",yytext);return OPERATOR; }\n{COMPARISON}            { printf(\"\\033[1;32mCOMPARISON\\033[0m\\t%s\\n\",yytext);return COMPARISON; }\n\"(\"                     { printf(\"\\033[1;32mLPARENT\\033[0m\\t\\t%s\\n\",yytext);return LPARENT; }\n\")\"                     { printf(\"\\033[1;32mRPARENT\\033[0m\\t\\t%s\\n\",yytext);return RPARENT; }\n\"[\"                     { printf(\"\\033[1;32mLBRACKET\\033[0m\\t%s\\n\",yytext);return LBRACKET; }\n\"]\"                     { printf(\"\\033[1;32mRBRACKET\\033[0m\\t%s\\n\",yytext);return RBRACKET; }\n\"{\"                     { printf(\"\\033[1;32mLBRACE\\033[0m\\t\\t%s\\n\",yytext);return LBRACE; }\n\"}\"                     { printf(\"\\033[1;32mRBRACE\\033[0m\\t\\t%s\\n\",yytext);return RBRACE; }\n\";\"                     { printf(\"\\033[1;32mSEMICN\\033[0m\\t\\t%s\\n\",yytext);return SEMICN; }\n\",\"                     { printf(\"\\033[1;32mCOMMA\\033[0m\\t\\t%s\\n\",yytext);return COMMA; }\n\"&amp;&amp;\"                    { printf(\"\\033[1;32mAND\\033[0m\\t\\t%s\\n\",yytext);return AND; }\n\"||\"                    { printf(\"\\033[1;32mOR\\033[0m\\t\\t%s\\n\",yytext);return OR; }\n{COMMENT1}|{COMMENT2}   { }\n[ \\t\\n]                 { }\n.                       { return UNEXPECTED; }\n\n%%\n\nint main()\n{\n    int token_type;\n    while (token_type = yylex())\n    {\n        if (token_type == UNEXPECTED)\n            printf(\"\\033[1;31mError type A at Line %d: Invalid character \\\"%s\\\"\\033[0m\\n\", yylineno, yytext);\n        else if (token_type == OCTAL_CONST)\n        {\n            int sum = 0;\n            for (int i = 1; i &lt; yyleng; ++i)\n                sum = sum * 8 + (yytext[i] - '0');\n            printf(\"%d\\n\", sum);\n        }\n        else if (token_type == HEX_CONST)\n        {\n            int sum = 0;\n            for (int i = 2; i &lt; yyleng; ++i)\n            {\n                if (yytext[i] &lt;= '9' &amp;&amp; yytext[i] &gt;= '0')\n                    sum = sum * 16 + (yytext[i] - '0');\n                else\n                {\n                    switch (yytext[i])\n                    {\n                    case 'a':\n                    case 'A':\n                        sum = sum * 16 + 10;\n                        break;\n                    case 'b':\n                    case 'B':\n                        sum = sum * 16 + 11;\n                        break;\n                    case 'c':\n                    case 'C':\n                        sum = sum * 16 + 12;\n                        break;\n                    case 'd':\n                    case 'D':\n                        sum = sum * 16 + 13;\n                        break;\n                    case 'e':\n                    case 'E':\n                        sum = sum * 16 + 14;\n                        break;\n                    case 'f':\n                    case 'F':\n                        sum = sum * 16 + 15;\n                        break;\n                    }\n                }\n            }\n            printf(\"%d\\n\", sum);\n        }\n        else if (token_type == ILLEGAL_OCTAL_CONST)\n            printf(\"\\033[1;31mError type B at line %d: Illegal octal number \\'%s\\'\\033[0m\\n\", yylineno, yytext);\n        else if (token_type == ILLEGAL_HEX_CONST)\n            printf(\"\\033[1;31mError type B at line %d: Illegal hex number \\'%s\\'\\033[0m\\n\", yylineno, yytext);\n    }\n}\n\n\nâ˜•ï¸ ä¸€äº›è¯´æ˜\nâ€œtranslator.hâ€å¤´æ–‡ä»¶å†…å¯¹éœ€è¦è¯†åˆ«çš„è¯æ³•ç±»å‹ï¼ˆTYPEï¼ŒOCTAL_CONSTï¼Œâ€¦ï¼‰è¿›è¡Œäº†enumæšä¸¾ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯æ•´æ•°\nç¬¬å››éƒ¨åˆ†ä¸­å¼•ç”¨ç¬¬ä¸‰éƒ¨åˆ†å®šä¹‰çš„åå­—æ—¶éœ€è¦æ³¨æ„åœ¨å¼•ç”¨åå­—å¤–é¢åŠ ä¸Š{å¤§æ‹¬å·}ï¼Œå¦åˆ™ä¼šå˜æˆè¯†åˆ«ä¸€æ®µå­—ç¬¦ä¸²\nprintfä¸­çš„ã€\\033[1;32mâ€¦\\033[0mã€‘æ˜¯å°†ä¸­é—´æ–‡å­—ä¸Šè‰²ğŸ¨\næ­£åˆ™è¡¨è¾¾å¼ä¸­å¯¹äºæ³¨é‡Šçš„è¯†åˆ«æ˜¯ä¸€ä¸ªæ¯”è¾ƒæ£˜æ‰‹çš„é—®é¢˜ã€‚\nå¯¹äºå•è¡Œæ³¨é‡Šï¼Œæˆ‘ä»¬çŸ¥é“å¼€å¤´æ˜¯â€œ//â€ï¼Œåé¢éœ€è¦å°†è¯¥è¡Œå‰©ä½™æ‰€æœ‰å­—ç¬¦éƒ½åŒ¹é…æ‰ï¼Œæ³¨æ„åˆ°ç‚¹å¯ä»¥åŒ¹é…éæ¢è¡Œç¬¦çš„ä»»æ„å­—ç¬¦ï¼ˆ.==[^\\n]ï¼‰ï¼Œé‚£ä¹ˆç‚¹çš„Kleeneé—­åŒ….*å³å¯åŒ¹é…è¯¥è¡Œå‰©ä½™æ‰€æœ‰å­—ç¬¦äº†\nå¯¹äºå¤šè¡Œæ³¨é‡Šï¼Œæˆ‘ä»¬çŸ¥é“å¼€å¤´æ˜¯â€œ/*â€ï¼Œä¸­é—´éƒ¨åˆ†åªè¦ä¸å‡ºç°â€œ*/â€å³å¯ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘å°†ä¸­é—´éƒ¨åˆ†ï¼ˆåŒ…æ‹¬ç»“å°¾â€œ*/â€ä¸­çš„â€œ*â€ï¼‰åˆ†ä¸ºå¤šæ®µä»¥â€œ**Â·Â·Â·*â€ï¼ˆï¼‰ç»“å°¾çš„å­—ç¬¦ä¸²ï¼Œæ¯ä¸€æ®µçš„ç»“å°¾å‰é¢éƒ½ä¸èƒ½å‡ºç°â€œ*â€ã€‚é‚£ä¹ˆæ¯ä¸€å°æ®µéƒ½å¯ä»¥å…ˆå†™ä¸º[^*]*\"*\"+ï¼ˆâš ï¸â€œ*â€ä»…è¡¨ç¤ºå­—ç¬¦ï¼Œ*è¡¨ç¤ºå‰é¢éƒ¨åˆ†çš„Kleeneé—­åŒ…ï¼‰ã€‚ä½†æ˜¯æ¯ä¸€æ®µè¿èµ·æ¥çš„æ—¶å€™ä¸èƒ½å‡ºç°â€œ*/â€ï¼Œå› æ­¤æ¯ä¸€å°æ®µçš„å¼€å¤´éƒ½ä¸èƒ½æ˜¯â€œ/â€ï¼Œè¿™æ—¶åˆ™å¯ä»¥å†™ä¸º[^/*][^*]*\"*\"+ã€‚ç„¶è€Œç¬¬ä¸€å°æ®µä»¥â€œ/â€å¼€å¤´å´æ˜¯æ²¡å…³ç³»çš„ï¼ˆ/*/ä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„æ³¨é‡Šï¼‰ï¼Œå› æ­¤ç¬¬ä¸€å°æ®µå•ç‹¬å†™ä¸º[^*]*\"*\"+ã€‚æœ€ç»ˆå¤šè¡Œæ³¨é‡Šçš„æ­£åˆ™è¡¨è¾¾å¼å³ä¸º\"/*\"[^*]*\"*\"+([^/*][^*]*\"*\"+)*\"/\"ã€‚\n\n\nç¬¬äº”éƒ¨åˆ†ä¸»è¦å®ç°äº†å…«è¿›åˆ¶ä¸åå…­è¿›åˆ¶çš„è½¬æ¢ï¼Œä»¥åŠä¸€äº›é”™è¯¯å¤„ç†ï¼ŒåŒ…æ‹¬è¯†åˆ«éæ³•å…«è¿›åˆ¶ã€åå…­è¿›åˆ¶å­—ç¬¦å’Œéæ³•å­—ç¬¦çš„æŠ¥é”™\nå…«è¿›åˆ¶ä¸åå…­è¿›åˆ¶çš„éæ³•å­—ç¬¦è¯†åˆ«æ˜¯å¦å¤–å®šä¹‰äº†ä¸¤ä¸ªç±»å‹ILLEGAL_OCTAL_CONSTä¸ILLEGAL_HEX_CONSTï¼Œåˆ†åˆ«ç½®äºç¬¬å››éƒ¨åˆ†ä¸­OCTAL_CONSTå’ŒHEX_CONSTçš„åé¢ã€‚è¿™æ ·ä¸€æ¥å¦‚æœæ›´é•¿çš„å­—ç¬¦ä¸²åŒ¹é…åˆ°äº†ILLEGALç±»å‹å°±ä¼šè¿”å›ILLEGALï¼Œè€Œæ­£ç¡®çš„æ ¼å¼åªä¼šåŒ¹é…å‰è€…ã€‚\nyylex()å‡½æ•°æ¯æ¬¡åŒ¹é…ä¸€æ®µå­—ç¬¦ä¸²ï¼Œè‹¥åŒ¹é…æˆåŠŸåˆ™æ‰§è¡Œè¯¥ç±»å‹åé¢çš„æ“ä½œï¼Œæ“ä½œä¸­å¦‚æ— returnè¯­å¥åˆ™ç»§ç»­è¯†åˆ«ï¼Œå¦‚æœ‰returnè¯­å¥åˆ™è¿”å›mainå‡½æ•°\n\n\nTest.cint main()\n{\n    int abc = 0123, bb = 0x12d23p, c = 0987, di = 0x45Fc1;\n    if (abc &gt;= bb) // hello\n        while (di == 1)\n            return 8;\n    /*This is a test\n      This is a test\n    */\n    $\n}\n\nCast Magic ğŸª„flex SysY.l                    \nclang lex.yy.c -ly -ll\ncat test.c|./a.out\n\nOutput\n\n\n\n\nâˆ‚ ä¸€ä¸ªå°å‘ç¬¬å››éƒ¨åˆ†ä¸­æˆ‘ä¸€å¼€å§‹å°†{KEYWORD}æ”¾åœ¨{ID}çš„åé¢ï¼Œæ‰§è¡ŒFlexçš„æ—¶å€™ä¸€ç›´æŠ¥é”™\nSysY.l:36: warning, rule cannot be matched\n\nå¾ˆè¿·ï¼Œå½“æ—¶æ”¹æ¥æ”¹å»è¿™ä¸ªwarningå°±ä¸€ç›´è·Ÿç€{KEYWORD}è·‘ï¼Œåªæœ‰è¡Œå·åœ¨å˜åŒ–ã€‚\nè¿™æ¡warningçš„æ„æ€åº”è¯¥æ˜¯æ— æ³•åŒ¹é…{KEYWORD}è¿™æ¡è§„åˆ™ã€‚\nä»”ç»†æƒ³æƒ³ï¼Œ{KEYWORD}åŒ¹é…çš„éƒ½æ˜¯å…³é”®å­—ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆå…³é”®å­—ä¼šæˆä¸ºå…³é”®å­—å‘¢ï¼Ÿå› ä¸ºåœ¨ä¸€å¼€å§‹çš„æ—¶å€™å°±è¢«{KEYWORD}åŒ¹é…åˆ°äº†ï¼Œä»è€Œç”¨æˆ·ä¸èƒ½ç”¨å…³é”®å­—æ¥å®šä¹‰å˜é‡åã€‚è¿™æ—¶å€™ä¸€çœ‹{ID}æœç„¶æ”¾åœ¨{KEYWORD}å‰é¢ï¼Œæ˜¾ç„¶{KEYWORD}æ˜¯{ID}çš„ä¸€ä¸ªå­é›†ï¼Œå› æ­¤{ID}åŒ¹é…å®Œå{KEYWORD}å°±æ˜¯å…‰æ†å¸ä»¤ä¸€ä¸ªäº†ã€‚\n","slug":"å€ŸåŠ©flexå®ç°SysYè¯æ³•åˆ†æ","date":"2022-03-22T10:49:25.000Z","categories_index":"ç¼–è¯‘åŸç†","tags_index":"èµ°ç è§‚èŠ±","author_index":"Starlit Rover"},{"id":"fbbac3b5688cf257c824005fed6d10e6","title":"Build Qt in arm64","content":"â™¿ï¸ å¼•è¨€è‡ªä»ç”µè„‘æ¢æˆMacåå°±éœ€è¦é¢å¯¹èŠ¯ç‰‡æ¶æ„ä¸åŒå¸¦æ¥çš„ä¼—å¤šé—®é¢˜ï¼Œå¸‚åœºä¸Šè¿˜æ˜¯æœ‰å¾ˆå¤šè½¯ä»¶åªé€‚é…x86è€Œä¸æ”¯æŒarmã€‚å½“ç„¶è¿™æ®µæ—¶é—´æˆ‘ä½“éªŒä¸‹æ¥ï¼Œarmæ¶æ„é‡‡ç”¨çš„æ˜¯ç²¾ç®€æŒ‡ä»¤é›†ï¼Œåœ¨ç»­èˆªæ–¹é¢å…¨é¢åŠæ‰“x86ï¼Œä¸€èˆ¬æ¥è¯´ä¸æ’ç”µå·¥ä½œä¸€å¤©ç»°ç»°æœ‰ä½™ã€‚å½“ç„¶ç¼ºç‚¹ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œå°±æ˜¯è½¯ä»¶å¸‚åœºä¾ç„¶ä¸æ˜¯å¾ˆå‹å¥½ï¼Œæ¯”å¦‚è¯´VSï¼ˆå¦ç™½åœ°è¯´ï¼ŒVS for macå°±æ˜¯å¾®è½¯åšå‡ºæ¥å˜²ç¬‘è‹¹æœçš„ï¼‰ã€‚è™½ç„¶å¾ˆå¤šè½¯ä»¶è¡¨ç¤ºå·²ç»åœ¨å¼€å‘armç‰ˆï¼Œä½†è¿˜æ˜¯éœ€è¦ä¸€å®šæ—¶é—´çš„ã€‚è¿™ä¹Ÿæ˜¯æœ¬æ–‡å­˜åœ¨çš„åŸå› ã€‚\n\n\nå¯¼å¸ˆé‚£è¾¹æœ‰ä¸ªæ¡†æ¶ä¹‹å‰æˆ‘éƒ½æ˜¯åœ¨è€ç”µè„‘çš„VSä¸Šç”¨çš„ï¼ˆä¹‹å‰ä¹Ÿåªæœ‰VSç‰ˆï¼‰ï¼Œç„¶è€Œæœ€è¿‘å‘å¸ƒçš„æ–°ç‰ˆæœ¬ä½¿ç”¨äº†CMakeã€‚ä¼—æ‰€å‘¨çŸ¥ï¼ŒCMakeæ˜¯ä¸€æ¬¾è·¨å¹³å°ç¼–è¯‘å·¥å…·ï¼ŒåƒCLionå°±æ˜¯ä½¿ç”¨CMakeè¿›è¡Œç¼–è¯‘çš„ã€‚Macäººç‹‚å–œï¼Œç„¶è€Œè¢«å­¦é•¿å‘ŠçŸ¥æ¡†æ¶æ‰€éœ€çš„Qtç›®å‰åªæ”¯æŒx86ï¼Œarmç‰ˆçš„éœ€è¦è‡ªå·±ç¼–è¯‘ã€‚å¯ä»¥è‡ªå·±ç¼–è¯‘çš„å…³é”®ä¸€ç‚¹æ˜¯ï¼ŒQtæ˜¯å¼€æºçš„ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—å…¶æºç ã€‚é‚£ä¹ˆç®€å•åœ°æ¥è¯´ï¼Œè™½ç„¶ç›´æ¥ä¸‹è½½ä¸‹æ¥çš„Qtæ˜¯x86ç‰ˆçš„ï¼Œä½†åªè¦å°†å…¶æºç åœ¨è‡ªå·±ç”µè„‘ç¼–è¯‘ä¸€éï¼Œç”Ÿæˆçš„å°±æ˜¯é€‚é…è‡ªå·±ç”µè„‘çš„ç‰ˆæœ¬å•¦ã€‚\nè¿™å°±ä¸å¾—ä¸æåˆ°makefileæ–‡ä»¶ã€‚è¯¥æ–‡ä»¶æ˜¯Linuxä¸‹çš„ä¸€ä¸ªå·¥ç¨‹ç®¡ç†æ–‡ä»¶ï¼Œç±»ä¼¼CMakeæ–‡ä»¶ï¼ŒæŒ‡å‡ºäº†å¦‚ä½•ç¼–è¯‘è½¯ä»¶çš„è§„åˆ™ï¼Œæœ‰ç€è‡ªå·±ä¸“é—¨çš„è¯­æ³•ã€‚ä½†æˆ‘ç›®å‰ä¹Ÿä¸æ˜¯å¾ˆäº†è§£ï¼Œåªæ˜¯åˆšåˆšå…¥é—¨ï¼Œä»¥åæœ‰æœºä¼šçš„è¯å†è®²å§ã€‚\n\nç‰ˆæœ¬ä¿¡æ¯\nQt 5.15.2\nCLion 2021.3.4\nMacOS Monterey 12.3\n\n\nâ©™ BUILD\næ‰“å¼€terminalï¼Œä½¿ç”¨homebrewï¼ˆé»˜è®¤å·²æœ‰ï¼‰å®‰è£…ä¾èµ–é¡¹\nbrew install pcre2 harfbuzz freetype\n#ä¸‹é¢è¿™ä¸€é¡¹å¯èƒ½ä¸éœ€è¦ï¼Œä¿é™©èµ·è§å°±å®‰ä¸Š\nbrew install cmake ninja python\n\nä¸‹è½½Qt 5.15.2çš„æºç ï¼Œé€šé“åœ¨æ­¤\n\nå‡è®¾ä¸‹è½½çš„å‹ç¼©åŒ…qt-everywhere-src-5.15.2.tar.xzæ‰€åœ¨æ–‡ä»¶å¤¹çš„ç»å¯¹è·¯å¾„ä¸ºpathï¼Œåœ¨terminalå†…\ncd path\n#è§£å‹å‹ç¼©åŒ…\nx qt-everywhere-src-5.15.2.tar.xz\n#åˆ›å»ºæ–‡ä»¶å¤¹buildir\nmkdir buildir\ncd buildir\n#è®¾ç½®arm64ç‰ˆç¼–è¯‘å¹¶ç”Ÿæˆmakefile\n../qt-everywhere-src-5.15.2/configure -release -prefix ./outDir -nomake examples -nomake tests QMAKE_APPLE_DEVICE_ARCHS=arm64 -opensource -confirm-license -skip qt3d -skip qtwebengine\n#æ¥ä¸‹æ¥ä¼šç”Ÿæˆå¾ˆå¤šå‘½ä»¤ï¼Œä¸ç”¨ç®¡\n\nåœ¨makeå‘½ä»¤ä¹‹å‰æˆ‘ä»¬éœ€è¦æ¶ˆé™¤ä¸¤ä¸ªé—®é¢˜ï¼ˆå½“ç„¶ç›´æ¥æ‰“å¼€æ–‡ä»¶æ”¹ä¹Ÿè¡Œï¼Œä¸‹é¢æ˜¯åœ¨terminalä¸­ç”¨vimä¿®æ”¹ï¼‰\n\né¦–å…ˆæ‰“å¼€ç¬¬ä¸€ä¸ªæ›´æ”¹æ–‡ä»¶ï¼Œpathæ˜¯ä¸Šé¢é‚£ä¸ªç»å¯¹è·¯å¾„\nvim path/qt-everywhere-src-5.15.2/qtbase/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h\n\næ‰¾åˆ°ä¸‹é¢çš„è¯­å¥å—\n#include &lt;qpa/qplatformgraphicsbuffer.h&gt;\n#include &lt;private/qcore_mac_p.h&gt;\n\nè¿›å…¥vimçš„æ’å…¥æ¨¡å¼ï¼Œåœ¨è¯¥è¯­å¥å—å‰åŠ ä¸Š\n#include &lt;CoreGraphics/CGColorSpace.h&gt;\n\næœ€ååº”è¯¥æ˜¯è¿™æ ·å­çš„\n\n\næ”¹å®Œåä¿å­˜é€€å‡ºï¼šesc+è¾“å…¥:wq\n\næ‰“å¼€ç¬¬äºŒä¸ªæ›´æ”¹æ–‡ä»¶\nvim path/qt-everywhere-src-5.15.2/qtlocation/include/QtLocation/5.15.2/QtLocation/private/../../../../../src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h\n\nè¾“å…¥:set numberåæ˜¾ç¤ºè¡Œå·ï¼Œç„¶åå°†523è¡Œå¤„çš„typedef struct {æ”¹ä¸ºtypedef struct MapPolylineEntry {ï¼Œæ”¹å®Œåä¿å­˜é€€å‡º\n\n\n\næ¥ä¸‹æ¥å¼€å¯æ‰€æœ‰è¿›ç¨‹è¿›è¡Œç¼–è¯‘\n#åœ¨buildirç›®å½•ä¸‹\nmake -j$(nproc)\n\nä¸Šæ­¥å®Œæˆåå¼€å§‹å®‰è£…\nmake install -j$(nproc)\n\nå®‰è£…å®Œæˆåå¯ä»¥æŠŠå’ŒbuildiråŒå±‚ç›®å½•å†…çš„qt-everywhere-src-5.15.2.tar.xzä¸qt-everywhere-src-5.15.2ç»™åˆ äº†\n\næ­¤æ—¶arm64ç‰ˆQtç®—æ˜¯å®‰è£…å®Œæˆï¼ˆbuildirï¼‰ï¼Œæ¥ä¸‹æ¥ï¼ˆå¯ä»¥å¿½ç•¥ï¼‰æ˜¯åœ¨CLionä¸Šçš„iGameMeshViewå·¥ç¨‹ä¸­ä½¿ç”¨Qt\n\nä¿®æ”¹iGameMeshViewçš„cmakeæ–‡ä»¶\n# MacOS\nelseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"AppleClang\")\n    message(STATUS \"ç¼–è¯‘å™¨æ˜¯AppleClang\")\n    #è®¾ç½®QTçš„ç›®å½•\n    set(Qt5Core_DIR path/buildir/outDir/lib/cmake/Qt5Core)\n    set(Qt5Gui_DIR path/buildir/outDir/lib/cmake/Qt5Gui)\n    set(Qt5OpenGL_DIR path/buildir/outDir/lib/cmake/Qt5OpenGL)\n    set(Qt5Widgets_DIR path/buildir/outDir/lib/cmake/Qt5Widgets)\n\nå®Œæˆ\n\n\n\nã€ŒReferenceã€\nQt5é€‚é…M1ï¼šhttps://www.cnblogs.com/wqcwood/p/15138983.html\n\n[Qt] Fix missing Cocoa includeï¼šhttps://github.com/microsoft/vcpkg/pull/21056/commits/99582d154236b0e7af70cadef8420c4f25829f61\n\n\n\n\n\nâƒ ç‰¹åˆ«é¸£è°¢CJggä¸¤èŠ‚è¯¾çš„è€å¿ƒè®²è§£ /doge","slug":"Build-Qt-in-arm64","date":"2022-03-19T02:32:08.000Z","categories_index":"è¡€æ³ªå²","tags_index":"arm64","author_index":"Starlit Rover"},{"id":"03afcc3b07031cb1f7cc8d70de23254b","title":"ã€ŒSection 6ã€æŒ‡ä»¤ç³»ç»Ÿ","content":"Î±. æŒ‡ä»¤ç³»ç»Ÿæ¦‚è¿°\nÎ². æŒ‡ä»¤æ ¼å¼\nÎ³. æ“ä½œæ•°ç±»å‹\n\n\n\nÎ± æŒ‡ä»¤ç³»ç»Ÿæ¦‚è¿°\nç°ä»£å†¯Â·è¯ºä¼Šæ›¼è®¡ç®—æœºç»“æ„æ¡†å›¾æ˜¯ä»¥å­˜å‚¨å™¨ä¸ºä¸­å¿ƒï¼Œè®¡ç®—æœºçš„å·¥ä½œè¿‡ç¨‹å°±æ˜¯å¾ªç¯å¾€å¤åœ°å–æŒ‡ä»¤ã€åˆ†ææŒ‡ä»¤ã€æ‰§è¡ŒæŒ‡ä»¤çš„è¿‡ç¨‹ã€‚\n\n\nä¸€äº›æ¦‚å¿µ\n\nè®¡ç®—æœºæŒ‡ä»¤ï¼šæŒ‡ç¤ºè®¡ç®—æœºç¡¬ä»¶è¿›è¡ŒæŸç§æ“ä½œçš„å‘½ä»¤ã€‚\n\næœºå™¨æŒ‡ä»¤ï¼ˆæœºå™¨å­—ï¼‰ï¼šä½¿ç”¨äºŒè¿›åˆ¶æ¥è¡¨ç¤ºè®¡ç®—æœºæŒ‡ä»¤ï¼Œèƒ½è¢«è®¡ç®—æœºç¡¬ä»¶è¯†åˆ«å¹¶æ‰§è¡Œçš„01ä»£ç ä¸²ã€‚\n\næœºå™¨è¯­è¨€ï¼šæœºå™¨æŒ‡ä»¤ç¼–å†™ç¨‹åºçš„è§„èŒƒï¼Œæ˜¯è®¡ç®—æœºç¡¬ä»¶çš„ç³»ç»Ÿè¯­è¨€ã€‚\n\næœºå™¨è¯­è¨€ç¨‹åºï¼šæœºå™¨æŒ‡ä»¤çš„æœ‰åºé›†åˆï¼Œå…·æœ‰ç‰¹å®šåŠŸèƒ½ã€‚\n\næŒ‡ä»¤ç³»ç»Ÿï¼šä¸€å°è®¡ç®—æœºæ‰€æœ‰æœºå™¨æŒ‡ä»¤çš„é›†åˆã€‚\n\n\næ±‡ç¼–æŒ‡ä»¤ï¼šæœºå™¨æŒ‡ä»¤çš„ä»£ç åŠ©è®°ç¬¦ï¼Œä¸æœºå™¨æŒ‡ä»¤å‡ ä¹ä¸€ä¸€å¯¹åº”ã€‚\n\nå¾®æŒ‡ä»¤ï¼šæŒ‡åœ¨æœºå™¨çš„ä¸€ä¸ªCPUå‘¨æœŸä¸­ï¼Œä¸€ç»„å®ç°ä¸€å®šæ“ä½œåŠŸèƒ½çš„å¾®å‘½ä»¤çš„ç»„åˆï¼Œå±äºç¡¬ä»¶å±‚é¢ã€‚è‹¥å¹²æ¡å¾®æŒ‡ä»¤å¯ä»¥æ„æˆä¸€ä¸ªå¾®ç¨‹åºï¼Œè€Œä¸€ä¸ªå¾®ç¨‹åºå°±å¯¹åº”äº†ä¸€æ¡æœºå™¨æŒ‡ä»¤ã€‚\n\n\n\nä¸åŒçº§åˆ«æŒ‡ä»¤ä¹‹é—´çš„å…³ç³»\n\n\n\né«˜çº§è¯­è¨€ä¸æ±‡ç¼–è¯­è¨€æŒ‡ä»¤å±äºè½¯ä»¶å±‚é¢ï¼Œè€Œæœºå™¨æŒ‡ä»¤ä¸å¾®æŒ‡ä»¤åˆ™å±äºç¡¬ä»¶å±‚é¢\nä¸€æ¡é«˜çº§è¯­è¨€è¢«ç¼–è¯‘ä¸ºå¤šæ¡æœºå™¨æŒ‡ä»¤\næ±‡ç¼–æŒ‡ä»¤ä¸æœºå™¨æŒ‡ä»¤ä¸€ä¸€å¯¹åº”\nä¸€æ¡æœºå™¨æŒ‡ä»¤åˆ™ä¾èµ–äºå¤šæ¡å¾®æŒ‡ä»¤çš„æ‰§è¡Œ\n\n\næŒ‡ä»¤æ‰€åŒ…å«çš„ä¿¡æ¯\n\næŒ‡ä»¤åŠŸèƒ½ï¼šè¦æ‰§è¡Œçš„æ“ä½œï¼Œä¸€èˆ¬æœ‰è¿ç®—ã€ä¼ é€ã€ç§»ä½ã€è·³è½¬ç­‰ã€‚\næ“ä½œå¯¹è±¡ï¼šè¦å¤„ç†æˆ–å‚åŠ è¿ç®—çš„æ•°æ®ï¼Œç§°ä¸ºæºæ“ä½œæ•°ã€‚\næ“ä½œçš„ç»“æœï¼šå­˜æ”¾è¿ç®—æˆ–å¤„ç†ç»“æœçš„æ•°æ®ï¼Œç§°ä¸ºç›®çš„æ“ä½œæ•°ï¼ˆâš ï¸ç›®çš„æ“ä½œæ•°ä¹Ÿå¯ä»¥ä¸ºæºæ“ä½œæ•°ï¼‰ã€‚\nä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ï¼šä¸‹ä¸€æ¡æŒ‡ä»¤åœ¨ä¸»å­˜ä¸­çš„åœ°å€ã€‚\n\n\næŒ‡ä»¤é›†ä½“ç³»æ¶æ„(ISA)ï¼šå¤„ç†å™¨æ‰€æ”¯æŒçš„æŒ‡ä»¤é›†ï¼ˆæ±‡ç¼–æŒ‡ä»¤é›†åŠæœºå™¨æŒ‡ä»¤ç¼–ç ï¼‰åŠå…¶æ“ä½œæ•°çš„ç›¸å…³ä¿¡æ¯ï¼ˆå¯„å­˜å™¨ã€å­˜å‚¨å™¨ã€I/Oç­‰ï¼‰\n\nä½œç”¨ï¼šåœ¨ç³»ç»Ÿè½¯ä»¶è®¾è®¡è€…å’Œå¤„ç†å™¨ç¡¬ä»¶è®¾è®¡è€…ä¹‹é—´æä¾›äº†ä¸€ä¸ªæŠ½è±¡å±‚\nè½¯ä»¶è®¾è®¡è€…ï¼šä¾æ®ISAçŸ¥é“å¦‚ä½•ç¼–å†™æœºå™¨è¯­è¨€ç¨‹åºæ¥æ§åˆ¶ä¸ä½¿ç”¨å¤„ç†å™¨ç¡¬ä»¶\nç¡¬ä»¶è®¾è®¡è€…ï¼šä¾æ®ISAæ¥è®¾è®¡å¾®ä½“ç³»ç»“æ„ï¼Œå¹¶å®ç°èƒ½æ‰§è¡Œæœºå™¨è¯­è¨€çš„å¤„ç†å™¨ç¡¬ä»¶\n\n\nå†…å®¹\nâ˜…å¯æ‰§è¡Œçš„æŒ‡ä»¤é›†åˆï¼ŒåŒ…æ‹¬æŒ‡ä»¤æ ¼å¼ã€æŒ‡ä»¤ç±»å‹ã€æŒ‡ä»¤åŠŸèƒ½ã€æŒ‡ä»¤ç¼–ç ç­‰\næŒ‡ä»¤å¯ä»¥æ¥å—çš„æ•°æ®ç±»å‹\næ“ä½œæ•°å¯ä»¥å­˜æ”¾çš„å¯„å­˜å™¨ç»„å’Œç»“æ„\næ“ä½œæ•°æ‰€èƒ½å­˜æ”¾çš„å­˜å‚¨ç©ºé—´ï¼ˆå­˜å‚¨å™¨å’ŒI/Oï¼‰å¤§å°ã€ç¼–å€æ–¹å¼ã€å¤§å°ç«¯æ¨¡å¼ç­‰\næŒ‡ä»¤è·å–æ“ä½œæ•°çš„æ–¹å¼ï¼Œå³æ•°æ®å¯»å€æ–¹å¼\næŒ‡ä»¤æ‰§è¡Œçš„æ§åˆ¶æ–¹å¼ï¼Œå³æŒ‡ä»¤å¯»å€æ–¹å¼ï¼ŒåŒ…æ‹¬ç¨‹åºè®¡æ•°å™¨ã€æ¡ä»¶ç å®šä¹‰ç­‰\n\n\n\n\n\n\nÎ² æŒ‡ä»¤æ ¼å¼\nåŸºæœ¬æ ¼å¼ï¼šæ“ä½œç å­—æ®µï¼ˆOPï¼‰+åœ°å€ç å­—æ®µï¼ˆAï¼‰\n\nä½äºŒè¿›åˆ¶æ“ä½œç æœ€å¤šè¡¨ç¤ºç§æŒ‡ä»¤\nåœ°å€ç ç”¨äºå¯»æ‰¾æ“ä½œæ•°æˆ–ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€\n\n\næŒ‡ä»¤å¯»å€æ–¹å¼\n\nç¨‹åºä¸­çš„æœºå™¨æŒ‡ä»¤åºåˆ—åœ¨ä¸»å­˜ä¸­å¾€å¾€æŒ‰é¡ºåºå­˜æ”¾\nCPUä½¿ç”¨ç¨‹åºè®¡æ•°å™¨PCï¼ˆProgram Counterï¼‰æ¥å­˜å‚¨æŒ‡ä»¤åœ°å€\nä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€å¯ä»¥ç”±æŒ‡å‡º\nè½¬ç§»ç±»æŒ‡ä»¤ï¼ˆå³éé¡ºåºæ‰§è¡Œè¯­å¥ï¼Œå¦‚å¾ªç¯ç­‰ï¼‰ä¾æ—§è¯»å–å¤„æŒ‡ä»¤ï¼Œåªæ˜¯è¯¥æŒ‡ä»¤æ˜¯è·³è½¬æŒ‡ä»¤\n\n\næŒ‡ä»¤å­—é•¿ï¼šä¸€æ¡æœºå™¨æŒ‡ä»¤çš„ä½æ•°\n\næœºå™¨å­—é•¿ï¼šè®¡ç®—æœºä¸€æ¬¡èƒ½å¤„ç†çš„äºŒè¿›åˆ¶æ•°æ®çš„ä½æ•°\nçŸ­æ ¼å¼æŒ‡ä»¤ï¼šæŒ‡ä»¤å­—é•¿â‰¤æœºå™¨å­—é•¿ï¼ŒèŠ‚çœç©ºé—´ï¼›é•¿æ ¼å¼æŒ‡ä»¤ï¼šæŒ‡ä»¤å­—é•¿&gt;æœºå™¨å­—é•¿ï¼ŒåŒ…å«æ›´å¤šæ“ä½œä¿¡æ¯ï¼ˆâš ï¸ä¸¤è€…å¯å¹¶å­˜äºä¸€ä¸ªæŒ‡ä»¤ç³»ç»Ÿï¼‰\nå®šé•¿æŒ‡ä»¤ç³»ç»Ÿï¼šæ‰€æœ‰æŒ‡ä»¤å­—é•¿ç›¸ç­‰ï¼Œä¸€èˆ¬éƒ½ç­‰äºæœºå™¨å­—é•¿ï¼Œç»“æ„ç®€å•ï¼›å˜é•¿æŒ‡ä»¤ç³»ç»Ÿï¼šæŒ‡ä»¤å­—é•¿ä¸å›ºå®šï¼Œé€šå¸¸å–å­—èŠ‚çš„æ•´æ•°å€ï¼Œå†—ä½™çŠ¶æ€å°‘ï¼Œç»“æ„çµæ´»ï¼ˆå•å­—é•¿æŒ‡ä»¤ï¼šæŒ‡ä»¤å­—é•¿=æœºå™¨å­—ï¼›åŒå­—é•¿æŒ‡ä»¤ï¼šæŒ‡ä»¤å­—é•¿=æœºå™¨å­—é•¿*2ï¼‰\n\n\nåœ°å€ç ï¼šç”¨æ¥å¯»æ‰¾æ‰§è¡ŒæŒ‡ä»¤æ‰€éœ€è¦çš„æ“ä½œæ•°ï¼ˆåˆ†ä¸ºæºå’Œç›®çš„æ“ä½œæ•°ï¼‰æˆ–è€…ä¸‹æ¡æŒ‡ä»¤åœ°å€ï¼Œåœ°å€ç çš„å«ä¹‰å–å†³äºå¯»å€æ–¹å¼ã€‚\n\nä¸‰åœ°å€æŒ‡ä»¤ï¼šOPï½œA1ï½œA2ï½œA3ï¼Œ(A1) OP (A2) â†’A3\n\näºŒåœ°å€æŒ‡ä»¤ï¼šOPï½œA1ï½œA2ï¼Œ(A1) OP (A2) â†’A1\n\nå•åœ°å€æŒ‡ä»¤ï¼šOPï½œAï¼Œ(AC) OP (A) â†’ACï¼ˆACä¸ºéšå«æ“ä½œæ•°ï¼‰ or OP(A)â†’Aï¼ˆå•ç›®è¿ç®—ï¼‰\n\né›¶åœ°å€æŒ‡ä»¤ï¼šOPï¼Œæ— éœ€æ“ä½œæ•°å¦‚å ä½å’Œå»¶æ—¶è€Œè®¾ç½®çš„ç©ºæ“ä½œæŒ‡ä»¤NOPã€ç­‰å¾…æŒ‡ä»¤WAITã€åœæœºæŒ‡ä»¤HALTç­‰ï¼Œæˆ–æ˜¯éšå«æ“ä½œæ•°çš„å•ç›®è¿ç®—ç¬¦\nâš ï¸ä¸Šè¿°å››ç§æŒ‡ä»¤å¯ä»¥å¹¶å­˜äºä¸€ä¸ªæŒ‡ä»¤ç³»ç»Ÿ\n\n\n\n\n\nÎ³ æ“ä½œæ•°ç±»å‹\næ ¹æ®æ“ä½œæ•°çš„å­˜æ”¾ä½ç½®è¿›è¡Œåˆ†ç±»\n\nç«‹å³æ•°ç±»å‹ï¼šæ“ä½œæ•°æ˜¯å¸¸æ•°ï¼Œå­˜æ”¾åœ¨æŒ‡ä»¤çš„åœ°å€å­—æ®µAä¸Šï¼ˆæŒ‡ä»¤å­˜æ”¾åœ¨ä¸»å­˜ [âš ï¸å³ä¸ºå†…å­˜] ä¸­ï¼‰\nå¯„å­˜å™¨ç±»å‹ï¼šæ“ä½œæ•°å­˜æ”¾åœ¨CPUçš„é€šç”¨å¯„å­˜å™¨ä¸­ï¼ŒAä¸ºå¯„å­˜å™¨ç¼–å·/åœ°å€\nå­˜å‚¨å™¨ç±»å‹ï¼šæ“ä½œæ•°å­˜æ”¾åœ¨ä¸»å­˜ä¸­ï¼ŒAä¸ºå…¶åœ°å€ä¿¡æ¯ï¼ˆå–å†³äºå¯»å€æ–¹å¼ï¼‰\nI/Oæ•°æ®ç±»å‹ï¼šæ“ä½œæ•°å­˜æ”¾åœ¨I/Oè®¾å¤‡æ¥å£ä¸­ï¼ŒAä¸ºå…¶ç«¯å£åœ°å€Port\n\n\næ ¹æ®æ“ä½œæ•°çš„ç‰©ç†å«ä¹‰è¿›è¡Œåˆ†ç±»\n\næ•°å€¼æ•°æ®ï¼šæ•´æ•°ã€æµ®ç‚¹æ•°ã€åè¿›åˆ¶æ•°ï¼Œå¸¦ç¬¦å·æ•°/ æ— ç¬¦å·æ•°\n\næŒ‡é’ˆ/åœ°å€ï¼šæŒ‡å­˜å‚¨å™¨åœ°å€ï¼Œç”±è®¿é—®å­˜å‚¨å™¨çš„æŒ‡ä»¤è®¡ç®—å‡ºï¼ˆâš ï¸æ˜¯æ— ç¬¦å·æ•´æ•°ï¼‰\n\nä½æˆ–ä½ä¸²æ•°æ®ï¼šä¸€èˆ¬ç”¨äºè¡¨ç¤ºæ ‡å¿—ä½ã€çŠ¶æ€ä½ã€æ§åˆ¶ä½ç­‰ä¿¡æ¯\n\nå­—ç¬¦æˆ–è€…å­—ç¬¦ä¸²ï¼šä¸€èˆ¬ç”¨äºè¡¨ç¤ºæ–‡æœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬è¥¿æ–‡å­—ç¬¦(ASCIlç ï¼‰å’Œä¸­æ–‡å­—ï¼ˆå†…ç ï¼‰ç­‰\n\né€»è¾‘æ•°æ®ï¼šç”¨0/1è¡¨ç¤ºçœŸ/å‡çš„é€»è¾‘å€¼ï¼Œé€šå¸¸ç”¨äºæ¡ä»¶è½¬ç§»æŒ‡ä»¤ä¸­å¯¹æ¡ä»¶ç çš„æ£€æµ‹\nâš ï¸ä»…æ ¹æ®æ“ä½œæ•°çš„äºŒè¿›åˆ¶ä»£ç åˆ™æ— æ³•è¿›è¡ŒåŒºåˆ†å…¶å…·ä½“çš„å«ä¹‰\n\n\n\n\n","slug":"æŒ‡ä»¤ç³»ç»Ÿ","date":"2022-03-16T01:57:48.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"b75f95681a59c62b9564ea4a8f3a4ec9","title":"ã€Œ1015ã€Reversible Primes","content":"â³ENTRY\nA reversible prime in any number system is a prime whose â€œreverseâ€ in that number system is also a prime. For example in the decimal system 73 is a reversible prime because its reverse 37 is also a prime.\nNow given any two positive integers  and  (1&lt;â‰¤10), you are supposed to tell if  is a reversible prime with radix .\n\n\nInput Specification:The input file consists of several test cases. Each case occupies a line which contains two integers  and . The input is finished by a negative .\nOutput Specification:For each test case, print in one line Yes if  is a reversible prime with radix , or No if not.\nSample Input:73 10\n23 2\n23 10\n-2\n\nSample Output:Yes\nYes\nNo\n\n\nÎ©æç®€ç¿»è¯‘ï¼šç»™å‡ºå¥½å‡ ç»„æ•°ï¼Œä¸€ç»„ä¸€è¡Œã€‚ä¸€ç»„æ•°åŒ…å«ä¸€ä¸ªåè¿›åˆ¶æ•°å’Œä¸€ä¸ªè¿›åˆ¶æ•°ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªç´ æ•°ä¸”åœ¨è¿›åˆ¶ä¸‹çš„åè½¬æ•°ä¹Ÿæ˜¯ç´ æ•°ï¼Œé‚£ä¹ˆä¾¿è¾“å‡ºYesï¼Œåä¹‹è¾“å‡ºNoã€‚æœ€åä»¥ä¸€ä¸ªè´Ÿæ•°è¡¨ç¤ºç»“æŸã€‚\n\n\n    ã€Šæ—¥å¸¸æ°´æ–‡ç« ç³»åˆ—ã€‹\nâš ï¸æœ¬é¢˜å”¯ä¸€éœ€è¦æ³¨æ„çš„åœ°æ–¹æ˜¯åˆ¤æ–­ç´ æ•°ä¸€å®šè¦è€ƒè™‘1ã€‚\nå¯¹äºåœ¨è¿›åˆ¶ä¸‹æ±‚çš„åè¿›åˆ¶åè½¬æ•°ï¼Œç”±äºå‡ºæ¥çš„ä¾æ¬¡æ˜¯åè½¬æ•°çš„æœ€é«˜ä½åˆ°æœ€ä½ä½ï¼Œå› æ­¤ç”¨ä¸€ä¸ªå¾ªç¯å³å¯ï¼š\nint rn=0;\nwhile(n&gt;0)\n{\n  rn=rn*d+n%d;\n  n/=d;\n}\n\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nbool isPrime(int n)\n{\n    int m = sqrt(n);\n    if (n == 1) return false;\n    for (int i = 2; i &lt;= m; ++i)\n        if (n % i == 0)\n            return false;\n    return true;\n}\n\nint main()\n{\n    int n, d;\n    cin &gt;&gt; n;\n    while (n &gt; 0)\n    {\n        cin &gt;&gt; d;\n        if (!isPrime(n))\n            cout &lt;&lt; \"No\" &lt;&lt; endl;\n        else\n        {\n            int rn = 0;\n            while (n &gt; 0)\n            {\n                rn = rn * d + n % d;\n                n /= d;\n            }\n            cout &lt;&lt; (isPrime(rn) ? \"Yes\" : \"No\") &lt;&lt; endl;\n        }\n        cin &gt;&gt; n;\n    }\n}","slug":"1015-Reversible-Primes","date":"2022-03-15T08:02:21.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,prime","author_index":"Starlit Rover"},{"id":"be23bf1b6bcf5e89051d9bbdaa72f245","title":"ã€Œ1014ã€Waiting in Line","content":"â³ENTRY\nSuppose a bank has  windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are:\n\nThe space inside the yellow line in front of each window is enough to contain a line with  customers. Hence when all the  lines are full, all the customers after (and including) the  one will have to wait in a line behind the yellow line.\nEach customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number.\n will take  minutes to have his/her transaction processed.\nThe first  customers are assumed to be served at 8:00 am.\n\n\n\nNow given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done.\nFor example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning,  is served at  while  is served at .  will wait in front of  and  will wait in front of .  will wait behind the yellow line.\nAt 08:01,  is done and  enters the line in front of  since that line seems shorter now.  will leave at 08:02,  at 08:06,  at 08:07, and finally  at 08:10.\nInput Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers:  (â‰¤20, number of windows),  (â‰¤10, the maximum capacity of each line inside the yellow line), K (â‰¤1000, number of customers), and Q (â‰¤1000, number of customer queries).\nThe next line contains K positive integers, which are the processing time of the K customers.\nThe last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K.\nOutput Specification:For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output Sorry instead.\nSample Input:2 2 7 5\n1 2 6 4 3 534 2\n3 4 5 6 7\n\nSample Output:08:07\n08:06\n08:10\n17:00\nSorry\n\n\nÎ©æç®€ç¿»è¯‘ï¼šé“¶è¡Œæœ‰ä¸ªçª—å£ï¼Œæ¯ä¸ªçª—å£å‰æœ€å¤šæ’ä¸ªäººï¼Œå…±æœ‰ä¸ªé¡¾å®¢ï¼Œæ¯ä¸ªé¡¾å®¢çš„äº‹åŠ¡å¤„ç†æ—¶é—´éƒ½æ˜¯çŸ¥é“çš„ï¼Œå…¶ä¸­ä¸ªé¡¾å®¢æ¥æŸ¥è¯¢è‡ªå·±çš„ç»“æŸæ—¶é—´ã€‚å½“çª—å£æœªæ’æ»¡çš„æ—¶å€™ï¼Œé¡¾å®¢ä¼šå‰å¾€äººæ•°æœ€å°‘çš„çª—å£ï¼Œè‹¥æœ‰å¤šä¸ªäººæ•°æœ€å°‘çš„çª—å£åˆ™å»ç¼–å·æœ€å°çš„ï¼›å½“æ‰€æœ‰çª—å£éƒ½æ’æ»¡æ—¶ï¼Œåé¢çš„é¡¾å®¢éœ€ç­‰åœ¨é»„çº¿åç›´åˆ°æœ‰é¡¾å®¢å®Œæˆç¦»å¼€çª—å£ã€‚\n\n\nå¾ˆæ˜¾ç„¶ï¼Œæœ¬é¢˜è€ƒæŸ¥çš„æ˜¯é˜Ÿåˆ—queueï¼Œç„¶åè€ƒè™‘çš„ä¸œè¥¿æœ‰ä¸€ç‚¹å¤šï¼š\n\nå‰ä½é¡¾å®¢æŒ‰çª—å£ç¼–å·ä»å°åˆ°å¤§ä¾æ¬¡æ’åˆ—ï¼Œä¸è€ƒè™‘å¤„ç†æ—¶é—´\nåçš„é¡¾å®¢åˆ™çœ‹å“ªä¸ªçª—å£çš„ç¬¬ä¸€ä¸ªï¼ˆâš ï¸ä¸æ˜¯æœ€åä¸€ä¸ªï¼‰é¡¾å®¢æœ€å…ˆå®Œæˆäº‹åŠ¡å°±å»å“ªä¸ª\né¡¾å®¢æ•°é‡å¹¶ä¸ä¸€å®šä¼šå®Œå…¨å¡«å……æ»¡çª—å£\nåŒä¸€æ—¶åˆ»å¦‚æœæœ‰å¤šä¸ªçª—å£ç©ºå‡ºæ¥é»„çº¿å¤–çš„ç¬¬ä¸€ä½é¡¾å®¢å‰å¾€ç¼–å·æœ€å°çš„çª—å£\nè‹¥é¡¾å®¢å¼€å§‹å¤„ç†äº‹åŠ¡çš„æ—¶é—´ï¼ˆâš ï¸ä¸æ˜¯å¤„ç†å®Œæˆæ—¶é—´ï¼‰â‰¥17:00ï¼Œé‚£ä¹ˆä¸å—ç†è¯¥é¡¾å®¢çš„äº‹åŠ¡\n\nå› æ­¤æˆ‘ä»¬éœ€è¦ç”¨é˜Ÿåˆ—å­˜å‚¨æ¯ä¸ªçª—å£æ’é˜Ÿçš„å®¢æˆ·ç¼–å·æ¥è·çŸ¥æ¯ä¸ªæ—¶åˆ»çª—å£ç¬¬ä¸€ä¸ªé¡¾å®¢æ˜¯è°ï¼Œå¦å¤–å½“æˆ‘ä»¬æŠŠä¸€ä¸ªé¡¾å®¢åˆ†é…è‡³ä¸€ä¸ªçª—å£æ—¶è¯¥é¡¾å®¢çš„ç»“æŸæ—¶é—´ä¾¿å·²ç»ç¡®å®šã€‚å¯¹äºé»„çº¿å¤–ç¬¬ä¸€ä½é¡¾å®¢çš„çª—å£é€‰æ‹©é—®é¢˜ï¼Œæˆ‘ä»¬åªéœ€è¦æ¯”è¾ƒå½“å‰æ¯ä¸ªçª—å£çš„ç¬¬ä¸€ä½é¡¾å®¢ç»“æŸæ—¶é—´ï¼Œç„¶ååˆ†é…è‡³ç»“æŸæ—¶é—´æœ€æ—©çš„çª—å£å³å¯ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, q, t, c;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;\n  //proc_timeï¼šæ¯ä¸ªé¡¾å®¢çš„äº‹åŠ¡æ‰€éœ€æ—¶é—´ï¼Œend_timeï¼šæ¯ä¸ªé¡¾å®¢çš„äº‹åŠ¡å®Œæˆæ—¶é—´\n  //line_timeï¼šæ¯ä¸ªçª—å£æœ€åä¸€ä½é¡¾å®¢çš„ç»“æŸæ—¶é—´ï¼Œfill_timeï¼šæ¯ä¸ªçª—å£å½“å‰ç¬¬ä¸€ä½é¡¾å®¢çš„ç»“æŸæ—¶é—´\n  vector&lt;int&gt; proc_time(k), end_time(k), line_time(n, 480), fill_time(n, 0);\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; t;\n        proc_time[i] = t;\n    }\n  //é»„çº¿å†…çš„å®é™…é¡¾å®¢æ•°\n    int inline_num = min(n * m, k);\n  //æ¯ä¸ªçª—å£çš„æ’é˜Ÿé˜Ÿåˆ—\n    vector&lt;queue&lt;int&gt;&gt; line(n);\n  //é»„çº¿å†…é¡¾å®¢çš„çª—å£åˆ†é…\n    for (int i = 0; i &lt; inline_num; ++i)\n    {\n        line[i % n].push(i);\n        end_time[i] = line_time[i % n] += proc_time[i];\n    }\n  //å¦‚æœæ¯ä¸ªçª—å£éƒ½æ»¡äº†ï¼ˆkâ‰¥mnï¼‰\n    if (inline_num &lt; k)\n    {\n      //åˆå§‹åŒ–æ¯ä¸ªçª—å£ç¬¬ä¸€ä½é¡¾å®¢çš„ç»“æŸæ—¶é—´\n        for (int i = 0; i &lt; n; ++i)\n        {\n            fill_time[i] += proc_time[line[i].front()];\n            line[i].pop();\n        }\n      //åˆ†é…é»„çº¿å¤–çš„é¡¾å®¢\n        for (int i = inline_num; i &lt; k; ++i)\n        {\n          //æ±‚æœ€æ—©ç©ºå‡ºä½ç½®çš„çª—å£ç¼–å·\n            int win = int(min_element(fill_time.begin(), fill_time.end()) - fill_time.begin());\n            end_time[i] = line_time[win] += proc_time[i];\n            fill_time[win] += proc_time[line[win].front()];\n            line[win].pop();\n            line[win].push(i);\n        }\n    }\n    for (int i = 0; i &lt; q; ++i)\n    {\n        cin &gt;&gt; c;\n      //è€ƒè™‘æ¯ä¸ªé¡¾å®¢å¼€å§‹å¤„ç†çš„æ—¶é—´=ç»“æŸæ—¶é—´-å¤„ç†æ—¶é—´\n        if (end_time[c - 1] - proc_time[c - 1] &gt;= 1020)\n            cout &lt;&lt; \"Sorry\" &lt;&lt; endl;\n        else\n            printf(\"%02d:%02d\\n\", end_time[c - 1] / 60, end_time[c - 1] % 60);\n    }\n}\n\n\nâš¡ï¸ ç®—æ³•è¯´æ˜\næ‰€æœ‰æ—¶é—´éƒ½å…ˆæŒ‰åˆ†é’Ÿè®¡ç®—ï¼Œæœ€åè½¬ä¸ºæ—¶é—´\nç»™é»„çº¿å¤–çš„ç¬¬ä¸€ä¸ªé¡¾å®¢åˆ†é…å®Œçª—å£åï¼Œéœ€è¦æ›´æ–°è¯¥çª—å£ç¬¬ä¸€ä¸ªé¡¾å®¢çš„ç»“æŸæ—¶é—´\nmin_element(fill_time.begin(), fill_time.end())æ‰¾åˆ°çš„æ˜¯æœ€å·¦è¾¹æœ€å°å€¼çš„è¿­ä»£å™¨ï¼Œå› æ­¤ç¬¦åˆå½“æœ‰å¤šä¸ªæœ€å°äººæ•°çª—å£æ—¶é€‰æ‹©ç¼–å·æœ€å°çš„è¦æ±‚\n\n","slug":"1014-Waiting-in-Line","date":"2022-03-15T03:27:08.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,queue","author_index":"Starlit Rover"},{"id":"d89b7bb9a5cb29131093afe1032ded19","title":"ã€ŒSection 5ã€å®šç‚¹è¿ç®—å™¨ï¼ˆ&æµ®ç‚¹åŠ å‡ï¼‰","content":"ç”±å‰å‡ èŠ‚çš„å†…å®¹æˆ‘ä»¬çŸ¥é“è®¡ç®—æœºä¸­çš„å„ç±»ç®—æœ¯è¿ç®—éƒ½å¯ä»¥ç”±æœ€åŸºæœ¬çš„å®šç‚¹åŠ æ³•ä¸ç§»ä½è¿ç®—è¿­ä»£å®ç°ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦å°†é€»è¾‘è¿ç®—ã€ç§»ä½è¿ç®—ã€å„ç§ç®—æœ¯è¿ç®—çš„æ•°å­—é€»è¾‘ç”µè·¯å®ç°é›†æˆåœ¨ä¸€èµ·å°±å¯ä»¥æ„æˆCPUä¸­çš„è¿ç®—å™¨ã€‚è¿ç®—å™¨å…·ä½“å¯ä»¥åˆ†ä¸ºå®šç‚¹è¿ç®—éƒ¨ä»¶å’Œæµ®ç‚¹è¿ç®—éƒ¨ä»¶ï¼Œæœ¬èŠ‚ä¸»è¦ä»‹ç»åˆç§°ä¸ºç®—æœ¯é€»è¾‘è¿ç®—å•å…ƒçš„å®šç‚¹è¿ç®—éƒ¨ä»¶ã€‚\nÎ±. å®šç‚¹è¿ç®—å™¨\nÎ². æµ®ç‚¹æ•°çš„åŠ å‡è¿ç®—\n\n\nÎ± å®šç‚¹è¿ç®—å™¨\nåŸºæœ¬ç»„æˆ\n\nç®—æœ¯é€»è¾‘è¿ç®—å•å…ƒALUï¼šæ ¸å¿ƒéƒ¨ä»¶ï¼Œå®ç°ç®—æœ¯è¿ç®—å’Œé€»è¾‘è¿ç®—\n\n\næš‚å­˜å™¨ï¼šç”¨æ¥å­˜æ”¾å‚ä¸è®¡ç®—çš„æ•°æ®åŠè¿ç®—ç»“æœï¼Œå®ƒåªå¯¹ç¡¬ä»¶è®¾è®¡è€…å¯è§ï¼Œå³åªè¢«æ§åˆ¶å™¨ç¡¬ä»¶é€»è¾‘æ§åˆ¶æˆ–å¾®ç¨‹åºæ‰€è®¿é—®ã€‚\n\n\n\né€šç”¨å¯„å­˜å™¨å †ï¼šç”¨äºå­˜æ”¾ç¨‹åºä¸­ç”¨åˆ°çš„æ•°æ®ï¼Œå®ƒå¯ä»¥è¢«è½¯ä»¶è®¾è®¡è€…æ‰€è®¿é—®ã€‚\nå†…éƒ¨æ€»çº¿ï¼šç”¨äºè¿æ¥å„ä¸ªéƒ¨ä»¶çš„ä¿¡æ¯é€šé“ã€‚ä¸ºé¿å…æ•°æ®å†²çªï¼ŒåŒä¸€æ—¶åˆ»ï¼ˆåœ¨ä¸€ä¸ªCPUå‘¨æœŸå†…ï¼‰æ€»çº¿ä¸Šåªèƒ½ä¼ è¾“ä¸€ä¸ªæ•°æ®ã€‚\n\n\nåŸºæœ¬ç»“æ„\n\nå•æ€»çº¿ç»“æ„1\n\n\n\nç”±äºæ€»çº¿ä¸€æ¬¡åªèƒ½ä¼ è¾“ä¸€ä¸ªæ•°æ®ï¼Œè€ŒALUæœ‰ä¸¤ä¸ªæ“ä½œæ•°ï¼Œä¸”åªæœ‰ä¸¤ä¸ªæ“ä½œæ•°åŒæ—¶å‡ºç°åœ¨è¾“å…¥ç«¯ALUæ‰èƒ½æ­£ç¡®è¿ç®—å‡ºç»“æœï¼Œå› æ­¤éœ€è¦åœ¨ALUçš„è¾“å…¥ç«¯æ”¾ç½®ä¸¤ä¸ªæš‚å­˜å™¨\n\néœ€è¦3æ­¥ï¼š\nå…¶ä¸­ä¸ºå¯„å­˜å™¨ï¼ŒIBä¸ºæ€»çº¿ï¼ˆinternal busï¼‰ï¼ŒLA/Bä¸ºæš‚å­˜å™¨\n\nç¼“å†²å™¨æ˜¯CPUå¯ä»¥æ“æ§çš„ä¸€ä¸ªé˜€é—¨ï¼Œæ‰“å¼€æ—¶æ•°æ®å¯ä»¥é€šè¿‡ã€‚ç”±äºALUæ˜¯ä¸€ä¸ªç»„åˆé€»è¾‘ç”µè·¯ï¼Œæ—¶åˆ»éƒ½åœ¨è¿ç®—ï¼Œå› æ­¤å¦‚æœæ²¡æœ‰ç¼“å†²å™¨é‚£ä¹ˆæ€»çº¿å°†ä¸€ç›´è¢«ALUçš„è¾“å‡ºæ‰€å ç”¨\n\n\n\nå•æ€»çº¿ç»“æ„2\n\n\n\nä¸å‰è€…ç›¸æ¯”æš‚å­˜å™¨ï¼Œä½†æ€»æ•°æœªå˜\néœ€è¦3æ­¥ï¼š\n\n\nåŒæ€»çº¿ç»“æ„1\n\n\n\nALU+1ä¸ªæš‚å­˜å™¨\n\nåªæœ‰å¯ä»¥å°†æ•°æ®é€å›GRï¼Œå› æ­¤LCåªèƒ½è¿æ¥\n\næ€»å…±éœ€è¦ä¸¤æ­¥ï¼š\n\n\n\n\n\n\n\n       \n\n\n\nåŒæ€»çº¿ç»“æ„2\n\n\n\nä¸å‰è€…ç›¸æ¯”æš‚å­˜å™¨ï¼Œæ€»æ•°æœªå˜\næ€»å…±éœ€è¦ä¸¤æ­¥ï¼š\n\n\nä¸‰æ€»çº¿ç»“æ„\n\n\n\næ—è·¯å™¨çš„ä½œç”¨æ˜¯ä¸é€šè¿‡ALUå®ç°é€šç”¨å¯„å­˜å™¨GRå†…çš„æ•°æ®ä¼ è¾“\né€Ÿåº¦æ˜¯ä¸Šè¿°æ‰€æœ‰ç»“æ„ä¸­æœ€å¿«çš„ï¼ˆå› ä¸ºæ­¥éª¤æœ€å°‘ï¼‰\nä»…éœ€1æ­¥ï¼š\n\n\n\n\n       \n\n\n\næ ‡å¿—å¯„å­˜å™¨ï¼šALUçš„è¾“å‡ºé™¤è¿ç®—ç»“æœå¤–ï¼Œè¿˜åŒ…æ‹¬è‹¥å¹²çŠ¶æ€æ ‡å¿—ä½\n\nZFï¼šé›¶æ ‡å¿—ã€‚è¿ç®—ç»“æœä¸º0ï¼ŒZF=1ï¼Œå…¶ä½™æƒ…å†µZF=0\n\nCFï¼šåŠ æ³•è¿›ä½()/å‡æ³•å€Ÿä½()/é€»è¾‘å·¦ç§»æº¢å‡ºæ ‡å¿—ä½ï¼Œä»…å¯¹æ— ç¬¦å·æ•°è¿ç®—æœ‰æ„ä¹‰\nâš ï¸æ— ç¬¦å·æ•°çš„å‡æ³•ä¾æ—§æ˜¯å¯¹å‡æ•°å–å+1å†ä¸è¢«å‡æ•°ç›¸åŠ ã€‚å‡è®¾æ— ç¬¦å·æ•°ä½æ˜¯ï¼Œé‚£ä¹ˆå‡æ•°çš„è¡¥ç å¯ä»¥è®¤ä¸ºæ˜¯ï¼Œè‹¥åŠ ä¸Šè¢«å‡æ•°åæœ€é«˜ä½æ²¡æœ‰äº§ç”Ÿè¿›ä½ï¼ˆäº§ç”Ÿè¿›ä½æ‰èƒ½çœŸæ­£åœ°æŠŠè·¨è¿‡å»ï¼‰ï¼Œé‚£ä¹ˆäº‹å®ä¸Šæœ€ç»ˆç»“æœä¾æ—§åœç•™åœ¨è´Ÿæ•°åŸŸ ï¼ˆï¼‰ï¼Œå¹¶æ²¡æœ‰å®Œå…¨è·¨è¿‡yï¼Œé‚£ä¹ˆè¿ç®—çš„æœ€ç»ˆç»“æœå°†ä¼šæ˜¯ä¸€ä¸ªæ¯”éƒ½å¤§çš„æ— ç¬¦å·æ•°ã€‚å¸Œæœ›ä¸‹å›¾èƒ½å¸®åŠ©ä½ ç†è§£\n\n\nOFï¼šæº¢å‡ºæ ‡å¿—ï¼Œåªé’ˆå¯¹æœ‰ç¬¦å·æ•°çš„åŠ å‡è¿ç®—æ˜¯å¦æº¢å‡ºï¼ˆä¸€èˆ¬æŒ‡ä¸Šæº¢ï¼‰\n\nSFï¼šç¬¦å·æ ‡å¿—ï¼Œåªé’ˆå¯¹æœ‰ç¬¦å·æ•°\n\nPFï¼šå¥‡å¶æ ‡å¿—ï¼Œåæ˜ è¿ç®—ç»“æœä¸­â€œ1â€ä¸ªæ•°çš„å¥‡å¶æ€§ï¼Œå¶1å¥‡0\n\n\n\nÎ² æµ®ç‚¹æ•°çš„åŠ å‡è¿ç®—æµ®ç‚¹æ•°çš„åŠ å‡è¿ç®—ä¸éš¾ï¼Œå› æ­¤ç®€å•è¯´ä¸€ä¸‹ã€‚\n\nå¯¹é˜¶\n\nå°é˜¶å‘å¤§é˜¶çœ‹é½ï¼Œä»è€Œå°é˜¶ä½æ•°çœ‹é½æ—¶å³ç§»èˆå»å°ä½ä»¥å‡å°è¯¯å·®\nå°é˜¶ä½æ•°å³ç§»æ—¶å…ˆä¿ç•™ç§»å‡ºçš„æœ€ä½ä½ï¼Œç§°ä¸ºä¿ç•™é™„åŠ ä½ã€‚ä¿ç•™é™„åŠ ä½å‚ä¸ä¸­é—´è¿ç®—ä»¥æé«˜è¿ç®—ç²¾åº¦ã€‚è¿ç®—ç»“æŸåè§„æ ¼åŒ–å†èˆå…¥ã€‚\n\n\nå°¾æ•°è¿ç®—ï¼šä¸€èˆ¬é‡‡ç”¨åŒç¬¦å·ä½è¿›è¡Œè¿ç®—\n\nç»“æœè§„æ ¼åŒ–\n\nå°¾æ•°éœ€è¦å³å½’æ“ä½œï¼šå°¾æ•°è¿ç®—ç»“æœä¸Šæº¢ï¼ˆç¬¦å·ä½ä¸º01/10ï¼‰\nå°¾æ•°éœ€è¦å·¦å½’æ“ä½œï¼šå°¾æ•°è¿ç®—ç»“æœæœ‰å‰å¯¼0\n\n\nèˆå…¥\n\nå‘ä¸Š/ä¸‹èˆå…¥ï¼šæ€»æ˜¯æœ+/-âˆèˆå…¥\nå‘0èˆå…¥ï¼šæœæ•°è½´åŸç‚¹èˆå…¥\nå°±è¿‘èˆå…¥ï¼š0èˆ1å…¥\n\n\n\n\n\n","slug":"å®šç‚¹è¿ç®—å™¨","date":"2022-03-14T03:08:02.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"74debfb0a3b8fd019ca9b40b7b9af159","title":"ã€Œ1013ã€Battle Over Cities","content":"â³ENTRY\nIt is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.\nFor example, if we have 3 cities and 2 highways connecting  and . Then if  is occupied by the enemy, we must have 1 highway repaired, that is the highway .\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.\nOutput Specification:For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.\nSample Input:3 2 3\n1 2\n1 3\n1 2 3\n\nSample Output:1\n0\n0\n\n\nÎ©é¦–å…ˆæç®€ç¿»è¯‘ä¸€æ³¢ã€‚ç®€å•çš„è¯´å°±æ˜¯ï¼Œæœ‰ä¸€äº›åŸå¸‚ï¼Œéƒ¨åˆ†åŸå¸‚ä¹‹é—´è¿æœ‰é«˜é€Ÿå…¬è·¯ã€‚å½“ä¸€ä¸ªåŸå¸‚è¢«æ•Œäººå é¢†åï¼Œä¸å…¶ç›¸è¿çš„é«˜é€Ÿå…¬è·¯éƒ½æ— æ³•é€šè¡Œï¼Œä½†è¦æ±‚å…¶ä½™åŸå¸‚å¿…é¡»æ˜¯è¿é€šçš„ï¼Œè¯•é—®æœ€å°‘éœ€è¦æ­å‡ æ¡é«˜é€Ÿå…¬è·¯ã€‚\nä¹çœ‹é¢˜ç›®æœ‰ç‚¹è¿·ï¼Œå…¶å®åªéœ€è¦æ±‚å‰©ä½™åŸå¸‚çš„è¿é€šåˆ†å›¾æ•°å³å¯ã€‚è‹¥å‰©ä½™åŸå¸‚å«ä¸ªè¿é€šåˆ†å›¾ï¼Œé‚£ä¹ˆæ˜¾ç„¶æœ€å°‘åªéœ€æ¡è¾¹å³å¯å°†æ‰€æœ‰å‰©ä½™åŸå¸‚ç›¸è¿ã€‚\næˆ‘é‡‡å–çš„æ˜¯Alg. BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰çš„æ€æƒ³ï¼ŒæŒ‰é¡ºåºéå†æ¯ä¸€åº§åŸå¸‚ï¼Œç„¶åå°†ä¸è¿™åº§åŸå¸‚ç›¸è¿çš„åŸå¸‚è¿›è¡Œæ ‡è®°ï¼Œæ¥ç€å†å°†ä¸è¿™äº›åŸå¸‚ç›¸è¿çš„åŸå¸‚è¿›è¡Œæ ‡è®°ï¼Œé€å±‚é€’å½’ï¼Œç›´è‡³ç›¸è¿çš„åŸå¸‚æ•°é‡ä¸º0ã€‚å½“ç„¶å¯¹äºè¢«æ•Œäººå é¢†çš„é‚£ä¸€åº§åŸå¸‚æˆ‘ä»¬éœ€è¦åœ¨ä¸€å¼€å§‹å¯¹å…¶å°±è¿›è¡Œæ ‡è®°ï¼Œä»è€Œåé¢é€’å½’çš„æ—¶å€™å°±æ— æ³•ä»è¿™åº§åŸå¸‚ç»è¿‡ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, k, a, b;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n  //è®°å½•é«˜é€Ÿå…¬è·¯\n    map&lt;int, vector&lt;int&gt;&gt; connect;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        connect[a].push_back(b);\n        connect[b].push_back(a);\n    }\n  //æ ‡è®°å˜é‡\n    vector&lt;bool&gt; mark(n + 1);\n    int city, num;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; city;\n        num = 0;\n        fill(mark.begin(), mark.end(), false);\n        mark[city] = true;\n        for (int j = 1; j &lt;= n; ++j)\n        {\n            if (mark[j])\n                continue;\n          //mark[j]=falseè¯´æ˜æ˜¯ä¸€ä¸ªæ–°çš„è¿é€šåˆ†å›¾\n            num += 1;\n          //cupå­˜å‚¨ä¸nextä¸­åŸå¸‚ç›¸è¿çš„åŸå¸‚\n            set&lt;int&gt; next{j}, cup;\n            while (!next.empty())\n            {\n                for (auto &amp;c: next)\n                    if (mark[c])\n                        continue;\n                    else\n                    {\n                        mark[c] = true;\n                        cup.insert(connect[c].begin(), connect[c].end());\n                    }\n                next = cup;\n                cup.clear();\n            }\n        }\n        cout &lt;&lt; num - 1 &lt;&lt; endl;\n    }\n}\n\n\nâš¡ï¸ ç®—æ³•è¯´æ˜\nä½¿ç”¨mapå¯ä»¥ç›´æ¥é€šè¿‡åŸå¸‚åºå·è®¿é—®ä¸å…¶ç›¸è¿çš„åŸå¸‚vector\nfill(mark.begin(), mark.end(), false);å°†markè¿­ä»£å™¨ä¸­çš„å€¼å…¨éƒ¨å¡«å……ä¸ºfalse\nç”¨setè®°å½•ä¸å½“å‰åŸå¸‚ç›¸è¿çš„åŸå¸‚å¯ä»¥é¿å…é‡å¤\ncup.insert(connect[c].begin(), connect[c].end());å°†vector&lt;int&gt; connect[c]ä¸­çš„å€¼æ’å…¥åˆ°set&lt;int&gt; cupçš„å°¾éƒ¨\næœ¬é¢˜ä¹Ÿå¯ä»¥é‡‡ç”¨Alg. DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰ï¼Œè¯¦æƒ…å¯è§æŸ³å©¼ ã® blog\n\n","slug":"1013-Battle-Over-Cities","date":"2022-03-12T11:09:43.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,set,BFS,Graph","author_index":"Starlit Rover"},{"id":"4b69eccade1977efb8c2be2f48efdb06","title":"ã€ŒSection 3ã€å…³ç³»æ¨¡å‹","content":"\nå…³ç³»æ¨¡å‹çš„ä¸»è¦æœ¯è¯­\n\nå…³ç³»ï¼ˆè¡¨ï¼‰ï¼šä¸€ä¸ªå…³ç³»å¯ç”¨ä¸€ä¸ªè¡¨æ¥è¡¨ç¤ºï¼Œæ¯ä¸ªå…³ç³»éƒ½æœ‰å”¯ä¸€çš„åç§°ã€‚\nå±æ€§ï¼šè¡¨ï¼ˆå…³ç³»ï¼‰ä¸­çš„æ¯ä¸€åˆ—å³ä¸ºä¸€ä¸ªå±æ€§ï¼Œä¸€ä¸ªè¡¨å†…çš„å±æ€§åéƒ½æ˜¯å”¯ä¸€çš„ï¼Œä¸”éƒ½æ˜¾ç¤ºåœ¨è¡Œé¦–ã€‚\nåŸŸï¼šå¯ä»¥è®¤ä¸ºæ˜¯å±æ€§çš„å®šä¹‰åŸŸã€‚\nå…ƒç»„ï¼šè¡¨ä¸­çš„ä¸€è¡Œæ•°æ®ç§°ä¸ºä¸€ä¸ªå…ƒç»„ï¼Œå³ä¸€ä¸ªå®ä½“æ‰€æœ‰å±æ€§å€¼çš„æ€»ç§°ã€‚åŒæ ·çš„ï¼Œä¸€ä¸ªè¡¨ä¸­çš„å…ƒç»„éƒ½æ˜¯å”¯ä¸€çš„ã€‚\n\n\n\n\nåˆ†é‡ï¼šä¸€ä¸ªå…ƒç»„åœ¨ä¸€ä¸ªå±æ€§ä¸Šçš„å€¼ç§°ä¸ºå…ƒç»„åœ¨è¯¥å±æ€§ä¸Šçš„åˆ†é‡ã€‚\n\nå€™é€‰ç ï¼šå¯ä»¥å”¯ä¸€ï¼ˆä¸€ä¸€æ˜ å°„ï¼‰æ ‡å¿—å…ƒç»„çš„å±æ€§ï¼ˆç»„ï¼‰\n\nä¸»ç ï¼šå…¶ä¸­ä¸€ä¸ªè¢«é€‰å®šçš„å€™é€‰ç ï¼Œæ¯ä¸ªè¡¨å”¯ä¸€ã€‚\n\nä¸»å±æ€§ï¼šåœ¨å€™é€‰ç ä¸­çš„å±æ€§ç§°ä¸ºä¸»å±æ€§ï¼Œåä¹‹ç§°ä¸ºéä¸»ï¼ˆç ï¼‰å±æ€§ã€‚\n\nå¤–éƒ¨ç ï¼šå…³ç³»çš„éç å±æ€§ä¸å…³ç³»çš„ç ç›¸å¯¹åº”ï¼Œåˆ™ç§°ä¸ºçš„å¤–éƒ¨ç ã€‚å¯ä»¥ä¸ç›¸åŒï¼Œä¸çš„åŸŸä¸€å®šç›¸åŒã€‚ï¼ˆå¯ä»¥è®¤ä¸ºéœ€è¦ä»çš„ç å€¼ä¸­é€‰å–ï¼‰\n\nå…³ç³»æ¨¡å¼ï¼šä¸€ä¸ªå…³ç³»çš„å…³ç³»ååŠå…¶å…¨éƒ¨å±æ€§åçš„é›†åˆç§°ä¸ºè¯¥å…³ç³»çš„å…³ç³»åï¼Œå³\nã€å…³ç³»åï¼ˆå±æ€§å1ï¼Œå±æ€§å2ï¼Œ... ï¼Œå±æ€§ånï¼‰ã€‘\n\n\nå…³ç³»çš„å…­ä¸ªåŸºæœ¬æ€§è´¨\n\nå…³ç³»ä¸­æ¯ä¸ªå±æ€§å…·æœ‰åŸå­ç‰¹æ€§ï¼Œæ˜¯åŸºæœ¬æ•°æ®é¡¹ï¼Œä¸å¯å†åˆ†\nåŒä¸€å±æ€§å±äºåŒä¸€åˆ—\nä¸åŒçš„åˆ—ï¼ˆå±æ€§ï¼‰å¯ä»¥æ‹¥æœ‰ç›¸åŒçš„åŸŸ\nåˆ—ï¼ˆå±æ€§ï¼‰çš„æ¬¡åºå¯ä»¥ç›¸äº’äº¤æ¢\nè¡Œï¼ˆå…ƒç»„ï¼‰çš„æ¬¡åºä¹Ÿå¯ä»¥ç›¸äº’äº¤æ¢\nä¸€ä¸ªå…³ç³»ä¸­ä¸èƒ½æœ‰ä¸¤ä¸ªç›¸åŒçš„å…ƒç»„ï¼ˆè¡Œï¼‰\n\n\nå…³ç³»æ¨¡å‹çš„æ•°æ®æ“ä½œ\n\næ“ä½œå¯¹è±¡å’Œæ“ä½œç»“æœéƒ½æ˜¯å…³ç³»ã€‚å…¶ç†è®ºæ ‡å‡†ä¸ºå…³ç³»ä»£æ•°å’Œå…³ç³»æ¼”ç®—ã€‚\nå­˜å–è·¯å¾„å¯¹ç”¨æˆ·éšè”½ï¼Œç”¨æˆ·åªéœ€æŒ‡å‡ºæ“ä½œï¼Œè€Œä¸å¿…è€ƒè™‘å¦‚ä½•æ“ä½œã€‚å­˜å–è·¯å¾„æ˜¯ç”±RDBMSï¼ˆRelational Database Management Systemï¼Œå…³ç³»æ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼‰è‡ªåŠ¨é€‰æ‹©çš„ï¼Œæé«˜äº†æ•°æ®çš„ç‹¬ç«‹æ€§ã€‚\n\n\nå…³ç³»çš„å®Œæ•´æ€§çº¦æŸï¼šè§„å®šäº†æ•°æ®å¿…é¡»ç¬¦åˆçš„æ¡ä»¶\n\nå®ä½“å®Œæ•´æ€§ï¼šåœ¨ä¸»å±æ€§ä¸Šçš„åˆ†é‡ä¸èƒ½ä¸ºç©ºï¼ˆå®é™…ç³»ç»Ÿä¸­æ²¡æœ‰å€™é€‰ç çš„æ¦‚å¿µï¼Œå› æ­¤å˜ä¸ºä»»æ„å…³ç³»çš„ä¸»ç ä¸èƒ½ä¸ºç©ºï¼‰\nå‚ç…§å®Œæ•´æ€§ï¼šä¸­çš„å¤–éƒ¨ç åªèƒ½å–ç©ºå€¼æˆ–è€…ä¸­æŸå…ƒç»„çš„ç å€¼ï¼ˆï¼‰ã€‚è¿™æ˜¯å¯¹å…³ç³»ä¹‹é—´å¼•ç”¨æ•°æ®çš„ä¸€ç§é™åˆ¶ã€‚\nç”¨æˆ·å®šä¹‰çš„å®Œæ•´æ€§ï¼šæ¯ä¸ªæ•°æ®åº“éƒ½æœ‰è‡ªå·±ç‹¬æœ‰çš„çº¦æŸè¦æ±‚ï¼Œæ¯”å¦‚å¹´é¾„ä¸èƒ½å¤§äº60å²ç­‰\n\n\nE-Ræ¨¡å‹å‘å…³ç³»æ¨¡å‹çš„è½¬åŒ–\n\nå®ä½“é›†ï¼šç›´æ¥è½¬\n\nè”ç³»é›†R\n\nRå•ç‹¬çš„å±æ€§è½¬åŒ–ä¸ºè¯¥å…³ç³»çš„å±æ€§\nRæ¶‰åŠçš„æ¯ä¸ªå®ä½“é›†çš„ç å±æ€§è½¬åŒ–ä¸ºè¯¥å…³ç³»çš„å±æ€§\nå¦‚ä½•é€‰å®šè¯¥å…³ç³»çš„ç (â€»)\nè‹¥Rä¸º1:1çš„è”ç³»ï¼Œæ¯ä¸ªç›¸å…³å®ä½“çš„ç å‡å¯ä»¥ä½œä¸ºè¯¥å…³ç³»çš„ç \nè‹¥Rä¸º1:nçš„è”ç³»ï¼Œåˆ™å…³ç³»çš„ç ä¸ºné‚£ä¸€ç«¯å®ä½“çš„ç \nè‹¥Rä¸ºm:nçš„è”ç³»ï¼Œåˆ™å…³ç³»çš„ç ä¸ºç›¸å…³å®ä½“é›†ç çš„é›†åˆ\n\n\næ‹¥æœ‰ç›¸åŒç çš„ä¸åŒå…³ç³»ï¼ˆè¡¨ï¼‰å®è´¨ä¸Šæ˜¯åŒä¸€ä¸ªå®ä½“é›†ï¼Œå› æ­¤å¯ä»¥åˆå¹¶ï¼Œåˆå¹¶åçš„å…³ç³»çš„å±æ€§æ˜¯ä¸¤ä¸ªå®ä½“é›†çš„æ‰€æœ‰å±æ€§\næ ¹æ®è¯¥è§„åˆ™ä¼šå‘ç°æœ€åè”ç³»ç•™ä¸‹æ¥çš„å…³ç³»åªæœ‰m:nçš„æ‰éœ€è¦å»ºç«‹å®ä½“é›†ï¼Œä»è€Œ(â€»)å˜ä¸º\nè‹¥Rä¸º1:1çš„è”ç³»ï¼Œæ— éœ€å»ºç«‹å…³ç³»ï¼Œç›´æ¥åœ¨ä»»æ„ä¸€æ–¹çš„å…³ç³»å±æ€§ä¸­åŠ å…¥å¦ä¸€æ–¹çš„ç å³å¯\nè‹¥Rä¸º1:nçš„è”ç³»ï¼Œæ— éœ€å»ºç«‹å…³ç³»ï¼Œç›´æ¥åœ¨næ–¹å…³ç³»å±æ€§ä¸­åŠ å…¥1æ–¹çš„ç \nè‹¥Rä¸ºm:nçš„è”ç³»ï¼Œéœ€è¦å»ºç«‹å…³ç³»ï¼Œè€Œä¸”ä»¥åŒæ–¹å…³ç³»çš„ç çš„é›†åˆä½œä¸ºè¯¥å…³ç³»çš„ç ï¼Œå…¶ä½™å±æ€§ä¸ºå…¶æœ¬èº«è‡ªå¸¦å±æ€§\n\n\n\n\n\n\nExample\n\n\n\n\n","slug":"å…³ç³»æ¨¡å‹","date":"2022-03-09T13:28:00.000Z","categories_index":"æ•°æ®åº“åŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"22f37ab474c466341b4a621e124d19bc","title":"ã€ŒSection 4ã€å®šç‚¹æ•°çš„ä¹˜é™¤æ³•å®ç°","content":"â˜™ å®šç‚¹ä¹˜æ³•è¿ç®—Î£ åŸç ä¸€ä½ä¹˜æ³•åŸåŸï¼Œå…¶ä¸­ä¸ºç¬¦å·ä½ã€‚\n\nç¬¦å·ä½å•ç‹¬è¿ç®—ï¼š\n\nç»å¯¹å€¼éƒ¨åˆ†çš„æ•°å€¼è¿ç®—\n\næˆ‘ä»¬å¹³å¸¸åˆ—ç«–å¼è®¡ç®—çš„æ–¹å¼å®è´¨ä¸Šå¯ä»¥çœ‹æˆç­‰å¼\n\n\nåªä¸è¿‡å¹³å¸¸æˆ‘ä»¬åˆ—ç«–å¼çš„å¯¹è±¡æ˜¯åè¿›åˆ¶ã€‚åœ¨åˆ—ç«–å¼çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ç”¨çš„æ¯ä¸€ä½å»ä¹˜ï¼Œä½†æ— éœ€å»å…³æ³¨ï¼Œè¿™æ˜¯å› ä¸ºæˆ‘ä»¬é€šè¿‡æ¯æ¬¡å°†éƒ¨åˆ†ç§¯ï¼ˆï¼‰å·¦ç§»ä¸€ä½å¹¶ä¸”çœå»äº†æœ«å°¾çš„0æ‰å®ç°çš„ï¼Œå·¦ç§»çš„è¿‡ç¨‹å°±æ˜¯ï¼Œè€Œæœ«å°¾çš„0å¯¹ç»“æœæ— å½±å“å› æ­¤å¯ä»¥çœç•¥ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º\n\n\næˆ‘ä»¬å¦‚ä½•è®©è®¡ç®—æœºå®ç°ä¸Šè¿°æ“ä½œå‘¢ï¼Ÿé¦–å…ˆæˆ‘ä»¬å¯ä»¥å°†ç¬¬ä¸€ä¸ªä¹˜æ•°ä¿å­˜ä¸‹æ¥ï¼Œç„¶åæˆ‘ä»¬éœ€è¦è®©çš„æ¯ä¸€ä½å»ä¹˜ï¼Œä¹˜å®Œä¹‹åå°±å°†å³ç§»ä¸€ä½ï¼Œä»è€Œå¯ä»¥ä¿è¯æ¯æ¬¡éƒ½ç”¨çš„æœ€å°ä½å»ä¹˜ã€‚å¦å¤–æˆ‘ä»¬éœ€è¦å°†éƒ¨åˆ†ç§¯è¿›è¡Œç´¯åŠ ï¼Œç´¯åŠ çš„ç»“æœå°±å­˜æ”¾åœ¨ï¼Œç„¶è€Œæ¯ä¸€æ¬¡ä¹˜å‡ºæ¥çš„éƒ¨åˆ†ç§¯éƒ½æ˜¯ä½ï¼Œå¹¶æ²¡æœ‰â€â€ï¼Œå³æœ«å°¾çš„0ã€‚åœ¨æ‰‹åˆ—ç«–å¼æ—¶æˆ‘ä»¬é€šè¿‡å°†éƒ¨åˆ†ç§¯å·¦ç§»æ¥ä½“ç°â€â€ï¼ŒåŒæ ·çš„ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç´¯åŠ ç»“æœå³ç§»ç„¶åç›´æ¥åŠ ä¸Š4ä½éƒ¨åˆ†ç§¯æ¥å®ç°ï¼Œè¿™åªæ˜¯ä¸€ä¸ªç›¸å¯¹è¿åŠ¨ã€‚\n\næ³¨æ„åˆ°ä¸Šè¿°è¿‡ç¨‹ä¸­æœ‰ä¸¤ä¸ªå€¼æ˜¯éœ€è¦å³ç§»çš„ï¼Œå…¶ä¸€æ˜¯ï¼Œå…¶äºŒæ˜¯ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬ä¸¤ä¸ªè¿åœ¨ä¸€èµ·è¿›è¡Œå³ç§»ï¼Œæ¥ä¸‹æ¥æ˜¯çš„åŸç ä¸€ä½ä¹˜æ³•è¯´æ˜\n\n\n\néƒ¨åˆ†ç§¯ä¹‹å’Œä¸ä¹˜æ•°æ˜¯è¿åœ¨ä¸€èµ·å³ç§»çš„\néƒ¨åˆ†ç§¯è¿ç®—æ—¶çš„ç¬¦å·ä½ä¸æ˜¯æœ€ç»ˆçš„ç¬¦å·ä½ï¼Œä½†æ”¾åœ¨è¿™é‡Œå¯ä»¥ä¿ç•™æº¢å‡ºä½ï¼Œå½“æ•´ä½“å³ç§»æ—¶æº¢å‡ºä½ä¼šåˆ°æœ€é«˜ä½ï¼ˆè§æœ€åä¸€æ­¥ï¼‰\nè€ƒè™‘ç¬¦å·ä½åæœ€ç»ˆç»“æœçš„åŸç å°±åº”è¯¥æ˜¯\n\n\n\n\nç¡¬ä»¶å®ç°\n\n\n\nè®¡æ•°å™¨æ¥æ§åˆ¶å¾ªç¯æ¬¡æ•°ï¼Œä»å‡åˆ°0è¯´æ˜å®ŒæˆåŸç ä¸€ä½ä¹˜æ³•\nå½“è®¡æ•°å™¨å‡åˆ°0æ—¶ï¼Œè¿æ¥ç€çš„æ¸…é›¶ç«¯ä½¿Dè§¦å‘å™¨å½’0ä»è€Œä¸clockçš„ä¸é—¨è¾“å‡ºä¸º0ï¼Œæ­¤æ—¶ç”µè·¯ä¸å·¥ä½œ\nçš„æœ€åä¸€ä½å†³å®šéƒ¨åˆ†ç§¯æ˜¯è¿˜æ˜¯ï¼Œå› æ­¤æ§åˆ¶é€»è¾‘å³æ˜¯ä¸è¢«ä¹˜æ•°çš„ä¸é—¨\n\n\n\nÎ  é˜µåˆ—ä¹˜æ³•å™¨è¿™ä¸ªä¹˜æ³•å™¨æ€æƒ³æ¯”è¾ƒå•çº¯ï¼Œç›´æ¥ä¸Šå›¾\n\n\nè¿™ä¸ªæ ·å­å°±éå¸¸ç¬¦åˆæˆ‘ä»¬æ‰‹åˆ—ç«–å¼çš„æ ·å­äº†ï¼Œäº‹å®ä¸Šä¹Ÿç¡®å®æ˜¯è¿™æ ·çš„ä¸€ä¸ªæƒ³æ³•ã€‚ä¸Šå›¾æ˜¯ä¸¤ä¸ªå››ä½æ— ç¬¦å·å®šç‚¹æ•´æ•°çš„ä¹˜æ³•ã€‚\n\nå°†ä¸¤ä¸ªä¹˜æ•°çš„ä»»æ„ä¸¤ä½è¿›è¡Œç›¸ä¹˜å¾—åˆ°ä½ä¹˜ç§¯ï¼Œç”±äºåªæ˜¯äºŒè¿›åˆ¶ä¸ªä½æ•°çš„ä¹˜æ³•ï¼Œå› æ­¤ç”¨ä¸é—¨å³å¯è§£å†³\nä¼ é€’è¿›ä½çš„æ–¹å¼ä¸åˆ—ç«–å¼ä¸åŒï¼Œæ¯ä¸€ä¸ªå…¨åŠ å™¨FAéƒ½å°†è‡ªå·±çš„è¿›ä½ä¼ é€’ç»™ä¸‹ä¸€å±‚çš„éš”å£ä½ï¼Œæœ¬è´¨ä¸Šè·Ÿç«–å¼å·®ä¸å¤š\nå…¨åŠ å™¨å…±æœ‰ä¸ªï¼Œæ¯ä¸ªFAè®¡ç®—ä¸Šé¢FAçš„è¾“å‡ºï¼Œå½“å‰ä½ä¹˜ç§¯è¿˜æœ‰å³ä¸Šè§’çš„è¿›ä½ä¹‹å’Œï¼Œå› æ­¤æ¯ä¸€åˆ—æœ€ä¸Šé¢çš„ä½ä¹˜ç§¯ä¸éœ€è¦FA\næ¯ä¸€å±‚ä¹‹é—´å­˜åœ¨å»¶æ—¶ï¼Œå› ä¸ºéœ€è¦ç­‰å¾…è¿›ä½æ•°ï¼Œä¸€å±‚ä¸­çš„FAæ˜¯åŒæ­¥çš„\nç›¸å¯¹åŸç ä¸€ä½ä¹˜æ³•æ¥è¯´æ•ˆç‡æ›´é«˜\n\n\nâ˜™ å®šç‚¹é™¤æ³•è¿ç®—é™¤æ³•ä¸ä¹˜æ³•ç±»ä¼¼ï¼Œç¬¦å·ä½å•ç‹¬è¿ç®—ï¼Œåªè€ƒè™‘ç»å¯¹å€¼çš„é™¤æ³•ã€‚è€Œé™¤æ³•ä¸­æˆ‘ä»¬æ—¶å¸¸éœ€è¦æ¯”è¾ƒä½™æ•°æ·»0åä¸é™¤æ•°çš„å¤§å°ï¼Œåœ¨è®¡ç®—æœºä¸­åªèƒ½é€šè¿‡å‡æ³•è¿›è¡Œæ¯”è¾ƒï¼Œå½“å‡æ³•ç»“æœä¸ºè´Ÿæ•°æ—¶æˆ‘ä»¬åˆæ ¹æ®æ˜¯å¦æ¢å¤ä½™æ•°å°†é™¤æ³•ç»†åˆ†ä¸ºåŸç æ¢å¤ä½™æ•°æ³•å’ŒåŸç ä¸æ¢å¤ä½™æ•°æ³•ã€‚æ¥ä¸‹æ¥æ˜¯ç”¨ä¸¤ç§æ–¹æ³•è®¡ç®—çš„è¯´æ˜ï¼Œè¿™é‡Œä¸ºä½ï¼ˆä¸å¸¦ç¬¦å·ä½ï¼‰å®šç‚¹å°æ•°ã€‚\nÎ± åŸç æ¢å¤ä½™æ•°æ³•\nåˆå§‹ä½™æ•°ï¼Œè®¡ç®—è¡¥\n\nâ¶ è‹¥åˆ™å•†0å¹¶é‡æ–°å¾—åˆ°ï¼ˆâš ï¸æœ¬æ¬¡ä½™æ•°ä¾ç„¶ä¸ºï¼Œåªæ˜¯ä½™æ•°ä¸ºè´Ÿï¼‰ï¼Œå¹¶å°†ï¼ˆå¯ä»¥è§†ä¸ºçš„æ­£ç‰ˆï¼‰ä¹˜2ï¼ˆå·¦ç§»ä¸€ä½ï¼‰å‡å»å¾—åˆ°æ–°çš„ä½™æ•°ï¼›\nâ· è‹¥åˆ™å•†1ï¼Œç„¶åå°†ä¹˜2ï¼ˆå·¦ç§»ä¸€ä½ï¼‰å‡å»å¾—åˆ°ã€‚\næœ¬è´¨ä¸Šï¼Œä¸Šè¿°ä¸¤ä¸ªæ“ä½œéƒ½æ˜¯ä½™æ•°å·¦ç§»ä¸€ä½å‡å»é™¤æ•°ã€‚\nâ¸ å¦å¤–ï¼Œè‹¥åˆ™ç»“æŸè¿ç®—ã€‚\næ€»çš„æ¥è¯´å°±æ˜¯ æ¯”è¾ƒâ†’ä¸Šå•†â†’å·¦ç§»â†’æ¯”è¾ƒ\n\n\n\n   \n\n\n\nä¸Šè¿°è¿‡ç¨‹æ€»å…±å¾ªç¯æ¬¡ï¼ˆæœ€åä¸€æ¬¡æ— éœ€å·¦ç§»ï¼‰ï¼Œå¾—åˆ°ä¸ªå•†ï¼ˆ1ä¸ªæ•´æ•°ä½+ä½å°æ•°ï¼‰ï¼Œå…¶ä¸­ç¬¬ä¸€æ¬¡å¾ªç¯å¾—åˆ°çš„å•†æ˜¯æ•´æ•°ä½ä¸Šçš„ï¼Œæœ€åå·¦ç§»ä¼šå°†å…¶ç§»åˆ°ç¬¦å·ä½ä¸Šï¼ˆä½†ä¼šè¢«çœŸæ­£çš„ç¬¦å·ä½æ›¿æ¢æ‰ï¼‰ï¼Œå› æ­¤å¦‚æœæ˜¯ä¸€ä¸ªå¤§æ•°é™¤ä»¥ä¸€ä¸ªå°æ•°å°†ä¼šå‘ç”Ÿæº¢å‡ºã€‚\n\nå¦‚æœå•†çš„æœ€åä¸€ä½ä¸º0å¯çŸ¥å½“å‰ä½™æ•°ä¸ºè´Ÿï¼Œå› æ­¤æƒ³è¦å¾—åˆ°ä½™æ•°è¿˜éœ€è¦åŠ ä¸Šé™¤æ•°\n\nå®é™…æ“ä½œè¿‡ç¨‹ä¸­ï¼Œä½™æ•°å’Œè¢«é™¤æ•°ã€é™¤æ•°å‡é‡‡ç”¨åŒç¬¦å·ä½ï¼šåœ¨è¿ç®—æ—¶å¯ä»¥ä¿ç•™æº¢å‡ºçš„æœ€é«˜ä½\n\nè¿™ä¸ªç®—æ³•ä¸­æ¢å¤ä½™æ•°çš„æ¬¡æ•°æ˜¯æœªçŸ¥çš„ä»è€Œå¯¼è‡´é¢„ç®—æ—¶é—´ä¹Ÿæ˜¯æœªçŸ¥çš„\n\nExampleï¼šX=0.1011ï¼ŒY=-0.1101\n\n\nâš ï¸æ³¨æ„åˆ°å•†çš„æ¯ä¸€ä½éƒ½æ˜¯åœ¨æœ€å³ç«¯äº§ç”Ÿçš„ï¼Œç„¶åä¸æ–­å·¦ç§»è¿‡æ¥ï¼Œè€Œæ¯æ¬¡ä½™æ•°ä¹Ÿéœ€è¦å·¦ç§»ï¼Œå› æ­¤è¿™é‡Œä¹Ÿæ˜¯å°†ä½™æ•°å’Œå•†è¿åœ¨ä¸€èµ·å·¦ç§»çš„\n\n\nÎ² åŸç ä¸æ¢å¤ä½™æ•°æ³•ï¼ˆåŠ å‡äº¤æ›¿æ³•ï¼‰æ˜¾ç„¶ï¼Œåè€…å­˜åœ¨çš„åŸå› å°±æ˜¯ä¸ºäº†æ”¹è¿›å‰è€…ã€‚äº‹å®ä¸Šï¼Œå‰é¢åŸç æ¢å¤ä½™æ•°çš„å¼å­å·²ç»ä½“ç°äº†åŸç ä¸æ¢å¤ä½™æ•°çš„æ€æƒ³ï¼Œæˆ‘ä»¬ç¨åŠ æ•´ç†å¯å¾—\n\n\n\n\nå¯è§ä¸¤è€…çš„å½¢å¼éå¸¸çš„ç»Ÿä¸€ï¼Œä¸è®ºå“ªç§æƒ…å†µæˆ‘ä»¬éƒ½æ— éœ€æ¢å¤ä½™æ•°ï¼Œè€Œä¸”åªè¦è¿ç®—2æ¬¡å³å¯å¾—åˆ°ä¸‹ä¸€ä¸ªä½™æ•°ã€‚ç”±æ­¤æˆ‘ä»¬ä¾¿å¯ä»¥è§£å†³è¿ç®—æ—¶é—´ä¸å¯é¢„æµ‹çš„é—®é¢˜äº†ã€‚\n\n\n\n\nÎ£ åŸç ä¸æ¢å¤ä½™æ•°é™¤æ³•çš„ç¡¬ä»¶å®ç°\n\n\nå¤„æ”¾æ¯æ¬¡è¿ç®—å¾—å‡ºçš„ä½™æ•°ï¼Œå…¶ä¸­ä¸ºç¬¦å·ä½\nçš„åˆå§‹å€¼ä¸º\nå¤„åˆ™å­˜æ”¾å•†çš„ç»“æœï¼Œåˆ™æ˜¯æ¯æ¬¡è¿ç®—çš„ä¸Šå•†ä½\nåˆå§‹å€¼éœ€è¦ä¸º1ï¼Œä¿è¯ç¬¬ä¸€æ¬¡åšçš„æ˜¯å‡æ³•\nè¯´æ˜ä½™æ•°&gt;0ï¼Œä½å•†1ï¼›åä¹‹å•†0\nä½å•†1ä¸‹ä¸€æ­¥åˆ™éœ€è¦å·¦ç§»å‡ï¼›ä½å•†0åˆ™éœ€è¦å·¦ç§»åŠ \nä¸­å­˜å‚¨çš„æ˜¯ï¼ŒåŠ åˆ™æ— éœ€å¯¹æ“ä½œï¼ˆï¼Œï¼‰ï¼Œå‡åˆ™éœ€è¦å¯¹å–è¡¥ç ï¼ˆï¼Œï¼‰\næ§åˆ¶é€»è¾‘å†³å®šå¼‚æˆ–å¯¹è±¡ï¼Œå†³å®šæ˜¯å¦+1\n\nÎ  é˜µåˆ—é™¤æ³•å™¨åŒæ ·åŸºäºé˜µåˆ—ä¹˜æ³•å™¨çš„æ€æƒ³ï¼Œæˆ‘ä»¬å¯ä»¥åº”ç”¨äºé™¤æ³•ä»è€ŒåŠ å¿«è¿ç®—é€Ÿåº¦ã€‚é˜µåˆ—ä¹˜æ³•å™¨ä¸­çš„æ ¸å¿ƒéƒ¨ä»¶æ˜¯CASå¯æ§åŠ å‡æ³•å•å…ƒã€‚\n\n\nCASæœ‰8ä¸ªå¼•è„šï¼Œ4ä¸ªè¾“å…¥ç«¯4ä¸ªè¾“å‡ºç«¯ã€‚Pæ§åˆ¶åŠ å‡æ“ä½œï¼Œæ—¶CASæ‰§è¡ŒåŠ æ³•ï¼Œå¦åˆ™æ‰§è¡Œå‡æ³•ï¼ˆä¾æ—§ç”¨å¼‚æˆ–ä¸é…åˆè¿›è¡Œå–å+1ï¼Œæ³¨æ„åˆ°æœ€ä½ä½çš„è¿›ä½ç«¯æ˜¯ä¸ç›¸è¿çš„ï¼‰ï¼›ä¸ºè¿›ä½/å€Ÿä½è¾“å…¥/è¾“å‡ºä¿¡å·ï¼›æ–œå‘è¾“å…¥å’Œè¾“å‡ºçš„ä¸ºé™¤æ•°ï¼Œæ–œå‘è¾“å‡ºè¿åˆ°ä¸‹ä¸€ä¸ªCASå•å…ƒï¼Œç›¸å½“äºæ‰‹åŠ¨é™¤æ³•ä¸­çš„å³ç§»ï¼›å‚ç›´è¾“å…¥çš„æ˜¯è¢«é™¤æ•°ï¼Œå‚ç›´è¾“å‡ºä½™æ•°ã€‚\nä»£å…¥å…¨åŠ å™¨çš„é€»è¾‘è¡¨è¾¾å¼ï¼ŒCASå•å…ƒçš„è¾“å‡ºå’Œè¾“å…¥ä¹‹é—´çš„å…³ç³»å¯ä»¥è¡¨ç¤ºä¸º\nä¸‹å›¾ä¸ºå­—é•¿ä¸º3çš„é˜µåˆ—é™¤æ³•å™¨åŸºæœ¬ç»“æ„ï¼Œå…¶ä¸­è¢«é™¤æ•°ï¼ˆåŒå­—é•¿ï¼‰ï¼Œé™¤æ•°ï¼Œå•†ï¼Œä½™æ•°\n\n\n\né˜µåˆ—é™¤æ³•å™¨é‡‡ç”¨çš„æ˜¯åŸç ä¸æ¢å¤é™¤æ³•çš„æ€æƒ³\nåˆå§‹æƒ…å†µä¿è¯ç¬¬ä¸€æ¬¡è¿ç®—åšå‡æ³•ï¼Œå¦å¤–è¦æ±‚ï¼Œå¦åˆ™è¿ç®—ç»“æœå°†ä¼šæº¢å‡º\nå¯ä»¥çœ‹åˆ°è¿æ¥åˆ°æœ€ä½ä½çš„è¿›ä½è¾“å…¥ç«¯ï¼Œä»è€Œå½“æ—¶å¯¹é™¤æ•°è¿›è¡Œå–å+1ç”Ÿæˆè¡¥ç ï¼Œéšåå®Œæˆè¿ç®—\næ–œå‘ä¼ é€’çš„æ˜¯é™¤æ•°çš„æ¯ä¸€ä½ï¼Œå› æ­¤æ¯ä¸€å±‚å‡ä¸ä¼šæ”¹å˜\nåŸç ä¸æ¢å¤ä½™æ•°é™¤æ³•çš„è¿ç®—è¿‡ç¨‹é‡‡ç”¨çš„æ˜¯åŒç¬¦å·ä½ï¼ŒåŒç¬¦å·ä½ä¸­çš„ç¬¬ä¸€ä½æ˜¯çœŸæ­£çš„ç¬¦å·ä½ï¼Œè€Œç¬¬äºŒä½åˆ™å¯ä»¥è§†ä¸ºæº¢å‡ºä¿ç•™ä½ï¼Œå³å®é™…è¿ç®—ä¸­çš„æœ€é«˜æœ‰æ•ˆä½ï¼ˆæœ¬è´¨ä¸Šæ¥è¯´åŒç¬¦å·æ•°åªæ˜¯å¤šäº†ä¸€ä½çš„å•ç¬¦å·æ•°ï¼‰ã€‚ä½†åœ¨é˜µåˆ—ä¹˜æ³•å™¨ä¸­ä»…æœ‰åŒç¬¦å·ä½çš„ç¬¬äºŒä½ï¼ˆæ¯ä¸€å±‚æœ€å·¦ä¾§çš„CASï¼‰ï¼Œè¿™æ˜¯å› ä¸ºä½™æ•°ä¸ºæ­£æ—¶ï¼ˆç¬¦å·ä½0ï¼‰éœ€è¦ï¼ˆç¬¦å·ä½1ï¼‰ï¼Œä½™æ•°ä¸ºè´Ÿæ—¶ï¼ˆç¬¦å·ä½1ï¼‰éœ€è¦ï¼ˆç¬¦å·ä½0ï¼‰ï¼Œå³åœ¨ä¸è€ƒè™‘ç¬¬äºŒä½ç¬¦å·ä½è¿›ä½æ—¶ç¬¦å·ä½å§‹ç»ˆä¸º1ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€å…³æ³¨æ¯ä¸€å±‚æœ€å·¦ä¾§CASçš„è¿›ä½è¾“å‡ºç«¯å³å¯ã€‚\nå½“æœ€å·¦ä¾§CASçš„è¿›ä½è¾“å‡ºç«¯ä¸º0æ—¶ï¼Œç¬¦å·ä½ä¸º1ï¼Œè¯´æ˜ä½™æ•°ä¸ºè´Ÿï¼Œå•†0å¹¶åœ¨ä¸‹ä¸€æ¬¡è¿ç®—ä¸­ç§»ä½ï¼›å½“è¿›ä½è¾“å‡ºç«¯ä¸º1æ—¶ï¼Œè¯´æ˜ä½™æ•°ä¸ºæ­£ï¼Œå•†1å¹¶åœ¨ä¸‹ä¸€æ¬¡è¿ç®—ä¸­ç§»ä½ã€‚ä»ä¸­å¯ä»¥çœ‹å‡ºæœ€å·¦ä¾§CASçš„è¿›ä½è¾“å‡ºç«¯ä¸ä»…ç­‰äºæ¯ä¸€å±‚çš„å•†å€¼ï¼ŒåŒæ—¶å†³å®šäº†ä¸‹ä¸€å±‚çš„åŠ å‡æ“ä½œã€‚å› æ­¤å°†æ¯ä¸€å±‚æœ€å·¦ä¾§CASçš„è¿›ä½è¾“å‡ºç«¯è¿è‡³ä¸‹ä¸€å±‚çš„åŠ å‡æ§åˆ¶ç«¯ï¼Œå¦å¤–é€šè¿‡CASæ’å¸ƒçš„å³ç§»æ¥å®Œæˆä½™æ•°çš„å·¦ç§»ã€‚\n\n","slug":"å®šç‚¹æ•°çš„ä¹˜é™¤æ³•å®ç°","date":"2022-03-09T01:13:56.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"a39f642fa5f3a366579e792c57ec2418","title":"BÃ©zier Curveï¼šå°è¯•ç‰›åˆ€","content":"è´å¡å°”æ›²çº¿æœ‰ç€å¾ˆå¤šç‰¹æ®Šçš„æ€§è´¨åœ¨å›¾å½¢è®¾è®¡å’Œè·¯å¾„è§„åˆ’ä¸­åº”ç”¨éƒ½éå¸¸å¹¿æ³›ã€‚è´å¡å°”æ›²çº¿å®Œå…¨ç”±å…¶æ§åˆ¶ç‚¹å†³å®šå…¶å½¢çŠ¶ï¼Œnä¸ªæ§åˆ¶ç‚¹å¯¹åº”ç€n-1é˜¶çš„è´å¡å°”æ›²çº¿ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡é€’å½’æ¥å®šä¹‰ã€‚æœ¬ç¯‡æ–‡ç« çš„é‡ç‚¹åœ¨äºå¯¹BÃ©zier Curveçš„ç†è§£ä»¥åŠç”¨OpenGLç»˜åˆ¶BÃ©zier Curveã€‚\n\n\n\n\nã€„ BÃ©zier CurveÂ·1é˜¶ç»™å®šä¸¤ä¸ªå·²çŸ¥åæ ‡çš„æ§åˆ¶ç‚¹ï¼Œï¼Œé‚£ä¹ˆ1é˜¶è´å¡å°”æ›²çº¿å¯ä»¥ç”¨ä¸€ä¸ªå…³äºtçš„å‚æ•°æ–¹ç¨‹æ¥æè¿°ï¼šå¾ˆæ˜¾ç„¶ï¼Œè¿™è¡¨ç¤ºçš„å³æ˜¯ä¸¤æ§åˆ¶ç‚¹ä¹‹é—´çš„çº¿æ®µï¼Œè€Œæ¯ä¸€ä¸ªåˆ™è¡¨ç¤ºçº¿æ®µä¸Šçš„ä¸€ä¸ªç‚¹ï¼Œè¿™ä¸ªå…³äºçš„åŠ¨ç‚¹æˆ‘ä»¬å§‘ä¸”å…ˆç§°ä¹‹ä¸ºè´å¡å°”åŠ¨ç‚¹ï¼Œè´å¡å°”åŠ¨ç‚¹éå†ä¾¿æ„æˆè´å¡å°”æ›²çº¿ã€‚\nâš ï¸äº‹å®ä¸Šè´å¡å°”æ›²çº¿æœ¬èº«è·Ÿæ˜¯æ— å…³çš„ï¼Œåªæ˜¯æ–¹ä¾¿æè¿°æ›²çº¿ä¸Šçš„ç‚¹è€Œå­˜åœ¨çš„ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ç”»å‡ºè´å¡å°”æ›²çº¿çš„ç”»ç¬”ã€‚\nã€„ BÃ©zier CurveÂ·2é˜¶ç»™å®šä¸‰ä¸ªå·²çŸ¥åæ ‡çš„æ§åˆ¶ç‚¹ï¼Œï¼Œï¼Œé‚£ä¹ˆè¿™æ—¶å€™æœ‰ä¸¤ä¸ªçº¿æ®µï¼Œæˆ‘ä»¬å¯ä»¥å…ˆæ±‚å‡ºè¿™ä¸¤ä¸ªçº¿æ®µä¸Šçš„è´å¡å°”åŠ¨ç‚¹ï¼Œç„¶åæ±‚ä¸¤ä¸ªè´å¡å°”åŠ¨ç‚¹çº¿æ®µä¸Šçš„è´å¡å°”åŠ¨ç‚¹ï¼ˆä¸‰ä¸ªè´å¡å°”åŠ¨ç‚¹å…³è”åŒä¸€ä¸ªï¼‰ï¼Œç¬¬ä¸‰ä¸ªè´å¡å°”åŠ¨ç‚¹å°†æ„æˆ2é˜¶è´å¡å°”æ›²çº¿ï¼šé‚£ä¹ˆ2é˜¶è´å¡å°”æ›²çº¿çš„å‚æ•°æ–¹ç¨‹å³ä¸ºæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™æ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ã€‚\nã€„ BÃ©zier CurveÂ·3é˜¶åŒç†3é˜¶è´å¡å°”æ›²çº¿çš„æ–¹ç¨‹ä¸ºä¸‹å›¾æ˜¯å½“æ—¶çš„è´å¡å°”åŠ¨ç‚¹çº¿æ®µä»¥åŠç›¸åº”çš„3é˜¶è´å¡å°”æ›²çº¿\n\n\n\n\näº‹å®ä¸Šå¯¹äºè´å¡å°”æ›²çº¿å‚æ•°æ–¹ç¨‹ä¸­æ¯ä¸ªæ§åˆ¶ç‚¹å‰çš„ç³»æ•°éƒ½æ˜¯ä¸€ä¸ªå…³äºçš„å‡½æ•°ï¼Œè€Œè¿™äº›ç³»æ•°å‡½æ•°æˆ‘ä»¬å¯ä»¥ç±»æ¯”æ¨è¾‰ä¸‰è§’ï¼ˆè´å¡å°”æ›²çº¿çš„é€’å½’è¿‡ç¨‹æœ¬è´¨ä¸Šå°±æ˜¯ä¸ªæ¨è¾‰ä¸‰è§’ï¼‰\n\n\nä¸Šå›¾åªæ˜¯ä¸€ä¸ªä¸‰é˜¶çš„æ¨è¾‰ä¸‰è§’ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¯ä¸ªæ§åˆ¶ç‚¹æ‰€åœ¨çš„å¶å­èŠ‚ç‚¹åˆ°æ ¹ç»“ç‚¹ï¼ˆæœ€ä¸Šé¢çš„é‚£ä¸ªç‚¹ï¼‰çš„è·¯å¾„ä¹˜ç§¯ä¹˜ä»¥å…¶æ‰€åœ¨å¶å­èŠ‚ç‚¹ä¸Šçš„æ•°å­—å³ä¸ºå…¶ç³»æ•°å‡½æ•°ã€‚æ¯”å¦‚è¯´ï¼Œæˆ‘ä»¬éšä¾¿å–ä¸€æ¡åˆ°æ ¹ç»“ç‚¹çš„è·¯å¾„ï¼ˆä¸ç®¡å“ªæ¡è·¯å¾„ï¼Œä¹˜ç§¯éƒ½æ˜¯ä¸€æ ·çš„ï¼‰ï¼Œå°†è·¯å¾„ä¸Šçš„è¡¨è¾¾å¼è¿›è¡Œç›¸ä¹˜å¾—åˆ°ï¼Œå†ä¹˜ä»¥å…¶å¶å­èŠ‚ç‚¹3å¾—åˆ°ï¼Œå¯¹ç…§å³ä¸ºçš„ç³»æ•°ã€‚\nã€„ BÃ©zier CurveÂ·  é˜¶æ³¨æ„åˆ°ä¸Šå›¾ä¸­çš„æ¨è¾‰ä¸‰è§’å…¶å®å°±æ˜¯çš„å±•å¼€å¼ï¼Œå› æ­¤æˆ‘ä»¬å…¶å®å¯ä»¥ç›´æ¥å†™å‡ºé˜¶è´å¡å°”æ›²çº¿ä¸­æ§åˆ¶ç‚¹çš„ç³»æ•°ä¸ºä¸Šå¼åˆç§°ä¸ºné˜¶çš„æ³¢æ©æ–¯å¦åŸºåº•å¤šé¡¹å¼ã€‚\n\næ¥ä¸‹æ¥å°±åˆ°äº†æ¿€åŠ¨äººå¿ƒçš„ç»˜åˆ¶é˜¶æ®µã€‚ä¸è¿‡å…¶å®ç†è®ºå†…å®¹å·²ç»å·®ä¸å¤šäº†ï¼Œå‰©ä½™çš„åªæ˜¯C++ç¼–ç¨‹ï¼ŒOpenGLè¿ç”¨ã€‚\nä»£ç é‡Œæ²¡æœ‰ä»€ä¹ˆé«˜æ·±çš„æ€æƒ³ï¼Œæ²¡æœ‰å•¥ä¼˜åŒ–ï¼ˆæ¦‚æ‹¬ï¼šæ‡’ï¼‰ï¼Œå°±æ˜¯å®ç°äº†ä¸€ä¸ªç‚¹ç±»ï¼Œç„¶åä¸æ–­é€’å½’æ±‚å‡ºæ–°çš„æ§åˆ¶ç‚¹åæ ‡ã€‚å½“ç„¶OpenGLä¸èƒ½ç»˜åˆ¶è¿ç»­çš„æ›²çº¿ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åŒ–æ›²ä¸ºç›´ã€‚è¿™æ—¶å€™å°±æ´¾ä¸Šç”¨åœºäº†ï¼Œæˆ‘å°†ä»ä¸­å‡åŒ€åœ°å–100ä¸ªå‡ºæ¥åˆ†åˆ«ç»˜åˆ¶ç›¸åº”çš„ç‚¹ï¼Œæœ€åå°†è¿™äº›ç‚¹è¿èµ·æ¥å³å¯ã€‚\n\n\nâš¡ï¸ ç®—æ³•è¯´æ˜\nå®ç°äº†ä¸€ä¸ªç‚¹ç±»Pointï¼Œç”¨äºå­˜å‚¨ä¸€ä¸ªç‚¹çš„åæ ‡ï¼ˆdouble x,yï¼‰ï¼Œå¹¶é‡è½½äº†*ã€+ç¬¦å·ï¼Œä½¿åæ ‡å¯ä»¥ç›´æ¥ä¸æµ®ç‚¹æ•°è¿›è¡ŒåŠ ä¹˜è¿ç®—\n\né¦–å…ˆéœ€è¦ç”¨æˆ·è¾“å…¥éœ€è¦ç»˜åˆ¶çš„è´å¡å°”æ›²çº¿çš„é˜¶æ•°ï¼Œéšåè¾“å…¥ä¸ªæ§åˆ¶å®šç‚¹çš„åæ ‡ï¼Œæœ€åæŒ‡å®šæ¥ç»˜åˆ¶å‡ºç›¸åº”çš„ä¸­é—´è¿­ä»£æ§åˆ¶ç‚¹\n\n\nå¯¹æ¯ä¸ªç‚¹çš„åæ ‡éƒ½æ¥æ»¡è¶³å®é™…ç»˜å›¾åæ ‡çš„èŒƒå›´ï¼ˆç»˜åˆ¶å‡½æ•°ä¼ å…¥çš„åæ ‡èŒƒå›´ï¼‰\n\nvector&lt;vector&lt;Point&gt;&gt; control_pointså­˜å‚¨å‚æ•°æ‰€å¯¹åº”çš„æ¯ä¸€æ¬¡è¿­ä»£çš„æ§åˆ¶ç‚¹åæ ‡ï¼Œcontrol_points[i]å­˜å‚¨çš„æ˜¯ç¬¬æ¬¡è¿­ä»£çš„æ§åˆ¶ç‚¹åæ ‡\n\nè‹¥è¡¨ç¤ºç¬¬æ¬¡è¿­ä»£çš„ç¬¬ä¸ªæ§åˆ¶ç‚¹ï¼Œé‚£ä¹ˆæ§åˆ¶ç‚¹çš„è¿­ä»£å…¬å¼ï¼š\n\n\n\n\nç»˜åˆ¶è´å¡å°”æ›²çº¿æ˜¯åŒ–æ›²ä¸ºç›´ï¼Œé¦–å…ˆå‡åŒ€å–äº†100ä¸ªï¼Œç”»å‡ºæ¯ä¸ªæ‰€å¯¹åº”çš„ä½äºè´å¡å°”æ›²çº¿ä¸Šçš„ç‚¹ï¼Œæœ€åå°†æ¯ä¸ªç‚¹è¿èµ·æ¥\nvector&lt;vector&lt;Point&gt;&gt; middle_pointså­˜å‚¨çš„æ˜¯æ¯ä¸ªè¿­ä»£è¿‡ç¨‹ä¸­çš„ä¸­é—´æ§åˆ¶ç‚¹åæ ‡ä»¥åŠæœ€åæ‰€è¦è¿èµ·æ¥çš„100ä¸ªç‚¹\nç»˜åˆ¶è¿‡ç¨‹ï¼šå¯¹åº”çš„è¿­ä»£è¿‡ç¨‹æ§åˆ¶ç‚¹è¿çº¿â†’è´å¡å°”æ›²çº¿è¿çº¿â†’åœ¨è´å¡å°”æ›²çº¿ä¸Šå¯¹åº”çš„ç‚¹\n\n\n\nå…¶ä½™å°±çœ‹ä»£ç æ³¨é‡Šå§ï½\n\nCâ˜ºDE#include &lt;glew.h&gt;\n#include &lt;glfw3.h&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n//é‡è½½äº†*ï¼Œ+è¿ç®—ç¬¦çš„ç‚¹ç±»\nclass Point\n{\npublic:\n    double x, y;\n\n    Point(double _x, double _y) : x(_x), y(_y) {};\n\n    inline Point operator*(const double &amp;t) const\n    {\n        return Point(t * this-&gt;x, t * this-&gt;y);\n    }\n\n    inline Point operator+(const Point &amp;rhs) const\n    {\n        return Point(this-&gt;x + rhs.x, this-&gt;y + rhs.y);\n    }\n};\n\nint main(void)\n{\n    int n;\n    cout &lt;&lt; \"BÃ©zier Curveçš„é˜¶æ•°ï¼š\";\n    cin &gt;&gt; n;\n\n    //control_pointså­˜å‚¨æŒ‡å®štçš„æ¯ä¸€æ¬¡è¿­ä»£æ§åˆ¶ç‚¹ï¼Œmiddle_pointså­˜å‚¨ç»˜åˆ¶è¿‡ç¨‹ä¸­çš„æ¯ä¸€æ¬¡è¿­ä»£æ§åˆ¶ç‚¹ï¼ˆtä¼šå˜ï¼‰\n    vector&lt;vector&lt;Point&gt;&gt; control_points(n + 1), middle_points(n + 1);\n    double x, y, t0;\n    cout &lt;&lt; \"è¯·è¾“å…¥\" &lt;&lt; n + 1 &lt;&lt; \"ä¸ªæ§åˆ¶ç‚¹åæ ‡ï¼ˆ0 â‰¤ |x|,|y| â‰¤ 100ï¼‰ï¼š\" &lt;&lt; endl;\n    for (int i = 0; i &lt; n + 1; ++i)\n    {\n        cin &gt;&gt; x &gt;&gt; y;\n        control_points[0].emplace_back(Point(x / 100, y / 100));\n    }\n\n    //è¾“å…¥æŒ‡å®štï¼Œå¯ç»˜åˆ¶å‡ºt0æ—¶æ¯ä¸€æ¬¡çš„è¿­ä»£æ§åˆ¶ç‚¹\n    cout &lt;&lt; \"t0 = \";\n    cin &gt;&gt; t0;\n    //è®¡ç®—t0æ—¶æ¯ä¸€æ¬¡çš„è¿­ä»£æ§åˆ¶ç‚¹\n    for (int i = 1; i &lt; n + 1; ++i)\n        for (int j = 0; j &lt; n + 1 - i; ++j)\n            control_points[i].emplace_back(control_points[i - 1][j] * (1 - t0) + control_points[i - 1][j + 1] * t0);\n    //æ±‚100ä¸ªtæ‰€å¯¹åº”çš„ç‚¹\n    middle_points[0] = control_points[0];\n    for (int k = 0; k &lt; 101; ++k)\n    {\n        double t = k / 100.0;\n        for (int i = 1; i &lt; n; ++i)\n        {\n            middle_points[i].clear();\n            for (int j = 0; j &lt; n + 1 - i; ++j)\n                middle_points[i].emplace_back(middle_points[i - 1][j] * (1 - t) + middle_points[i - 1][j + 1] * t);\n        }\n        middle_points[n].emplace_back(middle_points[n - 1][0] * (1 - t) + middle_points[n - 1][1] * t);\n    }\n    //å¼€å§‹ç»˜åˆ¶ï¼Œåˆå§‹åŒ–glfwåº“\n    if (!glfwInit())\n        return -1;\n    //åˆ›å»ºçª—å£ä»¥åŠä¸Šä¸‹æ–‡\n    GLFWwindow *window = glfwCreateWindow(800, 600, \"BÃ©zier Curve\", NULL, NULL);\n    if (!window)\n        glfwTerminate();\n    //å»ºç«‹å½“å‰çª—å£çš„ä¸Šä¸‹æ–‡\n    glfwMakeContextCurrent(window);\n    //å¾ªç¯ç»˜åˆ¶ä½¿å…¶åœç•™åœ¨å±å¹•ä¸Š\n    while (!glfwWindowShouldClose(window))\n    {\n        glfwPollEvents();\n        //èƒŒæ™¯é¢œè‰²\n        glClearColor(0.2, 0.1, 0.2, 1);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        //ç»˜åˆ¶t0æ—¶æ¯æ¬¡è¿­ä»£çš„æ§åˆ¶ç‚¹è¿çº¿\n        glLineWidth(5);\n        for (int i = 0; i &lt; n; ++i)\n        {\n            //ä½¿æ¯æ¬¡è¿­ä»£çš„æ§åˆ¶ç‚¹è¿çº¿é¢œè‰²ä¸åŒ\n            glColor3f(1.0 * (n - 1 - i) / (n - 1), 1.0 * i / (n - 1), 0);\n            glBegin(GL_LINE_STRIP);\n            for (auto &amp;p: control_points[i])\n                glVertex2f(p.x, p.y);\n            glEnd();\n        }\n        //ç»˜åˆ¶è´å¡å°”æ›²çº¿\n        glColor3f(0, 0, 1);\n        glBegin(GL_LINE_STRIP);\n        for (auto &amp;p: middle_points[n])\n            glVertex2f(p.x, p.y);\n        glEnd();\n\n        //ç»˜åˆ¶å‡ºè´å¡å°”æ›²çº¿ä¸Št0æ‰€å¯¹åº”çš„ç‚¹\n        glColor3f(0, 0.7, 0.7);\n        glPointSize(20);\n        glEnable(GL_POINT_SMOOTH);\n        glBegin(GL_POINTS);\n        glVertex2f(control_points[n][0].x, control_points[n][0].y);\n        glEnd();\n\n        glfwSwapBuffers(window);\n    }\n    glfwTerminate();\n    return 0;\n}\n\n\nâš›ï¸ 5 order Bezier curve ()\n","slug":"Bezier-Curve","date":"2022-03-08T08:47:55.000Z","categories_index":"è®¡ç®—æœºå›¾å½¢å­¦","tags_index":"èµ°ç è§‚èŠ±,OpenGL","author_index":"Starlit Rover"},{"id":"df24c0ec65d9b0432ce3e888de12a2d4","title":"ã€ŒSection 0ã€å°è®°OpenGL","content":"\nglfwMakeContextCurrent(GLFWwindow *window)ï¼šå°†çª—å£windowè®¾ä¸ºå½“å‰ä¸Šä¸‹æ–‡\n\nOpenGLå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªå·¨å¤§çš„çŠ¶æ€æœºã€‚æ‰€è°“çŠ¶æ€æœºï¼Œæ˜¯ä¸€ä¸ªåŒ…å«äº†è®¸å¤šå½“å‰å±æ€§ï¼ˆèƒŒæ™¯é¢œè‰²ã€æ¸²æŸ“æ¨¡å¼ï¼‰çš„é›†åˆï¼ˆçŠ¶æ€ï¼‰ï¼Œé‡Œé¢çš„å±æ€§å€¼ç›´åˆ°ä¸‹æ¬¡ä¿®æ”¹å‰éƒ½ä¸ä¼šæ”¹å˜ã€‚é‚£ä¹ˆå½“å†…éƒ¨å±æ€§å‘ç”Ÿæ”¹å˜æ—¶çŠ¶æ€ä¹Ÿéšä¹‹è€Œå˜ï¼Œç±»ä¼¼ç¼–è¯‘åŸç†é‡Œé¢çš„è‡ªåŠ¨æœºã€‚\nä¸Šä¸‹æ–‡å¯ä»¥è®¤ä¸ºæ˜¯OpenGLå½“å‰çš„çŠ¶æ€ï¼Œå³å½“å‰æ‰§è¡Œæ“ä½œçš„çª—å£ï¼Œå¯ä»¥è®¤ä¸ºé€‰æ‹©windowä½œä¸ºå½“å‰ç”»å¸ƒã€‚\n\n\n\nglViewport(GLint x,GLint y,GLsizei width,GLsizei height)ï¼šåœ¨çª—å£ä¸Šè®¾ç½®ç»˜åˆ¶åŒºåŸŸ\n\nxï¼Œyä»¥åƒç´ ä¸ºå•ä½ï¼ŒæŒ‡å®šäº†è§†å£çš„å·¦ä¸‹è§’ä½ç½®\nwidthï¼Œheight è¡¨ç¤ºè¿™ä¸ªè§†å£çŸ©å½¢çš„å®½åº¦å’Œé«˜åº¦ï¼Œæ ¹æ®çª—å£çš„å®æ—¶å˜åŒ–é‡ç»˜çª—å£\nåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œè§†å£è¢«è®¾ç½®ä¸ºå æ®æ‰“å¼€çª—å£çš„æ•´ä¸ªåƒç´ çŸ©å½¢ï¼Œè§†å£å¤§å°ä¸çª—å£å¤§å°ç›¸åŒ\néœ€è¦ç½®äºglfwMakeContextCurrent(GLFWwindow *window)å‡½æ•°åæ‰ä¼šç”Ÿæ•ˆ\nä¸€ä¸ªç¨‹åºå†…å¯ä»¥ä½¿ç”¨å¤šæ¬¡åœ¨ä¸åŒåŒºåŸŸå†…è¿›è¡Œç»˜åˆ¶\næ³¨å†Œå›è°ƒå‡½æ•°ï¼Œå³æ¯æ¬¡è°ƒæ•´çª—å£æ—¶è°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥è°ƒæ•´è§†å£\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    glViewport(0, 0, width, height);\n}\n\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\nOpenGLä¸­çš„å‡½æ•°åï¼šglColor3f,glVertex2f,glVertex3d, â€¦\n\nå¼€å¤´glè¡¨ç¤ºOpenGLä¸­çš„å‡½æ•°\næ•°å­—å‰çš„å•è¯è¡¨ç¤ºè¯¥å‡½æ•°çš„ä½œç”¨\næ•°å­—è¡¨ç¤ºæœ‰å‡ ä¸ªå‚æ•°ï¼Œåœ¨glVertexä¸­2è¡¨ç¤ºäºŒç»´åæ ‡ï¼Œ3åˆ™è¡¨ç¤ºä¸‰ç»´åæ ‡\næ•°å­—åé¢çš„å­—æ¯è¡¨ç¤ºå‚æ•°ç±»å‹\nsï¼š16ä½æ•´å‹\niï¼š32ä½æ•´å‹\nfï¼š32ä½ç¬¦ç‚¹æ•°\ndï¼š64ä½ç¬¦ç‚¹æ•°\n\n\n\n\n3Dåæ ‡ï¼šglVertex3f(x,y,z)\n\n\næ˜¯äºŒç»´å¹³é¢çš„åæ ‡ï¼Œæ˜¯çª—å£çš„ä¸­å¿ƒï¼Œè½´å‘å³ä¸ºæ­£æ–¹å‘ï¼Œè½´å‘ä¸Šä¸ºæ­£æ–¹å‘\nä¸ºæ·±åº¦ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯åˆ°å±å¹•çš„å‚ç›´è·ç¦»\n\n\nç»˜åˆ¶ä»£ç \nglBegin(TYPE);\n\t...\nglEnd()\n\nå…¶ä¸­TYPEä¸ºç»˜å›¾ç±»å‹ï¼Œå¸¸è§çš„ç±»å‹æœ‰ï¼š\n\nGL_POINTSï¼šç¦»æ•£çš„ç‚¹ï¼ˆâš ï¸ç”»åœ†ç‚¹ï¼šåœ¨glBeginå‰åŠ glEnable(GL_POINT_SMOOTH);ï¼‰\n\nGL_LINESï¼šçº¿\n\nGL_LINE_STRIPï¼šæŠ˜çº¿å›¾ï¼ˆå¤šä¸ªç‚¹çš„è¿çº¿ï¼‰\n\nGL_LINE_LOOPï¼šé¦–å°¾ç›¸è¿çš„é—­åˆçº¿\n\nGL_TRIANGLESï¼šä¸‰è§’å½¢\n\nGL_TRIANGLE_STRIPï¼šç»˜åˆ¶åŒæ–¹å‘çš„ä¸‰è§’å½¢\n\n\n\nè°ƒèŠ‚ç²—ç»†å¤§å°ï¼šç½®äºglBegin(TYPE)å‰\n\nçº¿çš„ç²—ç»†ï¼švoid glLineWidth(GLfloat width)ï¼Œ\nç‚¹çš„å¤§å°ï¼švoid glPointSize(GLfloat size) ï¼Œsizeçš„å•ä½æ˜¯åƒç´ ï¼ˆé»˜è®¤ä¸ºæ­£æ–¹å½¢ï¼‰\n\n\n\n","slug":"å°è®°OpenGL","date":"2022-03-08T08:01:35.000Z","categories_index":"è®¡ç®—æœºå›¾å½¢å­¦","tags_index":"OpenGL","author_index":"Starlit Rover"},{"id":"6e65b890459bfc2665ec0e0a14ed8ee7","title":"ã€ŒSection 2ã€å»ºç«‹æ•°æ®æ¨¡å‹","content":"\næ¦‚å¿µæ¨¡å‹çš„åŸºæœ¬æ¦‚å¿µ\n\nå®ä½“ï¼šå®¢è§‚äº‹ç‰©çš„æ˜ å°„ï¼Œå¯ä»¥æ˜¯å®é™…å­˜åœ¨çš„å¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ˜¯æŸç§æ¦‚å¿µ\n\nå±æ€§ï¼šå®ä½“çš„ç‰¹å¾ï¼Œæè¿°å®ä½“ï¼Œä½¿å®ä½“æ›´ä¸ºå…·ä½“\n\nåŸŸï¼šä¸€ä¸ªå±æ€§çš„å–å€¼èŒƒå›´\n\nå®ä½“é›†ï¼šæ‰€æœ‰å…·æœ‰ç›¸åŒå±æ€§çš„å®ä½“æ‰€æ„æˆçš„é›†åˆ\n\n\nå®ä½“å‹ï¼šå®ä½“åç§°ä»¥åŠæ‰€æœ‰å±æ€§åæ„æˆçš„é›†åˆ\n\nç ï¼šå®ä½“é›†ä¸­å¯ä»¥æ ¹æ®ä¸€ä¸ªå±æ€§æˆ–å¤šä¸ªå±æ€§å”¯ä¸€ç¡®å®šæ¯ä¸€ä¸ªå®ä½“ï¼Œé‚£ä¹ˆç§°è¯¥å±æ€§æˆ–å±æ€§ç»„ä¸ºç \n\n\n\nä¸»è¦çš„æ•°æ®æ¨¡å‹\n\nå±‚æ¬¡æ¨¡å‹\nç½‘çŠ¶æ¨¡å‹\nå…³ç³»æ¨¡å‹\né¢å‘å¯¹è±¡æ¨¡å‹\n\n\næ•°æ®æ¨¡å‹çš„ä¸‰å¤§åŸºæœ¬ç»„æˆéƒ¨åˆ†\n\næ•°æ®ç»“æ„ï¼šå®ä½“é—´è”ç³»åœ¨ä¿¡æ¯ä¸–ç•Œçš„è¡¨ç¤ºæ–¹æ³•ã€‚æè¿°äº†ç³»ç»Ÿçš„é™æ€ç‰¹æ€§ã€‚\næ•°æ®æ“ä½œï¼šå¯¹æ•°æ®å¯ä»¥æ‰§è¡Œçš„æ“ä½œï¼ˆä¸»è¦æœ‰æ•°æ®ç»´æŠ¤ã€æ•°æ®æ£€ç´¢ä¸¤å¤§ç±»ï¼‰åŠæ“ä½œè§„åˆ™ã€‚æè¿°äº†ç³»ç»Ÿçš„åŠ¨æ€ç‰¹æ€§ã€‚\nå®Œæ•´æ€§çº¦æŸï¼šåªæ‰§è¡Œç¬¦åˆå®Œæ•´æ€§çº¦æŸæ¡ä»¶çš„æ“ä½œï¼Œä»è€Œä¿è¯æ•°æ®çš„æ­£ç¡®ã€æœ‰æ•ˆã€ç›¸å®¹ã€‚\n\n\nE-Rå›¾çš„åŸºæœ¬è¡¨ç¤ºæ–¹æ³•\n\nçŸ©å½¢è¡¨ç¤ºå®ä½“é›†ï¼Œæ¤­åœ†è¡¨ç¤ºå®ä½“é›†çš„å±æ€§ï¼Œä¸¤è€…ä¹‹é—´ç”¨æ— å‘è¾¹ç›¸è¿\nå®ä½“çš„ç ï¼ˆe.g.å­¦å·ï¼Œèº«ä»½è¯å·ï¼‰ç”¨ä¸‹åˆ’çº¿æ ‡å‡º\nè±å½¢è¡¨ç¤ºå®ä½“é›†ä¹‹é—´çš„å…³ç³»ï¼Œè±å½¢ä¸­å†™ä¸Šå…³ç³»åï¼Œä¸å®ä½“é›†çš„è¿çº¿ä¸Šåˆ™å†™ä¸Šä¸¤ä¸ªå®ä½“é›†ä¹‹é—´çš„æ•°é‡å¯¹åº”å…³ç³»ï¼ˆè”ç³»çš„é˜¶ï¼‰\nä¸€å¯¹ä¸€ï¼š1:1\nä¸€å¯¹å¤šï¼š1:n\nå¤šå¯¹å¤šï¼šm:n\n\n\n\n\n\nå¤šå…ƒè”ç³»ï¼šä¸¤ä¸ªä»¥ä¸Šå®ä½“é›†ä¹‹é—´çš„è”ç³»\n\n\nè”ç³»çš„å±æ€§ï¼šæœ‰æ—¶ä¸€ä¸ªå±æ€§ä»é€»è¾‘ä¸Šä¸èƒ½å•ç‹¬åˆ†é…ç»™ä¸€ä¸ªå®ä½“æ—¶ï¼Œå¯ä»¥å°†å±æ€§åˆ†é…ç»™è”ç³»\n\n\nä¸Šå›¾ä¸­ä¸€åå­¦ç”Ÿæœ‰å¤šé—¨é€‰è¯¾çš„æˆç»©ï¼Œè€Œä¸€é—¨è¯¾ç¨‹åˆ™æœ‰å¤šä¸ªå­¦ç”Ÿçš„æˆç»©ï¼Œå› æ­¤ä¸¤è€…éƒ½ä¸èƒ½ç›´æ¥æ‹¥æœ‰æˆç»©å±æ€§ï¼Œè€Œæ˜¯å°†æˆç»©å±æ€§åˆ†é…ç»™é€‰è¯¾å…³ç³»æ›´ä¸ºåˆé€‚ï¼Œä¸€ä¸ªé€‰è¯¾ä¸€ä¸ªæˆç»©ã€‚\n\nå¼ºå®ä½“é›†ï¼šæœ‰ç çš„å®ä½“é›†ï¼›å¼±å®ä½“é›†ï¼šæ— ç çš„å®ä½“é›†ï¼Œä¾èµ–äºå…¶ä½™ä¸€ä¸ªæˆ–å¤šä¸ªå®ä½“é›†çš„ç ã€‚\n\n\n","slug":"å»ºç«‹æ•°æ®æ¨¡å‹","date":"2022-03-06T06:27:50.000Z","categories_index":"æ•°æ®åº“åŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"cf7c04c438de034cff5412cfe4f52f34","title":"ã€ŒSection 1ã€æ•°æ®åº“ç³»ç»Ÿæ¦‚è®º","content":"\næ•°æ®åº“ï¼ˆDataBaseï¼‰ï¼šå­˜å‚¨åœ¨è®¡ç®—æœºç³»ç»Ÿå†…çš„æœ‰ç»“æ„çš„æ•°æ®ç»“æ„ã€‚ä¸ä»…åŒ…å«æ•°æ®ï¼ŒåŒæ—¶è¿˜æœ‰æ•°æ®çš„å«ä¹‰ã€æ•°æ®ç»“æ„ã€çº¦æŸçš„å®Œæ•´æ€§å®šä¹‰\n\næ–‡ä»¶ç³»ç»Ÿçš„ç¼ºç‚¹\n\næ•°æ®å†—ä½™è¾ƒå¤§ï¼šæ•°æ®æ–‡ä»¶æ— æ³•å…±äº«\n\næ•°æ®å’Œç¨‹åºç¼ºä¹ç‹¬ç«‹æ€§ï¼šæ”¹å˜æ•°æ®çš„é€»è¾‘ç»“æ„å°±å¿…é¡»ä¿®æ”¹ç¨‹åº\n\n\n\næ•°æ®åº“ç®¡ç†ç³»ç»Ÿï¼ˆDatabase Management Systemï¼‰ï¼šDBMSæ˜¯ä½äºç”¨æˆ·ä¸æ“ä½œç³»ç»Ÿä¹‹é—´çš„ä¸€å±‚è½¯ä»¶ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¤§å‹çš„å¤æ‚çš„ç³»ç»Ÿè½¯ä»¶ã€‚é¢†å…ˆçš„è‘—åæ•°æ®åº“ç®¡ç†ç³»ç»ŸDBMSæœ‰PostgreSQLã€ IBM DB2ã€Oracleã€ Microsoft SQL Serverç­‰ã€‚å…¶æœ€åŸºæœ¬çš„åŠŸèƒ½å°±æ˜¯å…è®¸ç”¨æˆ·é€»è¾‘åœ°ä½¿ç”¨æ•°æ®è€Œæ— éœ€å…³æ³¨è¿™äº›æ•°æ®åœ¨è®¡ç®—æœºä¸­æ˜¯å¦‚ä½•å­˜æ”¾ã€å¦‚ä½•å¤„ç†çš„ã€‚\n\næ•°æ®å®šä¹‰ï¼šæ–¹ä¾¿ç”¨æˆ·å®šä¹‰æ•°æ®çš„é€»è¾‘ç»“æ„\næ•°æ®æ“æ§ï¼šæ–¹ä¾¿ç”¨æˆ·å¯¹æ•°æ®è¿›è¡Œæ’å…¥ã€åˆ é™¤ã€æŸ¥è¯¢ã€ä¿®æ”¹ç­‰æ“ä½œ\nå®Œæ•´æ€§çº¦æŸæ£€æŸ¥ï¼šæ•°æ®å¿…é¡»ç¬¦åˆä¸€äº›è§„å®šï¼Œå¦‚å­¦å·å¿…é¡»å”¯ä¸€ã€æ‰€å±åœ°åŒºå¿…é¡»å­˜åœ¨ç­‰\nè®¿é—®æœºåˆ¶ï¼šåªæœ‰åˆæ³•ç”¨æˆ·å¯ä»¥è®¿é—®ã€æ“ä½œæ•°æ®\nå¹¶å‘æ§åˆ¶ï¼šå…è®¸å¤šä¸ªç”¨æˆ·ã€åº”ç”¨å¹¶å‘è®¿é—®æ•°æ®åº“è€Œä¸ç ´åæ•°æ®çš„ä¸€è‡´æ€§\næ•°æ®åº“æ¢å¤\n\n\næ•°æ®åº“ç³»ç»Ÿï¼ˆDatabase Systemï¼‰ï¼šåŒ…æ‹¬æ•°æ®åº“ã€DBMSã€åº”ç”¨ç³»ç»Ÿã€è®¡ç®—æœºç¡¬ä»¶ã€æ•°æ®åº“ç®¡ç†å‘˜ï¼ˆDBAï¼‰\n\næ•´ä½“æ•°æ®çš„ç»“æ„åŒ–ï¼šæ•°æ®åº“ä¸­çš„æ•°æ®ä¸å±äºä»»ä½•åº”ç”¨è€Œæ˜¯å…¬å…±çš„ï¼Œç»“æ„æ˜¯å…¨é¢çš„ã€‚\næ•°æ®çš„å…±äº«åº¦é«˜ï¼šåˆæ³•ç”¨æˆ·å¯ä»¥åŒæ—¶ä½¿ç”¨æ•°æ®ã€‚\næ•°æ®çš„ç‹¬ç«‹æ€§é«˜ï¼šæ•°æ®å’Œç¨‹åºä¹‹é—´ç›¸äº’ç‹¬ç«‹ã€‚\né«˜åº¦çš„æ•°æ®æ§åˆ¶èƒ½åŠ›\næ•°æ®å®‰å…¨æ€§é«˜ï¼šåœ¨DBMSç®¡ç†ä¸‹ï¼Œåªæœ‰åˆæ³•ç”¨æˆ·å¯ä»¥è®¿é—®æ•°æ®åº“ã€‚\næ•°æ®å®Œæ•´æ€§å¥½ï¼šDBMSè‡ªåŠ¨æ£€æŸ¥æ•°æ®çš„ä¸€è‡´æ€§ã€ç›¸å®¹æ€§ã€‚\nå¹¶å‘æ§åˆ¶èƒ½åŠ›å¼ºï¼šå¯ä»¥ä½¿å¤šä¸ªç”¨æˆ·åŒæ—¶å¯¹æ•°æ®åº“ä¸­çš„æ•°æ®è¿›è¡Œæ“ä½œè€Œä¸ç ´åæ•°æ®çš„å®Œæ•´æ€§ã€‚\næ•°æ®æ¢å¤èƒ½åŠ›å¼ºï¼šå…·å¤‡æ¢å¤æ•°æ®åº“çš„åŠŸèƒ½ã€‚\n\n\n\n\n\næ•°æ®åº“çš„äººå‘˜æ„æˆ\n\næ•°æ®åº“ç®¡ç†å‘˜ï¼ˆDBAï¼‰\nåœ¨ç”¨æˆ·ä¸æ•°æ®åº“å¼€å‘äººå‘˜ä¹‹é—´è¿›è¡Œæ²Ÿé€šåè°ƒ\nå‚ä¸æ•°æ®åº“è®¾è®¡å·¥ä½œï¼Œç†Ÿæ‚‰æ•°æ®åº“çš„æ•´ä½“å¸ƒå±€\nå†³å®šæ•°æ®åº“çš„å®Œæ•´æ€§çº¦æŸæ¡ä»¶å’Œä¸åŒç”¨æˆ·çš„å­˜å–æƒé™\nè¿›è¡Œæ•°æ®åº“çš„ç»´æŠ¤å·¥ä½œï¼Œä¿è¯æ•°æ®åº“çš„æ­£å¸¸è¿è¡Œ\n\n\næ•°æ®åº“è®¾è®¡è€…ï¼šä¸€èˆ¬ç”±DBAæ‹…ä»»ã€‚éœ€è¦åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œé€‰å–é€‚å½“çš„å­˜å‚¨ç»“æ„ã€‚\nåº”ç”¨ç¨‹åºå¼€å‘äººå‘˜ï¼šå¼€å‘ç¨‹åºæ¥å®ç°å¯¹æ•°æ®åº“åº”ç”¨ç¨‹åºçš„å„åŠŸèƒ½æ¨¡å—\nç»ˆç«¯ç”¨æˆ·ï¼šåˆ©ç”¨åº”ç”¨ç¨‹åºè®¿é—®ã€æ“ä½œæ•°æ®åº“ï¼Œæ˜¯æ•°æ®åº“çš„ä¸»è¦é¢å‘å¯¹è±¡\n\n\nä¸‰çº§æ¨¡å¼ç»“æ„ï¼šä¸åŒå±‚æ¬¡çº§åˆ«çš„ç”¨æˆ·çœ‹åˆ°çš„æ•°æ®è§†å›¾æ˜¯ä¸åŒçš„\n\nï¼ˆé€»è¾‘ï¼‰æ¨¡å¼ï¼šå”¯ä¸€ã€‚æ•°æ®åœ¨é€»è¾‘ä¸Šçš„è§†å›¾ï¼Œæ˜¯æ•°æ®åº“ä¸­å…¨ä½“æ•°æ®çš„é€»è¾‘ç»“æ„å’Œç‰¹å¾çš„æè¿°ï¼Œæ˜¯æ‰€æœ‰ç”¨æˆ·çš„å…¬å…±æ•°æ®è§†å›¾ã€‚\nå¤–æ¨¡å¼ï¼šä¸å”¯ä¸€ã€‚å‘ˆç°ç»™ç»ˆç«¯ç”¨æˆ·çš„è§†å›¾ï¼Œå¤–æ¨¡å¼æ ¹æ®ç»ˆç«¯ç”¨æˆ·çš„éœ€æ±‚å‘ˆç°ç‰¹å®šéƒ¨åˆ†çš„æ•°æ®åº“ã€‚ä¸€ä¸ªå¤–æ¨¡å¼å¯ä»¥è¢«å¤šä¸ªåº”ç”¨ç¨‹åºåº”ç”¨ï¼Œä¸€ä¸ªåº”ç”¨ç¨‹åºåªèƒ½åº”ç”¨ä¸€ä¸ªå¤–æ¨¡å¼ã€‚å¤–æ¨¡å¼æ˜¯æ¨¡å¼çš„å­é›†ã€‚\nå†…æ¨¡å¼ï¼šå”¯ä¸€ã€‚å®šä¹‰äº†æ•°æ®åº“å­˜å–çš„ç‰©ç†ç»“æ„ï¼Œä¸è½¯ä»¶å’Œç¡¬ä»¶ç¯å¢ƒæœ‰å…³ã€‚\n\n\näºŒçº§æ˜ åƒï¼šå½“å…¶ä¸­ä¸€æ¨¡å¼æ”¹å˜æ—¶åªéœ€ä¿®æ”¹ç›¸åº”çš„æ˜ åƒå³å¯ä½¿å¦ä¸€æ¨¡å¼ä¸å‘ç”Ÿå˜åŒ–\n\nå¤–æ¨¡å¼/æ¨¡å¼æ˜ åƒï¼šé€»è¾‘ç‹¬ç«‹æ€§ï¼Œæ¨¡å¼å‘ç”Ÿæ”¹å˜æ—¶æ— éœ€æ”¹å˜å¤–æ¨¡å¼ä¸åº”ç”¨ç¨‹åºã€‚\næ¨¡å¼/å†…æ¨¡å¼æ˜ åƒï¼šç‰©ç†ç‹¬ç«‹æ€§ï¼Œå†…æ¨¡å¼æ”¹å˜æ—¶æ— éœ€æ”¹å˜æ¨¡å¼ã€‚\n\n\nåº”ç”¨ç¨‹åºè¯»å–æ•°æ®çš„è¿‡ç¨‹\n\nç»ˆç«¯ç”¨æˆ·é€šè¿‡åº”ç”¨ç¨‹åºæŒ‡å®šå¤–æ¨¡å¼åå‘å‡ºå‘½ä»¤\nDBMSè°ƒå–ç›¸åº”çš„å¤–æ¨¡å¼ï¼ŒåŒæ—¶æ£€æŸ¥ç”¨æˆ·çš„æƒé™ï¼Œåªæœ‰é€šè¿‡æ£€æŸ¥å¯ä»¥ç»§ç»­\nDBMSæ ¹æ®å¤–æ¨¡å¼ /æ¨¡å¼æ˜ åƒå¾—åˆ°ç›¸åº”æ•°æ®åœ¨æ¨¡å¼ä¸Šçš„ä¿¡æ¯\nDBMSæ ¹æ®æ¨¡å¼ /å†…æ¨¡å¼æ˜ åƒå¾—åˆ°ç›¸åº”æ•°æ®åœ¨å†…æ¨¡å¼ä¸Šçš„ä¿¡æ¯\nDBMSå‘æ“ä½œç³»ç»Ÿå‘å‡ºè¯»å–è¯¥æ•°æ®çš„è¯·æ±‚\næ“ä½œç³»ç»Ÿå°†è¯¥æ•°æ®ä»å¤–å­˜ä¸­è°ƒå…¥ç³»ç»Ÿç¼“å­˜åŒºä¸­\nDBMSå°†æ•°æ®æŒ‰ç…§å¤–æ¨¡å¼çš„å½¢å¼é€è‡³ç”¨æˆ·å·¥ä½œåŒº\nè®°è½½ç³»ç»Ÿå·¥ä½œæ—¥å¿—\n\n\n\n","slug":"æ•°æ®åº“ç³»ç»Ÿæ¦‚è®º","date":"2022-03-06T05:11:11.000Z","categories_index":"æ•°æ®åº“åŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"916fffb6f0cf37494d0f7af19c9c80e4","title":"ã€ŒSection 3ã€è¡¥ç åŠ å‡è¿ç®—æ–¹æ³•","content":"ç›®å‰è®¡ç®—æœºä¸­çš„æ•°æ®æ™®éæ˜¯ç”¨è¡¥ç å­˜å‚¨çš„ï¼Œå› ä¸ºè¡¥ç å…·æœ‰ç®€å•çš„åŠ å‡æ³•è§„åˆ™ï¼Œè¿ç®—ç®€å•ï¼Œæ˜“äºå®ç°ï¼Œè€Œä¸”ç¬¦å·ä½å¯ä»¥å’Œæ•°å€¼ä½ä¸€èµ·å‚ä¸è¿ç®—ã€‚\nÎ±. è¡¥ç è§„åˆ™è¿ç®—\nÎ². æº¢å‡ºæ£€æµ‹\nÎ³. æœºå™¨æ•°çš„ç§»ä½è¿ç®—\n\n\n\nÎ± è¡¥ç è¿ç®—è§„åˆ™è¡¥ç çš„åŠ å‡æ³•è¿ç®—å…¬å¼ä¸ºè¡¥è¡¥è¡¥\nè¡¥è¡¥è¡¥\nåœ¨ã€ŒSection 1ã€æ•°æ®æ ¼å¼ä¸­æˆ‘ä»¬æœ‰æè¿‡è¡¥ç çš„å‡æ³•æ˜¯ç”¨åŠ æ³•æ¥å®ç°çš„ï¼Œè¿™é‡Œå…¶å®å°±æ˜¯è¢«å‡æ•°çš„è¡¥ç +å‡æ•°ç›¸åæ•°çš„è¡¥ç ï¼Œè€Œä¸€ä¸ªæ­£æ•°ç›¸åæ•°çš„è¡¥ç æ˜¾ç„¶ä¸ºå…¶å„ä½ï¼ˆåŒ…æ‹¬ç¬¦å·ä½ï¼‰å–å+1ã€‚\né‚£ä¹ˆä¸Šè¿°çš„å…¬å¼åˆå¦‚ä½•è¢«è¯æ˜å‘¢ï¼Ÿè¿™é‡Œéœ€è¦ç”¨æ•°è®ºä¸­æ¨¡ï¼ˆmodï¼‰çš„æ¦‚å¿µã€‚æˆ‘ä»¬çŸ¥é“æ­£æ•°çš„è¡¥ç å³ä¸ºåŸç ï¼Œè€Œè´Ÿæ•°çš„è¡¥ç åˆ™æ˜¯å„ä½å–å+1ï¼Œè¿™ä¸¤ç§æƒ…å†µæ˜¯åˆ†å¼€çš„ï¼Œé‚£æ˜¯å¦æœ‰ä¸€ç§æ–¹å¼èƒ½å°†ä¸¤è€…å¤§ä¸€ç»Ÿå‘¢ï¼Ÿäº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºä¸€ä¸ªæ•°çš„è¡¥ç ï¼ˆç®—ä¸Šç¬¦å·ä½æ˜¯ä½çš„è¡¥ç ï¼‰æ˜¯è¯¥æ•°æ¨¡çš„ç»“æœï¼šè¡¥è¿™é‡Œçš„modæ˜¯å–ä½™çš„æ„æ€ã€‚æˆ‘ä»¬è§„å®šä½™æ•°å¿…é¡»ä¸ºæ­£ï¼Œé‚£ä¹ˆä¸€ä¸ªè´Ÿæ•°æ¨¡çš„ä½™æ•°å³ä¸ºï¼Œå°±ä¼šå‘ç°è¡¥ç çš„å®šä¹‰ç¡®å®å¦‚æ­¤ã€‚\né‚£ä¹ˆï¼Œè¡¥è¡¥è¡¥\næ ¹æ®ä¸Šå¼ï¼Œç¬¬äºŒä¸ªç­‰å¼ç”± è¡¥è¡¥ åˆ™æ˜¾ç„¶æˆç«‹ã€‚\n\nÎ² æº¢å‡ºæ£€æµ‹æˆ‘ä»¬å¾ˆé«˜å…´åœ°å‘ç°äº†è¡¥ç è¿ç®—çš„ç®€ä¾¿ï¼Œä½†ç®—ç€ç®—ç€å°±ä¼šå‘ç°ä¸€äº›ç¥å¥‡çš„æƒ…å†µï¼Œæ¯”å¦‚è¯´æ€ä¹ˆè¯´å‘¢ï¼Œå°±æ˜¯ä¸¤ä¸ªè´Ÿæ•°åŠ èµ·æ¥å˜æ­£äº†ã€‚æƒ³å¿…ï¼Œè¿™å°±æ˜¯ç‰©æå¿…åå§ï¼ˆbushi\nè¿™ä¸ªå¼å­çš„çœŸé¢ç›®åº”è¯¥æ˜¯ç„¶è€Œæœºå™¨æ•°çš„ä½æ•°æ˜¯æœ‰é™åˆ¶çš„ï¼Œè®¡ç®—æœºéš¾ä»¥å®¹å¿å¤šå‡ºçš„ä¸€ä½ï¼Œå› æ­¤ç›´æ¥å°†æœ€é«˜ä½æ‰”æ‰äº†ï¼Œåªæ˜¯ä»–ä¸çŸ¥é“æœ€é«˜ä½æœ‰ç€ç‰¹æ®Šå«ä¹‰ã€‚è¿™ç§ç°è±¡æˆ‘ä»¬ç§°ä¹‹ä¸ºæº¢å‡ºï¼ˆä¸€èˆ¬æŒ‡ä¸Šæº¢å‡ºï¼‰ã€‚\næº¢å‡ºåœ¨æ‰€éš¾å…ï¼Œå› æ­¤è®¡ç®—æœºå¿…é¡»è§£å†³æº¢å‡ºçš„é—®é¢˜ï¼Œéœ€è¦æ£€æµ‹å¹¶æŒ‡ç¤ºã€‚\n\n\nâ„ï¸ å•ç¬¦å·ä½åˆ¤æº¢æ–¹æ³•æˆ‘ä»¬æ¸…æ¥šäº‹å®ä¸Šåªæœ‰å½“ç»å¯¹å€¼å˜å¤§ï¼Œå³åŒå·ç›¸åŠ ã€å¼‚å·ç›¸å‡ï¼ˆä¸¤è€…æœ¬è´¨ç›¸åŒï¼‰çš„æƒ…å†µæ‰ä¼šå‘ç”Ÿæº¢å‡ºï¼Œæˆ‘ä»¬è®¾ä¸ºæº¢å‡ºç¬¦å·ä½ï¼Œä¸ºä¸¤ä¸ªè¿ç®—æ•°çš„æœ€é«˜ç¬¦å·ä½ï¼Œä¸ºè¿ç®—ç»“æœç¬¦å·ä½ï¼Œè€Œåˆ™è¡¨ç¤ºè¿ç®—ç¬¦ï¼Œ0ä¸º+ï¼Œ1ä¸º-ï¼Œé‚£ä¹ˆæœ‰\nâ„ï¸ è¿›ä½åˆ¤æº¢æ–¹æ³•è®¾ä¸ºä¸¤æ•°ç¬¦å·ä½ç›¸åŠ çš„è¿›ä½ä¿¡å·ï¼Œåˆ™æ˜¯ä¸¤æ•°æœ€é«˜æœ‰æ•ˆä½çš„è¿›ä½ä¿¡å·ã€‚ç”±äºè¡¥ç å¯ä»¥å°†å‡æ³•è½¬æ¢ä¸ºåŠ æ³•ï¼Œè€Œä¸”åªæœ‰åŒå·ç›¸åŠ æ—¶ä¼šå‘ç”Ÿæº¢å‡ºï¼Œå› æ­¤è¿™é‡Œåªè€ƒè™‘åŒå·åŠ æ³•ã€‚ç¬¦å·ä½åœ¨ä¸å—åˆ°å½±å“ä¹‹å‰ä¸º0ï¼Œé‚£ä¹ˆè€ƒè™‘åæœ‰ã€‚è€Œçš„å€¼åˆ™ä»£è¡¨äº†ä¸¤æ•°çš„ç¬¦å·ï¼Œ0æ­£1è´Ÿã€‚æˆ‘ä»¬æ¸…æ¥šè¿ç®—ç»“æœçš„ç¬¦å·ä½è‹¥ä¸ä¸¤æ•°ç¬¦å·ä½ä¸åŒåˆ™è¡¨æ˜æº¢å‡ºï¼Œå³ä¸ä¸åŒã€‚ç”±äºå¼‚å·ç›¸åŠ ï¼ˆä¸ä¼šå‘ç”Ÿæº¢å‡ºï¼‰æ—¶ä¹Ÿæœ‰ï¼Œå› æ­¤å¯ä»¥å°†çš„è¡¨è¾¾å¼ç›´æ¥å†™ä¸º\nâ„ï¸ åŒç¬¦å·ä½åˆ¤æº¢æ–¹æ³•è¿ç®—æ•°é‡‡ç”¨åŒç¬¦å·ä½è¡¥ç ï¼ˆå˜å½¢è¡¥ç ï¼‰è¿›è¡Œè¿ç®—ï¼Œæ­£æ•°çš„ç¬¦å·ä½å˜ä¸º00ï¼Œè´Ÿæ•°çš„ç¬¦å·ä½å˜ä¸º11ï¼Œå…¶ä½™ä½ä¸å˜ã€‚å½“è¿ç®—ç»“æœçš„ç¬¦å·ä½çš„ä¸¤ä½ä¸åŒæ—¶è¡¨æ˜å‘ç”Ÿæº¢å‡º ã€‚æ­£æº¢å‡ºï¼›è´Ÿæº¢å‡ºå…¶å®è¿™æ˜¯ä¸€ç§å¯¹è¿›ä½åˆ¤æº¢æ–¹æ³•çš„åº”ç”¨ï¼Œè®¾ä¸¤ä¸ªè¿ç®—æ•°çš„ç¬¦å·ä½åˆ†åˆ«ä¸ºï¼Œè¿ç®—ç»“æœçš„ç¬¦å·ä½ä¸ºï¼Œé‚£ä¹ˆæœ‰å½“ä¸ä¸åŒæ—¶ä¸ä¹Ÿä¸åŒã€‚è€ŒåŒå·è¿ç®—æ—¶æ˜¾ç„¶ï¼Œé‚£ä¹ˆæ—¶è¯´æ˜ä¸¤æ­£æ•°ç›¸åŠ ç»“æœä¸ºè´Ÿï¼Œä¸ºæ­£æº¢å‡ºï¼›æ—¶è¯´æ˜ä¸¤è´Ÿæ•°ç›¸åŠ ç»“æœä¸ºæ­£ï¼Œä¸ºè´Ÿæº¢å‡ºã€‚\nâš ï¸ç¬¬ä¸€ä½æ˜¯æ­£ç¡®çš„ç¬¦å·ä½ï¼Œç¬¬äºŒä½æ˜¯ä¿ç•™æº¢å‡ºä½ã€‚\n\nÎ³ æœºå™¨æ•°çš„ç§»ä½è¿ç®—\né€»è¾‘ç§»ä½ï¼šç›´æ¥å·¦å³è¡¥0ã€‚å°†ç§»ä½çš„æ•°æ®è§†ä¸ºæ— ç¬¦å·æ•°æ®ï¼Œå„æ•°æ®ä½åœ¨ä½ç½®ä¸Šå‘ç”Ÿäº†å˜åŒ–ï¼Œå¯¼è‡´æ— ç¬¦å·æ•°æ®çš„æ•°å€¼ï¼ˆæ— æ­£è´Ÿï¼‰æ”¾å¤§æˆ–ç¼©å°ã€‚(x86:SHL,SHR;RISC-V:sll,srl)\nç®—æœ¯ç§»ä½ï¼šå°†ç§»ä½çš„æ•°æ®è§†ä¸ºå¸¦ç¬¦å·æœºå™¨æ•°ã€‚ç®—æœ¯ç§»ä½çš„ç»“æœï¼Œåœ¨æ•°å€¼çš„ç»å¯¹å€¼ä¸Šè¿›è¡Œæ”¾å¤§æˆ–ç¼©å°ï¼ŒåŒæ—¶ï¼Œç¬¦å·ä½å¿…é¡»è¦ä¿æŒä¸å˜ã€‚(x86:SAL,SAR;RISC-V:sll,sra)\nè¡¥ç çš„ç®—æ•°å³ç§»ï¼šé«˜ä½è¡¥ç¬¦å·ä½\nè¡¥ç çš„ç®—æœ¯å·¦ç§»ï¼šæ•°æ®æœ€é«˜æœ‰æ•ˆä½å¿…é¡»ä¸ç¬¦å·ä½ç›¸åŒæ‰èƒ½ä¿è¯ä¸ä¼šæº¢å‡ºï¼Œæ­¤æ—¶å¯ä»¥ç›´æ¥å°†æœ€é«˜æœ‰æ•ˆä½ç§»å…¥ç¬¦å·ä½å¹¶åœ¨å·¦è¾¹è¡¥0\n\n\nå¾ªç¯ç§»ä½ï¼šæ‰€æœ‰çš„æ•°æ®ä½åœ¨è‡ªèº«èŒƒå›´å†…è¿›è¡Œå·¦ç§»æˆ–è€…å³ç§»ï¼Œå·¦ç§»æ—¶æœ€é«˜ä½ç§»å…¥æœ€ä½ä½ï¼Œå³ç§»æ—¶æœ€ä½ä½ç§»å…¥æœ€é«˜ä½ã€‚(x86:ROL,ROR,RCL,RCR)\n\n","slug":"è¡¥ç åŠ å‡è¿ç®—æ–¹æ³•","date":"2022-03-04T09:46:00.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"481cf8b49191f67983b97c3d9fc63cfa","title":"OpenGLè½è„šCLion","content":"æœ¬ç¯‡æ–‡ç« å°†é˜è¿°åœ¨Mac os Monterey(12.2.1)çš„CLion(2021.3.3)ä¸Šé…ç½®OpenGLçš„æ•´ä½“è¿‡ç¨‹ã€‚è™½ç„¶ç½‘ä¸Šå·²æœ‰ç›¸å…³çš„æ–‡ç« ï¼Œä½†æœ‰å¾ˆå¤šæ“ä½œå­˜åœ¨é—®é¢˜ï¼Œå¯èƒ½æ˜¯Macç³»ç»Ÿå˜è¿çš„åŸå› ï¼Œæ•…ä½œæ­¤æ–‡ã€‚\nåŸå‚è€ƒæ–‡ç« ï¼šMac Clion OpenGLå¼€å‘ç¯å¢ƒé…ç½®\n\n\n\n\næ‰“å¼€ terminalï¼Œç”¨homebrewï¼ˆé»˜è®¤å·²æœ‰ï¼‰å®‰è£…ä¾èµ–é¡¹\nbrew install glew\nbrew install glfw3\n\nå¯ä»¥é€šè¿‡ä¸‹è¿°å‘½ä»¤æ¥æŸ¥çœ‹ä¸Šè¿°ä¸¤ä¸ªä¾èµ–é¡¹çš„å®‰è£…ä½ç½®\nbrew list glew\nbrew list glfw\n\né…ç½®Gladï¼Œé€šé“åœ¨æ­¤\nâ‘ \n\n\nâ‘¡\n\n\nâ‘¢å°†glad.zipè¿›è¡Œè§£å‹åé‡Œé¢å°±æ˜¯ä¸Šå›¾ä¸­çš„includeå’Œsrcï¼Œå°†include/gladæ–‡ä»¶å¤¹ä¸‹çš„glad.hä¸­çš„#include &lt;KHR/khrplatform.h&gt;æ›´æ”¹ä¸º#include &lt;khrplatform.h&gt;\n\n\nâ‘£å°†includeé‡Œé¢çš„ä¸¤ä¸ªæ–‡ä»¶å¤¹gladä¸KHRæ‹–å…¥ /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/includeï¼ˆè¿™ä¸å‚è€ƒæ–‡ç« é‡Œçš„åœ°å€ä¸åŒï¼Œé‚£ç¯‡æ–‡ç« ä¸­çš„æ–‡ä»¶å¤¹æ˜¯çœŸçš„æ²¡æ‰¾åˆ°åœ¨å“ªï¼‰ï¼Œè€Œsrcæ–‡ä»¶å¤¹åˆ™ç›´æ¥æ‹–å…¥CLionä¸­çš„é¡¹ç›®æ–‡ä»¶å¤¹ï¼ˆè¿™ä¸ªé¡¹ç›®é…ç½®ä¸æ™®é€šC++é¡¹ç›®é…ç½®ç›¸åŒï¼‰\n\n\næ¥ä¸‹æ¥é…ç½®CLioné¡¹ç›®æ–‡ä»¶ä¸­çš„CMakeLists.txtæ–‡ä»¶\ncmake_minimum_required(VERSION 3.21)\nproject(OpenGLab)\n\nset(CMAKE_CXX_STANDARD 23)\n\n###############ä¸Šé¢éƒ¨åˆ†ä¸ç”¨æ”¹ï¼ŒæŒ‰è‡ªå·±åŸæ¥çš„å³å¯###############\n#è®¾ç½®ä¸€äº›OpenGLå¤´æ–‡ä»¶æ‰€åœ¨ç›®å½•çš„å®\nset(GLEW_H /opt/homebrew/Cellar/glew/2.2.0_1/include/GL)\nset(GLFW_H /opt/homebrew/Cellar/glfw/3.3.6/include/GLFW)\n#è®¾ç½®OpenGLåº“æ‰€åœ¨ä½ç½®ï¼Œå¹¶é“¾æ¥\nset(GLEW_LINK /opt/homebrew/Cellar/glew/2.2.0_1/lib/libGLEW.2.2.0.dylib)\nset(GLFW_LINK /opt/homebrew/Cellar/glfw/3.3.6/lib/libglfw.3.3.dylib)\nlink_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK})\n#########################################################\n\nset(GLAD_H /usr/local/include/)\nset(GLAD_H /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/glad)\nset(KH_H /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/KHR)\n#åŒ…å«ä¸Šè¿°å¤´æ–‡ä»¶æ‰€åœ¨ç›®å½•\ninclude_directories(${GLEW_H} ${GLFW_H} ${GLAD_H} ${KH_H})\n\n#è®¾ç½®è¦ç¼–è¯‘çš„c/cppæ–‡ä»¶åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œè¯¥exeåŒ…å«ä¸¤ä¸ªæ–‡ä»¶glad.c,main.cpp,ç”ŸæˆOpenGLab\nset(SOURCE_FILES \"src/glad.c\" \"main.cpp\")\nadd_executable(OpenGLab ${SOURCE_FILES})\n\n# macä¸‹è¿™æ­¥å¾ˆé‡è¦\nif (APPLE)\n    target_link_libraries(OpenGLab \"-framework OpenGL\")\n    target_link_libraries(OpenGLab \"-framework GLUT\")\nendif()\n\nâš ï¸å°†ä»£ç ä¸­æˆ‘çš„é¡¹ç›®åç§°OpenGLabæ¢æˆä½ è‡ªå·±çš„é¡¹ç›®åï¼Œå¦å¤–#ä¹‹é—´ä»£ç ä¸­çš„è·¯å¾„å¯èƒ½éœ€è¦ä¿®æ”¹ï¼Œè¯·å‚è€ƒç¬¬ä¸€æ­¥ä¸­brew listçš„ç»“æœï¼ˆä¸»è¦æ˜¯ç‰ˆæœ¬å·å¯èƒ½ä¸åŒçš„é—®é¢˜ï¼Œæˆ‘è¿™é‡Œglewæ˜¯2.2.0_1ï¼Œglfwæ˜¯3.3.6ï¼‰\n\n\næµ‹è¯•ä»£ç â€”â€”from å‚è€ƒæ–‡ç« \n#include &lt;glew.h&gt;\n#include &lt;glfw3.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nvoid key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)\n{\n    //å¦‚æœæŒ‰ä¸‹ESCï¼ŒæŠŠwindowShouldCloseè®¾ç½®ä¸ºTrueï¼Œå¤–é¢çš„å¾ªç¯ä¼šå…³é—­åº”ç”¨\n    if(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)\n        glfwSetWindowShouldClose(window, GL_TRUE);\n    std::cout&lt;&lt;\"ESC\"&lt;&lt;mode;\n}\n\nint main(void)\n{\n    //åˆå§‹åŒ–GLFWåº“\n    if(!glfwInit())\n        return -1;\n    //åˆ›å»ºçª—å£ä»¥åŠä¸Šä¸‹æ–‡\n    GLFWwindow* window = glfwCreateWindow(640, 480, \"hello world\", NULL, NULL);\n    if(!window)\n    {\n        //åˆ›å»ºå¤±è´¥ä¼šè¿”å›NULL\n        glfwTerminate();\n    }\n    //å»ºç«‹å½“å‰çª—å£çš„ä¸Šä¸‹æ–‡\n    glfwMakeContextCurrent(window);\n\n    glfwSetKeyCallback(window, key_callback); //æ³¨å†Œå›è°ƒå‡½æ•°\n    //å¾ªç¯ï¼Œç›´åˆ°ç”¨æˆ·å…³é—­çª—å£\n    while(!glfwWindowShouldClose(window))\n    {\n        /*******è½®è¯¢äº‹ä»¶*******/\n        glfwPollEvents();\n\n        /*******æ¸²æŸ“*******/\n        //é€‰æ‹©æ¸…ç©ºçš„é¢œè‰²RGBA\n        glClearColor(0.2, 0.3, 0.3, 1);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        //å¼€å§‹ç”»ä¸€ä¸ªä¸‰è§’å½¢\n        glBegin(GL_TRIANGLES);\n        glColor3f(1, 0, 0); //Red\n        glVertex3f(0, 1, 1);\n\n        glColor3f(0, 1, 0); //Green\n        glVertex3f(-1, -1, 0);\n\n        glColor3f(0, 0, 1); //Blue\n        glVertex3f(1, -1, 0);\n        //ç»“æŸä¸€ä¸ªç”»å›¾æ­¥éª¤\n        glEnd();\n\n        /******äº¤æ¢ç¼“å†²åŒºï¼Œæ›´æ–°windowä¸Šçš„å†…å®¹******/\n        glfwSwapBuffers(window);\n    }\n    glfwTerminate();\n    return 0;\n}\n\n\n\n","slug":"OpenGLè½è„šCLion","date":"2022-03-03T11:45:51.000Z","categories_index":"è¡€æ³ªå²","tags_index":"OpenGL","author_index":"Starlit Rover"},{"id":"e26b5ce0cae66dfe27a555c57255d754","title":"ã€Œ1012ã€The Best Rank","content":"â³ENTRY\nTo evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks â€“ that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student.\nFor example, The grades of C, M, E and A - Average of 4 students are given as the following:\nStudentID  C  M  E  A\n310101     98 85 88 90\n310102     70 95 88 84\n310103     82 87 94 88\n310104     91 91 91 91\n\nThen the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average.\n\n\nInput Specification:Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (â‰¤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID.\nOutput Specification:For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space.\nThe priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority.\nIf a student is not on the grading list, simply output N/A.\nSample Input:5 6\n310101 98 85 88\n310102 70 95 88\n310103 82 87 94\n310104 91 91 91\n310105 85 90 90\n310101\n310102\n310103\n310104\n310105\n999999\n\nSample Output:1 C\n1 M\n1 E\n1 A\n3 A\nN/A\n\n\nÎ©æœ‰ç‚¹ç±»ä¼¼é‚£é“å¥¥è¿æ’è¡Œæ¦œã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œå¥¥è¿å¥–ç‰Œæ¦œæœ‰é‡‘ç‰Œæ¦œã€æ€»ç‰Œæ¦œï¼Œç”šè‡³è¿˜æœ‰äººå‡å¥–ç‰Œæ¦œï¼Œä»¥ç¯å¡”å›½ä¸ºé¦–çš„è®¸å¤šå›½å®¶éƒ½ä¼šé€‰æ‹©è‡ªå·±å›½å®¶æ’åé å‰çš„æ¦œå•å‘å¸ƒã€‚è¿™é“é¢˜åˆ™æ¢æˆäº†å­¦ç”Ÿï¼Œä¸€ä¸ªå­¦ç”Ÿæœ‰ä¸‰é—¨è¯¾çš„æˆç»©ï¼Œç®—ä¸Šå¹³å‡åˆ†å°±ä¼šæœ‰å››ä¸ªæ’åã€‚ä¸ºäº†è®©æ¯ä½åŒå­¦èƒ½å¼€å¼€å¿ƒå¿ƒåœ°å›å®¶å—¨çš®ï¼Œå¹¶å…å—éº»éº»çš„å¨å¨ï¼Œå­¦æ ¡å†³å®šå¯¹æ¯ä½æ¥æŸ¥åˆ†æ•°çš„åŒå­¦éƒ½åªå‘Šè¯‰ä»–æœ€é«˜çš„æ’åä»¥åŠç›¸å¯¹åº”çš„ç§‘ç›®ï¼ˆå³æ’åæ–¹å¼ï¼‰ã€‚çœŸæ˜¯ä¸ªå¥½å­¦æ ¡å•Šï½\n\n\né‚£å°±å…ˆæ¥ä¸ªç»“æ„ä½“ï¼Œç”¨æ¥å­˜å‚¨ä¸€ä½å­¦ç”Ÿçš„å­¦å·ä»¥åŠå„ç§‘åˆ†æ•°\nclass info\n{\npublic:\n    string num;\n    int score[4];\n};\n\nå¤§ä½“æ€è·¯å‘¢ï¼Œç”¨ä¸€ä¸ªmapå»ºç«‹å­¦å·åˆ°æœ€é«˜æ’åä»¥åŠæ’åæ–¹å¼çš„ç´¢å¼•ï¼Œç„¶åæŒ‰ç…§ä¼˜å…ˆçº§çš„é¡ºåºå¯¹å››ä¸ªåˆ†æ•°ä¾æ¬¡è¿›è¡Œsortï¼Œå¦‚æœå½“å‰sortçš„ç»“æœæ¯”mapä¸­å­˜å‚¨çš„æœ€é«˜æ’åè¦å°çš„è¯å°±æ›¿æ¢ï¼ŒåŒæ—¶æ›´æ–°æ’åæ–¹å¼ã€‚\nmap&lt;string, pair&lt;int, char&gt;&gt; outcome;\n//map&lt;num,pair&lt;best rank,ranking method&gt; &gt;\n\nè¿™é‡Œéœ€è¦ç‰¹åˆ«æ³¨æ„æ’åçš„è§„åˆ™ï¼š\n\nç›¸åŒåˆ†æ•°çš„äººåæ¬¡ç›¸åŒ\nå½“å‰é¢ä¸ªäººçš„åˆ†æ•°ä¸åæ¬¡ç›¸åŒï¼ˆå‡ä¸ºï¼‰æ—¶ï¼Œåä¸€ä¸ªäººï¼ˆå…¶åˆ†æ•°æ¯”å‰é¢ä¸ªäººçš„åˆ†æ•°å°ï¼‰çš„åæ¬¡ä¸æ˜¯è€Œæ˜¯ï¼Œå…¶ä¸­æ˜¯æ¯”è¯¥äººåˆ†æ•°å¤§çš„äººæ•°\n\nå…¶å®è¿™äº›è§„åˆ™æˆ‘ä»¬éƒ½æ˜¯çŸ¥é“çš„ï¼Œä½†codingçš„æ—¶å€™æ€»ä¼šåˆ›é€ å‡ºä¸€ä¸ªæ–°çš„æ’åè§„åˆ™â€¦â€¦å› æ­¤æ’åæ—¶åªè¦å’Œå‰ä¸€ä¸ªäººçš„åˆ†æ•°è¿›è¡Œæ¯”è¾ƒå³å¯ï¼Œå¦‚æœç›¸åŒåˆ™åæ¬¡ä¸å˜ï¼Œä¸åŒæ—¶åˆ™å–å…¶æ’åºåºå·+1ã€‚\nr = (rank[i].score[idx] == pre ? r : i + 1);\n\nå¯¹äº†ï¼Œå¹³å‡åˆ†æ˜¯ä¸€ä¸ªå››èˆäº”å…¥çš„æ•´æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥+0.5\nscore[0] = (c + m + e) / 3.0 + 0.5\n\nc,m,eéƒ½æ˜¯æ•´å‹ï¼Œ/3.0åå˜ä¸ºdoubleï¼Œ+0.5åå†ï¼ˆè‡ªåŠ¨ï¼‰å¼ºåˆ¶ç±»å‹è½¬æ¢æˆintèµ‹å€¼ç»™score[0]å®Œæˆå››èˆäº”å…¥ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n//global: make sure lambda expression in sort can know \"idx\"\nint idx;\n\nclass info\n{\npublic:\n    string num;\n    int score[4];\n    //constructor\n    info(string n, int c, int m, int e) : num(move(n)), score{score[0] = (c + m + e) / 3.0 + 0.5, c, m, e} {}\n};\n\nint main()\n{\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    string num;\n    int c, m, e;\n  //used for sorting\n    vector&lt;info&gt; rank;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; num &gt;&gt; c &gt;&gt; m &gt;&gt; e;\n        rank.emplace_back(num, c, m, e);\n    }\n\n    map&lt;string, pair&lt;int, char&gt;&gt; outcome;\n  //initialize\n    for (auto &amp;s: rank)\n        outcome[s.num] = move(pair(n + 1, '-'));\n\n    char method[4] = {'A', 'C', 'M', 'E'};\n\n    for (idx = 0; idx &lt; 4; ++idx)\n    {\n        sort(rank.begin(), rank.end(), [](info &amp;a, info &amp;b) { return a.score[idx] &gt; b.score[idx]; });\n        int r = 1, pre = -1;\n        for (int i = 0; i &lt; n; ++i)\n        {\n            r = (rank[i].score[idx] == pre ? r : i + 1);\n            pre = rank[i].score[idx];\n            if (r &lt; outcome[rank[i].num].first)\n                outcome[rank[i].num] = move(pair(r, method[idx]));\n        }\n    }\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; num;\n        if (outcome.find(num) == outcome.end())\n            cout &lt;&lt; \"N/A\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; outcome[num].first &lt;&lt; \" \" &lt;&lt; outcome[num].second &lt;&lt; endl;\n    }\n}\n","slug":"1012-The-Best-Rank","date":"2022-03-03T07:03:15.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map,sort","author_index":"Starlit Rover"},{"id":"2aa32c1dad7cbbce692f6b1b0a062627","title":"ã€ŒSection 2ã€æµ®ç‚¹æ•°è¡¨ç¤º","content":"\næµ®ç‚¹æ•°ï¼šé¡¾åæ€ä¹‰ï¼Œå°æ•°ç‚¹çš„ä½ç½®å¯ä»¥æµ®åŠ¨ï¼Œé‡‡ç”¨äº†ç§‘å­¦è®°æ•°æ³•çš„æ€æƒ³\n\nä»»æ„ä¸€ä¸ªäºŒè¿›åˆ¶æ•°éƒ½å¯ä»¥ç”¨é˜¶ç ã€å°¾æ•°å”¯ä¸€åœ°è¡¨ç¤ºä¸ºâš ï¸æ­£å¸¸æƒ…å†µä¸‹çš„å°¾æ•°åŒ…æ‹¬ç¬¦å·ä½\n\né˜¶ç å†³å®šäº†æ•°æ®çš„è¡¨ç¤ºèŒƒå›´ï¼Œå°¾æ•°å†³å®šäº†æ•°æ®çš„è¡¨ç¤ºç²¾åº¦\n\né˜¶ç ä¸å°¾æ•°å¯ä»¥é‡‡ç”¨ä¸åŒçš„æœºå™¨ç è¿›è¡Œè¡¨ç¤º\n\n\nå½“æµ®ç‚¹æ•°çš„ç»å¯¹å€¼è¶…è¿‡æœ€å¤§æ­£æ•°æ—¶å‘ç”Ÿä¸Šæº¢ï¼Œå°äºæœ€å°æ­£æ•°æ—¶å‘ç”Ÿä¸‹æº¢\n\n\nâš ï¸æ­£æº¢å‡º/è´Ÿæº¢å‡ºæŒ‡ä¸¤æ­£æ•°/ä¸¤è´Ÿæ•°ç›¸åŠ æ—¶è¶…å‡ºæœ€å¤§å€¼/æœ€å°å€¼ï¼Œå‡å±äºä¸Šæº¢å‡ºçš„ç‰¹ä¾‹ã€‚\n\næœºå™¨æ•°0ï¼šæœ‰ä¸¤ç§æƒ…å†µ\n\nè‹¥æµ®ç‚¹æ•°çš„å°¾æ•°ä¸ºé›¶ï¼Œæ— è®ºé˜¶ç ä¸ºä½•å€¼ï¼›\nå½“é˜¶ç çš„å€¼é‡åˆ°æ¯”å®ƒèƒ½è¡¨ç¤ºçš„æœ€å°å€¼è¿˜è¦å°æ—¶ï¼ˆé˜¶ç è´Ÿæº¢å‡ºï¼‰ï¼Œæ— è®ºå…¶å°¾æ•°ä¸ºä½•å€¼\n\n\n\n\næµ®ç‚¹æ•°çš„è§„æ ¼åŒ–ï¼šä¸Šæ–‡ä¸­çš„æµ®ç‚¹æ•°è¡¨ç¤ºæ–¹æ³•éšç€é˜¶ç çš„å˜åŒ–ä¼šæœ‰å¤šç§è¡¨ç¤ºæ–¹æ³•ï¼Œç„¶è€Œè®¡ç®—æœºä¸­éœ€è¦å”¯ä¸€æ€§ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¯¹æµ®ç‚¹æ•°çš„å°¾æ•°è¿›è¡Œè§„æ ¼åŒ–å¤„ç†ã€‚\n\nè§„æ ¼åŒ–å¤„ç†ï¼šä½¿å°¾æ•°çš„æœ€é«˜æœ‰æ•ˆä½ï¼ˆâš ï¸å°¾æ•°çš„ç¬¬ä¸€ä½æ˜¯ç¬¦å·ä½ï¼Œå› æ­¤æœ€é«˜æœ‰æ•ˆä½ä¸ºç¬¦å·ä½åä¸€ä½ï¼‰ä¸º1ï¼Œå³ã€‚\n\né‚£ä¹ˆå¯¹äºéè§„æ ¼åŒ–å°¾æ•°çš„å¤„ç†ä¹Ÿéå¸¸çš„æ˜æ˜¾ï¼Œåªéœ€æ”¹å˜é˜¶ç å€¼æ¥ä½¿å¾—å°¾æ•°å·¦ç§»æˆ–å³ç§»\n\nå¦ä¸€ç§è§„æ ¼åŒ–æ•°æ–¹æ³•ï¼Œæ˜¯å°†ç¬¦å·ä½å•ç‹¬å–å‡ºæè‡³æœ€å‰ï¼Œç„¶åéšè—æœ€é«˜æœ‰æ•ˆä½çš„1éšè—ï¼Œé‚£ä¹ˆå°±æœ‰ï¼šè¿™ä¾¿æ˜¯IEEE754æ ‡å‡†æ‰€é‡‡ç”¨çš„è§„æ ¼æ•°ï¼Œä¸¤ç§è§„æ ¼åŒ–æ•°çš„æ–¹æ³•æ²¡æœ‰æœ¬è´¨åŒºåˆ«ï¼Œæ²¡æœ‰ç‰¹æ®Šè¯´æ˜çš„è§„æ ¼åŒ–æ•°éƒ½æ˜¯æŒ‰ç…§ç¬¬ä¸€ç§çš„æ ‡å‡†ã€‚\n\n\n\nIEEE754æµ®ç‚¹æ•°æ ‡å‡†ï¼šåˆ°æ­¤ä¸ºæ­¢ï¼Œå…¶å®è¿˜æ˜¯æ²¡ç»™å‡ºæµ®ç‚¹æ•°å”¯ä¸€çš„æ ‡å‡†ï¼Œæ¯”å¦‚è¯´å°¾æ•°ä¸é˜¶ç çš„æœºå™¨ç å½¢å¼å°±è¿˜æ²¡ç¡®å®šã€‚å› æ­¤åœ¨20ä¸–çºª70å¹´åº•ï¼Œç¾å›½ç”µæ°”åŠç”µå­å·¥ç¨‹å¸ˆåä¼šï¼ˆIEEEï¼‰äº1985å¹´æå‡ºäº†æµ®ç‚¹æ•°æ ‡å‡†IEEE754ï¼Œè¯¥æ ‡å‡†è‡³ä»Šä»è¢«ä¸»æµè®¡ç®—æœºæ‰€é‡‡ç”¨ã€‚\n\nè¯¥æ ‡å‡†ä¸»è¦åŒ…æ‹¬32ä½å•ç²¾åº¦æµ®ç‚¹æ•°floatä¸64ä½åŒç²¾åº¦æµ®ç‚¹æ•°double\n\nè§„å®šæ‰€æœ‰äºŒè¿›åˆ¶æµ®ç‚¹æ•°å‡ç”±ç¬¦å·ä½ã€é˜¶ç ä¸å°¾æ•°ä¸‰éƒ¨åˆ†ç»„æˆï¼Œä¸åŒç²¾åº¦çš„æµ®ç‚¹æ•°å„éƒ¨åˆ†ä½å®½ä¸åŒï¼Œä¸‹å›¾ä¸º16ä½æµ®ç‚¹æ•°å„éƒ¨åˆ†ä½å®½åˆ†å¸ƒ\n\n\né˜¶ç ç”¨ç§»ç è¡¨ç¤ºï¼Œâš ï¸å…¶åç§»é‡ä¸æ˜¯æ­£å¸¸æƒ…å†µä¸‹çš„è€Œæ˜¯ï¼Œä¹‹æ‰€ä»¥ç”¨ç§»ç è¡¨ç¤ºé˜¶ç ï¼Œå…¶ä¸€æ˜¯ä¸éœ€è¦ç¬¦å·ä½ï¼ˆç§»ç å¯ä»¥è®¤ä¸ºå°†æ•´ä½“èŒƒå›´è¿›è¡Œäº†ä¸€ä¸ªå¹³ç§»ï¼‰ï¼›å…¶äºŒå¯ä»¥ç›´æ¥ä½¿ç”¨é˜¶ç æ¯”è¾ƒå¤§å°ï¼›å…¶ä¸‰æ›´æ–¹ä¾¿ç§»ä½è¿›è¡ŒåŠ å‡è¿ç®—ã€‚è€Œå¯¹äºåç§»é‡é‡‡ç”¨è€Œéåˆ™ä¼—è¯´çº·çº­ï¼Œæˆ‘æä¾›ä¸€éƒ¨åˆ†è¾ƒä¸ºåˆç†çš„è§£é‡Šï¼š\n\nåç§»é‡å˜å°ï¼Œè¡¨ç¤ºçš„å®é™…èŒƒå›´å¾€å³å¹³ç§»ï¼Œå³æœ€å¤§å€¼æ›´å¤§ï¼Œæ­£æ•°è¡¨ç¤ºèŒƒå›´ç›´æ¥ç¿»ä¸€å€ï¼Œæ•´ä½“èŒƒå›´å˜å¤§ï¼ˆè´Ÿæ•°èŒƒå›´å˜å°åªä¼šä½¿ç²¾åº¦å˜ä½ï¼‰\nä½¿æ¯ä¸€ä¸ªè§„æ ¼åŒ–æ•°çš„å€’æ•°èƒ½ç”¨å¦ä¸€ä¸ªæµ®ç‚¹æ•°è¡¨ç¤ºï¼šé˜¶ç èŒƒå›´ï¼ˆ00â€¦0ä¸11â€¦1çš„é˜¶ç è¢«ä¿ç•™ç”¨ä½œç‰¹æ®Šæƒ…å†µï¼Œå› æ­¤èŒƒå›´è¾ƒå¾€å¸¸æ›´å°ï¼‰ã€‚åç§»é‡å–æ—¶ï¼Œé˜¶ç ä¸ºçš„æ•°å–å®Œå€’æ•°åé˜¶ç å˜ä¸ºå‘ç”Ÿä¸Šæº¢ï¼ŒæŸå¤±å€¼è¾ƒå¤§ï¼›åç§»é‡å– æ—¶ï¼Œé˜¶ç ä¸ºçš„æ•°å–å®Œå€’æ•°åé˜¶ç å˜ä¸ºå‘ç”Ÿä¸‹æº¢ï¼Œä½†æŸå¤±å€¼æå°ã€‚\n\n\nå°¾æ•°ä¸ºå®šç‚¹å°æ•°ï¼Œå°†å°æ•°ç‚¹å·¦ä¾§çš„1éšè—ï¼Œå®Œæ•´çš„å°¾æ•°å½¢å¼åº”è¯¥ä¸ºï¼Œå®é™…åªä¿å­˜ï¼ŒèŠ‚çœä¸‹æ¥çš„å­˜å‚¨ç©ºé—´ç”¨äºæé«˜ç²¾åº¦ã€‚å¯ä»¥è®¤ä¸ºå°¾æ•°æ˜¯ä»¥åŸç è¡¨ç¤ºã€‚\nâš ï¸å°¾æ•°æœ¬èº«æ˜¯åŒ…æ‹¬ç¬¦å·ä½çš„ï¼Œä½†IEEE754æ ‡å‡†ä¸­å°†å…¶åˆ†å¼€å¹¶ç½®äºå¼€å¤´æ˜¯ç‰¹æ®Šæ“ä½œï¼Œå¦‚æ— ç‰¹åˆ«è¯´æ˜ç¬¦å·ä½ä¸å°¾æ•°æ˜¯è¿åœ¨ä¸€èµ·çš„ä¸€ä¸ªæ•´ä½“ã€‚\n\nç‰¹æ®Šæƒ…å†µï¼š\n\n\nå½“é˜¶ç ä¸å°¾æ•°å‡ä¸º0æ—¶è¡¨ç¤ºæœºå™¨æ•°0ã€‚å¦å¤–ç”±äºå°¾æ•°é‡‡ç”¨åŸç è¡¨ç¤ºï¼Œå› æ­¤å­˜åœ¨+0ä¸-0ã€‚\n\nå½“æ—¶ï¼Œæµ®ç‚¹æ•°ä¸ºè§„æ ¼åŒ–æ•°ï¼Œå…¶å€¼ä¸º\n\næˆ‘ä»¬æ¸…æ¥šè§„æ ¼åŒ–æ•°æ— æ³•è¡¨ç¤ºç»å¯¹å€¼åœ¨å†…çš„æ•°ï¼Œé‚£ä¹ˆä¸ºäº†è¿›ä¸€æ­¥æé«˜æµ®ç‚¹æ•°çš„è¡¨ç¤ºç²¾åº¦ï¼Œäºæ˜¯å¼•å…¥éè§„æ ¼åŒ–æ•°ã€‚å½“æ—¶ï¼Œæµ®ç‚¹æ•°ä¾¿ä¸ºéè§„æ ¼åŒ–æ•°ï¼Œå…¶å€¼ä¸º\n\n\n\n\n","slug":"æµ®ç‚¹æ•°è¡¨ç¤º","date":"2022-03-01T08:43:17.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"ace59b7e8a5639360739593f39df1262","title":"ã€Œ1010ã€Radix","content":"â³ENTRY\nGiven a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.\nNow for any pair of positive integers  and , your task is to find the radix of one number while that of the other is given.\n\n\nInput Specification:Each input file contains one test case. Each case occupies a line which contains 4 positive integers:\nN1 N2 tag radix\n\nHere N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2.\nOutput Specification:For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix.\nSample Input 1:6 110 1 10\n\nSample Output 1:2\n\nSample Input 2:1 ab 1 2\n\nSample Output 2:Impossible\n\n\nÎ©è¿™é“é¢˜çš„æµ‹è¯•ç‚¹ç®—æ˜¯æŠŠæˆ‘çš„è®¤çŸ¥ç»™æ‰“ç©¿äº†ï¼Œä¸æ›¾æƒ³ï¼Œä¹‹å‰åˆ·çš„é¢˜ç›®éƒ½æ˜¯é‚£ä¹ˆçš„å•çº¯å¯çˆ±â€¦â€¦\n\n\nå’³å’³ï¼Œä½ è¯´æ20ä¸ªæµ‹è¯•ç‚¹ä¹Ÿå°±ç®—äº†ï¼ŒçœŸå°±ä¸€ä¸ªæç¤ºéƒ½ä¸ç»™ï¼Ÿ\nå¯¹çš„ï¼Œè®¡ç®—æœºæ˜¯ä¸€é—¨è¿½æ±‚ä¸¥è°¨çš„å­¦ç§‘ï¼Œä¸¥è°¨çš„ï¼Œä¸¥â€¦â€¦\nå¥½å§ï¼Œè‚å°±å®Œäº‹äº†ã€‚\n\n\né¢˜ç›®å¤§æ„æ˜¯ï¼Œç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²æ•°å­—ï¼Œå‘Šè¯‰ä½ å…¶ä¸­ä¸€ä¸ªæ•°æ˜¯å‡ è¿›åˆ¶ï¼Œé—®ä½ å¦ä¸€ä¸ªæ•°æ˜¯å‡ è¿›åˆ¶æ—¶å¯ä»¥ä½¿ä¸¤æ•°ç›¸ç­‰ï¼Œå¦‚æœä¸å¯èƒ½åˆ™è¾“å‡ºImpossibleã€‚\n\n\nä¹ä¸€çœ‹ï¼Œso easyï½ ä¸€é€šæšä¸¾çŒ›å¦‚è™ï¼Œè¿™ä¸ç›´æ¥â€¦â€¦ä½†ï¼Œé¢˜ç›®æ²¡æœ‰ç»™å‡ºè¿›åˆ¶æ•°çš„èŒƒå›´ï¼Œä¸è®²æ­¦å¾·å‘ã€‚ä¸è¿‡æ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬æ¸…æ¥šå­—ç¬¦ä¸²æ•°å­—çš„å€¼éšç€è¿›åˆ¶æ•°çš„å¢åŠ æ˜¯å•è°ƒé€’å¢çš„ï¼ˆâš ï¸ä¸€ç§æƒ…å†µé™¤å¤–ï¼Œé‚£å°±æ˜¯åªæœ‰ä¸€ä½æ•°å­—ï¼Œå…¶å€¼ä¸ä¼šéšç€è¿›åˆ¶çš„æ”¹å˜è€Œæ”¹å˜ã€‚æ˜¾ç„¶ï¼Œæˆ‘æ ¹æœ¬ä¸å¯èƒ½æ‰è¿›è¿™ç§ä½çº§çš„å‘ï¼‰ï¼Œé‚£ä¹ˆå°±å¯ä»¥å…ˆæ‰¾å‡ºè¿›åˆ¶æœªçŸ¥æ•°ä¸­æœ€å¤§çš„å­—ç¬¦ï¼Œç„¶åä»æœ€å¤§çš„å­—ç¬¦å¼€å§‹å¾€ä¸Šæšä¸¾ï¼Œå¦‚æœæšä¸¾åˆ°æŸä¸ªè¿›åˆ¶æ—¶è¶…è¿‡äº†å¦ä¸€ä¸ªå·²çŸ¥æ•°å°±è¯´æ˜ä¸¤è€…ä¸å¯èƒ½ç›¸ç­‰ã€‚æ¯”å¦‚è¯´1ac3bä¸­æœ€å¤§çš„å­—ç¬¦æ˜¯c=12ï¼Œé‚£å°±ä»13è¿›åˆ¶å¼€å§‹æšä¸¾ç›´åˆ°å…¶å€¼â‰¥å¦ä¸€ä¸ªæ•°ã€‚\næ€è·¯éå¸¸çš„æ¸…æ™°å•Šï¼Œå°æ‰‹ä¸€æŠ–ä»£ç å°±å†™å®Œäº†å‘¢ï½\n\nCâ˜¹DE#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b;\n  //each has no more than 10 digitsï¼\n  //a_dï¼šdecimal aï¼›raï¼šradix of a\n    long long int t, ra, rb = 1, n, a_d = 0, b_d = 0;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; ra;\n  //make sure a's value is known\n    if (t == 2)\n        swap(a, b);\n  //calculate a's decimal value\n    for (auto &amp;c: a)\n    {\n        n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n        a_d = a_d * ra + n;\n    }\n  //mark if there is an answer\n    bool flag = false;\n  //find the max character of b\n    auto max_digit = *max_element(b.begin(), b.end());\n    rb = (isdigit(max_digit) ? max_digit - '0' : max_digit - 'a' + 10);\n\n  //start enumeration\n    while (b_d &lt; a_d)\n    {\n        b_d = 0;\n        ++rb;\n        for (auto &amp;c: b)\n        {\n            n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n            b_d = b_d * rb + n;\n        }\n        if (b_d == a_d)\n            flag = true;\n    }\n    if (flag)\n        cout &lt;&lt; rb;\n    else\n        cout &lt;&lt; \"Impossible\";\n}\n\n\nç¬¬ä¸€æ¬¡æäº¤çš„æ—¶å€™æ²¡æœ‰ç”¨long long intï¼Œæœ‰ä¸€ä¸ªæµ‹è¯•ç‚¹ç‚¸äº†ï¼Œæ”¹æ­£åå°±ã€æµ‹è¯•ç‚¹7ã€‘æ˜¾ç¤ºè¿è¡Œè¶…æ—¶ã€‚ä¸é”™å•Šï¼Œ20ä¸ªé‡Œé¢å·²ç»æ¶ˆç­19ä¸ªäº†ï¼Œä¸è¿‡æ„Ÿè§‰è¿™ä¸ªè¿è¡Œè¶…æ—¶ä¸æ˜¯å¾ˆå‹å¥½â€¦â€¦æ¯•ç«Ÿæšä¸¾æœ€æ€•çš„å°±æ˜¯è¿è¡Œè¶…æ—¶äº†ã€‚\næœç„¶ï¼Œç»è¿‡ä¸€ç•ªæµ‹è¯•ï¼ˆå°†rbçš„åˆå§‹å€¼ä¸æ–­æé«˜çœ‹ä»€ä¹ˆæ—¶å€™ä¸è¶…æ—¶ï¼‰ï¼Œéå¸¸æƒŠå–œåœ°å‘ç°ã€æµ‹è¯•ç‚¹7ã€‘çš„æµ‹è¯•æ•°æ®æ˜¯10 2147483647 2 10ã€‚ç‹—å¸¦ï¼Œè¿™ç”¨ä¾‹å®Œå…¨å°±æ˜¯ä¸“æ€¼æšä¸¾çš„ï¼Œå› ä¸ºè¿™è¦ä»2è¿›åˆ¶æšä¸¾åˆ°æœ€å¤§çš„32ä½æ•´å‹ã€‚ä¹Ÿè¿˜å¥½å•¦ï¼Œå†ç»™æˆ‘å¤šä¸€ç‚¹æ—¶é—´â€¦â€¦\nä¸æšä¸¾çš„è¯é‚£å’‹åŠï¼Œçªç„¶æƒ³èµ·æ¥å…¶å€¼éšç€è¿›åˆ¶æ•°çš„å¢å¤§æ˜¯å•è°ƒé€’å¢çš„ã€‚å•è°ƒçš„äº‹ç‰©å¾€å¾€æŸ¥æ‰¾æ–¹ä¾¿ï¼Œå› ä¸ºè¿˜æœ‰ä¸€ä¸ªå«äºŒåˆ†æ³•çš„ä¸œè¥¿ã€‚å¯¹å•Šï¼Œè¿™ä¸å°±æ˜¯å…¸å‹çš„äºŒåˆ†æ³•åº”ç”¨é¢˜å˜›ã€‚\nä¸€é€šä»£ç çŒ›å¦‚è™ï¼Œä¿®æ”¹æ–¹æ¡ˆçš„æ—¶å€™å¾€å¾€ä¼šæ¡äº†è¥¿ç“œä¸¢äº†èŠéº»ã€‚\nå·®ç‚¹å¿˜äº†é¢˜ç›®é‡Œè¿˜æœ‰ä¸ªè¦æ±‚ï¼Œå¦‚æœæœ‰å¤šä¸ªç¬¦å’Œè¦æ±‚çš„ç­”æ¡ˆåˆ™è¾“å‡ºæœ€å°çš„é‚£ä¸ªã€‚æˆ‘å¯»æ€ç€å•è°ƒè¿˜èƒ½æœ‰å¤šè§£ï¼Ÿä¸ªä½æ•°ä»¬ï¼šä½ å¥½ã€‚\nå¯¹äº†ï¼Œâ€œäºŒè¿›åˆ¶æ•°é‡Œæ²¡æœ‰132â€ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    string a, b;\n    long long int t, ra, rb = 1, n, a_d = 0, b_d, cup = 1;\n    cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; ra;\n    if (t == 2)\n        swap(a, b);\n    for (auto &amp;c: a)\n    {\n        n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n        a_d = a_d * ra + n;\n    }\n  //consider one-digit\n    if (b.size() == 1 &amp;&amp; atoi(b.c_str()) == a_d)\n    {\n        cout &lt;&lt; atoi(b.c_str()) + 1;\n        exit(0);\n    }\n    bool flag = false;\n  //\"132 isn't binary number\"\n    auto max_digit = *max_element(b.begin(), b.end());\n    long long int rb_max = INT32_MAX, rb_min = (isdigit(max_digit) ? max_digit - '0' : max_digit - 'a' + 10);\n    while (rb_max &gt; rb_min)\n    {\n        b_d = 0;\n        rb = (rb_max + rb_min + 1) / 2;\n      // unchanged rb demonstrates impossibility\n        if (cup == rb)\n            break;\n        cup = rb;\n        for (auto &amp;c: b)\n        {\n            n = (isdigit(c) ? c - '0' : c - 'a' + 10);\n            b_d = b_d * rb + n;\n          //break in time\n            if (b_d &gt; a_d)\n                break;\n        }\n        if (b_d == a_d)\n        {\n            flag = true;\n            break;\n        }\n        else if (b_d &lt; a_d)\n            rb_min = rb;\n        else\n            rb_max = rb;\n    }\n    if (flag)\n        cout &lt;&lt; rb;\n    else\n        cout &lt;&lt; \"Impossible\";\n}\n\n\nÎ» ä¸€ä¸ªå°æ³¨åœ¨å®æ–½äºŒåˆ†æ³•çš„æ—¶å€™æœ‰ä¸€ä¸ªé—®é¢˜éœ€è¦å…³æ³¨ï¼Œé‚£å°±æ˜¯è¾¹ç•Œèƒ½å¦å–åˆ°ã€‚æ³¨æ„åˆ°ï¼Œä¸Šæ–‡ä¸­é‚£ä¸ªè®©æˆ‘å¤§æšä¸¾æ³•çˆ†ç‚¸çš„æµ‹è¯•æ•°æ®çš„ç­”æ¡ˆæ˜¯2147483647ï¼Œä¹Ÿå°±æ˜¯æœ€å¤§çš„32ä½æ•´æ•°ã€‚è€Œæˆ‘åœ¨codeé‡Œå–çš„rbåˆå§‹æœ€å¤§å€¼å°±æ˜¯INT32_MAX=2147483647,å› æ­¤æˆ‘éœ€è¦è®©rbå¯ä»¥äºŒåˆ†åˆ°è¿™ä¸ªæœ€å¤§è¾¹ç•Œï¼Œä¸€ç§è§£å†³æ–¹æ¡ˆä¾¿æ˜¯codeé‡Œé‡‡ç”¨çš„äºŒåˆ†æ—¶+1ç­–ç•¥ï¼Œè¿™æ ·çš„è¯rbä¸‹ç•Œå°±å¿…é¡»å–ä¸€ä¸ªä¸å¯èƒ½çš„å€¼ï¼Œå› ä¸ºè¾¾ä¸åˆ°ä¸‹ç•Œã€‚\nrb = (rb_max + rb_min + 1) / 2;\n\nè¿˜æœ‰ä¸€ç§æ–¹æ³•ï¼Œå°±æ˜¯rb_maxä¸rb_minéƒ½å–ä¸€ä¸ªè¾¾ä¸åˆ°çš„å€¼ï¼Œæ¯”å¦‚è¯´\nlong long int rb_max = INT32_MAX + 1;\n\nç„¶è€Œä¸€å¼€å§‹é‡‡ç”¨è¿™ä¸ªç­–ç•¥æ—¶ï¼Œæˆ‘å‘ç°rb_maxè¢«èµ‹å€¼ä¸ºäº†-2147483648ã€‚æœ‰ç‚¹æ‡µï¼Œå¯»æ€ç€long long intä¸æ˜¯64ä½çš„å—ï¼Œæ€ä¹ˆç¼©æ°´æº¢å‡ºäº†ï¼Ÿåæ¥ä»”ç»†æƒ³æƒ³æ˜¯å› ä¸ºINT32_MAXæ˜¯intç±»å‹çš„ï¼Œå› æ­¤+1çš„æ—¶å€™å…ˆæ˜¯æŒ‰intç±»å‹è¿›è¡Œè®¡ç®—çš„ï¼Œç„¶åæ‰å°†intçš„ç»“æœè½¬æ¢æˆlong long intã€‚æ‰€ä»¥ä¸€å¼€å§‹å°±éœ€è¦å¯¹INT32_MAXè¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬åŒ–ã€‚\n","slug":"1010-Radix","date":"2022-02-28T15:04:14.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,binary search","author_index":"Starlit Rover"},{"id":"2e1e3e282f89766b686da9305ae12c26","title":"ã€ŒSection 0ã€è®¡ç½‘ä¸“æœ‰åè¯","content":"\nç‹¬ç«‹æ¨¡å¼ï¼šè®¡ç®—æœºæœªè¿æ¥åˆ°ç½‘ç»œï¼Œå„è‡ªç‹¬ç«‹ä½¿ç”¨çš„æ–¹å¼ï¼ˆopp. ç½‘ç»œäº’è¿æ¨¡å¼ï¼‰\n\nWAN ( Wide Area Networkï¼Œå¹¿åŸŸç½‘ï¼‰ï¼šæŒ‡æ¶µç›–å¤šä¸ªè¿œè·ç¦»åŒºåŸŸçš„è¿œç¨‹ç½‘ç»œã€‚æ¯”å¹¿åŸŸç½‘å†å°ä¸€çº§çš„ã€è¿æ¥æ•´ä¸ªåŸå¸‚çš„ç½‘ç»œå«åŸåŸŸç½‘(MAN, Metropolitan Area Network)ã€‚\n\nLAN ( Local Area Network, å±€åŸŸç½‘ï¼‰ï¼šæŒ‡ä¸€ä¸ªæ¥¼å±‚ã€ä¸€æ ‹æ¥¼æˆ–ä¸€ä¸ªæ ¡å›­ç­‰ç›¸å¯¹è¾ƒå°çš„åŒºåŸŸå†…çš„ç½‘ç»œã€‚\n\nç»ˆç«¯ï¼šç”±é”®ç›˜ã€æ˜¾ç¤ºå™¨ç­‰è¾“å…¥è¾“å‡ºè®¾å¤‡ç»„æˆã€‚æœ€åˆè¿˜åŒ…æ‹¬æ‰“å­—æœºã€‚\n\n\næ‰¹å¤„ç†ï¼ˆBatch Processingï¼‰ï¼šæŒ‡äº‹å…ˆå°†ç”¨æˆ·ç¨‹åºå’Œæ•°æ®è£…äººå¡å¸¦æˆ–ç£å¸¦ï¼Œå¹¶ç”±è®¡ç®—æœºæŒ‰ç…§ä¸€å®šçš„é¡ºåºè¯»å–ï¼Œä½¿ç”¨æˆ·æ‰€è¦æ‰§è¡Œçš„è¿™äº›ç¨‹åºå’Œæ•°æ®èƒ½å¤Ÿä¸€å¹¶æ‰¹é‡å¾—åˆ°å¤„ç†çš„æ–¹å¼ã€‚\n\n\nåˆ†æ—¶ç³»ç»Ÿï¼ˆTime Sharing Systemï¼‰ï¼šæŒ‡å¤šä¸ªç»ˆç«¯ä¸åŒä¸€ä¸ªè®¡ç®—æœºè¿æ¥ï¼Œå…è®¸å¤šä¸ªç”¨æˆ·åŒæ—¶ä½¿ç”¨ä¸€å°è®¡ç®—æœºçš„ç³»ç»Ÿã€‚åˆ†æ—¶ç³»ç»Ÿçš„é‡è¦ç‰¹æ€§åŒ…æ‹¬å¤šè·¯æ€§ã€ç‹¬å æ€§ã€äº¤äº’æ€§å’ŒåŠæ—¶æ€§ã€‚\n\n\nåˆ†ç»„äº¤æ¢ï¼šåˆ†ç»„äº¤æ¢æ˜¯æŒ‡å°†å¤§æ•°æ®åˆ†å‰²ä¸ºä¸€ä¸ªä¸ªå«åšåŒ…ï¼ˆPacketï¼‰çš„è¾ƒå°å•ä½è¿›è¡Œä¼ è¾“çš„æ–¹æ³•ã€‚\n\n\nOSIï¼ˆOpen Systems Interconnectionï¼‰ï¼šå¼€æ”¾å¼é€šä¿¡ç³»ç»Ÿäº’è”å‚è€ƒæ¨¡å‹ã€‚\n\nOSI å‚è€ƒæ¨¡å‹ä¸­å„ä¸ªåˆ†å±‚çš„ä½œç”¨\n\n\nMACåœ°å€ï¼šç§°ä¸ºç‰©ç†åœ°å€æˆ–ç¡¬ä»¶åœ°å€ï¼Œç”¨æ¥ç¡®è®¤ç½‘ç»œè®¾å¤‡ä½ç½®çš„åœ°å€ï¼Œæ¯ä¸ªç½‘å¡éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„MACåœ°å€ï¼Œä¸”ä¸èƒ½æ›´æ”¹ã€‚é‡‡ç”¨ MAC åœ°å€ï¼Œç›®çš„æ˜¯ä¸ºäº†è¯†åˆ«è¿æ¥åˆ°åŒä¸€ä¸ªä¼ è¾“ä»‹è´¨ä¸Šçš„è®¾å¤‡ã€‚\n\nIPåœ°å€ï¼šäº’è”ç½‘åè®®åœ°å€ï¼Œå½“è®¾å¤‡è¿æ¥ç½‘ç»œæ—¶ï¼Œè®¾å¤‡å°†è¢«åˆ†é…ä¸€ä¸ªIPåœ°å€ï¼ˆâš ï¸äº‹å®ä¸Šæ˜¯åˆ†é…ç»™è®¾å¤‡ä¸­å®‰è£…çš„ç½‘ç»œç¡¬ä»¶ï¼Œå³ä¸€å°è®¾å¤‡ä¸ä¸€å®šåªæœ‰ä¸€ä¸ªIPåœ°å€ï¼‰ï¼Œç”¨ä½œæ ‡è¯†ã€‚é€šè¿‡IPåœ°å€ï¼Œè®¾å¤‡é—´å¯ä»¥äº’ç›¸é€šè®¯ã€‚å…±32ä½ï¼Œç”±ç½‘ç»œå·å’Œä¸»æœºå·ç»„æˆï¼Œå®ƒä»¬æ²¡æœ‰ä½æ•°è¦æ±‚ï¼Œè€Œæ˜¯ç”±å­ç½‘æ©ç æ¥ä½“ç°ã€‚è‹¥ä¸»æœºå·éƒ¨åˆ†å…¨éƒ¨ä¸º0åˆ™ä»£è¡¨æ•´ä¸ªå­ç½‘è€Œä¸æ˜¯å­ç½‘ä¸­çš„æŸå°è®¾å¤‡ã€‚æ­¤å¤–ï¼Œä¸»æœºå·éƒ¨åˆ†å…¨éƒ¨ä¸º1ä»£è¡¨å‘å­ç½‘ä¸Šæ‰€æœ‰è®¾å¤‡å‘é€åŒ…ï¼Œå³å¹¿æ’­ã€‚\n\nå­ç½‘æ©ç ï¼šä¸€ä¸²ä¸IPåœ°å€é•¿åº¦ç›¸åŒçš„32æ¯”ç‰¹æ•°å­—ã€‚å·¦è¾¹ä¸€éƒ¨åˆ†å…¨ä¸º1ï¼Œç›¸å¯¹åº”çš„IPåœ°å€éƒ¨åˆ†è¡¨ç¤ºç½‘ç»œå·ï¼›å³è¾¹å‰©ä½™éƒ¨åˆ†å…¨ä¸º0ï¼Œå¯¹åº”çš„IPåœ°å€éƒ¨åˆ†è¡¨æ˜ä¸»æœºå·ã€‚\n\nDNS: Domain Namme Systemï¼ŒåŸŸåæœåŠ¡ç³»ç»Ÿã€‚å°†æœåŠ¡å™¨åç§°å’Œ IP åœ°å€è¿›è¡Œå…³è”æ˜¯ DNS æœ€å¸¸è§çš„ç”¨æ³•ï¼Œä½† DNS çš„åŠŸèƒ½å¹¶ä¸ä»…é™äºæ­¤ï¼Œå®ƒè¿˜å¯ä»¥å°†é‚®ä»¶åœ°å€å’Œé‚®ä»¶æœåŠ¡å™¨è¿›è¡Œå…³è”ï¼Œä»¥åŠä¸ºå„ç§ä¿¡æ¯å…³è”ç›¸åº”çš„åç§°ã€‚âš ï¸ä¸€ä¸ªIPåœ°å€å¯ä»¥å¯¹åº”å¤šä¸ªåŸŸåï¼Œä¸€ä¸ªåŸŸåä¹Ÿå¯ä»¥è§£æä¸ºå¤šä¸ªIPåœ°å€ã€‚\n\né¢å‘æœ‰è¿æ¥å‹ï¼šé¢å‘æœ‰è¿æ¥å‹ä¸­ï¼Œåœ¨å‘é€æ•°æ®ä¹‹å‰ï¼Œéœ€è¦åœ¨æ”¶å‘ä¸»æœºä¹‹é—´è¿æ¥ä¸€æ¡é€šä¿¡çº¿è·¯ã€‚ï¼ˆéœ€è¦å¯¹æ–¹åŒæ„ï¼‰\n\né¢å‘æ— è¿æ¥å‹ï¼šé¢å‘æ— è¿æ¥å‹åˆ™ä¸è¦æ±‚å»ºç«‹å’Œæ–­å¼€è¿æ¥ã€‚å‘é€ç«¯å¯äºä»»ä½•æ—¶å€™è‡ªç”±å‘é€æ•°æ®ã€‚\n\nç½‘å¡ï¼šç½‘ç»œæ¥å£å¡ï¼ŒNIC ( Network Interface Card)ï¼Œæ˜¯è®¡ç®—æœºè¿ç½‘æ—¶æ‰€ä½¿ç”¨çš„éƒ¨ä»¶ã€‚\n\nå¸¦å®½ï¼ˆBandwidthï¼‰ï¼šå•ä½æ—¶é—´å†…ä¼ è¾“çš„æ•°æ®é‡æœ‰å¤šå°‘ï¼Œå³ä¼ è¾“é€Ÿç‡ï¼Œå•ä½ä¸ºbps ( Bits Per Secondï¼Œæ¯ç§’æ¯”ç‰¹æ•°ï¼‰ã€‚å¸¦å®½è¶Šå¤§ç½‘ç»œä¼ è¾“èƒ½åŠ›è¶Šå¼ºã€‚ä»ä¸¥æ ¼æ„ä¹‰ä¸Šè®²ï¼Œå„ç§ä¼ è¾“åª’ä»‹ä¸­ä¿¡å·çš„æµåŠ¨é€Ÿåº¦æ˜¯æ’å®šçš„ã€‚å› æ­¤ï¼Œå³ä½¿æ•°æ®é“¾è·¯çš„ä¼ è¾“é€Ÿç‡ä¸ç›¸åŒï¼Œä¹Ÿä¸ä¼šå‡ºç°ä¼ è¾“çš„é€Ÿåº¦å¿½å¿«å¿½æ…¢çš„æƒ…å†µï¼Œå› ä¸ºå…‰å’Œç”µæµçš„ä¼ è¾“é€Ÿåº¦æ˜¯æ’å®šçš„ã€‚\n\nååé‡ï¼šæŒ‡ä¸»æœºä¹‹é—´å®é™…çš„ä¼ è¾“é€Ÿç‡ï¼Œå•ä½ä¸å¸¦å®½ç›¸åŒã€‚\n\nä¸­ç»§å™¨ï¼ˆRepeaterï¼‰ï¼šç‰©ç†å±‚é¢ä¸Šå»¶é•¿ç½‘ç»œçš„è®¾å¤‡ã€‚ç”±ç”µç¼†ä¼ è¿‡æ¥çš„ç”µä¿¡å·æˆ–å…‰ä¿¡å·ç»ç”±ä¸­ç»§å™¨çš„æ³¢å½¢è°ƒæ•´å’Œæ”¾å¤§å†ä¼ ç»™å¦ä¸€ä¸ªç”µç¼†ã€‚å¦å¤–ï¼Œä¸­ç»§å™¨æ— æ³•è¿æ¥ä¸¤ä¸ªä¸åŒé€Ÿåº¦çš„ç½‘ç»œï¼Œè¿™éœ€è¦ç½‘æ¡¥æˆ–è·¯ç”±å™¨è¿™æ ·çš„è®¾å¤‡æ¥å®Œæˆã€‚\n\n\nç½‘æ¡¥ï¼šæ•°æ®é“¾è·¯å±‚é¢ä¸Šè¿æ¥ä¸¤ä¸ªç½‘ç»œçš„è®¾å¤‡ã€‚å®ƒèƒ½å¤Ÿè¯†åˆ«æ•°æ®é“¾è·¯å±‚ä¸­çš„æ•°æ®å¸§ï¼Œå¹¶å°†è¿™äº›æ•°æ®å¸§ä¸´æ—¶å­˜å‚¨äºå†…å­˜ï¼Œå†é‡æ–°ç”Ÿæˆä¿¡å·ä½œä¸ºä¸€ä¸ªå…¨æ–°çš„å¸§è½¬å‘ç»™ç›¸è¿çš„å¦ä¸€ä¸ªç½‘æ®µã€‚ç”±äºèƒ½å¤Ÿå­˜å‚¨è¿™äº›æ•°æ®å¸§ï¼Œç½‘æ¡¥å¯ä»¥è¿æ¥ä¼ è¾“é€Ÿç‡å®Œå…¨ä¸åŒçš„æ•°æ®é“¾è·¯ï¼Œå¹¶ä¸é™åˆ¶è¿æ¥ç½‘æ®µçš„ä¸ªæ•°ã€‚\n\n\nè·¯ç”±å™¨ï¼šæä¾›è·¯ç”±ä¸è½¬é€ä¸¤ç§é‡è¦æœºåˆ¶ï¼Œå¯ä»¥å†³å®šæ•°æ®åŒ…ç”±æ¥æºç«¯åˆ°ç›®çš„ç«¯æ‰€ç»è¿‡çš„è·¯å¾„ã€‚ç½‘æ¡¥æ˜¯æ ¹æ®ç‰©ç†åœ°å€ï¼ˆMAC åœ°å€ï¼‰è¿›è¡Œå¤„ç†ï¼Œè€Œè·¯ç”±å™¨/3å±‚äº¤æ¢æœºåˆ™æ˜¯æ ¹æ® IP åœ°å€è¿›è¡Œå¤„ç†çš„ã€‚ç”±æ­¤ï¼ŒTCP/IP ä¸­ç½‘ç»œå±‚çš„åœ°å€å°±æˆä¸ºäº† IPåœ°å€ã€‚\n\n\nç½‘å…³ï¼šè½¬å‘å…¶ä»–æœåŠ¡å™¨é€šä¿¡æ•°æ®çš„æœåŠ¡å™¨ï¼Œæ¥æ”¶ä»å®¢æˆ·ç«¯å‘é€æ¥çš„è¯·æ±‚æ—¶ï¼Œå®ƒå°±åƒè‡ªå·±æ‹¥æœ‰èµ„æºçš„æºæœåŠ¡å™¨ä¸€æ ·å¯¹è¯·æ±‚è¿›è¡Œå¤„ç†ã€‚ç½‘å…³èƒ½ä½¿é€šä¿¡çº¿è·¯ä¸Šçš„æœåŠ¡å™¨æä¾›é HTTPåè®®æœåŠ¡ã€‚\n\n\næŠ¥æ–‡ï¼šæ˜¯HTTPé€šä¿¡ä¸­çš„åŸºæœ¬å•ä½ï¼Œç”±8ä½ç»„å­—èŠ‚æµ (octet sequenceï¼Œå…¶ä¸­ octet ä¸º8ä¸ªæ¯”ç‰¹ï¼‰ç»„æˆï¼Œé€šè¿‡ HTTP é€šä¿¡ä¼ è¾“ã€‚\n\nä»£ç†ï¼šä»£ç†æ˜¯ä¸€ç§æœ‰è½¬å‘åŠŸèƒ½çš„åº”ç”¨ç¨‹åºï¼Œå®ƒæ‰®æ¼”äº†ä½äºæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯â€œä¸­é—´äººâ€çš„è§’è‰²ï¼Œæ¥æ”¶ç”±å®¢æˆ·ç«¯å‘é€çš„è¯·æ±‚å¹¶è½¬å‘ç»™æœåŠ¡å™¨ï¼ŒåŒæ—¶ä¹Ÿæ¥æ”¶æœåŠ¡å™¨è¿”å›çš„å“åº”å¹¶è½¬å‘ç»™å®¢æˆ·ç«¯ã€‚\n\néš§é“ï¼šéš§é“æ˜¯åœ¨ç›¸éš”ç”šè¿œçš„å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¸¤è€…ä¹‹é—´è¿›è¡Œä¸­è½¬ï¼Œå¹¶ä¿æŒåŒæ–¹é€šä¿¡è¿æ¥çš„åº”ç”¨ç¨‹åºã€‚éš§é“çš„ç›®çš„æ˜¯ç¡®ä¿å®¢æˆ·ç«¯èƒ½ä¸æœåŠ¡å™¨è¿›è¡Œå®‰å…¨çš„é€šä¿¡ã€‚\n\nä¸´æ—¶ç½‘ç»œæ–‡ä»¶ï¼šå®¢æˆ·ç«¯ä¸Šçš„ç½‘é¡µç¼“å­˜ã€‚\n\nå¥—æ¥å­—ï¼šæ˜¯å¯¹ç½‘ç»œä¸­ä¸åŒä¸»æœºä¸Šçš„åº”ç”¨è¿›ç¨‹ä¹‹é—´è¿›è¡ŒåŒå‘é€šä¿¡çš„ç«¯ç‚¹çš„æŠ½è±¡ã€‚ä¸€ä¸ªå¥—æ¥å­—å°±æ˜¯ç½‘ç»œä¸Šè¿›ç¨‹é€šä¿¡çš„ä¸€ç«¯ï¼Œæä¾›äº†åº”ç”¨å±‚è¿›ç¨‹åˆ©ç”¨ç½‘ç»œåè®®äº¤æ¢æ•°æ®çš„æœºåˆ¶ã€‚ä»æ‰€å¤„çš„åœ°ä½æ¥è®²ï¼Œå¥—æ¥å­—ä¸Šè”åº”ç”¨è¿›ç¨‹ï¼Œä¸‹è”ç½‘ç»œåè®®æ ˆï¼Œæ˜¯åº”ç”¨ç¨‹åºé€šè¿‡ç½‘ç»œåè®®è¿›è¡Œé€šä¿¡çš„æ¥å£ï¼Œæ˜¯åº”ç”¨ç¨‹åºä¸ç½‘ç»œåè®®æ ˆè¿›è¡Œäº¤äº’çš„æ¥å£ã€‚\n\n\nç«¯å£å·ï¼šæ˜ç¡®æŒ‡å‡ºæŸå°å…·ä½“è®¡ç®—æœºä¸ŠæŸä¸ªå…·ä½“çš„å¥—æ¥å­—ã€‚å¦‚æœè¯´æè¿°ç¬¦æ˜¯ç”¨æ¥åœ¨ä¸€å°è®¡ç®—æœºå†…éƒ¨è¯†åˆ«å¥—æ¥å­—çš„æœºåˆ¶ï¼Œé‚£ä¹ˆç«¯å£å·å°±æ˜¯ç”¨æ¥è®©é€šä¿¡çš„å¦ä¸€æ–¹èƒ½å¤Ÿè¯†åˆ«å‡ºå¥—æ¥å­—çš„æœºåˆ¶ã€‚\n\nè´Ÿè½½å‡è¡¡ï¼šå…¶èŒè´£æ˜¯å°†ç½‘ç»œè¯·æ±‚ï¼Œæˆ–è€…å…¶ä»–å½¢å¼çš„è´Ÿè½½â€œå‡æ‘Šâ€åˆ°ä¸åŒçš„æœºå™¨ä¸Šï¼Œé¿å…é›†ç¾¤ä¸­éƒ¨åˆ†æœåŠ¡å™¨å‹åŠ›è¿‡å¤§ï¼Œè€Œå¦ä¸€äº›æœåŠ¡å™¨æ¯”è¾ƒç©ºé—²çš„æƒ…å†µã€‚é€šè¿‡è´Ÿè½½å‡è¡¡ï¼Œå¯ä»¥è®©æ¯å°æœåŠ¡å™¨è·å–åˆ°é€‚åˆè‡ªå·±å¤„ç†èƒ½åŠ›çš„è´Ÿè½½ã€‚åœ¨ä¸ºé«˜è´Ÿè½½æœåŠ¡å™¨åˆ†æµçš„åŒæ—¶ï¼Œè¿˜å¯ä»¥é¿å…èµ„æºæµªè´¹ï¼Œä¸€ä¸¾ä¸¤å¾—ã€‚\n\nè™šæ‹Ÿä¸»æœºï¼ˆvirtual hostingï¼‰ï¼šæˆ–ç§° å…±äº«ä¸»æœºï¼ˆshared web hostingï¼‰ï¼Œåˆç§°è™šæ‹ŸæœåŠ¡å™¨ï¼Œæ˜¯ä¸€ç§åœ¨å•ä¸€ä¸»æœºæˆ–ä¸»æœºç¾¤ä¸Šï¼Œå®ç°å¤šç½‘åŸŸæœåŠ¡çš„æ–¹æ³•ï¼Œå¯ä»¥æ‰§è¡Œå¤šä¸ªç½‘ç«™æˆ–æœåŠ¡çš„æŠ€æœ¯ã€‚è™šæ‹Ÿä¸»æœºä¹‹é—´å®Œå…¨ç‹¬ç«‹ï¼Œå¹¶å¯ç”±ç”¨æˆ·è‡ªè¡Œç®¡ç†ï¼Œè™šæ‹Ÿå¹¶éæŒ‡ä¸å­˜åœ¨ï¼Œè€Œæ˜¯æŒ‡ç©ºé—´æ˜¯ç”±å®ä½“çš„æœåŠ¡å™¨å»¶ä¼¸è€Œæ¥ï¼Œå…¶ç¡¬ä»¶ç³»ç»Ÿå¯ä»¥æ˜¯åŸºäºæœåŠ¡å™¨ç¾¤ï¼Œæˆ–è€…å•ä¸ªæœåŠ¡å™¨ã€‚\n\nISPï¼ˆInternet Service Providerï¼‰ï¼šäº’è”ç½‘æœåŠ¡æä¾›å•†ã€‚\n\nNATï¼ˆNetwork Address Translationï¼‰ï¼šç½‘ç»œåœ°å€ç¿»è¯‘ï¼Œå®ƒçš„æå‡ºä¹Ÿå®Œå…¨æ˜¯ä¸ºè§£å†³IPv4åœ°å€çŸ­ç¼ºçš„é—®é¢˜ï¼Œä¸ºIPV6çš„å¼€å‘äº‰å–è¶³å¤Ÿæ—¶é—´ã€‚åœ¨è®¡ç®—æœºç½‘ç»œä¸­æ˜¯ä¸€ç§åœ¨IPæ•°æ®åŒ…é€šè¿‡è·¯ç”±å™¨æˆ–é˜²ç«å¢™æ—¶é‡å†™æ¥æºIPåœ°å€æˆ–ç›®çš„IPåœ°å€çš„æŠ€æœ¯ã€‚è¿™ç§æŠ€æœ¯è¢«æ™®éä½¿ç”¨åœ¨æœ‰å¤šå°ä¸»æœºä½†åªé€šè¿‡ä¸€ä¸ªå…¬æœ‰IPåœ°å€è®¿é—®äº’è”ç½‘çš„ç§æœ‰ç½‘ç»œä¸­ã€‚\n\n\n","slug":"è®¡ç½‘ä¸“æœ‰åè¯","date":"2022-02-27T13:03:14.000Z","categories_index":"è®¡ç®—æœºç½‘ç»œ","tags_index":"notes","author_index":"Starlit Rover"},{"id":"0891150107830e3ac5d4a54442d1eabc","title":"ã€Œ1009ã€Product of Polynomials","content":"â³ENTRY\nThis time, you are supposed to find  where A and B are two polynomials.\n\n\nInput Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:where K is the number of nonzero terms in the polynomialï¼Œ and   are the exponents and coefficients, respectively. It is given that ï¼Œ.\nOutput Specification:For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.\nSample Input:2 1 2.4 0 3.2\n2 2 1.5 1 0.5\n\n\n\nSample Output:3 3 3.6 2 6.0 1 1.6\n\n\nÎ©å¯¹äºæœ¬é¢˜æˆ‘åªæƒ³è¯´mapå¤§æ³•å¥½ï¼ŒåºŸè¯ä¸å¤šè¯´è§Code~\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;int, double&gt; a, b, p;\n    int k, n;\n    double m;\n    cin &gt;&gt; k;\n    //A input\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; m;\n        a[n] = m;\n    }\n    //B input\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; m;\n        b[n] = m;\n    }\n    //product\n    for (auto &amp;x: a)\n        for (auto &amp;y: b)\n            p[x.first + y.first] += x.second * y.second;\n    //delete monomial with coefficient 0\n    for (auto z = p.begin(); z != p.end(); ++z)\n        if (z-&gt;second == 0)\n            p.erase(z);\n    cout &lt;&lt; p.size();\n    for (auto z = p.rbegin(); z != p.rend(); ++z)\n        printf(\" %d %.1f\", z-&gt;first, z-&gt;second);\n}\n\n\nAppendix å¤šé¡¹å¼åŠ æ³• â³ENTRY#include&lt;iostream&gt;\n#include&lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;int, double&gt; x, y, z;\n    int k, n;\n    double a;\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; a;\n        x[n] = a;\n    }\n    cin &gt;&gt; k;\n    for (int i = 0; i &lt; k; ++i)\n    {\n        cin &gt;&gt; n &gt;&gt; a;\n        y[n] = a;\n    }\n\n    for (auto &amp;p: x)\n        z[p.first] += p.second;\n    for (auto &amp;p: y)\n    {\n        z[p.first] += p.second;\n        if (z[p.first] == 0)\n            z.erase(p.first);\n    }\n\n    cout &lt;&lt; z.size();\n    for (auto s = z.rbegin(); s != z.rend(); ++s)\n        printf(\" %d %.1f\", s-&gt;first, s-&gt;second);\n}\n\n","slug":"1009-Product-of-Polynomials","date":"2022-02-27T11:45:51.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"Cï¼‹ï¼‹,map","author_index":"Starlit Rover"},{"id":"ac5b1c5b9bdf438ff9cc932e6cd1efaf","title":"ã€Œ1007ã€ Maximum Subsequence Sum","content":"â³ENTRY\nGiven a sequence of K integers . A continuous subsequence is defined to be  where . The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence , its maximum subsequence is  with the largest sum being 20.\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\n\nInput Specification:Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (â‰¤10000). The second line contains K numbers, separated by a space.\nOutput Specification:For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\nSample Input:10\n-10 1 2 3 4 -5 -23 3 7 -21\n\nSample Output:10 1 4\n\n\nÎ©æœ€å¤§å­åºå’Œï¼Œé¡¾åæ€ä¹‰ï¼Œæ±‚å‡ºå’Œæœ€å¤§çš„è¿ç»­å­åºåˆ—ã€‚\nè¿™æ˜¯ä¸€é“éå¸¸ç»å…¸çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œæ®è¯´ä¹Ÿæ˜¯å¾ˆå¤šå¤§å‚çš„é¢è¯•é¢˜ï¼Œä¸è¿‡ç°åœ¨åº”è¯¥å·²ç»è¢«åšçƒ‚äº†ï¼Œå› ä¸ºä¹‹å‰æˆ‘å°±å·²ç»ç¢°åˆ°è¿‡ä¸‰å››å›äº†ã€‚å¯¹ï¼Œä¸æ˜¯è¿™ä¸€ç±»é¢˜ç›®ï¼Œæ˜¯è¿™ä¸€é“é¢˜ç›®ã€‚ä½†æˆ‘åˆçœ‹é¢˜ç›®çš„æ—¶å€™è¿˜æ˜¯æœ‰ç‚¹æ‡µï¼Œä¼°è®¡æ˜¯ä¹‹å‰æ²¡æƒ³é€å§ï¼Œé‚£ä¹ˆä»Šå¤©å°±è®©å®ƒæ°¸ä¹…ä½åœ¨æˆ‘çš„åšå®¢é‡Œï¼Œä»¥åŠ æ·±å°è±¡ã€‚\nè¯´å®è¯ä¸€å¼€å§‹çš„æ€è·¯å¿…ç„¶æ˜¯æœ‰çš„ï¼Œç¬¬ä¸€ä¸ªæƒ³æ³•å¿…ç„¶æ˜¯æšä¸¾æ‰€æœ‰çš„å­åºå’Œï¼Œé‡è›®åˆæš´åŠ›ã€‚ä½œä¸ºä¸€ä¸ªå—è¿‡é«˜ç­‰æ•™è‚²çš„ç§‘ç­å¤§å­¦ç”Ÿï¼Œæˆ‘ä»¬è¦æ–‡æ˜ä¸€ç‚¹ã€‚å½“ç„¶ä¸æ˜¯è¯´æšä¸¾ä¸å¥½ï¼Œæœ‰æ—¶å€™æšä¸¾ä¹Ÿä¼šæœ‰æ„æƒ³ä¸åˆ°çš„å¥‡æ•ˆï¼Œbut not now.\nä»”ç»†åˆ†æä¸€ä¸‹æœ€å¤§å­åºåˆ—ï¼Œæˆ‘ä»¬ä¸å¦¨è®¾æœ€å¤§å­åºåˆ—ä¸ºï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆèƒ½æˆä¸ºæœ€å¤§å­åºåˆ—å‘¢ï¼Ÿé¦–å…ˆå³çš„ä»»æ„è¿ç»­å­åºåˆ—å’Œå¿…ç„¶å°äºä¹‹å’Œã€‚å¦å¤–çš„ä¸¤ç«¯è¦ä¹ˆæ²¡æœ‰æ•°è¦ä¹ˆå°±æ˜¯è´Ÿæ•°ï¼Œä¸ç„¶å‘ä¸¤è¾¹æ‰©å¼ è¿˜å¯ä»¥å˜å¤§ï¼Œè¿™ä¸å…¶å®šä¹‰â€œæœ€å¤§â€çŸ›ç›¾ã€‚\nç”±æ­¤æˆ‘ä»¬å…¶å®å¯ä»¥å¾—åˆ°ä¸€ä¸ªéå¸¸é‡è¦çš„æ¨è®ºâ€”â€”å‰nä¸ªæ•°ä¹‹å’Œå¿…ç„¶æ˜¯çš„ï¼Œå¦åˆ™ä¸¢å¼ƒå‰nä¸ªæ•°å¾—åˆ°æ–°çš„å­åºåˆ—ä¹‹å’Œå°†ä¼šå¤§äºä¹‹å’Œã€‚é‚£ä¹ˆæˆ‘ä»¬ä¾¿å¯ä»¥è®¾ç½®ä¸€ä¸ªsum=0å˜é‡ï¼Œä¾æ¬¡è¯»å…¥æ¯ä¸€ä¸ªæ•°å¹¶è®¡å…¥sumä¸­ï¼Œè‹¥sum&lt;0äº†æ ¹æ®ä¹‹å‰çš„æ¨è®ºè¯´æ˜å‰é¢è®¡å…¥sumçš„åºåˆ—ä¸å¯èƒ½æˆä¸ºæœ€å¤§å­åºåˆ—çš„å‰ç½®éƒ¨åˆ†ï¼Œå› æ­¤ç›´æ¥ä»¤sum=0ä¸¢å¼ƒå‰é¢è¯»å…¥çš„åºåˆ—å’Œï¼Œç›´åˆ°å†æ¬¡è¯»å…¥ä¸€ä¸ªæ­£æ•°åå†å¼€å§‹è®¡æ•°ã€‚åªè¦sum&gt;0å°±ä¸æœ€å¤§å€¼è¿›è¡Œæ¯”è¾ƒï¼Œè®°å½•ä¸‹æœ€å¤§çš„sumã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, sum = 0, max_sum = -1, former = 0, latter, former_tmp = 0; \n  //former,latterè®°å½•æœ€å¤§å­åºåˆ—çš„é¦–ä½indexï¼Œ\n  //max_sum=-1è€ƒè™‘0çš„å­˜åœ¨ï¼Œformer_tmpå¿…é¡»èµ‹åˆå€¼(è€ƒè™‘ç¬¬ä¸€ä¸ªæ•°æ˜¯0çš„æƒ…å†µ)\n    cin &gt;&gt; n;\n    latter = n - 1; //å…¨ä¸ºè´Ÿæ•°æ—¶è¾“å‡ºåºåˆ—çš„é¦–ä½ä¸¤ä¸ªæ•°\n    vector&lt;int&gt; seq(n);\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%d\", &amp;seq[i]);\n        sum += seq[i];\n        if (sum &lt; 0)\n        {\n            sum = 0;\n            former_tmp = i + 1; //former_tmpå®šä½å¯èƒ½çš„æœ€å¤§å­åºåˆ—å¤´index\n        }\n        else if (sum &gt; max_sum)\n        {\n            max_sum = sum;\n            former = former_tmp;\n            latter = i;\n        }\n    }\n    max_sum = (max_sum &lt; 0 ? 0 : max_sum);//è€ƒè™‘å…¨ä¸ºè´Ÿæ•°çš„æƒ…å†µ\n    cout &lt;&lt; max_sum &lt;&lt; \" \" &lt;&lt; seq[former] &lt;&lt; \" \" &lt;&lt; seq[latter];\n}\n\n\nAppendixï¼ˆæ— éœ€è¾“å‡ºæœ€å¤§å­åºåˆ—å¤´å°¾ç‰ˆæœ¬ï¼‰#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, m, sum = 0, max_sum = 0;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; m;\n        sum = ((sum += m) &gt; 0 ? sum : 0);\n        max_sum = (sum &gt; max_sum ? sum : max_sum);\n    }\n    cout &lt;&lt; max_sum;\n}\n\n\n\n","slug":"1007-Maximum-Subsequence-Sum","date":"2022-02-27T06:48:38.000Z","categories_index":"PATï¼ˆAdvanced Levelï¼‰Practice","tags_index":"åŠ¨æ€è§„åˆ’,Cï¼‹ï¼‹","author_index":"Starlit Rover"},{"id":"b84d0f0ccbd1fa272bb501c55b437830","title":"ã€ŒSection 1ã€æ•°æ®æ ¼å¼","content":"\næœºå™¨æ•°ï¼šæ•°å€¼æ•°æ®åœ¨è®¡ç®—æœºä¸­çš„è¡¨ç°å½¢å¼ç§°ä¸ºæœºå™¨æ•°ã€‚\n\nè¡¨ç¤ºèŒƒå›´å—è®¡ç®—æœºå­—é•¿çš„é™åˆ¶\n\næœºå™¨æ•°çš„ç¬¦å·ä½å¿…é¡»è¢«æ•°å€¼åŒ–ä¸º0å’Œ1\n\næœºå™¨æ•°çš„å°æ•°ç‚¹æ˜¯ç”¨è§„å®šçš„éšå«æ–¹å¼æ¥è¡¨è¾¾çš„\nâš ï¸ è®¡ç®—æœºç¡¬ä»¶æ— æ³•åŒºåˆ†æœ‰ç¬¦å·ï¼ˆsigned ï¼‰ä¸æ— ç¬¦å·ï¼ˆunsigned ï¼‰æ•°ï¼Œåªèƒ½ç”±ç¨‹åºæŒ‡ä»¤åŠ ä»¥åŒºåˆ†\n\n\n\n\nå°æ•°ç‚¹çš„è¡¨ç¤ºæ–¹æ³•\n\nå®šç‚¹è¡¨ç¤ºæ³•ï¼šçº¦å®šæ‰€æœ‰æœºå™¨æ•°çš„å°æ•°ç‚¹ä½ç½®éƒ½æ˜¯å›ºå®šä¸å˜çš„ï¼Œå¯åˆ†ä¸ºå®šç‚¹å°æ•°ã€å®šç‚¹æ•´æ•°ä¸¤ç§ã€‚\n\nå®šç‚¹å°æ•°ï¼šç”¨äºè¡¨ç¤ºçº¯å°æ•°ï¼Œæœ€é«˜ä½æ˜¯ç¬¦å·ä½ï¼Œå› æ­¤ä½å®šç‚¹å°æ•°èƒ½è¡¨ç¤ºçš„æœ€ç²¾ç¡®æ•°ä¸ºï¼Œå³Bï¼ˆâ¨³ä¸ºæ–¹ä¾¿æè¿°ï¼Œå®šä¹‰è¡¨ç¤ºnä¸ªk ï¼‰\nå®šç‚¹æ•´æ•°ï¼šç”¨äºè¡¨ç¤ºçº¯æ•´æ•°ï¼Œæœ€é«˜ä½ä¹Ÿæ˜¯ç¬¦å·ä½ï¼Œå› æ­¤ä½å®šç‚¹æ•´æ•°èƒ½è¡¨ç¤ºçš„ç»å¯¹å€¼æœ€å¤§çš„æ•´æ•°ä¸ºï¼ˆä¸è€ƒè™‘è¡¥ç ï¼Œè¡¥ç åˆ™æ˜¯ï¼‰ï¼Œå³B\n\nâš ï¸ç„¶è€Œè®¡ç®—æœºæ‰€å¤„ç†çš„å¾ˆå¤šæ•°æ®å‡æ˜¯æ•´æ•°å’Œå°æ•°éƒ½ä¸ä¸º0çš„å®æ•°ï¼Œå› æ­¤åœ¨å®šç‚¹è®¡ç®—æœºä¸­ç»å¸¸éœ€è¦å°†å®æ•°ä¹˜ä»¥æ¥ç§»åŠ¨å°æ•°ç‚¹ä»è€Œæ»¡è¶³çº¯å°æ•°æˆ–çº¯æ•´æ•°çš„è¦æ±‚ï¼Œå¤„ç†å®Œåå†å¤åŸï¼Œ\ne.g. \n\næµ®ç‚¹è¡¨ç¤ºæ³•ï¼šä»¥ç§‘å­¦è®°æ•°æ³•è¡¨ç¤ºæ•°å€¼ï¼Œå…¶ä¸­è¡¨ç¤ºé˜¶æ•°ï¼Œæ•°æ®çš„å°æ•°ç‚¹ä½ç½®ç”±é˜¶æ•°å†³å®šï¼Œå› æ­¤æ˜¯æµ®åŠ¨çš„ã€‚\n\né˜¶ç çš„åº•ä¸€èˆ¬å–2çš„å¹‚æ¬¡2ã€8ã€16ï¼Œåœ¨æœºå™¨ä¸­è§„å®šéšå«ï¼ˆä¸è®°å½•ï¼‰\nå°¾æ•°æ˜¯ä¸€ä¸ªå®šç‚¹å°æ•°ï¼Œå†³å®šæµ®ç‚¹æ•°çš„ç²¾åº¦\né˜¶æ•°æ˜¯ä¸€ä¸ªå®šç‚¹æ•´æ•°ï¼Œå†³å®šæµ®ç‚¹æ•°çš„è¡¨ç¤ºèŒƒå›´\n\n\n\n\nå®šç‚¹æœºå™¨æ•°çš„è¡¨ç¤ºæ–¹æ³•ï¼šnä½å®šç‚¹ [æ•´æ•°\\å°æ•°] ä¸€èˆ¬æœ‰ä½æœºå™¨æ•°ï¼Œå³ç¬¦å·ä½ä¸åŒ…å«åœ¨nä½å®šç‚¹æ•°ä¸­\n\nåŸç ï¼šæœ€é«˜ä½è¡¨ç¤ºç¬¦å·ä½ï¼ˆ0æ­£1è´Ÿï¼Œä¸‹åŒ ï¼‰ï¼Œå…¶ä½™ä½ä¸ç»å¯¹å€¼ç›¸åŒã€‚\n\nå¯¹äºnä½å®šç‚¹æ•´æ•°ï¼Œæ­£æ•°ä¸ºå…¶æœ¬èº«ï¼Œè€Œè´Ÿæ•°åˆ™å…ˆå–å…¶ç»å¯¹å€¼å†åŠ ä¸Šæœ€é«˜ç¬¦å·ä½ï¼Œå› æ­¤å…¶åŸç ä¸º\nåŸ\n\nå¯¹äºnä½å®šç‚¹å°æ•°ï¼Œæ­£æ•°ä¸ºå…¶æœ¬èº«ï¼Œè´Ÿæ•°åˆ™å°†æ•´æ•°ä½å˜1ï¼Œå…¶ä½™ä½ä¸å˜ï¼Œå› æ­¤åŒå®šç‚¹æ•´æ•°å¯å¾—\nåŸ\n\n\nç‰¹ç‚¹ï¼š0æœ‰ä¸¤ä¸ªåŸç ï¼Œä¼šé€ æˆæ­§ä¹‰\n\n\n\nåç ï¼šæœ€é«˜ä½ä¸ºç¬¦å·ä½ï¼Œæ­£æ•°çš„å…¶ä½™ä½ä¸ºå…¶åŸç ï¼Œè´Ÿæ•°åˆ™æŒ‰åŸç å–åã€‚\n\nå¯¹äºnä½å®šç‚¹æ•´æ•°ï¼Œæ­£æ•°ä¸ºå…¶æœ¬èº«ï¼Œè€Œå¯¹è´Ÿæ•°æ¥è¯´ï¼Œåœ¨ä¸è€ƒè™‘ç¬¦å·ä½çš„æƒ…å†µä¸‹æ ¹æ®åç å®šä¹‰æœ‰åï¼Œå†è€ƒè™‘ç¬¦å·ä½å¯å¾— å ï¼Œå› æ­¤å…¶åç ä¸º\n\n å\n \n\nå¯¹äºnä½å®šç‚¹å°æ•°ï¼Œæ­£æ•°ä¸ºå…¶æœ¬èº«ï¼Œè€Œå¯¹è´Ÿæ•°æ¥è¯´ï¼Œæ³¨æ„åˆ°äºŒè¿›åˆ¶ä¸­æœ‰ï¼Œé‚£ä¹ˆåŒç†æœ‰åï¼Œå†è€ƒè™‘ç¬¦å·ä½1å¯å¾—åï¼Œå› æ­¤å…¶åç ä¸º\n\nå\n \n\nç‰¹ç‚¹ï¼š0ä¾ç„¶æœ‰ä¸¤ä¸ªåŸç ï¼›é€šå¸¸ä½œä¸ºè¡¥ç è½¬æ¢çš„ä¸­é—´æ€\n\n\n\nâ˜…è¡¥ç â˜…ï¼šæœ€é«˜ä½ä¸ºç¬¦å·ä½ï¼Œæ­£æ•°çš„å…¶ä½™ä½å–åŸç ï¼Œè´Ÿæ•°å…¶ä½™ä½å–åç +1.\n\nå¯¹äºnä½å®šç‚¹æ•´æ•°ï¼Œæ ¹æ®å…¶å®šä¹‰ä»¥åŠå‰åŸç ä¸åç çš„è¡¨è¾¾å¼ï¼Œå¯å¾—\n  è¡¥\nâš ï¸è´Ÿæ•°éƒ¨åˆ†å–ä¸åˆ°0ï¼Œä½†æ•´ä½“èŒƒå›´å¾€è´Ÿæ–¹å‘å¹³ç§»1\n\nå¯¹äºnä½å®šç‚¹å°æ•°ï¼Œå–åç ååŠ 1åŠ çš„æ˜¯æœ€åä¸€ä½ï¼Œå³ï¼Œå› æ­¤å¯å¾—\n  è¡¥\n  âš ï¸è´Ÿæ•°éƒ¨åˆ†å¯ä»¥å–åˆ°-1äº†ï¼Œ-1çš„è¡¥ç ä¸ºï¼Œè¿™ä¸ªç¼–ç åœ¨åç ä¸­ä¸º0ï¼Œåœ¨è¡¥ç ä¸­ç”±äºè´Ÿæ•°å–å€¼èŒƒå›´çš„æ•´ä½“å¹³ç§»ï¼Œä½¿å¾—0å°†è‡ªå·±çš„ä¸€ä¸ªç¼–ç è®©å‡ºæ¥ç»™äº†-1ã€‚\n\nç‰¹ç‚¹ï¼šè®¡ç®—æœºä¸­æœ€å¹¿æ³›åº”ç”¨çš„ä¸€ç§æœºå™¨æ•°è¡¨ç¤ºæ–¹æ³•ï¼Œèƒ½å°†å‡æ³•ç”¨åŠ æ³•å®ç°ï¼ˆè¡¥ç å¹²äº†ä»€ä¹ˆï¼šåç æ—¶å¸®ä½ åšäº†å‡æ³•ï¼Œè¡¥ç +1æŠµæ¶ˆ-1ï¼Œè€Œè¶…è¿‡nä½å‘ç”Ÿä¸Šæº¢ï¼Œä»è€Œå‡ºè‰²åœ°å®Œæˆäº†å‡æ³•ï¼‰\nè¡¥è¡¥\n\n\n\nç§»ç ï¼šæœ€é«˜ä½ä¸ºç¬¦å·ä½ï¼Œä½†æ˜¯0è´Ÿ1æ­£ï¼å…¶ä½™ä½ä¸è¡¥ç ç›¸åŒç§»å…¶ä¸­ç§°ä¸ºåç§»é‡.\n\n\n\n\n","slug":"æ•°æ®æ ¼å¼","date":"2022-02-24T09:03:45.000Z","categories_index":"è®¡ç®—æœºç»„æˆåŸç†","tags_index":"notes","author_index":"Starlit Rover"},{"id":"8a97cd3a588257a772fc378d09ae2199","title":"ã€ŒSection 1ã€è®¡ç®—æœºç½‘ç»œçš„æ¦‚å¿µ","content":"\nè®¡ç®—æœºç½‘ç»œï¼šä¸€ä¸ªå°†åˆ†æ•£çš„ã€å…·æœ‰ç‹¬ç«‹åŠŸèƒ½çš„è®¡ç®—æœºç³»ç»Ÿï¼Œé€šè¿‡é€šä¿¡è®¾å¤‡ä¸çº¿è·¯è¿æ¥èµ·æ¥ï¼Œç”±åŠŸèƒ½å®Œå–„çš„è½¯ä»¶å®ç°èµ„æºå…±äº«å’Œä¿¡æ¯ä¼ é€’çš„ç³»ç»Ÿã€‚ æ€»çš„æ¥è¯´ï¼Œè®¡ç®—æœºç½‘ç»œæ˜¯äº’è¿çš„ã€è‡ªæ²»çš„ï¼ˆæ— ä¸»ä»å…³ç³» ï¼‰è®¡ç®—æœºé›†åˆã€‚\n\nè®¡ç®—æœºç½‘ç»œçš„åŠŸèƒ½\n\næ•°æ®é€šä¿¡ï¼ˆè¿é€šæ€§ ï¼‰\nèµ„æºå…±äº«\nåˆ†å¸ƒå¼å¤„ç†ï¼šå¤šå°è®¡ç®—æœºå„è‡ªæ‰¿æ‹…åŒä¸€å·¥ä½œä»»åŠ¡çš„ä¸åŒéƒ¨åˆ†\næé«˜å¯é æ€§\nè´Ÿè½½å‡è¡¡\n\n\n\nè®¡ç®—æœºç½‘ç»œçš„ç»„æˆ\n\nç»„æˆéƒ¨åˆ†ï¼šç¡¬ä»¶ï¼ˆä¸»æœºã€é“¾è·¯ã€é€šä¿¡è®¾å¤‡ ï¼‰ã€è½¯ä»¶ã€åè®®ï¼ˆä¿è¯å®‰å…¨å¯é çš„ä¼ è¾“ ï¼‰\n\nå·¥ä½œæ–¹å¼ï¼š\n\nè¾¹ç¼˜éƒ¨åˆ†ï¼šä¸»æœºå­˜åœ¨çš„éƒ¨åˆ†ï¼Œç”¨æˆ·ç›´æ¥ä½¿ç”¨\næ ¸å¿ƒéƒ¨åˆ†ï¼šä¸ºè¾¹ç¼˜éƒ¨åˆ†æœåŠ¡\n\n\nåŠŸèƒ½ç»„æˆ\n\né€šä¿¡å­ç½‘ï¼šå®ç°æ•°æ®é€šä¿¡\nèµ„æºå­ç½‘ï¼šå®ç°èµ„æºå…±äº«/æ•°æ®å¤„ç† \nèµ„æºå¤„ç†â†’é€šä¿¡ä¼ è¾“\n\n\n\n\nè®¡ç®—æœºç½‘ç»œçš„åˆ†ç±»\n\nåˆ†å¸ƒèŒƒå›´ï¼šå¹¿åŸŸç½‘WANï¼ˆäº¤æ¢æŠ€æœ¯ ï¼‰ï¼ŒåŸåŸŸç½‘MANï¼Œå±€åŸŸç½‘LANï¼ˆå¹¿æ’­æŠ€æœ¯ ï¼‰ï¼Œä¸ªäººåŒºåŸŸç½‘PAN\nä½¿ç”¨è€…ï¼šå…¬ç”¨ç½‘ï¼ˆe.g. ä¸­å›½ç”µä¿¡ ï¼‰ï¼Œä¸“ç”¨ç½‘ï¼ˆe.g. æ”¿åºœï¼Œå†›æ–¹ ï¼‰\näº¤æ¢æŠ€æœ¯ï¼šç”µè·¯äº¤æ¢ï¼ŒæŠ¥æ–‡äº¤æ¢ï¼Œåˆ†ç»„äº¤æ¢\næ‹“æ‰‘ç»“æ„ ï¼ˆé€šè®¯è®¾å¤‡è§†ä¸ºç‚¹ï¼Œé“¾è·¯è§†ä¸ºè¾¹ ï¼‰ï¼šæ˜Ÿå‹ï¼Œæ€»çº¿å‹ï¼Œç¯å‹ï¼Œç½‘çŠ¶å‹ï¼ˆå¸¸ç”¨äºå±€åŸŸç½‘ ï¼‰\n\n\nä¼ è¾“æŠ€æœ¯ï¼šå¹¿æ’­å¼ç½‘ç»œï¼ˆå…±äº«å…¬å…±é€šä¿¡ä¿¡é“ ï¼‰ï¼Œç‚¹å¯¹ç‚¹ç½‘ç»œï¼ˆä½¿ç”¨åˆ†ç»„å­˜å‚¨è½¬å‘å’Œè·¯ç”±é€‰æ‹©æœºåˆ¶ ï¼‰\n\nMindmapï¼ˆfrom ç‹é“è€ƒç ” ï¼‰\n\n\n\n","slug":"è®¡ç®—æœºç½‘ç»œçš„æ¦‚å¿µ","date":"2022-02-23T13:03:14.000Z","categories_index":"è®¡ç®—æœºç½‘ç»œ","tags_index":"notes","author_index":"Starlit Rover"},{"id":"f036210e20161e9bc9972b673206da20","title":"åšå®¢ç€ç«äº‹ä»¶","content":"\n\næµ‘æµ‘ï¼Œå™©å™©ã€‚\n\né¦–å…ˆï¼Œæˆ‘åªæƒ³å¯¹åœ¨åº§çš„å„ä½è¯´ï¼š\nä¸€å®šè¦è®°å¾—å¤‡ä»½ï¼ï¼ï¼\n\né¬¼çŸ¥é“æˆ‘æ˜¨å¤©æ™šä¸Šç»å†äº†ä»€ä¹ˆâ€¦\n\n\næˆ‘çš„åšå®¢æ˜¯æ‰˜ç®¡åœ¨Githubä¸Šçš„ï¼Œä½†Githubä¹Ÿåªæ˜¯é™æ€æ‰˜ç®¡ï¼Œä¸Šé¢åªæœ‰å·²ç»ç”Ÿæˆçš„ç½‘é¡µä»£ç ï¼Œè€ŒçœŸæ­£çš„æºä»£ç ä»¥åŠæ¯ç¯‡æ–‡ç« çš„mdæ–‡ä»¶éƒ½æ˜¯å­˜æ”¾åœ¨æœ¬åœ°çš„ä¸€ä¸ªå¤§æ–‡ä»¶å¤¹é‡Œé¢çš„ã€‚è¿™ä¹ˆé‡è¦çš„æ–‡ä»¶å¤¹ï¼Œé‚£å¿…ç„¶å¾—å¤‡ä»½ä¸€æ³¢å•Šï¼Œä¸‡ä¸€é­é‡ä¸ªä»€ä¹ˆä¸æµ‹â€¦ï¼ˆé˜…è¯»ç†è§£ï¼šæ­¤å¤„ä¸ºåæ–‡åŸ‹ä¸‹ä¼ç¬”ï¼Œæš—ç¤ºä¸»äººå…¬å‘½è¿çš„æ‚²å‰§èµ°å‘ï¼Œä½¿æ¬§äº¨åˆ©å¼ç»“å°¾å‡ºäººæ„æ–™åˆåˆä¹æƒ…ç† ï¼‰äºæ˜¯ä¹ï¼Œæˆ‘æ‰“å¼€ç™¾åº¦äº‘ï¼Œæƒ³æŠŠè¿™ä¸ªå¤§æ–‡ä»¶å¤¹æ‹–åˆ°å¤‡ä»½æ–‡ä»¶å¤¹ä¸­ã€‚å°±æ˜¯è¿™è½»è½»çš„ä¸€æ‹–ï¼Œæˆ‘å¯»æ€ç€é­”æ³•éƒ½æ²¡è¿™ä¹ˆç¥å¥‡â€”â€”æ•´ä¸ªå¤§æ–‡ä»¶å¤¹ç›´æ¥æ¶ˆå¤±äº†ï¼Ÿï¼Ÿ\nçœŸçš„æ˜¯ç¦»è°±ä»–å¦ˆç»™ç¦»è°±å¼€é—¨ï¼Œç¦»è°±åˆ°å®¶äº†å¥½å§\næˆ‘ç¿»éäº†æ•´ä¸ªç”µè„‘ï¼ŒåºŸçº¸ç¯“ï¼ŒiCloudï¼ˆæ¡Œé¢å¤‡ä»½ç«Ÿç„¶é»˜è®¤å…³é—­ï¼‰ã€‚ä¸é”™ä¸é”™ï¼ŒçœŸæ­£ä½“ä¼šåˆ°ä»€ä¹ˆå«åšäººé—´è’¸å‘ã€‚åæ¥æˆ‘åˆç”¨äº†äº›æ•°æ®æ¢å¤è½¯ä»¶ï¼Œç”šè‡³è¿˜å’Œè‹¹æœå®¢æœèŠäº†åŠå¤©ï¼Œæœ€ç»ˆæˆåŠŸè¯æ˜ç¡®å®æ˜¯æ‰¾ä¸å›æ¥äº†å‘¢ã€‚æ²¡çŒœé”™çš„è¯ï¼Œåº”è¯¥æ˜¯æˆ‘æ— æ„é—´è§¦å‘äº†ç™¾åº¦äº‘çš„å“ªä¸ªé­”æ³•bugâ€¦\nè®©æˆ‘è§‰å¾—æœ€è®½åˆºçš„æ˜¯ï¼Œ\nä¸€ä¸ªæ–‡ä»¶å¤¹ç«Ÿç„¶åœ¨å¤‡ä»½çš„è¿‡ç¨‹ä¸­å‡ºç°äº†æ„å¤–\n\nå¹¸å¥½æœ¬åœ°åœ¨ä¸‹ä¸€æ¬¡deployè‡³Githubä¹‹å‰æ˜¯ä¸ä¼šå½±å“é™æ€æ‰˜ç®¡çš„ï¼Œä¹Ÿå°±æ˜¯ç½‘é¡µæš‚æ—¶ä¸ä¼šæœ‰ä»€ä¹ˆå˜åŒ–ã€‚ä½†æˆ‘è¦æ˜¯ä¸è¡¥å…¨ä¹‹å‰æ–‡ç« çš„mdæ–‡ä»¶çš„è¯ï¼Œä¸‹æ¬¡deployåä¹‹å‰çš„æ–‡ç« å°±ä¼šæ¶ˆå¤±ã€‚å½“ç„¶åœ¨è¡¥æ–‡ç« ä¹‹å‰è¿˜éœ€è¦é‡å»ºåšå®¢ç¯å¢ƒï¼Œæ‰€å¹¸æ¯æ¬¡è§£å†³é—®é¢˜åæˆ‘éƒ½ä¼šåœ¨ç¬¬ä¸€ç¯‡æ–‡ç« çš„è¯„è®ºé‡Œç•™ä¸‹è§£å†³æ—¥å¿—ï¼Œä»è€Œå¾—ä»¥å¿«é€Ÿé‡æ­ç¯å¢ƒã€‚\n\nÏƒæ„Ÿè§‰ï¼Œåƒæ˜¯ä¸€åœºå¤©é™å¤§ç«ï¼Œä¸€æŠŠå°±çƒ§äº†ä¸ªç²¾å…‰ã€‚\næµ´ç«ï¼Œè¦ä¹ˆæ­»å»ï¼Œè¦ä¹ˆé‡ç”Ÿã€‚\næ˜¯è¿™æ ·çš„ã€‚\n\n\n","slug":"åšå®¢ç€ç«äº‹ä»¶","date":"2022-02-11T02:55:42.000Z","categories_index":"Daily","tags_index":"blog","author_index":"Starlit Rover"},{"id":"e48195bb952699bdcd7eaab2b29014de","title":"7-50 ç•…é€šå·¥ç¨‹ä¹‹å±€éƒ¨æœ€å°èŠ±è´¹é—®é¢˜","content":"â³ENTRYæŸåœ°åŒºç»è¿‡å¯¹åŸé•‡äº¤é€šçŠ¶å†µçš„è°ƒæŸ¥ï¼Œå¾—åˆ°ç°æœ‰åŸé•‡é—´å¿«é€Ÿé“è·¯çš„ç»Ÿè®¡æ•°æ®ï¼Œå¹¶æå‡ºâ€œç•…é€šå·¥ç¨‹â€çš„ç›®æ ‡ï¼šä½¿æ•´ä¸ªåœ°åŒºä»»ä½•ä¸¤ä¸ªåŸé•‡é—´éƒ½å¯ä»¥å®ç°å¿«é€Ÿäº¤é€šï¼ˆä½†ä¸ä¸€å®šæœ‰ç›´æ¥çš„å¿«é€Ÿé“è·¯ç›¸è¿ï¼Œåªè¦äº’ç›¸é—´æ¥é€šè¿‡å¿«é€Ÿè·¯å¯è¾¾å³å¯ï¼‰ã€‚ç°å¾—åˆ°åŸé•‡é“è·¯ç»Ÿè®¡è¡¨ï¼Œè¡¨ä¸­åˆ—å‡ºäº†ä»»æ„ä¸¤åŸé•‡é—´ä¿®å»ºå¿«é€Ÿè·¯çš„è´¹ç”¨ï¼Œä»¥åŠè¯¥é“è·¯æ˜¯å¦å·²ç»ä¿®é€šçš„çŠ¶æ€ã€‚ç°è¯·ä½ ç¼–å†™ç¨‹åºï¼Œè®¡ç®—å‡ºå…¨åœ°åŒºç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚\nè¾“å…¥æ ¼å¼:è¾“å…¥çš„ç¬¬ä¸€è¡Œç»™å‡ºæ‘åº„æ•°ç›®N (1â‰¤Nâ‰¤100)ï¼›éšåçš„è¡Œå¯¹åº”æ‘åº„é—´é“è·¯çš„æˆæœ¬åŠä¿®å»ºçŠ¶æ€ï¼šæ¯è¡Œç»™å‡º4ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ä¸¤ä¸ªæ‘åº„çš„ç¼–å·ï¼ˆä»1ç¼–å·åˆ°Nï¼‰ï¼Œæ­¤ä¸¤æ‘åº„é—´é“è·¯çš„æˆæœ¬ï¼Œä»¥åŠä¿®å»ºçŠ¶æ€-1è¡¨ç¤ºå·²å»ºï¼Œ0è¡¨ç¤ºæœªå»ºã€‚\n\n\nè¾“å‡ºæ ¼å¼:è¾“å‡ºå…¨çœç•…é€šéœ€è¦çš„æœ€ä½æˆæœ¬ã€‚\nè¾“å…¥æ ·ä¾‹:4\n1 2 1 1\n1 3 4 0\n1 4 1 1\n2 3 3 0\n2 4 2 1\n3 4 5 0\n\nè¾“å‡ºæ ·ä¾‹:3\n\n\nÎ©åˆçœ‹è¿™é¢˜çš„åˆ†æ•°æ—¶ï¼Œæˆ‘è™èº¯ä¸€éœ‡â€¦ç«Ÿç„¶æœ‰35åˆ†ã€‚å›æƒ³è‡ªå·±ä»¥å¾€è¢«è™çš„éš¾é¢˜æœ€å¤šä¹Ÿåªæœ‰30åˆ†ï¼Œè«éæ˜¯ä»€ä¹ˆç»ä¸–éš¾é¢˜ã€‚\n\n\nä¸è¿‡â€¦çœ‹è¿™é¢˜ç›®é•¿åº¦å¹¶æ²¡æœ‰éš¾é¢˜çš„æ°”åŠ¿ã€‚\nè¯»å®Œé¢˜ç›®ï¼Œå¸¸è§„ä¹‹ä¸­é€ç€ä¸€ä¸ä¸ç¾ã€‚ç¬¬ä¸€æ„Ÿè§‰æ˜¯ä¸€é“æ±‚æœ€å°ç”Ÿæˆæ ‘çš„é¢˜ç›®ï¼Œä¸è¿‡åˆæœ‰æ‰€ä¸åŒï¼Œå› ä¸ºéƒ¨åˆ†è¾¹å·²ç»é€‰å®šäº†ï¼Œæˆ‘ä»¬éœ€è¦åœ¨é¢˜ç›®é€‰å®šéƒ¨åˆ†è¾¹çš„æƒ…å†µä¸‹é€‰å–æˆæœ¬ï¼ˆæƒå€¼ä¹‹å’Œï¼‰æœ€å°å¹¶èƒ½ä½¿æ‰€æœ‰ç‚¹è¿é€šçš„è¾¹ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œé‚£å°±æŠŠå·²ç»è¿é€šçš„ç‚¹ä»¬çœ‹ä½œä¸€ä¸ªå¤§ç‚¹ï¼Œç„¶åæ±‚å¤§ç‚¹ä»¬çš„æœ€å°ç”Ÿæˆæ ‘å°±å®Œäº‹äº†ã€‚å‚ç…§å¤„ç†æœ€å°ç”Ÿæˆæ ‘çš„Alg.Kruskalæ€æƒ³ï¼Œæˆ‘ä»¬å¯ä»¥æ¯æ¬¡é€‰å–ä¸€æ¡ä¸¤ä¸ªé¡¶ç‚¹ä¸åœ¨åŒä¸€ä¸ªè¿é€šé›†å†…ä¸”æƒå€¼æœ€å°çš„è¾¹ï¼Œç›´è‡³æ‰€æœ‰ç‚¹å‡è¿é€šã€‚\nå¯¹äºè¿é€šé›†çš„å¤„ç†ï¼Œé‚£å°±ä¸å¾—ä¸è¯´ä¸€è¯´å¹¶æŸ¥é›†ã€‚ä¸‹é¢ç®€å•ä»‹ç»ä¸€ä¸‹å¹¶æŸ¥é›†ã€‚\nWikipediaï¼šâ€å¹¶æŸ¥é›†æ˜¯ä¸€ç§ç”¨äºå¤„ç†ä¸€äº›ä¸äº¤é›†çš„åˆå¹¶åŠæŸ¥è¯¢é—®é¢˜çš„æ•°æ®ç»“æ„ã€‚â€ æˆ‘ä»¬éœ€è¦å¯¹ä¸€äº›å…ƒç´ è¿›è¡Œåˆ’åˆ†ï¼Œè¿™é‡Œå¯ä»¥è®¤ä¸ºå…ƒç´ ä¸­æœ‰è‹¥å¹²ä¸ªå¸®æ´¾ï¼Œå¸®æ´¾é‡Œçš„å…ƒç´ ä¹Ÿæœ‰ç­‰çº§åˆ¶åº¦ï¼ˆè¯¸å¦‚å¤´å¤´ï¼Œå¤§å“¥ï¼Œå°å¼Ÿï¼Œetcï¼‰ã€‚é‚£ä¹ˆäº‹å®ä¸Šæˆ‘ä»¬åªè¦è®©æ¯ä¸ªå…ƒç´ è®°ä½è‡ªå·±ä¸Šä¸€çº§æ˜¯è°å³å¯ï¼Œå³çˆ¶èŠ‚ç‚¹ï¼Œè€Œç­‰çº§æœ€é«˜å…ƒç´ çš„çˆ¶èŠ‚ç‚¹æ˜¯ä»–è‡ªå·±ï¼ŒæŠŠè¿™ç§å±‚æ¬¡å½¢è±¡åŒ–åå…¶å®å°±æ˜¯ä¸ªæ ‘çš„æ•°æ®ç»“æ„ã€‚é‚£ä¹ˆå¯¹ä»»æ„ä¸€ä¸ªå°å¼Ÿï¼Œé€šè¿‡ä¸æ–­è®¿é—®çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å°±èƒ½æ‰¾åˆ°æœ€å¤§çš„å¤´å¤´ã€‚å…¶æœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯æ¯ä¸ªå…ƒç´ åªå­˜è‡ªå·±çš„çˆ¶èŠ‚ç‚¹ã€‚å¯¹äºä¸¤ä¸ªå¸®æ´¾äº¤æ±‡ï¼Œè‹¥æƒ³è¦å…ƒç´ è¾ƒå°‘çš„å¸®æ´¾å½’é™„äºå¦ä¸€å¸®æ´¾ï¼Œåªè¦è®©è¯¥å¸®æ´¾å¤´å¤´çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘ï¼ˆè¿™é‡Œçš„æŒ‡å‘å¹¶ä¸æ˜¯è¯´çˆ¶èŠ‚ç‚¹æ˜¯æŒ‡é’ˆï¼Œä¹Ÿå¯ä»¥æ˜¯æ•°ç»„ï¼‰å¦ä¸€å¸®æ´¾çš„å¤´å¤´å³å¯ã€‚ä»¥ä¸Šæ‰€è¯´çš„è¿™ç§å‘¢æ˜¯æ¯«æ— ä¼˜åŒ–æœ€åŸºç¡€çš„å¹¶æŸ¥é›†ï¼Œå› ä¸ºå¾ˆæ˜¾ç„¶åœ¨ç‰¹æ®Šæƒ…å†µä¸‹å¯èƒ½ä¼šé€€åŒ–æˆé“¾è¡¨ã€‚æˆ‘ä»¬å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥è®©æ‰€æœ‰å¸®æ´¾æˆå‘˜çš„çˆ¶èŠ‚ç‚¹éƒ½æŒ‡å‘æœ€å¤§å…ƒç´ ï¼Œæœ‰å…´è¶£è¿›ä¸€æ­¥äº†è§£å¯ä»¥ç§»æ­¥è‡³ç®—æ³•å­¦ä¹ ç¬”è®°(1) : å¹¶æŸ¥é›†ã€‚\né‚£ä¹ˆæœ¬é¢˜ä¸­çš„æ‘åº„å¾ˆæ˜¾ç„¶å°±æ˜¯æˆ‘ä»¬è¦åˆ’åˆ†çš„å…ƒç´ ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å…ˆå®šä¹‰ä¸€ä¸ªå­˜å‚¨å„æ‘åº„çˆ¶èŠ‚ç‚¹çš„vectorï¼Œä¸€å¼€å§‹å‡åˆå§‹åŒ–ä¸ºè‡ªå·±:\nvector&lt;int&gt; belong(n);\niota(belong.begin(), belong.end(), 0);\n//belong-&gt;[0,1,2,...,n-1]\n\nåŒæ—¶æˆ‘ä»¬éœ€è¦ä¸€ä¸ªsizeå‘é‡æ¥å­˜å‚¨æ¯ä¸ªå¸®æ´¾ç°æœ‰çš„å…ƒç´ ä¸ªæ•°ï¼Œå¥½åœ¨å¸®æ´¾äº¤æ±‡æ—¶å†³å®šè°å¹¶å…¥è°ï¼Œè¿™æ˜¯ä¸€ç§ä¼˜åŒ–ç­–ç•¥ï¼š\nvector&lt;int&gt; size(n, 1);\n\nå¯¹äºå·²ç»å»ºæˆçš„å…¬è·¯ï¼Œå…¬è·¯ä¸¤ç«¯çš„æ‘åº„æ˜¯è¿é€šçš„ï¼Œéœ€è¦å°†è¿™ä¸¤ä¸ªå¸®æ´¾åˆå¹¶ï¼Œé‚£ä¹ˆå°±æ ¹æ®å°‘æ•°å¹¶å…¥å¤šæ•°çš„ç­–ç•¥è¿›è¡Œåˆå¹¶ï¼š\nint max_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[x] : belong[y],\n    min_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[y] : belong[x];\nbelong[min_idx] = max_idx;\nsize[max_idx] += size[min_idx];\n\nç”±äºæˆ‘æƒ³è¦çŸ¥é“åˆå§‹æƒ…å†µä¸‹è¿é€šé›†çš„ä¸ªæ•°ï¼Œå› æ­¤æˆ‘å¿…é¡»è®©æ‰€æœ‰æˆå‘˜å‡æŒ‡å‘å…¶å¸®æ´¾å¤´ç›®ï¼Œæ‰èƒ½å¾—çŸ¥æœ‰å‡ ä¸ªå¸®æ´¾å¤´ç›®ã€‚ä½†æ˜¯ä¸Šè¿°ä»£ç ä¼šå‘ç”Ÿä¸€ä¸ªå¸®æ´¾å¤´å¤´çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘äº†å¦ä¸€ä¸ªå¸®æ´¾å¤´å¤´ï¼Œä½†å…¶æ‰‹ä¸‹æˆå‘˜çš„çˆ¶èŠ‚ç‚¹å¹¶æœªæ›´æ–°ï¼Œå› æ­¤ç»“æŸä¸Šè¿°æ“ä½œåè¿˜éœ€æ‰¾åˆ°æ¯ä¸ªå…ƒç´ çœŸæ­£çš„å¤´å¤´ï¼š\nfor (auto &amp;v: belong)\n    while (v != belong[v])\n        v = belong[v];\n\næ­¤æ—¶belongä¸­éƒ½æ˜¯å¤´å¤´çš„ç¼–å·äº†ï¼Œæˆ‘ä»¬åªéœ€å°†å…¶æ”¾å…¥setå®¹å™¨ä¸­å³å¯å¾—çŸ¥è¿é€šé›†çš„ä¸ªæ•°ã€‚æ˜¾ç„¶ï¼Œæ¯æ¬¡æ‰¾ä¸€æ¡è¾¹åªèƒ½ä½¿è¿é€šé›†ä¸ªæ•°-1ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ‰¾çš„è¾¹æ•°å³æ˜¯è¿é€šé›†çš„ä¸ªæ•°-1ã€‚\n\nè¯è¯´å›æ¥ï¼Œæ¯æ¡å…¬è·¯çš„æˆæœ¬è¯¥æ€ä¹ˆå­˜å‘¢ï¼Ÿå…¶å®åˆçœ‹é¢˜ç›®çš„æ—¶å€™æˆ‘å°±çº³é—·å·²ç»ä¿®é€šçš„å…¬è·¯ä¸ºå•¥è¿˜è¦å‘Šè¯‰æˆ‘æˆæœ¬ã€‚å¦‚æœä¸ç»™çš„è¯ï¼Œæ•°æ®å€’æ˜¯ä¸è§„æ•´äº†â€¦ä¼°è®¡æ˜¯ç¨‹åºå‘˜é‚£è¯¥æ­»çš„å¼ºè¿«ç—‡ä½œç¥Ÿå§ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå…¶å®éœ€è¦çš„æ•°æ®ä¹Ÿä¸æ˜¯å¾ˆå¤šâ€¦æœ¬æ¥æœ€å¤§ä¹Ÿå°±çš„æˆæœ¬çŸ©é˜µï¼Œç°åœ¨æ²¡è¿™ä¸ªå¿µå¤´äº†ã€‚æœ¬æ¥æƒ³ç”¨mapå’Œpairç»“åˆçš„ï¼Œä¸è¿‡ç”±äºåé¢éœ€è¦å¯¹æˆæœ¬è¿›è¡Œæ’åºâ€¦sortå’Œmapå¤©æ€§ä¸æ­ï¼Œå…¨å‰§ç»ˆã€‚é‚£å°±æ‰¾mapä»–çˆ¸pair:\nvector&lt;pair&lt;pair&lt;int, int&gt;, int&gt; cost;\n/*pair&lt;pair&lt;village1,village2&gt;,cost&gt;*/\n\næœ€åï¼Œåªè¦å°†costæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¿›è¡Œsortï¼Œç„¶åæŒ‰é¡ºåºåˆ¤æ–­æ¯ä¸ªå…¬è·¯çš„ä¸¤ä¸ªæ‘åº„æ˜¯å¦ä½äºä¸¤ä¸ªè¿é€šé›†ï¼Œè‹¥æ˜¯åˆ™è®¡å…¥å…¶æˆæœ¬ç›´è‡³æœ‰ï¼ˆè¿é€šé›†çš„ä¸ªæ•°-1ï¼‰æ¡ç¬¦åˆæ¡ä»¶çš„å…¬è·¯ä¸ºæ­¢ã€‚å¦å¤–è¿™ä¸ªè¿‡ç¨‹éœ€è¦åŠ¨æ€æ›´æ–°è¿é€šé›†çš„å…³ç³»ï¼Œå› ä¸ºè¿é€šé›†çš„ä¸ªæ•°ä¸€ç›´åœ¨å˜å°‘ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\ntypedef pair&lt;pair&lt;int, int&gt;, int&gt; info;\n\nint main()\n{\n    int n, x, y, c;\n    bool flag;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; belong(n), size(n, 1);\n    vector&lt;info&gt; cost;\n    iota(belong.begin(), belong.end(), 0);\n    for (int i = 0; i &lt; n * (n - 1) / 2; ++i)\n    {\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c &gt;&gt; flag;\n        x -= 1; y -= 1;\n        if (!flag)\n            cost.push_back({ {x, y}, c});\n        else\n        {\n            int max_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[x] : belong[y],\n                min_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[y] : belong[x];\n            belong[min_idx] = max_idx;\n            size[max_idx] += size[min_idx];\n        }\n    }\n    for (auto &amp;v: belong)\n        while (v != belong[v])\n            v = belong[v];\n    set&lt;int&gt; div(belong.begin(), belong.end());\n    int all_cost = 0, idx = 0;\n    sort(cost.begin(), cost.end(), [](info &amp;a, info &amp;b) { return a.second &lt; b.second; });\n    for (int i = 1; i &lt; div.size(); ++i)\n    {\n        int v1, v2;\n        // ä¼˜åŒ–ç‰ˆ\n        do\n        {\n            v1 = cost[idx].first.first, v2 = cost[idx].first.second;\n            while (belong[v1] != belong[belong[v1]])\n                belong[v1] = belong[belong[v1]];\n            while (belong[v2] != belong[belong[v2]])\n                belong[v2] = belong[belong[v2]];\n            ++idx;\n        } while (belong[v1] == belong[v2]);\n        int max_idx = (size[belong[v1]] &gt; size[belong[v2]]) ? belong[v1] : belong[v2],\n            min_idx = (size[belong[v1]] &gt; size[belong[v2]]) ? belong[v2] : belong[v1];\n        belong[min_idx] = max_idx;\n        size[max_idx] += size[min_idx];\n        /* ç®€åŒ–ç‰ˆ\n        do\n        {\n            v1 = cost[idx].first.first, v2 = cost[idx].first.second;\n            ++idx;\n        } while (belong[v1] == belong[v2]);\n        belong[belong[v1]] = belong[v2];\n         */\n        all_cost += cost[idx - 1].second;\n    }\n    cout &lt;&lt; all_cost;\n}\n\nÎ£ å‡ ç‚¹è¯´æ˜\nmapçš„æœ¬è´¨æ˜¯pairï¼Œä½†pairçš„ä¸¤éƒ¨åˆ†æ˜¯å¹³ç­‰çš„ï¼Œä¸èƒ½é€šè¿‡å…¶ä¸€è®¿é—®å¦ä¸€ä¸ª\n\niotaå‡½æ•°åœ¨æŒ‡å®šåˆå€¼åå¯ä»¥ä½¿vectoræŒ‰å¢åºæ’åˆ—ï¼š\n#include &lt;numeric&gt;\n vector&lt;int&gt; v(num); //éœ€è¦å…ˆç¡®å®šå‘é‡å¤§å°\n iota(v.begin(),v.end(),start_num);\n//v=[start_num , start_num+1 , â€¦ , start_num+num-1]\n\nç»è¿‡å‡ æ¬¡å®éªŒï¼Œè¯»å…¥boolå˜é‡ï¼Œåªèƒ½è¾“å…¥0å’Œ1.è‹¥è¾“å…¥å…¶ä»–æ•°å­—å¯èƒ½ä¸ä¼šå½±å“boolå˜é‡çš„è¯»å…¥ï¼Œä½†ä¼šå½±å“åé¢å˜é‡çš„è¯»å…¥.\n\nä¼˜åŒ–ç‰ˆä»£ç åœ¨æŸ¥æ‰¾ç¬¦åˆæ¡ä»¶çš„å…¬è·¯æ—¶é¡ºä¾¿æ›´æ–°çˆ¶èŠ‚ç‚¹ï¼Œå¹¶ä¾æ—§æŒ‰ç…§å°å¹¶å¤§åŸåˆ™è¿›è¡Œåˆå¹¶ï¼Œè¿™åœ¨æ•°æ®è¾ƒå¤§æ—¶è¾ƒæœ‰ä¼˜åŠ¿ï¼›è€Œç®€åŒ–ç‰ˆåˆ™ç®€çŸ­ç²¾ç‚¼ï¼Œåˆå¹¶æ—¶ä¸ç®¡ä¸‰ä¸ƒäºŒåä¸€å‡å°†v1å¹¶å…¥v2ï¼Œä¹Ÿä¸æ›´æ–°çˆ¶èŠ‚ç‚¹. ä»¥ä¸‹æ˜¯ä¸¤è€…çš„æ—¶é—´æ¯”è¾ƒï¼š\nâ˜œä¼˜åŒ–ç‰ˆç®€åŒ–ç‰ˆâ˜\nâ£\nâ£\nâ£\nâ£\nâ£\nâ£\n\n\nÎ´ å½©è›‹ç„¶é¹…ç®€åŒ–ç‰ˆçœŸçš„æ˜¯å¯¹çš„å—ï¼Ÿå“ˆå“ˆå“ˆå“ˆï¼Œè™½ç„¶ç®€åŒ–ç‰ˆç¡®å®é€šè¿‡äº†æ‰€æœ‰æµ‹è¯•ç‚¹ï¼Œä½†æˆ‘ä¸€ç›´è§‰çš„ç®€åŒ–ç‰ˆä¸å¤Ÿä¸¥è°¨ï¼Œå› æ­¤å°è¯•ç€æšä¸¾ä¸€ä¸ªåä¾‹å‡ºæ¥ã€‚éšä¾¿æ„é€ äº†ä¸€ä¸ªï¼š\n\n\nç®€åŒ–ç‰ˆçœŸçš„æ˜¯å¯¹çš„å—ï¼Ÿå“ˆå“ˆå“ˆå“ˆï¼Œè™½ç„¶ç®€åŒ–ç‰ˆç¡®å®é€šè¿‡äº†æ‰€æœ‰æµ‹è¯•ç‚¹ï¼Œä½†æˆ‘ä¸€ç›´è§‰çš„ç®€åŒ–ç‰ˆä¸å¤Ÿä¸¥è°¨ï¼Œå› æ­¤å°è¯•ç€æšä¸¾ä¸€ä¸ªåä¾‹å‡ºæ¥ã€‚éšä¾¿æ„é€ äº†ä¸€ä¸ªï¼š\n5\n1 2 2 0\n1 3 10 1\n1 4 10 0\n1 5 3 0\n2 3 1 0\n2 4 10 1\n2 5 10 0\n3 4 10 0\n3 5 10 0\n4 5 10 0\n\nè¿™ä¸ªæµ‹è¯•ç”¨ä¾‹ä¼˜åŒ–ç‰ˆçš„ç»“æœæ˜¯4ï¼Œè€Œç®€åŒ–ç‰ˆçš„ç»“æœæ˜¯3ã€‚æ˜¾ç„¶ï¼Œç®€åŒ–ç‰ˆä¸­æªäº†ï¼Œæˆ‘æ„é€ çš„æ€è·¯å°±æ˜¯ç€çœ¼äºç®€åŒ–ç‰ˆä¸åŠ¨æ€æ›´æ–°å„ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹ï¼Œä¸æ›´æ–°ä¹Ÿå°±ç®—äº†ï¼Œåœ¨æ£€æŸ¥çš„æ—¶å€™è¿˜ä¸è®¿é—®å…ƒç´ çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œè¿™æ ·åœ¨ä¸€å®šçš„æ¡ä»¶ä¸‹å°±å¿…ç„¶ä¼šå¯¼è‡´é€‰ä¸­çš„ä¸€æ¡å…¬è·¯ï¼Œå…¶ç«¯ç‚¹ä¸¤ä¸ªæ‘åº„çš„çˆ¶èŠ‚ç‚¹ä¸åŒï¼Œç„¶è€Œåœ¨ä¹‹å‰çš„é€‰å–è¿‡ç¨‹ä¸­è¿™ä¸¤ä¸ªçˆ¶èŠ‚ç‚¹å·²ç»åˆå¹¶äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé€‰å–äº†ä¸€æ¡å¤„äºä¸€ä¸ªè¿é€šé›†ä¸­çš„å…¬è·¯ï¼ŒèŠ±äº†æ²¡å¿…è¦çš„é€ è·¯æˆæœ¬ã€‚\nå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆï¼Œè¯´çš„ç®€åŒ–ç‰ˆä¸æ˜¯æˆ‘å†™çš„ä¸€æ ·ï¼Œå…¶å®ç®€åŒ–ç‰ˆæ˜¯æˆ‘åœ¨æäº¤å®Œä¼˜åŒ–ç‰ˆåä¹±åˆ è€Œæˆçš„ã€‚å½“æ—¶å°±æƒ³ç€èƒ½ä¸èƒ½ç®€åŒ–ä»£ç ï¼Œä½†è‡ªå·±æ”¹æ”¹å¤ªç´¯äº†ï¼Œä¸å¦¨å…ˆè¯•ç€åˆ äº¿ç‚¹ç„¶åæäº¤çœ‹çœ‹ï¼Œå¦‚æœé€šè¿‡äº†é‚£å°±å†æ€è€ƒæ€è€ƒä¸ºä»€ä¹ˆå¯ä»¥åˆ æ‰ï¼Œäºæ˜¯ä¹ï¼Œæœ‰äº†è¿™ä¸ªå½©è›‹ï¼æˆ‘å·²ç»å°†è¿™ä¸ªé—®é¢˜ä»¥é‚®ä»¶çš„å½¢å¼å‘ç»™PTAäº†ï¼Œä½†æˆ‘æ²¡ç•™åå­—ï¼Œæˆ–è®¸ä»¥åèƒ½åœ¨è¿™é“é¢˜ä¸‹é¢çœ‹åˆ°æ„Ÿè°¢ä¸€ä½ä¸çŸ¥åçš„åŒå­¦è¡¥å……æ•°æ®ï¼é‚£ä¹ˆæ€ä¹ˆæ”¹æ­£ç®€åŒ–ç‰ˆå‘¢ï¼Œå…¶å®ä¸æ”¹do-whileéƒ¨åˆ†å°±å¥½äº†ï¼š\ndo\n{\n    v1 = cost[idx].first.first, v2 = cost[idx].first.second;\n    while (belong[v1] != belong[belong[v1]])\n        belong[v1] = belong[belong[v1]];\n    while (belong[v2] != belong[belong[v2]])\n        belong[v2] = belong[belong[v2]];\n    ++idx;\n} while (belong[v1] == belong[v2]);\nbelong[belong[v1]] = belong[v2];\n","slug":"7-50-ç•…é€šå·¥ç¨‹ä¹‹å±€éƒ¨æœ€å°èŠ±è´¹é—®é¢˜","date":"2022-02-09T14:37:31.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"Cï¼‹ï¼‹,Graph,pair,å¹¶æŸ¥é›†,numeric","author_index":"Starlit Rover"},{"id":"b06eec1520de8e94623ad87c71416a11","title":"7-48 é“¶è¡Œæ’é˜Ÿé—®é¢˜ä¹‹å•çª—å£â€œå¤¹å¡â€ç‰ˆ","content":"â³ENTRYæ’é˜Ÿâ€œå¤¹å¡â€æ˜¯å¼•èµ·å¤§å®¶å¼ºçƒˆä¸æ»¡çš„è¡Œä¸ºï¼Œä½†æ˜¯è¿™ç§ç°è±¡æ—¶å¸¸å­˜åœ¨ã€‚åœ¨é“¶è¡Œçš„å•çª—å£æ’é˜Ÿé—®é¢˜ä¸­ï¼Œå‡è®¾é“¶è¡Œåªæœ‰1ä¸ªçª—å£æä¾›æœåŠ¡ï¼Œæ‰€æœ‰é¡¾å®¢æŒ‰åˆ°è¾¾æ—¶é—´æ’æˆä¸€æ¡é•¿é¾™ã€‚å½“çª—å£ç©ºé—²æ—¶ï¼Œä¸‹ä¸€ä½é¡¾å®¢å³å»è¯¥çª—å£å¤„ç†äº‹åŠ¡ã€‚æ­¤æ—¶å¦‚æœå·²çŸ¥ç¬¬iä½é¡¾å®¢ä¸æ’åœ¨åé¢çš„ç¬¬jä½é¡¾å®¢æ˜¯å¥½æœ‹å‹ï¼Œå¹¶ä¸”æ„¿æ„æ›¿æœ‹å‹åŠç†äº‹åŠ¡çš„è¯ï¼Œé‚£ä¹ˆç¬¬iä½é¡¾å®¢çš„äº‹åŠ¡å¤„ç†æ—¶é—´å°±æ˜¯è‡ªå·±çš„äº‹åŠ¡åŠ æœ‹å‹çš„äº‹åŠ¡æ‰€è€—æ—¶é—´çš„æ€»å’Œã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¡¾å®¢çš„ç­‰å¾…æ—¶é—´å°±å¯èƒ½è¢«å½±å“ã€‚å‡è®¾æ‰€æœ‰äººåˆ°è¾¾é“¶è¡Œæ—¶ï¼Œè‹¥æ²¡æœ‰ç©ºçª—å£ï¼Œéƒ½ä¼šè¯·æ±‚æ’åœ¨æœ€å‰é¢çš„æœ‹å‹å¸®å¿™ï¼ˆåŒ…æ‹¬æ­£åœ¨çª—å£æ¥å—æœåŠ¡çš„æœ‹å‹ï¼‰ï¼›å½“æœ‰ä¸æ­¢ä¸€ä½æœ‹å‹è¯·æ±‚æŸä½é¡¾å®¢å¸®å¿™æ—¶ï¼Œè¯¥é¡¾å®¢ä¼šæ ¹æ®è‡ªå·±æœ‹å‹è¯·æ±‚çš„é¡ºåºæ¥ä¾æ¬¡å¤„ç†äº‹åŠ¡ã€‚è¯•ç¼–å†™ç¨‹åºæ¨¡æ‹Ÿè¿™ç§ç°è±¡ï¼Œå¹¶è®¡ç®—é¡¾å®¢çš„å¹³å‡ç­‰å¾…æ—¶é—´ã€‚\n\nè¾“å…¥æ ¼å¼:è¾“å…¥çš„ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°ï¼š1â‰¤Nâ‰¤10000ï¼Œä¸ºé¡¾å®¢æ€»æ•°ï¼›0â‰¤Mâ‰¤100ï¼Œä¸ºå½¼æ­¤ä¸ç›¸äº¤çš„æœ‹å‹åœˆå­ä¸ªæ•°ã€‚è‹¥Mé0ï¼Œåˆ™æ­¤åMè¡Œï¼Œæ¯è¡Œå…ˆç»™å‡ºæ­£æ•´æ•°2â‰¤Lâ‰¤100ï¼Œä»£è¡¨è¯¥åœˆå­é‡Œæœ‹å‹çš„æ€»æ•°ï¼Œéšåç»™å‡ºè¯¥æœ‹å‹åœˆé‡Œçš„Lä½æœ‹å‹çš„åå­—ã€‚åå­—ç”±3ä¸ªå¤§å†™è‹±æ–‡å­—æ¯ç»„æˆï¼Œåå­—é—´ç”¨1ä¸ªç©ºæ ¼åˆ†éš”ã€‚æœ€åNè¡Œç»™å‡ºNä½é¡¾å®¢çš„å§“åã€åˆ°è¾¾æ—¶é—´Tå’Œäº‹åŠ¡å¤„ç†æ—¶é—´Pï¼ˆä»¥åˆ†é’Ÿä¸ºå•ä½ï¼‰ï¼Œä¹‹é—´ç”¨1ä¸ªç©ºæ ¼åˆ†éš”ã€‚ç®€å•èµ·è§ï¼Œè¿™é‡Œå‡è®¾é¡¾å®¢ä¿¡æ¯æ˜¯æŒ‰ç…§åˆ°è¾¾æ—¶é—´å…ˆåé¡ºåºç»™å‡ºçš„ï¼ˆæœ‰å¹¶åˆ—æ—¶é—´çš„æŒ‰ç…§ç»™å‡ºé¡ºåºæ’é˜Ÿï¼‰ï¼Œå¹¶ä¸”å‡è®¾æ¯ä¸ªäº‹åŠ¡æœ€å¤šå ç”¨çª—å£æœåŠ¡60åˆ†é’Ÿï¼ˆå¦‚æœè¶…è¿‡åˆ™æŒ‰60åˆ†é’Ÿè®¡ç®—ï¼‰ã€‚\nè¾“å‡ºæ ¼å¼:æŒ‰é¡¾å®¢æ¥å—æœåŠ¡çš„é¡ºåºè¾“å‡ºé¡¾å®¢åå­—ï¼Œæ¯ä¸ªåå­—å 1è¡Œã€‚æœ€åä¸€è¡Œè¾“å‡ºæ‰€æœ‰é¡¾å®¢çš„å¹³å‡ç­‰å¾…æ—¶é—´ï¼Œä¿ç•™åˆ°å°æ•°ç‚¹å1ä½ã€‚\nè¾“å…¥æ ·ä¾‹:6 2\n3 ANN BOB JOE\n2 JIM ZOE\nJIM 0 20\nBOB 0 15\nANN 0 30\nAMY 0 2\nZOE 1 61\nJOE 3 10\nè¾“å‡ºæ ·ä¾‹:JIM\nZOE\nBOB\nANN\nJOE\nAMY\n75.2\n\nÎ©ç»ˆäºä¸å†æ˜¯ä¸€é“å¤„ç†å­—ç¬¦ä¸²çš„é¢˜ç›®äº†ï¼Œè¿™é“é¢˜è¾ƒå‰é¢å‡ é¢˜éƒ½ç•¥éš¾ä¸€äº›ï¼Œä¹Ÿæ›´æœ‰æ„æ€ä¸€ç‚¹ã€‚åˆçœ‹è¿™é“é¢˜çš„æ—¶å€™æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«å¥½çš„æ€è·¯ï¼Œæ„£äº†åŠå¤©ï¼Œä¸çŸ¥é“è¿™è·Ÿä»€ä¹ˆæ•°æ®ç»“æ„æœ‰å…³ï¼Œé‚£å°±ä¾æ„Ÿè§‰å†™å§ã€‚\nç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å¦‚ä½•å­˜å‚¨ä»–ä»¬ä¹‹é—´çš„æœ‹å‹å…³ç³»ï¼Œæœ€å…ˆæƒ³åˆ°çš„æ˜¯æ— å‘å›¾ï¼Œå»ºç«‹ä¸€ä¸ªå…³ç³»çŸ©é˜µï¼Œæœ€å¤§çš„æƒ…å†µæ˜¯ï¼Œå¾ˆå¯èƒ½ä¼šæ˜¯ä¸ªç¨€ç–çŸ©é˜µï¼Œæ„Ÿè§‰è¿™é“é¢˜æ²¡æœ‰å¿…è¦ç”¨å›¾ã€‚æˆ–è€…åªè¦æ¯ä¸ªé¡¾å®¢å­˜ä¸€ä¸‹è‡ªå·±æ‰€åœ¨æœ‹å‹åœˆçš„ç¼–å·ä¹Ÿæ˜¯å¯ä»¥ç›´æ¥åˆ¤æ–­ä¸¤äººæ˜¯å¦ä¸ºæœ‹å‹ã€‚è§‚å¯Ÿè¿™é“é¢˜çš„è¦æ±‚ï¼Œå…¶å®æ¯ä¸ªäººåªä¼šæ‰¾å‰ä¸€ä¸ªç¦»è‡ªå·±æœ€è¿‘çš„æœ‹å‹å¸®å¿™ï¼Œå› æ­¤æˆ‘ä»¬åªè¦çŸ¥é“æ¯ä¸ªé¡¾å®¢åé¢æœ€è¿‘çš„æœ‹å‹ä½ç½®å³å¯ã€‚ç”±æ­¤å¯ä»¥å»ºä¸€ä¸ªclientç±»ï¼š\nclass client\n{\npublic:\n    string name;\n    int T, P, nxt = -1;\n    //T-&gt;Arrival Time,P-&gt;Processing Time\n    //nxt-&gt;number in line of next friend,-1 means no friend in line behind himself\n}\né‚£ä¹ˆå½“æ¯ä½é¡¾å®¢éƒ½åŠå®Œäº‹åéƒ½çœ‹çœ‹é˜Ÿä¼åé¢æœ‰æ²¡æœ‰è‡ªå·±çš„æœ‹å‹ï¼Œæœ‰çš„è¯å¸®ä»–ä¹ŸåŠäº†ï¼Œä»¥æ­¤ç±»æ¨ã€‚æ³¨æ„å¦‚æœåŠå®Œäº‹æœ‹å‹è¿˜æ²¡åˆ°åˆ™ä¸èƒ½å¸®å¿™ã€‚æ•´æ¡é˜Ÿä¼çš„é¡ºåºå¯ä»¥ç”¨ä¸€ä¸ªvectorå­˜å‚¨ã€‚å¯¹äºå¸®å¿™åŠå®Œäº‹çš„æœ‹å‹ï¼Œå¯ä»¥é€‰æ‹©ä»é˜Ÿä¼ä¸­åˆ é™¤ï¼Œä¹Ÿå¯ä»¥è®¾ç½®ä¸€ä¸ªisProcessedçš„å¸ƒå°”å˜é‡æ¥æ ‡è®°ï¼Œè‹¥å·²å¤„ç†åˆ™continueã€‚å‰è€…å¯èƒ½ä¼šå¯¼è‡´å¾ªç¯å‡ºç°é—®é¢˜ï¼Œå› æ­¤è¿™é‡Œæˆ‘é€‰æ‹©çš„æ˜¯åè€…ã€‚ç”±äºè¿˜éœ€è¦è®¡ç®—å¹³å‡ç­‰å¾…æ—¶é—´(âš ï¸ç­‰å¾…æ—¶é—´ä¸åŒ…æ‹¬è‡ªå·±äº‹æƒ…å¤„ç†çš„æ—¶é—´)ï¼Œå› æ­¤è¦è®¾ç½®ä¸€ä¸ªtimeå˜é‡æ¥è®°å½•å½“å‰çš„æ—¶é—´ï¼Œtimeå‡å»å½“å‰é¡¾å®¢åˆ°è¾¾æ—¶é—´å³ä¸ºå…¶ç­‰å¾…æ—¶é—´ã€‚\nå½“æˆ‘ä»¥ä¸ºå¯èƒ½ä¼šæœ‰æµ‹è¯•ç‚¹è¶…æ—¶çš„æ—¶å€™ï¼Œç«Ÿç„¶ä¸€æ¬¡æ€§å…¨éƒ¨é€šè¿‡äº†ã€‚çœŸæ˜¯å¾ˆéš¾ä½“ä¼šåˆ°è¿™ç§feelingäº†ï¼Œä¸”è¡Œä¸”çæƒœå§ã€‚\n\nCâ˜ºDE#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nclass client\n{\npublic:\n    string name;\n    bool isProcessed = false;\n    int T, P, nxt = -1;\n\n    client(string _name, int t, int p):\n    name(move(_name)), T(t), P(p) {};\n};\n\nint main()\n{\n    int n, m, k;\n    cin &gt;&gt; n &gt;&gt; m;\n    map&lt;string, int&gt; circle;\n    //pre_loc[i]è¡¨ç¤ºæœ‹å‹åœˆiæ­¤æ—¶æœ€åä¸€ä¸ªè¯»å…¥çš„é¡¾å®¢åœ¨é˜Ÿä¼ä¸­çš„åºå·\n    vector&lt;int&gt; pre_loc(m, -1);\n    string name;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; k;\n        for (int j = 0; j &lt; k; ++j)\n        {\n            cin &gt;&gt; name;\n            circle[name] = i + 1;\n            //å¯¹æ²¡æœ‰æœ‹å‹åœˆçš„nameï¼Œcircle[name]ä¼šåˆå§‹åŒ–ä¸º0ï¼Œå› æ­¤+1ä½¿æœ‰æœ‹å‹åœˆçš„nameä¸ä¼šä¸º0\n        }\n    }\n    vector&lt;client&gt; queue;\n    int t, p;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; name &gt;&gt; t &gt;&gt; p;\n        queue.emplace_back(client(name, t, p &gt; 60 ? 60 : p));\n        if (circle[name])\n        {\n            if (pre_loc[circle[name] - 1] != -1)\n                queue[pre_loc[circle[name] - 1]].nxt = i;\n            pre_loc[circle[name] - 1] = i;\n        }\n    }\n    int time = 0, all_waiting_time = 0;\n    vector&lt;string&gt; final_list;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        if (queue[i].isProcessed)\n            continue;\n        //è€ƒè™‘çª—å£å­˜åœ¨é—²ç½®çš„æ—¶é—´\n        time = time &lt; queue[i].T ? queue[i].T : time;\n        int clt = i;\n        while (clt != -1 &amp;&amp; time &gt;= queue[clt].T)\n        {\n            all_waiting_time += (time - queue[clt].T);\n            time += queue[clt].P;\n            final_list.push_back(queue[clt].name);\n            queue[clt].isProcessed = true;\n            clt = queue[clt].nxt;\n        }\n    }\n    for (auto &amp;s: final_list)\n        cout &lt;&lt; s &lt;&lt; endl;\n    cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; 1.0 * all_waiting_time / n &lt;&lt; endl;\n}","slug":"7-48-é“¶è¡Œæ’é˜Ÿé—®é¢˜ä¹‹å•çª—å£â€œå¤¹å¡â€ç‰ˆ","date":"2022-02-08T14:22:42.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"Cï¼‹ï¼‹,vector","author_index":"Starlit Rover"},{"id":"0c577028a09af77ed6d5c0870f900894","title":"7-47 æ‰“å°é€‰è¯¾å­¦ç”Ÿåå•","content":"â³ENTRYå‡è®¾å…¨æ ¡æœ‰æœ€å¤š40000åå­¦ç”Ÿå’Œæœ€å¤š2500é—¨è¯¾ç¨‹ã€‚ç°ç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„é€‰è¯¾æ¸…å•ï¼Œè¦æ±‚è¾“å‡ºæ¯é—¨è¯¾çš„é€‰è¯¾å­¦ç”Ÿåå•ã€‚\nè¾“å…¥æ ¼å¼:è¾“å…¥çš„ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ­£æ•´æ•°ï¼šNï¼ˆâ‰¤40000ï¼‰ï¼Œä¸ºå…¨æ ¡å­¦ç”Ÿæ€»æ•°ï¼›Kï¼ˆâ‰¤2500ï¼‰ï¼Œä¸ºæ€»è¯¾ç¨‹æ•°ã€‚æ­¤åNè¡Œï¼Œæ¯è¡ŒåŒ…æ‹¬ä¸€ä¸ªå­¦ç”Ÿå§“åï¼ˆ3ä¸ªå¤§å†™è‹±æ–‡å­—æ¯+1ä½æ•°å­—ï¼‰ã€ä¸€ä¸ªæ­£æ•´æ•°Cï¼ˆâ‰¤20ï¼‰ä»£è¡¨è¯¥ç”Ÿæ‰€é€‰çš„è¯¾ç¨‹é—¨æ•°ã€éšåæ˜¯Cä¸ªè¯¾ç¨‹ç¼–å·ã€‚ç®€å•èµ·è§ï¼Œè¯¾ç¨‹ä»1åˆ°Kç¼–å·ã€‚\n\n\nè¾“å‡ºæ ¼å¼:é¡ºåºè¾“å‡ºè¯¾ç¨‹1åˆ°Kçš„é€‰è¯¾å­¦ç”Ÿåå•ã€‚æ ¼å¼ä¸ºï¼šå¯¹æ¯ä¸€é—¨è¯¾ï¼Œé¦–å…ˆåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¯¾ç¨‹ç¼–å·å’Œé€‰è¯¾å­¦ç”Ÿæ€»æ•°ï¼ˆä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ï¼‰ï¼Œä¹‹ååœ¨ç¬¬äºŒè¡ŒæŒ‰å­—å…¸åºè¾“å‡ºå­¦ç”Ÿåå•ï¼Œæ¯ä¸ªå­¦ç”Ÿåå­—å ä¸€è¡Œã€‚\nè¾“å…¥æ ·ä¾‹:10 5\nZOE1 2 4 5\nANN0 3 5 2 1\nBOB5 5 3 4 2 1 5\nJOE4 1 2\nJAY9 4 1 2 5 4\nFRA8 3 4 2 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 5 4 2\nLOR6 4 2 4 1 5\n\nè¾“å‡ºæ ·ä¾‹:1 4\nANN0\nBOB5\nJAY9\nLOR6\n2 7\nANN0\nBOB5\nFRA8\nJAY9\nJOE4\nKAT3\nLOR6\n3 1\nBOB5\n4 7\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n5 9\nAMY7\nANN0\nBOB5\nDON2\nFRA8\nJAY9\nKAT3\nLOR6\nZOE1\n\n\nÎ©å…¶å®è¿™é“é¢˜æˆ‘ä¸æ˜¯å¾ˆæƒ³å†™ï¼Œæ„Ÿè§‰è‡ªå·±å°†èƒŒè´Ÿç€æ°´æ–‡ç« çš„å«Œç–‘ï¼Œå› ä¸ºç¡®å®ä¸æ˜¯ä¸€èˆ¬çš„æ°´ï¼Œä½†debugè¿˜æ˜¯å¡äº†åŠå¤©ï¼Œå…¶ä¸­ä¸€äº›åå·ä¹Ÿå¯ä»¥æ‹¿å‡ºæ¥èŠä¸€èŠã€‚ç”±äºæ¯ä¸€é—¨è¯¾ç¨‹çš„å­¦ç”Ÿæ˜¯ä¸ä¼šé‡å¤çš„ï¼Œè€Œä¸”æœ€åéœ€è¦æŒ‰å­—æ¯åºè¾“å‡ºå­¦ç”Ÿåå•ï¼Œé‚£ä¹ˆè‡ªç„¶è€Œç„¶å°±æƒ³åˆ°äº†setå®¹å™¨ã€‚ç å‘¢ï¼Œä¹Ÿéå¸¸ç®€å•ï¼Œä¸‰ä¸‹äº”é™¤äºŒï¼Œå°±ä¸‰åæ¥è¡Œã€‚å†…å¿ƒæ„Ÿè§‰éå¸¸è‰¯å¥½ï¼Œå°æ‰‹ä¸€ç‚¹\nè¿è¡Œè¶…æ—¶è€ç†Ÿäººäº†ï¼Œå†…å¿ƒç‹‚å–œcoutï¼Œcinæ‹œæ‹œå§(å‚è§7-45 èˆªç©ºå…¬å¸VIPå®¢æˆ·æŸ¥è¯¢)â€¦ä¸è¿‡è¿™é‡Œæœ‰ä¸€ä¸ªé—®é¢˜ï¼šCä¸­çš„printfå’Œscanfè¦å¦‚ä½•ä¸C++çš„stringç±»å…¼å®¹ï¼Ÿ\nstring ç±»æä¾›äº†c_str()æ–¹æ³•å¯ä¾›printfï¼š\nprintf(\"%s\",str.c_str());\n\nå¦å¤–å¯¹äºscanfï¼Œæˆ‘ä»¬éœ€è¦ç”¨resizeæ–¹æ³•å…ˆç»™ stråˆ†é…ç©ºé—´ï¼Œç„¶åå†å°†strçš„å¤´æŒ‡é’ˆä¼ ç»™scanfï¼Œè¿™ä¸æˆ‘ä»¬è®¤è¯†çš„scanfç›¸åŒï¼š\nstr.resize(n);\nscanf(\"%s\",&amp;str[0]);\n\nå°æ‰‹ä¸€ç‚¹ï¼Œã€è¿è¡Œè¶…æ—¶ã€‘å˜æˆäº†ã€ç­”æ¡ˆé”™è¯¯ã€‘ï¼Ÿ\næ³¨æ„åˆ°å‰é¢5ä¸ªæµ‹è¯•ç‚¹éƒ½é€šè¿‡äº†ï¼Œæœ€åä¸€ä¸ªæµ‹è¯•ç‚¹çš„æ•°æ®é‡æ‹‰æ»¡ğŸ¤”ï¼Œä¼°è®¡æ˜¯å®¹å™¨çš„é—®é¢˜ã€‚äºæ˜¯æˆ‘å°†setæ¢æˆvectorï¼Œæœ€åå¯¹æ¯é—¨è¯¾ç¨‹çš„vectorè¿›è¡Œsortåè¾“å‡ºï¼Œbingoï¼å—¯ï¼Œçœ‹æ¥ç”¨setä¹Ÿè¦èŠ‚åˆ¶ï¼Œæ¯•ç«Ÿsetçš„åº•å±‚æ˜¯ç”¨çº¢é»‘æ ‘å®ç°çš„ï¼Œå¤æ‚åº¦å¿…ç„¶æ˜¯è¦æ¯”çº¿æ€§å®¹å™¨é«˜è®¸å¤šçš„ã€‚\n\nğŸ#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int n, k, c, m;\n    scanf(\"%d %d\", &amp;n, &amp;k);\n    string name;\n    name.resize(5);\n    vector&lt;vector&lt;string&gt;&gt; info(k, vector&lt;string&gt;());\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;name[0], &amp;c);\n        for (int j = 0; j &lt; c; ++j)\n        {\n            scanf(\"%d\", &amp;m);\n            info[m - 1].push_back(name);\n        }\n    }\n    for (int i = 0; i &lt; k; ++i)\n    {\n        printf(\"%d %d\\n\", i + 1, info[i].size());\n        sort(info[i].begin(), info[i].end());\n        for (auto &amp;w: info[i])\n            puts(w.c_str());\n    }\n}","slug":"7-47-æ‰“å°é€‰è¯¾å­¦ç”Ÿåå•","date":"2022-02-06T14:08:04.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"Cï¼‹ï¼‹,vector","author_index":"Starlit Rover"},{"id":"44dec690db2bddd5b1d02e910fef2f3a","title":"7-46 æ–°æµªå¾®åšçƒ­é—¨è¯é¢˜","content":"â³ENTRYæ–°æµªå¾®åšå¯ä»¥åœ¨å‘è¨€ä¸­åµŒå…¥â€œè¯é¢˜â€ï¼Œå³å°†å‘è¨€ä¸­çš„è¯é¢˜æ–‡å­—å†™åœ¨ä¸€å¯¹â€œ#â€ä¹‹é—´ï¼Œå°±å¯ä»¥ç”Ÿæˆè¯é¢˜é“¾æ¥ï¼Œç‚¹å‡»é“¾æ¥å¯ä»¥çœ‹åˆ°æœ‰å¤šå°‘äººåœ¨è·Ÿè‡ªå·±è®¨è®ºç›¸åŒæˆ–è€…ç›¸ä¼¼çš„è¯é¢˜ã€‚æ–°æµªå¾®åšè¿˜ä¼šéšæ—¶æ›´æ–°çƒ­é—¨è¯é¢˜åˆ—è¡¨ï¼Œå¹¶å°†æœ€çƒ­é—¨çš„è¯é¢˜æ”¾åœ¨é†’ç›®çš„ä½ç½®æ¨èå¤§å®¶å…³æ³¨ã€‚\næœ¬é¢˜ç›®è¦æ±‚å®ç°ä¸€ä¸ªç®€åŒ–çš„çƒ­é—¨è¯é¢˜æ¨èåŠŸèƒ½ï¼Œä»å¤§é‡è‹±æ–‡ï¼ˆå› ä¸ºä¸­æ–‡åˆ†è¯å¤„ç†æ¯”è¾ƒéº»çƒ¦ï¼‰å¾®åšä¸­è§£æå‡ºè¯é¢˜ï¼Œæ‰¾å‡ºè¢«æœ€å¤šæ¡å¾®åšæåˆ°çš„è¯é¢˜ã€‚\nè¾“å…¥æ ¼å¼:è¾“å…¥è¯´æ˜ï¼šè¾“å…¥é¦–å…ˆç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°Nï¼ˆâ‰¤ï¼‰ï¼ŒéšåNè¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€æ¡è‹±æ–‡å¾®åšï¼Œå…¶é•¿åº¦ä¸è¶…è¿‡140ä¸ªå­—ç¬¦ã€‚ä»»ä½•åŒ…å«åœ¨ä¸€å¯¹æœ€è¿‘çš„#ä¸­çš„å†…å®¹å‡è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªè¯é¢˜ï¼Œè¾“å…¥ä¿è¯#æˆå¯¹å‡ºç°ã€‚\n\n\nè¾“å‡ºæ ¼å¼:ç¬¬ä¸€è¡Œè¾“å‡ºè¢«æœ€å¤šæ¡å¾®åšæåˆ°çš„è¯é¢˜ï¼Œç¬¬äºŒè¡Œè¾“å‡ºå…¶è¢«æåˆ°çš„å¾®åšæ¡æ•°ã€‚å¦‚æœè¿™æ ·çš„è¯é¢˜ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºæŒ‰å­—æ¯åºæœ€å°çš„è¯é¢˜ï¼Œå¹¶åœ¨ç¬¬ä¸‰è¡Œè¾“å‡ºAnd k more â€¦ï¼Œå…¶ä¸­kæ˜¯å¦å¤–å‡ æ¡çƒ­é—¨è¯é¢˜çš„æ¡æ•°ã€‚è¾“å…¥ä¿è¯è‡³å°‘å­˜åœ¨ä¸€æ¡è¯é¢˜ã€‚\n\næ³¨æ„ï¼šä¸¤æ¡è¯é¢˜è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„ï¼Œå¦‚æœåœ¨å»æ‰æ‰€æœ‰éè‹±æ–‡å­—æ¯å’Œæ•°å­—çš„ç¬¦å·ã€å¹¶å¿½ç•¥å¤§å°å†™åŒºåˆ«åï¼Œå®ƒä»¬æ˜¯ç›¸åŒçš„å­—ç¬¦ä¸²ï¼›åŒæ—¶å®ƒä»¬æœ‰å®Œå…¨ç›¸åŒçš„åˆ†è¯ã€‚è¾“å‡ºæ—¶é™¤é¦–å­—æ¯å¤§å†™å¤–ï¼Œåªä¿ç•™å°å†™è‹±æ–‡å­—æ¯å’Œæ•°å­—ï¼Œå¹¶ç”¨ ä¸€ ä¸ª ç©º æ ¼ åˆ†éš”åŸæ–‡ä¸­çš„å•è¯ã€‚\n\nè¾“å…¥æ ·ä¾‹:4\nThis is a #test of topic#.\nAnother #Test of topic.#\nThis is a #Hot# #Hot# topic\nAnother #hot!# #Hot# topic\n\nè¾“å‡ºæ ·ä¾‹:Hot\n2\nAnd 1 more ...\n\n\nÎ©ç¬¬ä¸€æ¬¡æäº¤â€¦\nå¯ä»¥æ¥å—çš„å•¦ï¼Œæ¯•ç«Ÿ\nACåªæ˜¯codingä¸­çš„å†°æ·‡æ·‹ï¼Œdebugæ‰æ˜¯codingçš„æ­£é¤ã€‚\nâ€”â€”æ²ƒæ»‹åŸºç¡•å¾· \næœ¬é¢˜æ»¡åˆ†30åˆ†ï¼Œæˆ‘å·²ç»æ‹¿åˆ°äº†20åˆ†ï¼Œçœ‹æ¥ å¤§åŠ¿å·²å»ï¼Œè®©æˆ‘ä»¬çœ‹ä¸‹ä¸€é¢˜ åˆæ˜¯ä¸€äº›éå¸¸å¾®å°çš„ç»†èŠ‚æ‰€å¯¼è‡´çš„é”™è¯¯ã€‚\né€šè¿‡ä»”ç»†é˜…è¯»é¢˜ç›®ï¼Œä¸éš¾å‘ç°ã€æ³¨æ„ã€‘é‡Œé¢æœ‰ä¸€å¥éå¸¸æ˜¾çœ¼çš„è¯è¯´è¦ç”¨ **ä¸€ ä¸ª ç©º æ ¼** åˆ†éš”å•è¯ã€‚\nSo easyçš„å•¦ï½è¯»åˆ°ç©ºæ ¼çš„æ—¶å€™æŠŠåé¢çš„åˆ†éš”ç¬¦å…¨éƒ¨è¯»æ‰å°±å®Œäº‹äº†ã€‚\n\nå“¦å¯¹ï¼Œç©ºæ ¼å¯èƒ½åœ¨å¼€å¤´å“¦å¯¹ï¼Œéè‹±æ–‡å­—æ¯å’Œæ•°å­—çš„ç¬¦å·ä¹Ÿä¼šåˆ†éš”å“¦å¯¹ï¼Œç©ºæ ¼åé¢è¿˜å¯èƒ½æ˜¯ç»“æŸç¬¦â€™#â€™å“¦å¯¹ï¼Œä¼šä¸ä¼šâ€™#â€™ä¹‹é—´åªæœ‰ç©ºæ ¼å‘¢ğŸ˜…\n[å°æ‰‹ä¸€ç‚¹]\nå¯ä»¥æ¥å—çš„å•¦ï¼Œå°±å·®4åˆ†äº†å‘¢~ã€‚ã€‚ã€‚Ten minutes laterâ€¦\n\nä¸ç§‘å­¦å•Šï¼Œä¸€ä¸ªè¯é¢˜çš„æƒ…å†µæ€ä¹ˆä¼šå‡ºé”™å‘¢ï¼Œæˆ‘è¯•äº†âˆä¸ªè¾“å…¥äº†\næœ€åï¼Œæˆ‘åœ¨ç½‘ä¸Šæ‰¾åˆ°åˆ«äººACçš„ç æ¥è‡ªå·±æµ‹è¯•ï¼Œåˆšè¾“å®Œä¸€ä¸ªäººå°±å‚»äº†ğŸ˜… é€šè¿‡æ›´åŠ ä»”ç»†åœ°é˜…è¯»é¢˜ç›®ï¼Œä¸éš¾å‘ç° â€œå¦‚æœè¿™æ ·çš„è¯é¢˜ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºæŒ‰å­—æ¯åºæœ€å°çš„è¯é¢˜ï¼Œå¹¶åœ¨ç¬¬ä¸‰è¡Œè¾“å‡ºAnd k more â€¦â€ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸å­˜åœ¨â€And 0 more â€¦â€çš„è¾“å‡ºã€‚\näººè€äº†ï¼Œå¸Œæœ›çœ¼ç›è¿˜å¥åœ¨ã€‚\n\nCodeee#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\ntypedef pair&lt;string, int&gt; tc;\n\nint main()\n{\n    set&lt;string&gt; topics;\n    map&lt;string, int&gt; topics_cnt;\n    int n;\n    cin &gt;&gt; n;\n    getchar();\n    string str, topic;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        getline(cin, str);\n        for (int j = 0; j &lt; str.size(); ++j)\n            if (str[j] == '#')\n            {\n                j += 1;\n                while (str[j] != '#')\n                {\n                    if (isalnum(str[j]))\n                        topic += str[j];\n                    else //æµ‹è¯•ç‚¹2ï¼šéè‹±æ–‡å­—æ¯å’Œæ•°å­—ç¬¦å·ä¹Ÿå…·æœ‰åˆ†è¯ä½œç”¨\n                    {\n                        while (!isalnum(str[++j]) &amp;&amp; str[j] != '#');\n                        if (str[j] != '#' &amp;&amp; !topic.empty())\n                            topic += ' ';\n                        j -= 1;\n                    }\n                    ++j;\n                }\n                transform(topic.begin(), topic.end(), topic.begin(), ::tolower);\n                topics.insert(topic);\n                topic = \"\";\n            }\n        for (auto &amp;t: topics)\n            topics_cnt[t] += 1;\n        topics.clear();\n    }\n    vector&lt;tc&gt; cup(topics_cnt.begin(), topics_cnt.end());\n    sort(cup.begin(), cup.end(), [](tc &amp;a, tc &amp;b) { return a.second &gt; b.second; });\n    int index = 0;\n    string hottest_topic = cup[0].first;\n    while (++index &lt; cup.size() &amp;&amp; cup[index].second == cup[0].second)\n        if (cup[index].first &lt; hottest_topic)\n            hottest_topic = cup[index].first;\n    hottest_topic[0] = toupper(hottest_topic[0]);\n    cout &lt;&lt; hottest_topic &lt;&lt; endl &lt;&lt; cup[0].second &lt;&lt; endl;\n    if (index &gt; 1) //æµ‹è¯•ç‚¹3\n        cout &lt;&lt; \"And \" &lt;&lt; index - 1 &lt;&lt; \" more ...\";\n}\n\n\nâˆ‘ å‡ ç‚¹è¯´æ˜\nåŸºæœ¬æ€è·¯ï¼šä¸€æ¡å¾®åšä¸­çš„è¯é¢˜ç”¨setå­˜å‚¨å¯ä»¥é¿å…é‡å¤è®¡ç®—ï¼Œè¯»å®Œä¸€æ¡å¾®åšåå°†setä¸­çš„è¯é¢˜è®¡æ•°è‡³mapä¸­\n\nsortä¸èƒ½å¯¹mapè¿›è¡Œæ’åºï¼Œå› æ­¤å…ˆå°†åŸmapæ”¾ç½®äºåŒç±»å‹pairçš„vectorä¸­ï¼Œå†è¿›è¡Œæ’åºï¼Œæ’åºå®Œæ‰¾æœ€å°è¯é¢˜\n\nä¾ç„¶ç”¨transformå‡½æ•°å°†æ‰€æœ‰è‹±æ–‡å­—æ¯è½¬æ¢ä¸ºå°å†™ï¼Œæœ€åå°†é¦–å­—æ¯è½¬æ¢ä¸ºå¤§å†™\n\nè¿™é‡Œç”¨åˆ°çš„isalnumå‡½æ•°ç”¨æ¥åˆ¤æ–­å­—ç¬¦æ˜¯å¦ä¸ºå­—æ¯æˆ–æ•°å­—\n\n\n\nå‡½æ•°\n ä½œç”¨\n\n\n\nislower(char c)\næ˜¯å¦ä¸ºå°å†™å­—æ¯\n\n\nisupper(char c)\næ˜¯å¦ä¸ºå¤§å†™å­—æ¯\n\n\nisdigit(char c)\næ˜¯å¦ä¸ºæ•°å­—\n\n\nisalpha(char c)\næ˜¯å¦ä¸ºå­—æ¯\n\n\nisalnum(char c)\næ˜¯å¦ä¸ºå­—æ¯æˆ–è€…æ•°å­—\n\n\ntoupper(char c)\nå­—æ¯å°å†™è½¬å¤§å†™\n\n\ntolower(char c)\nå­—æ¯å¤§å†™è½¬å°å†™\n\n\n\n\n","slug":"7-46-æ–°æµªå¾®åšçƒ­é—¨è¯é¢˜","date":"2022-02-06T13:21:31.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"Cï¼‹ï¼‹,map,set","author_index":"Starlit Rover"},{"id":"bd9129163f952044453adc76640f4d91","title":"7-45 èˆªç©ºå…¬å¸VIPå®¢æˆ·æŸ¥è¯¢","content":"â³ENTRYä¸å°‘èˆªç©ºå…¬å¸éƒ½ä¼šæä¾›ä¼˜æƒ çš„ä¼šå‘˜æœåŠ¡ï¼Œå½“æŸé¡¾å®¢é£è¡Œé‡Œç¨‹ç´¯ç§¯è¾¾åˆ°ä¸€å®šæ•°é‡åï¼Œå¯ä»¥ä½¿ç”¨é‡Œç¨‹ç§¯åˆ†ç›´æ¥å…‘æ¢å¥–åŠ±æœºç¥¨æˆ–å¥–åŠ±å‡èˆ±ç­‰æœåŠ¡ã€‚ç°ç»™å®šæŸèˆªç©ºå…¬å¸å…¨ä½“ä¼šå‘˜çš„é£è¡Œè®°å½•ï¼Œè¦æ±‚å®ç°æ ¹æ®èº«ä»½è¯å·ç å¿«é€ŸæŸ¥è¯¢ä¼šå‘˜é‡Œç¨‹ç§¯åˆ†çš„åŠŸèƒ½ã€‚\nè¾“å…¥æ ¼å¼:è¾“å…¥é¦–å…ˆç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•°Nï¼ˆâ‰¤ï¼‰å’ŒKï¼ˆâ‰¤500ï¼‰ã€‚å…¶ä¸­Kæ˜¯æœ€ä½é‡Œç¨‹ï¼Œå³ä¸ºç…§é¡¾ä¹˜åçŸ­ç¨‹èˆªç­çš„ä¼šå‘˜,èˆªç©ºå…¬å¸è¿˜ä¼šå°†èˆªç¨‹ä½äºKå…¬é‡Œçš„èˆªç­ä¹ŸæŒ‰Kå…¬é‡Œç´¯ç§¯ã€‚éšåNè¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€æ¡é£è¡Œè®°å½•ã€‚é£è¡Œè®°å½•çš„è¾“å…¥æ ¼å¼ä¸ºï¼š18ä½èº«ä»½è¯å·ç ï¼ˆç©ºæ ¼ï¼‰é£è¡Œé‡Œç¨‹ã€‚å…¶ä¸­èº«ä»½è¯å·ç ç”±17ä½æ•°å­—åŠ æœ€åä¸€ä½æ ¡éªŒç ç»„æˆï¼Œæ ¡éªŒç çš„å–å€¼èŒƒå›´ä¸º0~9å’Œxå…±11ä¸ªç¬¦å·ï¼›é£è¡Œé‡Œç¨‹å•ä½ä¸ºå…¬é‡Œï¼Œæ˜¯(0, 15000]åŒºé—´å†…çš„æ•´æ•°ã€‚ç„¶åç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°Mï¼ˆâ‰¤ï¼‰ï¼Œéšåç»™å‡ºMè¡ŒæŸ¥è¯¢äººçš„èº«ä»½è¯å·ç ã€‚\n\nè¾“å‡ºæ ¼å¼:å¯¹æ¯ä¸ªæŸ¥è¯¢äººï¼Œç»™å‡ºå…¶å½“å‰çš„é‡Œç¨‹ç´¯ç§¯å€¼ã€‚å¦‚æœè¯¥äººä¸æ˜¯ä¼šå‘˜ï¼Œåˆ™è¾“å‡ºNo Infoã€‚æ¯ä¸ªæŸ¥è¯¢ç»“æœå ä¸€è¡Œã€‚\nè¾“å…¥æ ·ä¾‹:4 500\n330106199010080419 499\n110108198403100012 15000\n120104195510156021 800\n330106199010080419 1\n4\n120104195510156021\n110108198403100012\n330106199010080419\n33010619901008041x\nè¾“å‡ºæ ·ä¾‹:800\n15000\n1000\nNo Info\n\nCedo#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, int&gt; fly;\n    int m, n, k, d;\n    string id;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        cin &gt;&gt; id &gt;&gt; d;\n        fly[id] += (d &lt; k ? k : d);\n    }\n    cin &gt;&gt; m;\n    for (int i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; id;\n        if (fly.find(id) == fly.end())\n            cout &lt;&lt; \"No Info\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; fly[id] &lt;&lt; endl;\n    }\n}\nÎ©ä¹çœ‹è¿™é“é¢˜ä¹Ÿå¤ªç®€å•äº†å§ï¼Œç›´æ¥ç”¨mapå®¹å™¨ä¹±æ€ï¼Œä½†æ˜¯æäº¤ä¸Šè¿°ä»£ç åå´å¾—åˆ°ä¸‹é¢çš„ç»“æœï¼š\nå¼€å§‹çº³é—·äº†ï¼Œmapå®¹å™¨ä¼˜åŒ–çš„ä¸å¤Ÿå¥½ï¼Ÿå¾ªç€å¾€æ˜”æƒ¨ç—›ç»å†ï¼Œçªç„¶æƒ³èµ·coutæ˜¯ä¸ªè´¹æ—¶çš„è¾“å‡ºå‡½æ•°ï¼Œé‚£å°±æŠŠæ‰€æœ‰çš„coutæ”¹æˆprintfè¯•è¯•ï¼ˆæ»¡æ€€æœŸå¾….jpg)ï¿½æ€ä¹ˆè¿˜æ˜¯ä¸€æ ·çš„ç»“æœâ€¦cinå’Œcoutæ˜¯ä¸€ä¼™çš„ï¼Œä¸€èµ·å¹²äº†å§ã€‚\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nint main()\n{\n    map&lt;string, int&gt; fly;\n    int m, n, k, d;\n    char id[19];\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 0; i &lt; n; ++i)\n    {\n        scanf(\"%s %d\", &amp;id, &amp;d);\n        fly[id] += (d &lt; k ? k : d);\n    }\n    scanf(\"%d\", &amp;m);\n    for (int i = 0; i &lt; m; ++i)\n    {\n        scanf(\"%s\", &amp;id);\n        if (fly[id])\n            printf(\"%d\\n\", fly[id]);\n        else\n            printf(\"No Info\\n\");\n        // è‹¥idä¸å­˜åœ¨ï¼Œåˆ™fly[id]è‡ªåŠ¨åˆå§‹åŒ–ä¸º0\n    }\n}\n[å°æ‰‹ä¸€ç‚¹]\nå—¯ï¼Ÿ(çœç•¥ä¸€åƒå­—è„è¯â€¦\nç”±äºè¿è¡Œè¶…æ—¶çš„ä»£ç çœ‹ä¸äº†è¿è¡Œæ—¶é—´ï¼Œå› æ­¤æˆ‘åˆé¡ºå¸¦æŠŠprintfæ”¹å›coutä¹Ÿæ˜¯å¯ä»¥é€šè¿‡çš„ï¼š\nå—¯ï¼Œåœ¨å±é™©çš„è¾¹ç¼˜ç–¯ç‹‚è¯•æ¢â€¦(é™æ—¶400ms)\n\nÎ£ ç»“è¯­äº‹å®ä¸Šå·²ç»æœ‰å¾ˆå¤šäººåšè¿‡å…³äºcinã€cout ä¸scanfã€printfçš„æ•ˆç‡æ¯”è¾ƒå®éªŒäº†ï¼Œæµ‹è¯•ç»“æœæ˜¾ç¤ºåè€…æ¯”å‰è€…å¿«äº†å°†è¿‘10å€. æœ‰ä¸€ç§è§£é‡Šè®¤ä¸ºå‰è€…éœ€è¦ç¼“å­˜è€Œåè€…ç›´æ¥è°ƒç”¨ç³»ç»Ÿçš„IOå‡½æ•°ï¼Œæ˜¯éç¼“å­˜çš„. å¦å¤–æµè¾“å…¥è¾“å‡ºä¾èµ–äºå‡½æ•°é‡è½½ï¼Œä¹Ÿä¼šé€ æˆæ•ˆç‡çš„ä½ä¸‹.\n","slug":"7-45-èˆªç©ºå…¬å¸VIPå®¢æˆ·æŸ¥è¯¢","date":"2022-02-02T12:48:48.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"Cï¼‹ï¼‹,map","author_index":"Starlit Rover"},{"id":"c1bb0c3958152b806f4d44bad6ebbf7f","title":"7-44 åŸºäºè¯é¢‘çš„æ–‡ä»¶ç›¸ä¼¼åº¦","content":"â³ENTRYå®ç°ä¸€ç§ç®€å•åŸå§‹çš„æ–‡ä»¶ç›¸ä¼¼åº¦è®¡ç®—ï¼Œå³ä»¥ä¸¤æ–‡ä»¶çš„å…¬å…±è¯æ±‡å æ€»è¯æ±‡çš„æ¯”ä¾‹æ¥å®šä¹‰ç›¸ä¼¼åº¦ã€‚ä¸ºç®€åŒ–é—®é¢˜ï¼Œè¿™é‡Œä¸è€ƒè™‘ä¸­æ–‡ï¼ˆå› ä¸ºåˆ†è¯å¤ªéš¾äº†ï¼‰ï¼Œåªè€ƒè™‘é•¿åº¦ä¸å°äº3ã€ä¸”ä¸è¶…è¿‡10çš„è‹±æ–‡å•è¯ï¼Œé•¿åº¦è¶…è¿‡10çš„åªè€ƒè™‘å‰10ä¸ªå­—æ¯ã€‚\nè¾“å…¥æ ¼å¼:è¾“å…¥é¦–å…ˆç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤100ï¼‰ï¼Œä¸ºæ–‡ä»¶æ€»æ•°ã€‚éšåæŒ‰ä»¥ä¸‹æ ¼å¼ç»™å‡ºæ¯ä¸ªæ–‡ä»¶çš„å†…å®¹ï¼šé¦–å…ˆç»™å‡ºæ–‡ä»¶æ­£æ–‡ï¼Œæœ€ååœ¨ä¸€è¡Œä¸­åªç»™å‡ºä¸€ä¸ªå­—ç¬¦#ï¼Œè¡¨ç¤ºæ–‡ä»¶ç»“æŸã€‚åœ¨Nä¸ªæ–‡ä»¶å†…å®¹ç»“æŸä¹‹åï¼Œç»™å‡ºæŸ¥è¯¢æ€»æ•°Mï¼ˆâ‰¤ï¼‰ï¼ŒéšåMè¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹æ–‡ä»¶ç¼–å·ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚è¿™é‡Œå‡è®¾æ–‡ä»¶æŒ‰ç»™å‡ºçš„é¡ºåºä»1åˆ°Nç¼–å·ã€‚\n\n\nè¾“å‡ºæ ¼å¼:é’ˆå¯¹æ¯ä¸€æ¡æŸ¥è¯¢ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºä¸¤æ–‡ä»¶çš„ç›¸ä¼¼åº¦ï¼Œå³ä¸¤æ–‡ä»¶çš„å…¬å…±è¯æ±‡é‡å ä¸¤æ–‡ä»¶æ€»è¯æ±‡é‡çš„ç™¾åˆ†æ¯”ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹å1ä½ã€‚æ³¨æ„è¿™é‡Œçš„ä¸€ä¸ªâ€œå•è¯â€åªåŒ…æ‹¬ä»…ç”±è‹±æ–‡å­—æ¯ç»„æˆçš„ã€é•¿åº¦ä¸å°äº3ã€ä¸”ä¸è¶…è¿‡10çš„è‹±æ–‡å•è¯ï¼Œé•¿åº¦è¶…è¿‡10çš„åªè€ƒè™‘å‰10ä¸ªå­—æ¯ã€‚å•è¯é—´ä»¥ä»»ä½•éè‹±æ–‡å­—æ¯éš”å¼€ã€‚å¦å¤–ï¼Œå¤§å°å†™ä¸åŒçš„åŒä¸€å•è¯è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„å•è¯ï¼Œä¾‹å¦‚â€œYouâ€å’Œâ€œyouâ€æ˜¯åŒä¸€ä¸ªå•è¯ã€‚\nè¾“å…¥æ ·ä¾‹:3\nAaa Bbb Ccc\n#\nBbb Ccc Ddd\n#\nAaa2 ccc Eee\nis at Ddd@Fff\n#\n2\n1 2\n1 3\n\nè¾“å‡ºæ ·ä¾‹:50.0%\n33.3%\n\n\nCodeï½#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint main()\n{\n    int m, n, a, b;\n    cin &gt;&gt; n;\n    vector&lt;set&lt;string&gt;&gt; files(n, set&lt;string&gt;());\n    char c = getchar();\n    for (size_t i = 0; i &lt; n; ++i)\n    {\n        string s = \"\";\n        while ((c = getchar()) != '#')\n        {\n            if (isalpha(c))\n                s += c;\n            else\n            {\n                if (s.size() &lt; 3)\n                {\n                    s = \"\";\n                    continue;\n                } else if (s.size() &gt; 10)\n                    s = s.substr(0, 10);\n                transform(s.begin(), s.end(), s.begin(), ::tolower);\n                files[i].insert(s);\n                s = \"\";\n            }\n        }\n    }\n    cin &gt;&gt; m;\n    for (size_t i = 0; i &lt; m; ++i)\n    {\n        cin &gt;&gt; a &gt;&gt; b;\n        set&lt;string&gt; inter;\n        set_intersection(files[a - 1].begin(), files[a - 1].end(), files[b - 1].begin(), files[b - 1].end(),\n                         inserter(inter, inter.begin()));\n        printf(\"%.1f%%\\n\", inter.size() * 100.0 / (files[a - 1].size() + files[b - 1].size() - inter.size()));\n        inter.clear();\n    }\n}\n\nÎ© ä¸€äº›è¯´æ˜ï¼š1.åŸºæœ¬æ€æƒ³ï¼šä¸€ä¸ªæ–‡ä»¶ä¸­æ‰€æœ‰çš„æœ‰æ•ˆå•è¯ç”¨setè¿›è¡Œå­˜å‚¨ï¼Œå„ä¸ªæ–‡ä»¶çš„setç”¨ä¸€ä¸ªvectorè¿›è¡Œå­˜å‚¨ã€‚å¯¹äºä»»æ„ä¸¤ä¸ªæ–‡ä»¶å…¬å…±è¯æ±‡ä¸ªæ•°çš„æ±‚å–ï¼Œæ˜¯ç›´æ¥æ±‚ä¸¤ä¸ªæ–‡ä»¶setçš„äº¤é›†(set_intersection,from &lt; algorithm &gt;)çš„ä¸ªæ•°ã€‚\n2.ç”±äºä¸åˆ†å¤§å°å†™ï¼Œå› æ­¤å­˜å…¥çš„å•è¯ç»Ÿä¸€è½¬ä¸ºç›¸åº”çš„å°å†™å•è¯å­˜å…¥ã€‚è¿™é‡Œé‡‡ç”¨çš„æ˜¯transform(s.begin(), s.end(), s.begin(), ::tolower)æ–¹æ³•ï¼Œå°†tolowerå‡½æ•°åº”ç”¨äºsçš„æ¯ä¸ªå­—ç¬¦ã€‚\n3.tolowerå‡½æ•°ä¹‹å‰æœ‰â€œ::â€æ˜¯å› ä¸ºè¿™ä¸ªå‡½æ•°æ—¢æœ‰Cç‰ˆæœ¬çš„ï¼Œåˆæœ‰STLæ¨¡æ¿çš„ï¼ŒäºŒè€…å­˜åœ¨å†²çªã€‚è¿™é‡Œç”¨å®šç•Œç¬¦å¼ºåˆ¶æŒ‡å®šä¸ºCç‰ˆæœ¬çš„ã€‚\n4.set_intersectå‡½æ•°å¯ä»¥æ±‚å–ä¸¤ä¸ªsetçš„äº¤é›†ï¼Œå¦å¤–è¿˜æœ‰set_unionï¼ˆå–å¹¶é›†ï¼‰ã€set_differenceï¼ˆå–å·®é›†ï¼‰ã€set_symmetric_differenceï¼ˆå–å¯¹ç§°å·®é›†ï¼‰ç­‰å‡½æ•°ã€‚\n","slug":"7-44-åŸºäºè¯é¢‘çš„æ–‡ä»¶ç›¸ä¼¼åº¦","date":"2022-01-27T16:37:22.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"Cï¼‹ï¼‹,set","author_index":"Starlit Rover"},{"id":"4d044ba098bb35996b72630bc962fb79","title":"README","content":"\n\n\n\n\n\n\n\nâœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦ Githubä»“åº“å¯¼èˆª   âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦âœ¦\n\n\n\n","slug":"README","date":"2022-01-27T08:50:38.000Z","categories_index":"PTA-æ•°æ®ç»“æ„ä¸ç®—æ³•é¢˜ç›®é›†","tags_index":"","author_index":"Starlit Rover"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Hello, nice to meet you! Iâ€™m Starlit Rover, Jammy Zeta. \nWelcome to my Blog, which is powered by Hexo. This is my very first post . \nActually, the thought of creating a blog for myself originated long long time ago. Through blog, I want to record some studying process and outcomes or write something about my emotional ups and downs. In my belief, it is bound to be a brilliant journey!\nBuilding this blog mainly referred to this webpage, to which my much appreciation goes. Whatâ€™s more, I  encountered many obstacles in the process. But fortunately, they all have already been tackled by seniors, which sharply diminished my bug-killing time.\n\nprintf(\"Hello, World!\");\nprint(\" å“ˆå•°ï¼\")\ncout &lt;&lt; \"Hola!\";\ndisp('Morning!');\nSystem.out.println(\"Go for it!\");\necho \"Life is not about how to live through storms but how to dance in the rain.\"\n\n\n\n\n\n","slug":"hello-world","date":"2022-01-16T08:08:38.000Z","categories_index":"Daily","tags_index":"blog","author_index":"Starlit Rover"}]