{"title":"粒子群算法","uid":"67f2a5903961e96580b14bb51c7ce9c9","slug":"粒子群算法","date":"2022-08-22T02:55:53.000Z","updated":"2022-08-28T05:34:26.011Z","comments":true,"path":"api/articles/粒子群算法.json","keywords":null,"cover":[],"content":"<p>$\\qquad$通过上一节我们得知遗传算法是一种智能的随机搜索算法，胡乱随机的过程中隐隐透着一丝章法，这是借鉴了大自然的生存法则。而今天登场的<strong>粒子群算法</strong>也源于日常生活。</p>\n<p>$\\qquad$当地上掉落一坨蜂蜜时，我们希望找到它的方位，怎么办呢？于是乎我们放出100只蚂蚁，让他们在这片广袤无垠的土地上随机搜索。但并不是完全随机，当有一只蚂蚁嗅到了极高浓度的蜂蜜气息时，它会对其他蚂蚁大喊（触角：你礼貌吗）：“Come here！“，于是乎所有蚂蚁会往它的方位靠拢。然而每一只蚂蚁也是一个单独的个体，它们会有自己的搜索记忆，对于自己搜索路径上出现过最高浓度的方位也一直念念不忘，因此每一只蚂蚁还会向自己的历史最强方位靠拢。由此每个蚂蚁的运动方式都是通过运动惯性+个体认知+群体协作决定的。</p>\n<img title src=\"/images/数学煎馍/1.png\" alt data-align=\"center\" width=\"457\">\n\n<span id=\"more\"></span>\n\n<br>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$基础的算法流程非常简单易懂：</p>\n<ol>\n<li><p>有必要的话需对优化问题的可行解进行编码</p>\n</li>\n<li><p>初始化各粒子的位置和速度，每个位置坐标对应一个可行解</p>\n</li>\n<li><p>指定粒子适应度（蜂蜜气息浓度）计算方式，计算各个粒子的适应值</p>\n</li>\n<li><p>与个体最高适应值进行比较，更高则进行替换，并记录当前位置</p>\n</li>\n<li><p>与群体最高适应值进行比较，更高则进行替换，并记录当前位置</p>\n</li>\n<li><p>更新当前粒子速度</p>\n<p>$$<br>v_{new}&#x3D;w\\cdot v_{old}+c_1r_1\\cdot(p_{id}-x)+c_2r_2\\cdot (p_{gd}-x)<br>$$</p>\n<p>其中$w$为惯性系数，表示维持当前速度的趋势因子；$r_1,r_2\\in [0,1]$均为每次更新时产生的随机数；$c_1,c_2$则为对个体最优、群体最优方位的学习因子；$p_{id},p_{gd}$分别为个体最优位置坐标、群体最优位置坐标</p>\n</li>\n<li><p>更新当前粒子方位</p>\n<p>$$<br>x_{new}&#x3D;x_{old}+v_{new}<br>$$</p>\n</li>\n</ol>\n<br>\n\n<p>$\\qquad$那么在算法开始前，我们往往需要指定【粒子个数、最大迭代次数、学习因子*2、惯性系数】，另外由于可行解域往往是一块有限的区域，因此我们不能让速度过大，需要设定一个速度上限，而这个上限往往通过方位的最大绝对值$x_{\\max}$进行设定，即</p>\n<p>$$<br>|v|\\leq k\\cdot x_{\\max}\\ ,\\ 0.1\\leq k\\leq 1<br>$$</p>\n<p>$\\qquad$注意算法中的$v，x$都可以是$n$维向量，下面请欣赏我随便应用的一个案例。</p>\n<hr>\n<h2><span id=\"ƺ\">ƺ</span></h2><p>$\\qquad$这个案例是<a href=\"https://www.gurobi.com/\">Gurobi求解器</a>（不是广告！不过学生版免费申请还是很香的，Python体验也不错）官方给出的，一个建塔问题，官方文档<a href=\"https://gurobi.github.io/modeling-examples/cell_tower_coverage/cell_tower.html\">见这</a>。</p>\n<p>$\\qquad$简单地说，就是设计一个通讯塔的选址方案，每个塔的搭建费用和覆盖的地区不同，不同地区所涵盖的人口也不同，由于资金有预算限制，因此我们需要在预算范围内求出能够覆盖最大人数的搭建方案。</p>\n<h4><span id=\"导入数据\">∻ 导入数据</span></h4><p>$\\qquad$原题中只有6座塔，那么意味着只有64种情况，我30个粒子就已经占了一大半，这还迭代个毛球，于是乎我把塔数改成了10，同时更改了个别塔所涵盖的地区。下面是基本信息的导入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> random <span class=\"keyword\">as</span> rd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 各地区人口数量</span></span><br><span class=\"line\">pop = np.array([<span class=\"number\">523</span>, <span class=\"number\">690</span>, <span class=\"number\">420</span>, <span class=\"number\">1010</span>, <span class=\"number\">1200</span>, <span class=\"number\">850</span>, <span class=\"number\">400</span>, <span class=\"number\">1008</span>, <span class=\"number\">950</span>])</span><br><span class=\"line\"><span class=\"comment\"># 建塔费用</span></span><br><span class=\"line\">cost = np.array([<span class=\"number\">4.2</span>, <span class=\"number\">6.1</span>, <span class=\"number\">5.2</span>, <span class=\"number\">5.5</span>, <span class=\"number\">4.8</span>, <span class=\"number\">9.2</span>, <span class=\"number\">7.6</span>, <span class=\"number\">5.8</span>, <span class=\"number\">8.7</span>, <span class=\"number\">4.9</span>])</span><br><span class=\"line\">tn = <span class=\"built_in\">len</span>(cost)</span><br><span class=\"line\"><span class=\"comment\"># 资金预算</span></span><br><span class=\"line\">budget = <span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"comment\"># 每座塔涵盖的地区</span></span><br><span class=\"line\">cover = np.array([[<span class=\"literal\">False</span>] * <span class=\"built_in\">len</span>(pop)] * tn)</span><br><span class=\"line\">cover[<span class=\"number\">0</span>][[<span class=\"number\">0</span>, <span class=\"number\">5</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">1</span>][[<span class=\"number\">8</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">2</span>][[<span class=\"number\">3</span>, <span class=\"number\">4</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">3</span>][[<span class=\"number\">2</span>, <span class=\"number\">6</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">4</span>][[<span class=\"number\">6</span>, <span class=\"number\">8</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">5</span>][[<span class=\"number\">0</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">6</span>][[<span class=\"number\">1</span>, <span class=\"number\">5</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">7</span>][[<span class=\"number\">2</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">8</span>][[<span class=\"number\">3</span>, <span class=\"number\">7</span>]] = <span class=\"literal\">True</span></span><br><span class=\"line\">cover[<span class=\"number\">9</span>][[<span class=\"number\">7</span>]] = <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n\n<h4><span id=\"特殊化处理\">∻ 特殊化处理</span></h4><p>$\\qquad$在本题中没有直接的坐标$x$，我们需要对每个方案进行编码，由于每座塔只有建&#x2F;不建两种情况，那么一个10位二进制数即可表示一种方案</p>\n<p>$$<br>\\overline{b_1b_2\\cdots b_{10}} \\ ,\\ b_i&#x3D;1\\Rightarrow build\\ T_i<br>$$</p>\n<p>$\\qquad$但是这里有最大资金约束，意味着并不是随便一个10位二进制数就是可行解。这里我采取的方法是，初始粒子生成的都是可行解，但对于搜索过程中产生的不可行解，我们将其适应值设为0，从而对搜索过程不会造成太大影响。</p>\n<h4><span id=\"参数设置\">∻ 参数设置</span></h4><p>$\\qquad$接下来设置各个参数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数设定</span></span><br><span class=\"line\">pn = <span class=\"number\">20</span>           <span class=\"comment\"># 粒子数量</span></span><br><span class=\"line\"><span class=\"built_in\">iter</span> = <span class=\"number\">500</span>        <span class=\"comment\"># 迭代次数</span></span><br><span class=\"line\">maxx = <span class=\"number\">2</span>**tn-<span class=\"number\">1</span>    <span class=\"comment\"># x_max(全为1)</span></span><br><span class=\"line\">r_vx = <span class=\"number\">0.5</span>        <span class=\"comment\"># x_max/v_max</span></span><br><span class=\"line\">maxv = r_vx*maxx  <span class=\"comment\"># v_max</span></span><br><span class=\"line\">w = <span class=\"number\">0.5</span>           <span class=\"comment\"># 惯性系数</span></span><br><span class=\"line\">c1 = <span class=\"number\">5</span>            <span class=\"comment\"># 个体学习因子</span></span><br><span class=\"line\">c2 = <span class=\"number\">3</span>            <span class=\"comment\"># 群体学习因子</span></span><br></pre></td></tr></table></figure>\n\n<h4><span id=\"解码函数\">∻ 解码函数</span></h4><p>$\\qquad$在计算下一步坐标时我们不直接对一个十维向量进行操作，毕竟每一位就两个选择也不能存在小数。我先将二进制数转换为十进制数，在进行坐标的计算，即这里的坐标和速度都是1维的，那么我们就需要一个将十进制数转换为十位二进制列表的解码函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decode</span>(<span class=\"params\">p</span>):</span><br><span class=\"line\">    b = <span class=\"built_in\">list</span>(<span class=\"built_in\">bin</span>(p)[<span class=\"number\">2</span>:])</span><br><span class=\"line\">    a = [<span class=\"string\">&#x27;0&#x27;</span>] * (tn - <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">    a.extend(b)</span><br><span class=\"line\">    a = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, a))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$转换时别忘了把前置0补全。</p>\n<h4><span id=\"粒子群初始化\">∻ 粒子群初始化</span></h4><p>$\\qquad$初始化起点坐标和速度，这里构造的每个粒子都是可行解：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化粒子群</span></span><br><span class=\"line\">x = []</span><br><span class=\"line\">v = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(pn):</span><br><span class=\"line\">    a = [<span class=\"number\">1</span>] * tn</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"built_in\">sum</span>(cost * a) &gt; budget:</span><br><span class=\"line\">        c = rd.randint(<span class=\"number\">0</span>, maxx)</span><br><span class=\"line\">        a = decode(c)</span><br><span class=\"line\">    x.append(c)</span><br><span class=\"line\">    v.append(r_vx * c)</span><br></pre></td></tr></table></figure>\n\n<h4><span id=\"适应度函数\">∻ 适应度函数</span></h4><p>$\\qquad$很显然本问中的适应度函数即为涵盖的人口总数，我们只需判断每个地区是否有塔覆盖即可，对于不可行解则直接返回0。</p>\n<p>$\\qquad$⚠️$p&#x3D;&#x3D;0$在else里会出大问题，由于idx为空，所以和pop相乘的也是个None。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 适应度函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">adpt</span>(<span class=\"params\">p</span>):</span><br><span class=\"line\">    a = decode(p)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">sum</span>(cost * a) &gt; budget <span class=\"keyword\">or</span> p == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        idx = <span class=\"built_in\">list</span>(np.where(np.array(a) == <span class=\"number\">1</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">sum</span>(<span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">bool</span>, <span class=\"built_in\">sum</span>(cover[idx]))) * pop)</span><br></pre></td></tr></table></figure>\n\n<h4><span id=\"迭代搜索\">∻ 迭代搜索</span></h4><p>$\\qquad$这里注意当速度和坐标超出上下限时需要及时调整。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 粒子群搜索</span></span><br><span class=\"line\">maxp = <span class=\"number\">0</span></span><br><span class=\"line\">optx = <span class=\"number\">0</span></span><br><span class=\"line\">maxp_idv = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(adpt, x))</span><br><span class=\"line\">optx_idv = x</span><br><span class=\"line\">record_p = []</span><br><span class=\"line\">record_iter = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">iter</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(pn):</span><br><span class=\"line\">        v[j] = w * v[j] + c1 * rd.random() * (optx - x[j]) + c2 * rd.random() * (optx_idv[j] - x[j])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">abs</span>(v[j]) &gt; maxv:</span><br><span class=\"line\">            v[j] = maxv <span class=\"keyword\">if</span> v[j] &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> -maxv</span><br><span class=\"line\">        x[j] = <span class=\"built_in\">round</span>(x[j] + v[j])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x[j] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            x[j] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> x[j] &gt; maxx:</span><br><span class=\"line\">            x[j] = maxx</span><br><span class=\"line\">        new_adpt = adpt(x[j])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> new_adpt &gt; maxp_idv[j]:</span><br><span class=\"line\">            maxp_idv[j] = new_adpt</span><br><span class=\"line\">            optx_idv[j] = x[j]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> new_adpt &gt; maxp:</span><br><span class=\"line\">                maxp = new_adpt</span><br><span class=\"line\">                optx = x[j]</span><br><span class=\"line\">                record_p.append(new_adpt)</span><br><span class=\"line\">                record_iter.append(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;最大覆盖人数：\\t&quot;</span>, maxp)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;最佳建塔计划：\\t&quot;</span>, decode(optx))</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$最终求得的结果：</p>\n<img title src=\"/images/数学煎馍/3.png\" alt data-align=\"center\" width=\"450\">\n\n<p>$\\qquad$这与Gurobi给出的最优解结果一致：</p>\n<img title src=\"/images/数学煎馍/4.png\" alt data-align=\"center\" width=\"520\">\n\n<h4><span id=\"绘制搜索过程\">∻ 绘制搜索过程</span></h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置字体</span></span><br><span class=\"line\">plt.rc(<span class=\"string\">&#x27;font&#x27;</span>, family=<span class=\"string\">&#x27;Times New Roman&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 设置图像的像素</span></span><br><span class=\"line\">plt.rcParams[<span class=\"string\">&#x27;figure.dpi&#x27;</span>] = <span class=\"number\">150</span></span><br><span class=\"line\"><span class=\"comment\"># 设置字体的颜色</span></span><br><span class=\"line\">plt.rcParams[<span class=\"string\">&#x27;text.color&#x27;</span>] = <span class=\"string\">&#x27;black&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">plt.plot(record_iter, record_p, color=<span class=\"string\">&#x27;b&#x27;</span>, linestyle=<span class=\"string\">&#x27;-.&#x27;</span>, marker=<span class=\"string\">&#x27;*&#x27;</span>, label=<span class=\"string\">&#x27;Survived&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;max Population&#x27;</span>, fontsize=<span class=\"number\">13</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;iteration num&#x27;</span>, fontsize=<span class=\"number\">13</span>)</span><br><span class=\"line\">plt.xticks(ticks=record_iter)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$用matplotlib库我们可以绘制出最大人口数的变化过程，由于运行速度很快，所以我多运行了几次：</p>\n<br>\n<center class=\"half\">\n    <img src=\"/images/数学煎馍/2.png\" width=\"420\" style=\"display: inline-block\">\n  <img src=\"/images/数学煎馍/5.png\" width=\"420\" style=\"display: inline-block\">\n</center>\n<center>\n    <img src=\"/images/数学煎馍/6.png\" width=\"420\" style=\"display: inline-block\">\n    <img src=\"/images/数学煎馍/7.png\" width=\"420\" style=\"display: inline-block\">\n</center>\n\n<p>$\\qquad$咳咳，虽然吧算法鲁棒性不高，不过就以上四种情况来看，五百轮迭代是足够了，最坏也就408次。只能说调参真的是一门技术活，我觉得我这里的参数肯定不是最优的，或许用智能算法搜索智能算法的参数会是个好主意（禁止套娃\\doge）。</p>\n","text":"$\\qquad$通过上一节我们得知遗传算法是一种智能的随机搜索算法，胡乱随机的过程中隐隐透着一丝章法，这是借鉴了大自然的生存法则。而今天登场的粒子群算法也源于日常生活。 $\\qquad$当地上掉落一坨蜂蜜时，我们希望找到它的方位，怎么办呢？于是乎我们放出100只蚂蚁，让他们在这片...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"智能算法","slug":"智能算法","count":4,"path":"api/categories/智能算法.json"}],"tags":[{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"},{"name":"数学煎馍","slug":"数学煎馍","count":4,"path":"api/tags/数学煎馍.json"},{"name":"Gurobi","slug":"Gurobi","count":2,"path":"api/tags/Gurobi.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">ƺ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 导入数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 特殊化处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 参数设置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 解码函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 粒子群初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 适应度函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 迭代搜索</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">∻ 绘制搜索过程</span></a></li></ol></li></ol></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1044」Shopping in Mars","uid":"e150e507cccee9246ee324168daabc61","slug":"「1044」Shopping-in-Mars","date":"2022-08-23T05:43:36.000Z","updated":"2022-08-27T07:25:36.303Z","comments":true,"path":"api/articles/「1044」Shopping-in-Mars.json","keywords":null,"cover":null,"text":"Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M\\$). W...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1043」Is It a Binary Search Tree","uid":"77ba14d37a0bc8ef24c6a9af2180a766","slug":"「1043」Is-It-a-Binary-Search-Tree","date":"2022-08-21T16:26:25.000Z","updated":"2022-10-19T10:53:33.111Z","comments":true,"path":"api/articles/「1043」Is-It-a-Binary-Search-Tree.json","keywords":null,"cover":null,"text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains o...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"binary search","slug":"binary-search","count":7,"path":"api/tags/binary-search.json"},{"name":"traversal order","slug":"traversal-order","count":13,"path":"api/tags/traversal-order.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}