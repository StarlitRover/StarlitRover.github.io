{"title":"「Section 7」寻址方式","uid":"d8805cb4c52676259ff97b6383bdfab8","slug":"寻址方式","date":"2022-03-23T01:04:09.000Z","updated":"2022-03-29T12:58:20.381Z","comments":true,"path":"api/articles/寻址方式.json","keywords":null,"cover":[],"content":"<ol>\n<li><p><strong>寻址方式</strong>：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法</p>\n<ul>\n<li><strong>指令寻址</strong>：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址<ul>\n<li><p><strong>顺序寻址</strong>：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址</p>\n</li>\n<li><p><strong>跳跃寻址</strong>：当前指令将目标指令的地址置入PC中从而实现跳转（本质上也是顺序寻址的结果）</p>\n</li>\n<li><p>寄存器PC在开机上电后自动初始化为第一条指令地址</p>\n<span id=\"more\"></span></li>\n</ul>\n</li>\n<li><strong>数据寻址</strong>：确定操作数在主存中的地址<ul>\n<li><p><strong>形式地址</strong>：指令的<strong>地址码字段Addr</strong>，通常都不是真实的地址值</p>\n</li>\n<li><p><strong>有效地址</strong>：操作数在主存中的真实地址，由地址码字段Addr与寻址方式共同确定，记作<strong>EA</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>数据寻址方式</strong></p>\n<ul>\n<li><p><strong>立即寻址</strong>：Addr即为操作数本身，立即可用。一般用于变量赋初值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV EAX,2008H</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>直接寻址</strong>：操作数存储于主存中，Addr为其在主存中的地址，直接通过Addr访问即可得操作数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV EAX,[2008H]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>间接寻址</strong>：相对直接寻址而言，但Addr不是其存储地址，而是操作数的地址的地址，需要访问两次主存才可以得到操作数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV EAX,@2008H</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>解决了直接寻址地址码长度受限的问题，能用较短的地址码访问较大的主存地址</p>\n</li>\n<li><p>更加灵活，当操作数地址改变时无需改变指令只需改变Addr指向的主存单元即可</p>\n<img src=\"/images/计算机组成原理/6/1.jpg\" style=\"zoom:45%;\"></li>\n</ul>\n</li>\n<li><p><strong>寄存器寻址</strong>：操作数在CPU的某个通用寄存器中，Addr为其通用寄存器编号（通用寄存器组可以视作数组，编号即为下标），访问相应寄存器即可得操作数。</p>\n<ul>\n<li>寄存器的访问速度较访问主存更快</li>\n<li>编号长度较短，有利于缩短指令长度</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV EAX,ECX</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>寄存器间接寻址</strong>：与间接寻址不同的是，操作数的地址存储于<strong>寄存器</strong>，Addr为该寄存器编号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV AL,[EBX]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>相对寻址</strong>：Addr放的是相对PC的偏移量，EA&#x3D;Addr+PC（为下一条指令的地址）为操作数的有效地址。</p>\n<ul>\n<li>只需存储指令与操作数之间的相对距离，因此有利于实现程序的<strong>浮动</strong></li>\n</ul>\n</li>\n<li><p><strong>变址寻址</strong>：变址寄存器被指定用来存放变化的地址，此时地址码字段Addr会增加一个变址寄存器编号X，X与形式地址D之和即为操作数的有效地址，$EA&#x3D;R[X]+D$。</p>\n<img src=\"/images/计算机组成原理/6/2.jpg\" style=\"zoom:40%;\">\n\n<ul>\n<li>X提供修改量，D提供基准量。X的内容一直在变，而D的值一经设定执行过程中将不会变化</li>\n<li>主要应用于对线性表之类的数组元素进行重复的访问</li>\n</ul>\n</li>\n<li><p><strong>基址寻址</strong>：基址寄存器被指定来存放基地址，与变址寻址类似，多了一段基址寄存器编号B，B与形式地址D之和即为操作数的有效地址。与变址寻址不同的是，基址寄存器的值一经设定运行过程中将不会改变，此时由D来提供修改量。</p>\n</li>\n<li><p><strong>堆栈寻址</strong>：寻找存放在堆栈中的操作数称为堆栈寻址。根据开辟堆栈的位置可以将堆栈分为存储器堆栈和寄存器堆栈。</p>\n<ul>\n<li><p><strong>存储器堆栈</strong></p>\n<img src=\"/images/计算机组成原理/6/3.jpg\" style=\"zoom:45%;\">\n\n<ul>\n<li>堆栈指针寄存器SP指向栈顶单元</li>\n<li>入栈：SP&#x3D;SP-1（低地址在上），M[SP]&#x3D;R</li>\n<li>出栈：R&#x3D;M[SP]，SP&#x3D;SP+1</li>\n</ul>\n</li>\n<li><p><strong>寄存器堆栈</strong></p>\n<img src=\"/images/计算机组成原理/6/4.jpg\" style=\"zoom:50%;\">\n\n<ul>\n<li>寄存器堆栈栈顶固定不动</li>\n<li>堆栈操作时，寄存器堆栈内数据整体移动</li>\n<li>寄存器堆栈速度快，但容量有限；存储器堆栈则速度慢，容量大</li>\n<li>寄存器堆栈必须采用专用的堆栈指令进行控制</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","text":" 寻址方式：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法 指令寻址：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址 顺序寻址：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址 跳跃寻址：当前指令将目标指令的地址置入PC中从而实...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"toc":"","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"Naive Bayes","uid":"430d590163d20d4eee403c80b7319692","slug":"Naive-Bayes","date":"2022-03-29T12:46:48.000Z","updated":"2022-05-26T15:30:18.996Z","comments":true,"path":"api/articles/Naive-Bayes.json","keywords":null,"cover":[],"text":"朴素贝叶斯是一个非常经典易懂的分类方法，其核心思想是上式即为概率论中的Bayes定理，描述了两个条件概率之间的关系，那么先让我们来回顾一下概率论的知识。 α Bayes’ theorem对于计算两个事件X和Y同时发生的概率，可以由Y发生的概率与Y已发生时会发生X的概率相乘得到，即...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Machine Learning","slug":"Machine-Learning","count":3,"path":"api/categories/Machine-Learning.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"借助Flex实现SysY词法分析","uid":"bba1ccc43c803be00dfdf449eaee8924","slug":"借助flex实现SysY词法分析","date":"2022-03-22T10:49:25.000Z","updated":"2022-06-10T11:59:42.342Z","comments":true,"path":"api/articles/借助flex实现SysY词法分析.json","keywords":null,"cover":[],"text":"$\\qquad$词法分析（lexical analysis）是编译器的第一阶段，主要是将代码的字符序列转换为token的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说int asd=897;，其词法分析的结果即为 int ：&lt; TY...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}