{"title":"「Section 7」寻址方式","uid":"d8805cb4c52676259ff97b6383bdfab8","slug":"寻址方式","date":"2022-03-23T01:04:09.000Z","updated":"2022-03-29T12:58:20.000Z","comments":true,"path":"api/articles/寻址方式.json","keywords":null,"cover":[],"content":"<ol>\n<li><p><strong>寻址方式</strong>：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法</p>\n<ul>\n<li><strong>指令寻址</strong>：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址<ul>\n<li><p><strong>顺序寻址</strong>：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址</p>\n</li>\n<li><p><strong>跳跃寻址</strong>：当前指令将目标指令的地址置入PC中从而实现跳转（本质上也是顺序寻址的结果）</p>\n</li>\n<li><p>寄存器PC在开机上电后自动初始化为第一条指令地址</p>\n<span id=\"more\"></span></li>\n</ul>\n</li>\n<li><strong>数据寻址</strong>：确定操作数在主存中的地址<ul>\n<li><p><strong>形式地址</strong>：指令的<strong>地址码字段Addr</strong>，通常都不是真实的地址值</p>\n</li>\n<li><p><strong>有效地址</strong>：操作数在主存中的真实地址，由地址码字段Addr与寻址方式共同确定，记作<strong>EA</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>数据寻址方式</strong></p>\n<ul>\n<li><p><strong>立即寻址</strong>：Addr即为操作数本身，立即可用。一般用于变量赋初值。</p>\n<pre class=\"line-numbers language-x86\" data-language=\"x86\"><code class=\"language-x86\">MOV EAX,2008H<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>直接寻址</strong>：操作数存储于主存中，Addr为其在主存中的地址，直接通过Addr访问即可得操作数。</p>\n<pre class=\"line-numbers language-x86\" data-language=\"x86\"><code class=\"language-x86\">MOV EAX,[2008H]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>间接寻址</strong>：相对直接寻址而言，但Addr不是其存储地址，而是操作数的地址的地址，需要访问两次主存才可以得到操作数。</p>\n<pre class=\"line-numbers language-x86\" data-language=\"x86\"><code class=\"language-x86\">MOV EAX,@2008H<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><p>解决了直接寻址地址码长度受限的问题，能用较短的地址码访问较大的主存地址</p>\n</li>\n<li><p>更加灵活，当操作数地址改变时无需改变指令只需改变Addr指向的主存单元即可</p>\n<img src=\"/images/计算机组成原理/6/1.jpg\" style=\"zoom:45%;\"></li>\n</ul>\n</li>\n<li><p><strong>寄存器寻址</strong>：操作数在CPU的某个通用寄存器中，Addr为其通用寄存器编号（通用寄存器组可以视作数组，编号即为下标），访问相应寄存器即可得操作数。</p>\n<ul>\n<li>寄存器的访问速度较访问主存更快</li>\n<li>编号长度较短，有利于缩短指令长度</li>\n</ul>\n<pre class=\"line-numbers language-x86\" data-language=\"x86\"><code class=\"language-x86\">MOV EAX,ECX<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>寄存器间接寻址</strong>：与间接寻址不同的是，操作数的地址存储于<strong>寄存器</strong>，Addr为该寄存器编号。</p>\n<pre class=\"line-numbers language-x86\" data-language=\"x86\"><code class=\"language-x86\">MOV AL,[EBX]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p><strong>相对寻址</strong>：Addr放的是相对PC的偏移量，EA=Addr+PC（为下一条指令的地址）为操作数的有效地址。</p>\n<ul>\n<li>只需存储指令与操作数之间的相对距离，因此有利于实现程序的<strong>浮动</strong></li>\n</ul>\n</li>\n<li><p><strong>变址寻址</strong>：变址寄存器被指定用来存放变化的地址，此时地址码字段Addr会增加一个变址寄存器编号X，X与形式地址D之和即为操作数的有效地址，<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"15.984ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -750 7065 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D438\" d=\"M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z\"/></g><g data-mml-node=\"mi\" transform=\"translate(764,0)\"><path data-c=\"1D434\" d=\"M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(1791.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"/></g><g data-mml-node=\"mi\" transform=\"translate(2847.6,0)\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(3606.6,0)\"><path data-c=\"5B\" d=\"M118 -250V750H255V710H158V-210H255V-250H118Z\"/></g><g data-mml-node=\"mi\" transform=\"translate(3884.6,0)\"><path data-c=\"1D44B\" d=\"M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(4736.6,0)\"><path data-c=\"5D\" d=\"M22 710V750H159V-250H22V-210H119V710H22Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(5236.8,0)\"><path data-c=\"2B\" d=\"M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z\"/></g><g data-mml-node=\"mi\" transform=\"translate(6237,0)\"><path data-c=\"1D437\" d=\"M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z\"/></g></g></g></svg></mjx-container>。</p>\n<img src=\"/images/计算机组成原理/6/2.jpg\" style=\"zoom:40%;\">\n\n<ul>\n<li>X提供修改量，D提供基准量。X的内容一直在变，而D的值一经设定执行过程中将不会变化</li>\n<li>主要应用于对线性表之类的数组元素进行重复的访问</li>\n</ul>\n</li>\n<li><p><strong>基址寻址</strong>：基址寄存器被指定来存放基地址，与变址寻址类似，多了一段基址寄存器编号B，B与形式地址D之和即为操作数的有效地址。与变址寻址不同的是，基址寄存器的值一经设定运行过程中将不会改变，此时由D来提供修改量。</p>\n</li>\n<li><p><strong>堆栈寻址</strong>：寻找存放在堆栈中的操作数称为堆栈寻址。根据开辟堆栈的位置可以将堆栈分为存储器堆栈和寄存器堆栈。</p>\n<ul>\n<li><p><strong>存储器堆栈</strong></p>\n<img src=\"/images/计算机组成原理/6/3.jpg\" style=\"zoom:45%;\">\n\n<ul>\n<li>堆栈指针寄存器SP指向栈顶单元</li>\n<li>入栈：SP=SP-1（低地址在上），M[SP]=R</li>\n<li>出栈：R=M[SP]，SP=SP+1</li>\n</ul>\n</li>\n<li><p><strong>寄存器堆栈</strong></p>\n<img src=\"/images/计算机组成原理/6/4.jpg\" style=\"zoom:50%;\">\n\n<ul>\n<li>寄存器堆栈栈顶固定不动</li>\n<li>堆栈操作时，寄存器堆栈内数据整体移动</li>\n<li>寄存器堆栈速度快，但容量有限；存储器堆栈则速度慢，容量大</li>\n<li>寄存器堆栈必须采用专用的堆栈指令进行控制</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","text":" 寻址方式：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法 指令寻址：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址 顺序寻址：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址 跳跃寻址：当前指令将目标指令的地址置入PC中从而实...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":14,"path":"api/tags/notes.json"}],"toc":"","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"Naive Bayes","uid":"430d590163d20d4eee403c80b7319692","slug":"Naive-Bayes","date":"2022-03-29T12:46:48.000Z","updated":"2022-05-26T15:30:18.000Z","comments":true,"path":"api/articles/Naive-Bayes.json","keywords":null,"cover":[],"text":"朴素贝叶斯是一个非常经典易懂的分类方法，其核心思想是上式即为概率论中的Bayes定理，描述了两个条件概率之间的关系，那么先让我们来回顾一下概率论的知识。 α Bayes’ theorem对于计算两个事件X和Y同时发生的概率，可以由Y发生的概率与Y已发生时会发生X的概率相乘得到，即...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"Machine Learning","slug":"Machine-Learning","count":3,"path":"api/categories/Machine-Learning.json"}],"tags":[{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"},{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"借助Flex实现SysY词法分析","uid":"bba1ccc43c803be00dfdf449eaee8924","slug":"借助flex实现SysY词法分析","date":"2022-03-22T10:49:25.000Z","updated":"2022-06-10T11:59:42.000Z","comments":true,"path":"api/articles/借助flex实现SysY词法分析.json","keywords":null,"cover":[],"text":"词法分析（lexical analysis）是编译器的第一阶段，主要是将代码的字符序列转换为token的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说int asd=897;，其词法分析的结果即为 int ：&lt; TYPE , ‘in...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}