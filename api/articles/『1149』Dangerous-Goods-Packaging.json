{"title":"『1149』Dangerous Goods Packaging","uid":"ff3134335de30a822a5e1c46f95fdfc6","slug":"『1149』Dangerous-Goods-Packaging","date":"2022-11-28T10:26:29.000Z","updated":"2022-11-28T14:36:11.446Z","comments":true,"path":"api/articles/『1149』Dangerous-Goods-Packaging.json","keywords":null,"cover":null,"content":"<p>When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ourselves in serious trouble. For example, oxidizing agent （氧化剂） must not be packed with flammable liquid （易燃液体）, or it can cause explosion.</p>\n<p>Now you are given a long list of incompatible goods, and several lists of goods to be shipped. You are supposed to tell if all the goods in a list can be packed into the same container.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line gives two positive integers: $N (≤10^4)$, the number of pairs of incompatible goods, and $M (≤100)$, the number of lists of goods to be shipped.</p>\n<p>Then two blocks follow. The first block contains N pairs of incompatible goods, each pair occupies a line; and the second one contains M lists of goods to be shipped, each list occupies a line in the following format:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">K G[1] G[2] ... G[K]</span><br></pre></td></tr></table></figure>\n\n<p>where <code>K</code> (≤1,000) is the number of goods and <code>G[i]</code>‘s are the IDs of the goods. To make it simple, each good is represented by a 5-digit ID number. All the numbers in a line are separated by spaces.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each shipping list, print in a line <code>Yes</code> if there are no incompatible goods in the list, or <code>No</code> if not.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 3</span><br><span class=\"line\">20001 20002</span><br><span class=\"line\">20003 20004</span><br><span class=\"line\">20005 20006</span><br><span class=\"line\">20003 20001</span><br><span class=\"line\">20005 20004</span><br><span class=\"line\">20004 20006</span><br><span class=\"line\">4 00001 20004 00002 20003</span><br><span class=\"line\">5 98823 20002 20003 20006 10010</span><br><span class=\"line\">3 12345 67890 23333</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No</span><br><span class=\"line\">Yes</span><br><span class=\"line\">Yes</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$今天真的是水逆，一会TLE，一会MLE，总之每次第一个思路总是错的，可恶。</p>\n<p>$\\qquad$给出$N$对不能一起运输的物品ID，随后输入$M$个运输清单，输出能否运输。就连这种题目都不能一边过，服了。</p>\n<p>$\\qquad$一开始我打算用一个<code>set&lt;long long&gt;</code>存储不能一起运输的物品ID，假设$(a,b)$是一对不能一起运输的物品，那么就将查询索引$[10^5\\min(a,b)+\\max(a,b)]$存入set。在读入一个运输清单时，将每一个读入物品与之前读入物品组成查询索引在set中查找，如果找到了就说明不能一起运输。结果后面两个测试点TLE了。后来我想直接给每个物品开一个<code>bitset&lt;100000&gt;</code>来记录不能一起存储的物品，结果ME（Memory Limit Exceeded）。</p>\n<p>$\\qquad$最后采取常规做法，用<code>map&lt;int,vector&lt;int&gt;&gt;</code>建立ID到不能一起运输物品集的映射，然后每读入一个物品就将不能和其一起运输的物品ID进行标记，如果后面出现了标记过的物品，则说明这单不能运输。事实证明，中庸才是王道，我之前的两个做法分别在时间和空间上过于极端（当然题目限的太狠也是一个因素</p>\n<p>$\\qquad$反思了一下，最开始建立的那个查询索引会让索引量增长到$n^2$，set和map内部的数据结构都是红黑树，查找效率在$O(\\log_2n)$，那么$n^2$会让时间增长一倍，这确实是一笔不小的开销。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bitset&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, a, b;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;&gt; incap;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class=\"line\">        incap[a].<span class=\"built_in\">push_back</span>(b), incap[b].<span class=\"built_in\">push_back</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">        bitset&lt;<span class=\"type\">size_t</span>(1e5)&gt; tmp;</span><br><span class=\"line\">        <span class=\"type\">bool</span> ans = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;a);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!ans) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp[a]) ans = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: incap[a]) tmp[k] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(ans ? <span class=\"string\">&quot;Yes\\n&quot;</span> : <span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"When shipping goods with containers, we have to be careful not to pack some incompatible goods into the same container, or we might get ours...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"bitset","slug":"bitset","count":4,"path":"api/tags/bitset.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"『1150」Travelling Salesman Problem","uid":"a4815f6ae46beab8c783f42705d05394","slug":"『1150」Travelling-Salesman-Problem","date":"2022-11-28T12:44:21.000Z","updated":"2022-12-02T15:17:27.740Z","comments":true,"path":"api/articles/『1150」Travelling-Salesman-Problem.json","keywords":null,"cover":null,"text":"The “travelling salesman problem” asks the following question: “Given a list of cities and the distances between each pair of cities, what i...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"},{"name":"TSP","slug":"TSP","count":2,"path":"api/tags/TSP.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1148」Werewolf - Simple Version","uid":"00adf0accb1aad7e13f310feb201ca0a","slug":"「1148」Werewolf-Simple-Version","date":"2022-11-28T08:38:29.000Z","updated":"2022-11-28T14:31:33.637Z","comments":true,"path":"api/articles/「1148」Werewolf-Simple-Version.json","keywords":null,"cover":null,"text":"Werewolf（狼人杀） is a game in which the players are partitioned into two parties: the werewolves and the human beings. Suppose that in a game, ...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}