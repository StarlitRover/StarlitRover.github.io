{"title":"『1087』All Roads Lead to Rome","uid":"36db02f696efbf1ae4833c7a9cd82a86","slug":"『1087』All-Roads-Lead-to-Rome","date":"2022-10-18T15:38:59.000Z","updated":"2022-10-18T16:14:57.950Z","comments":true,"path":"api/articles/『1087』All-Roads-Lead-to-Rome.json","keywords":null,"cover":null,"content":"<p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2≤N≤200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format <code>City1 City2 Cost</code>. Here the name of a city is a string of 3 capital English letters, and the destination is always <code>ROM</code> which represents Rome.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p>\n<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format <code>City1-&gt;City2-&gt;...-&gt;ROM</code>.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 7 HZH</span><br><span class=\"line\">ROM 100</span><br><span class=\"line\">PKN 40</span><br><span class=\"line\">GDN 55</span><br><span class=\"line\">PRS 95</span><br><span class=\"line\">BLN 80</span><br><span class=\"line\">ROM GDN 1</span><br><span class=\"line\">BLN ROM 1</span><br><span class=\"line\">HZH PKN 1</span><br><span class=\"line\">PRS ROM 2</span><br><span class=\"line\">BLN HZH 2</span><br><span class=\"line\">PKN GDN 1</span><br><span class=\"line\">HZH PRS 1</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 3 195 97</span><br><span class=\"line\">HZH-&gt;PRS-&gt;ROM</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$好久没Dijkstra了，这道题要输出的东西有亿点多。</p>\n<p>$\\qquad$从一个城市去罗马，每条路上有一定的代价，到一座城市能收获相应的快乐值，输出【代价最短的路线数 最小代价 最小代价中的最大快乐值 平均快乐值】和最优路线（评价优先级依次为：代价最小，快乐多多，城市少少）。</p>\n<p>$\\qquad$首先用Dijkstra求出所有代价最小的路线，老套路，最短路线上的每个节点存储上一个节点的编号，由于路线不唯一，所以每个节点可能有多个前节点，用vector进行存储。然后从终点DFS回溯，回溯的路上顺便计算一下快乐值和节点个数，然后记录每个节点的最优next节点，即如果回到某个城市得到了一个更优的$(happiness,nodes)$，那么就更新其next值，回溯到起点0就停止。那么最后最优的快乐值和节点数就存储在起点0的info中。</p>\n<p>$\\qquad$第一次提交case 3超时，看到网上也没有人case 3裂开的，于是乎我改进了回溯函数，对于已经回溯过的节点不再重新回溯，直接用之前得出的结果，但绿色依旧，直到我把所有的<code>INT16_MAX</code>换成了<code>INT32_MAX</code>。<code>INT_MAX</code>是用来代替Dijkstra中走不通距离$∞$的，有时候替代数太小了会出问题。</p>\n<p>$\\qquad$⚠️ 尽量用大数（<code>INT32_MAX</code>）替代$∞$。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; happy, nxt, path;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; pre;     <span class=\"comment\">// previous nodes in the least cost paths</span></span><br><span class=\"line\">vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; info; <span class=\"comment\">// &lt;happiness sum, nodes num&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">collect</span><span class=\"params\">(<span class=\"type\">int</span> &amp;node)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> k: pre[node])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> p = <span class=\"built_in\">make_pair</span>(info[node].first + happy[k], info[node].second - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p &gt; info[k])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            info[k] = p;</span><br><span class=\"line\">            nxt[k] = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum += (path[k] == <span class=\"number\">-1</span> ? <span class=\"built_in\">collect</span>(k) : path[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path[node]=sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, k, dst, c;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">city</span><span class=\"params\">(n, string(<span class=\"number\">3</span>, <span class=\"number\">0</span>))</span></span>;</span><br><span class=\"line\">    happy.<span class=\"built_in\">resize</span>(n, <span class=\"number\">0</span>);</span><br><span class=\"line\">    map&lt;string, <span class=\"type\">int</span>&gt; num;</span><br><span class=\"line\">    cin &gt;&gt; city[<span class=\"number\">0</span>];</span><br><span class=\"line\">    num[city[<span class=\"number\">0</span>]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s %d&quot;</span>, &amp;city[i][<span class=\"number\">0</span>], &amp;happy[i]);</span><br><span class=\"line\">        num[city[i]] = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (city[i] == <span class=\"string\">&quot;ROM&quot;</span>)</span><br><span class=\"line\">            dst = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt; &gt; <span class=\"built_in\">cost</span>(n);</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span>, <span class=\"title\">c2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s %s %d&quot;</span>, &amp;c1[<span class=\"number\">0</span>], &amp;c2[<span class=\"number\">0</span>], &amp;c);</span><br><span class=\"line\">        cost[num[c1]].<span class=\"built_in\">emplace_back</span>(num[c2], c);</span><br><span class=\"line\">        cost[num[c2]].<span class=\"built_in\">emplace_back</span>(num[c1], c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT32_MAX)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">done</span><span class=\"params\">(n, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    dist[<span class=\"number\">0</span>] = <span class=\"number\">0</span>, done[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    pre.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v: cost[<span class=\"number\">0</span>])</span><br><span class=\"line\">        pre[v.first].<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>), dist[v.first] = v.second;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!done[dst])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> min_d = INT32_MAX;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; opt;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (done[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dist[i] &lt; min_d)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                opt.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">                opt.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">                min_d = dist[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dist[i] == min_d)</span><br><span class=\"line\">                opt.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;o: opt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v: cost[o])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[o] + v.second &lt; dist[v.first])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    dist[v.first] = dist[o] + v.second;</span><br><span class=\"line\">                    pre[v.first].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">                    pre[v.first].<span class=\"built_in\">push_back</span>(o);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dist[o] + v.second == dist[v.first])</span><br><span class=\"line\">                    pre[v.first].<span class=\"built_in\">push_back</span>(o);</span><br><span class=\"line\">            done[o] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    info.<span class=\"built_in\">resize</span>(n, &#123;INT32_MIN, INT32_MIN&#125;);</span><br><span class=\"line\">    info[dst] = <span class=\"built_in\">make_pair</span>(happy[dst], <span class=\"number\">0</span>);</span><br><span class=\"line\">    nxt = path = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    path[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d %d\\n&quot;</span>, <span class=\"built_in\">collect</span>(dst), dist[dst], info[<span class=\"number\">0</span>].first, info[<span class=\"number\">0</span>].first / -info[<span class=\"number\">0</span>].second);</span><br><span class=\"line\">    <span class=\"type\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, city[<span class=\"number\">0</span>].<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((idx = nxt[idx]) != <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;-&gt;%s&quot;</span>, city[idx].<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4><span id=\"tips\">Tips</span></h4><ol>\n<li><p>注意到回溯函数中节点数我是-1处理的，因为快乐数要bigger，而节点数要尽量smaller，如果要使用pair的比较运算就需要统一两者，所以对节点数取了个负</p>\n</li>\n<li><p>对所有城市先进行了编号，map用来获取编号，vector存取编号对应城市名</p>\n</li>\n<li><p>距离用了邻接表的结构进行存储，Dijkstra用邻接表足矣</p>\n</li>\n</ol>\n","text":"Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost wh...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"},{"name":"Dijkstra","slug":"Dijkstra","count":6,"path":"api/tags/Dijkstra.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li></ol></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"『1088」Rational Arithmetic","uid":"358311a56ccea31028176b056f12f8e9","slug":"『1088」Rational-Arithmetic","date":"2022-10-20T05:15:51.000Z","updated":"2022-10-20T05:33:42.928Z","comments":true,"path":"api/articles/『1088」Rational-Arithmetic.json","keywords":null,"cover":null,"text":"For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"pair","slug":"pair","count":6,"path":"api/tags/pair.json"},{"name":"numeric","slug":"numeric","count":4,"path":"api/tags/numeric.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"『1086』Tree Traversals Again","uid":"241889b3806f3abfea3a2386c711c8ff","slug":"『1086』Tree-Traversals-Again","date":"2022-10-18T11:47:02.000Z","updated":"2022-10-19T10:54:51.942Z","comments":true,"path":"api/articles/『1086』Tree-Traversals-Again.json","keywords":null,"cover":[],"text":"An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"traversal order","slug":"traversal-order","count":13,"path":"api/tags/traversal-order.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}