{"title":"「1020」Tree Traversals","uid":"ecd0b7f9610ba01de460fb7fa358ee35","slug":"「1020」Tree-Traversals","date":"2022-07-04T03:51:27.000Z","updated":"2022-07-05T03:34:42.057Z","comments":true,"path":"api/articles/「1020」Tree-Traversals.json","keywords":null,"cover":null,"content":"<p><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072\">➳ENTRY</a></p>\n<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p>\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7</span><br><span class=\"line\">2 3 1 5 7 6 4</span><br><span class=\"line\">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 1 6 3 5 7 2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>题意简单明了，就是通过二叉树的后序遍历序列和中序遍历序列求出层次遍历序列。</p>\n<p>我们只需抓住后序和中序的重要特征即可，后序的中间节点是在最后的，中序的中间节点则是在左右子树的中间。那么我们可以采取如下算法构建二叉树：</p>\n<ol>\n<li><p>先取出后序的最后一个数字即可知当前节点的编号</p>\n</li>\n<li><p>在中序序列中找到该编号所处的位置，那么中序序列就被该节点划分成了左右两棵子树的中序序列，同时我们也得到了两棵子树的节点个数</p>\n</li>\n<li><p>根据得到的左右子树节点个数也可以将后序序列划分成左右两棵子树的后序序列</p>\n</li>\n<li><p>如此一来我们就分别得到了左右子树的后序和中序遍历序列，从而划分成了两个子问题再重复上述过程进行解决</p>\n</li>\n</ol>\n<p>很显然，划分为子问题是递归的思想，因此只需码一个递归构建二叉树的函数即可，传入当前子树的后序和中序序列在原序列中的位置即可。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; tree;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; post, in;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> in_start, <span class=\"type\">int</span> in_end, <span class=\"type\">int</span> post_start, <span class=\"type\">int</span> post_end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (in_start &gt;= in_end)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> crt = post[post_end], in_pos = <span class=\"built_in\">find</span>(in.<span class=\"built_in\">begin</span>() + in_start, in.<span class=\"built_in\">begin</span>() + in_end, crt) - in.<span class=\"built_in\">begin</span>() - in_start;</span><br><span class=\"line\">    tree[crt].first = (in_pos == <span class=\"number\">0</span>) ? <span class=\"number\">0</span> : post[post_start + in_pos - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(in_start, in_start + in_pos - <span class=\"number\">1</span>, post_start, post_start + in_pos - <span class=\"number\">1</span>);</span><br><span class=\"line\">    tree[crt].second = (in_pos == in_end - in_start) ? <span class=\"number\">0</span> : post[post_end - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(in_start + in_pos + <span class=\"number\">1</span>, in_end, post_start + in_pos, post_end - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    post.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    in.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        cin &gt;&gt; post[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        cin &gt;&gt; in[i];</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; level, tmp;</span><br><span class=\"line\">    cout &lt;&lt; post[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tree[post[n - <span class=\"number\">1</span>]].first != <span class=\"number\">0</span>)</span><br><span class=\"line\">        level.<span class=\"built_in\">push_back</span>(tree[post[n - <span class=\"number\">1</span>]].first);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tree[post[n - <span class=\"number\">1</span>]].second != <span class=\"number\">0</span>)</span><br><span class=\"line\">        level.<span class=\"built_in\">push_back</span>(tree[post[n - <span class=\"number\">1</span>]].second);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!level.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: level)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tree[k].first != <span class=\"number\">0</span>)</span><br><span class=\"line\">                tmp.<span class=\"built_in\">push_back</span>(tree[k].first);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tree[k].second != <span class=\"number\">0</span>)</span><br><span class=\"line\">                tmp.<span class=\"built_in\">push_back</span>(tree[k].second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        level = tmp;</span><br><span class=\"line\">        tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"tips\">Tips</span></h3><ol>\n<li><p>用<code>map&lt;int,pair&lt;int,int&gt;&gt;</code>来表示二叉树，通过节点编号可以直接得知左右节点，若节点编号为0则代表该节点为空</p>\n</li>\n<li><p>注意左右子树为空的情况，也是递归结束的时候</p>\n</li>\n<li><p>在本题中其实可以无需构建出完整的二叉树，因为只需输出层次遍历序列，所以我们可以给每个编号都给予一个层次遍历的索引，最后按索引输出编号即可，详见<a href=\"https://www.liuchuo.net/archives/2100\">柳婼 の blog</a></p>\n</li>\n</ol>\n","text":"➳ENTRY Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you a...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1021」Deepest Root","uid":"984c45eac2cbd15ed424e46306609be5","slug":"「1021」Deepest-Root","date":"2022-07-05T03:27:49.000Z","updated":"2022-07-17T15:23:59.994Z","comments":true,"path":"api/articles/「1021」Deepest-Root.json","keywords":null,"cover":null,"text":"➳ENTRY A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are sup...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"},{"name":"BFS","slug":"BFS","count":10,"path":"api/tags/BFS.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"<11> Left Factoring","uid":"1a8f64477679eeab68479d654eb4e8ee","slug":"11-Left-Factoring","date":"2022-06-06T15:29:06.000Z","updated":"2022-06-06T16:21:25.701Z","comments":true,"path":"api/articles/11-Left-Factoring.json","keywords":null,"cover":[],"text":"$\\qquad$本文实现了一个较为简单的算法——文法的左公因子提取。umm其实也称不上是算法。 $\\qquad$我们的目标非常明确，就是将文法产生式的左公因式都提出来，需要注意以下几点： 在一个产生式中需要提取范围最大的公因式，即拥有该左公因式的右部应该尽可能得多 提取左公因子之...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}