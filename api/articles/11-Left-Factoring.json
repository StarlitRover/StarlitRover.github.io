{"title":"<11> Left Factoring","uid":"1a8f64477679eeab68479d654eb4e8ee","slug":"11-Left-Factoring","date":"2022-06-06T15:29:06.000Z","updated":"2022-06-06T16:21:25.000Z","comments":true,"path":"api/articles/11-Left-Factoring.json","keywords":null,"cover":[],"content":"<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>本文实现了一个较为简单的算法——文法的左公因子提取。umm其实也称不上是算法。</p>\n<img src=\"/images/编译原理/15.png\" style=\"zoom:50%;\">\n<span id=\"more\"></span>\n\n<br>\n\n<hr>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>我们的目标非常明确，就是将文法产生式的左公因式都提出来，需要注意以下几点：</p>\n<ol>\n<li><p>在一个产生式中需要提取范围最大的公因式，即拥有该左公因式的右部应该尽可能得多</p>\n</li>\n<li><p>提取左公因子之后会产生新的产生式，该产生式也可能存在左公因子，需要一并提取，因此是一种递归的思想</p>\n</li>\n<li><p>好像也就这两点…</p>\n</li>\n</ol>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>那么我们只需要从广度和深度进行确定即可。首先确定左公因子广度，即最多的含有左公因子的右部个数。很显然，对于最大的广度，只要找第一个符号相等的右部即可。确定最大广度后，我们再求这些首字符相等右部的最大深度（最长的左公因子）即可，那么就一遍一遍地遍历，直到发现其中一个右部和其他右部的第<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.179ex\" height=\"1.595ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -694 521 705\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D458\" d=\"M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z\"/></g></g></g></svg></mjx-container>位字符不同时，退出循环。构造新产生式，然后对新产生式进行左公因子提取即可。</p>\n<hr>\n<h2><span id=\"c-d-e\">C ☺ D E</span></h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">extract</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    k <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    flag <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n    next_str <span class=\"token operator\">=</span> left <span class=\"token operator\">+</span> <span class=\"token string\">\"'\"</span>\n    <span class=\"token keyword\">while</span> k <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        kk <span class=\"token operator\">=</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n        <span class=\"token comment\"># 确定横向最大距离</span>\n        <span class=\"token keyword\">while</span> kk <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>kk<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>kk <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            kk <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">if</span> kk <span class=\"token operator\">==</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n            k <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token comment\"># 确定纵向最大深度</span>\n        common <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        depth <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n        <span class=\"token keyword\">for</span> depth <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            flag <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> kk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">if</span> depth <span class=\"token operator\">&gt;=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">or</span> gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                    flag <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n                    <span class=\"token keyword\">break</span>\n            <span class=\"token keyword\">if</span> flag<span class=\"token punctuation\">:</span>\n                common <span class=\"token operator\">+=</span> gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">]</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">break</span>\n        <span class=\"token comment\"># 当整个gen[left][k]均为左公因式（flag始终为True）时必须将depth+=1，因为depth指的是左公因式的后一位</span>\n        depth <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token keyword\">if</span> flag <span class=\"token keyword\">else</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># extract common part</span>\n        gen<span class=\"token punctuation\">[</span>next_str<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">if</span> depth <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'ε'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> common <span class=\"token operator\">+</span> next_str\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> kk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            gen<span class=\"token punctuation\">[</span>next_str<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>depth<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">if</span> depth <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'ε'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            gen<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 递归调用</span>\n        extract<span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">,</span> next_str<span class=\"token punctuation\">)</span>\n        next_str <span class=\"token operator\">+=</span> <span class=\"token string\">\"'\"</span>\n        k <span class=\"token operator\">=</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\n\nn <span class=\"token operator\">=</span> <span class=\"token builtin\">eval</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token string\">'请输入文法产生式的个数：'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'请输入文法产生式：'</span><span class=\"token punctuation\">)</span>\ngen <span class=\"token operator\">=</span> <span class=\"token builtin\">dict</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    g <span class=\"token operator\">=</span> <span class=\"token builtin\">input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>replace<span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">assert</span> g<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'-&gt;'</span>\n    gen<span class=\"token punctuation\">.</span>setdefault<span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    start <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> g<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'|'</span> <span class=\"token keyword\">or</span> i <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n            i <span class=\"token operator\">+=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token keyword\">if</span> i <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token keyword\">else</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">assert</span> start <span class=\"token operator\">&lt;</span> i\n            gen<span class=\"token punctuation\">[</span>g<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">:</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n            start <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    extract<span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">,</span> g<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\nAfter left factoring:\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> key <span class=\"token keyword\">in</span> gen<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">+</span> <span class=\"token string\">' -&gt; '</span><span class=\"token punctuation\">,</span> end<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>gen<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> sep<span class=\"token operator\">=</span><span class=\"token string\">' | '</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2><span id=\"tips\">Tips</span></h2><ol>\n<li><p>数据结构与<a href=\"/post/10-NO-Left-Recursion.html\" title=\"<10> NO Left Recursion\">&lt;10&gt; NO Left Recursion</a>的类似，只是列表中无需分终结符开头还是非终结符开头，提取左公因子一视同仁</p>\n</li>\n<li><p>由于相同字符开头的右部可能很分散，不太好直接找，因此我们在提取之前可以对一个产生式的右部先按照字符序进行排序</p>\n</li>\n<li><p>用<code>[k,kk)</code>来表示最大广度范围，<code>depth</code>是最大深度，<code>next_str</code>是下一个新产生式左部的名称（就是每次加一个【‘】）</p>\n</li>\n<li><p>注意有时其中一个右部本身就是左公因式的特殊情况，此时提取后的新产生式右部需要加上【ε】</p>\n</li>\n</ol>\n<hr>\n<h2><span id=\"outcome\">Outcome</span></h2><img src=\"/images/编译原理/16.png\" style=\"zoom:60%;\">","text":"本文实现了一个较为简单的算法——文法的左公因子提取。umm其实也称不上是算法。 我们的目标非常明确，就是将文法产生式的左公因式都提出来，需要注意以下几点： 在一个产生式中需要提取范围最大的公因式，即拥有该左公因式的右部应该尽可能得多 提取左公因子之后会产生新的产生式，该产生式也可...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"},{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C ☺ D E</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Outcome</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1020」Tree Traversals","uid":"ecd0b7f9610ba01de460fb7fa358ee35","slug":"「1020」Tree-Traversals","date":"2022-07-04T03:51:27.000Z","updated":"2022-07-05T03:34:42.000Z","comments":true,"path":"api/articles/「1020」Tree-Traversals.json","keywords":null,"cover":null,"text":"➳ENTRY Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you a...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"Lexer（Ver. Hand）","uid":"e7d5cd857c1aa61505680c49d614561a","slug":"Lexer（Ver-Hand）","date":"2022-05-29T16:39:19.000Z","updated":"2022-07-17T16:52:30.000Z","comments":true,"path":"api/articles/Lexer（Ver-Hand）.json","keywords":null,"cover":[],"text":"本文介绍如何手撕词法分析器，整体来说难度不大，还是文件读取麻烦。 lexer.h#ifndef LEXER_H #define LEXER_H #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vect...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}