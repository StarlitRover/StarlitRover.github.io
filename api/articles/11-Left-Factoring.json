{"title":"<11> Left Factoring","uid":"1a8f64477679eeab68479d654eb4e8ee","slug":"11-Left-Factoring","date":"2022-06-06T15:29:06.000Z","updated":"2022-06-06T16:21:25.701Z","comments":true,"path":"api/articles/11-Left-Factoring.json","keywords":null,"cover":[],"content":"<p>$\\qquad$本文实现了一个较为简单的算法——文法的左公因子提取。umm其实也称不上是算法。</p>\n<img src=\"/images/编译原理/15.png\" style=\"zoom:50%;\">\n<span id=\"more\"></span>\n\n<br>\n\n<hr>\n<p>$\\qquad$我们的目标非常明确，就是将文法产生式的左公因式都提出来，需要注意以下几点：</p>\n<ol>\n<li><p>在一个产生式中需要提取范围最大的公因式，即拥有该左公因式的右部应该尽可能得多</p>\n</li>\n<li><p>提取左公因子之后会产生新的产生式，该产生式也可能存在左公因子，需要一并提取，因此是一种递归的思想</p>\n</li>\n<li><p>好像也就这两点…</p>\n</li>\n</ol>\n<p>$\\qquad$那么我们只需要从广度和深度进行确定即可。首先确定左公因子广度，即最多的含有左公因子的右部个数。很显然，对于最大的广度，只要找第一个符号相等的右部即可。确定最大广度后，我们再求这些首字符相等右部的最大深度（最长的左公因子）即可，那么就一遍一遍地遍历，直到发现其中一个右部和其他右部的第$k$位字符不同时，退出循环。构造新产生式，然后对新产生式进行左公因子提取即可。</p>\n<hr>\n<h2><span id=\"c-d-e\">C ☺ D E</span></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">extract</span>(<span class=\"params\">gen, left</span>):</span><br><span class=\"line\">    gen[left].sort()</span><br><span class=\"line\">    k = <span class=\"number\">0</span></span><br><span class=\"line\">    flag = <span class=\"literal\">True</span></span><br><span class=\"line\">    next_str = left + <span class=\"string\">&quot;&#x27;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> k &lt; <span class=\"built_in\">len</span>(gen[left]) - <span class=\"number\">1</span>:</span><br><span class=\"line\">        kk = k + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># 确定横向最大距离</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> kk &lt; <span class=\"built_in\">len</span>(gen[left]) <span class=\"keyword\">and</span> gen[left][kk][<span class=\"number\">0</span>] == gen[left][kk - <span class=\"number\">1</span>][<span class=\"number\">0</span>]:</span><br><span class=\"line\">            kk += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> kk == k + <span class=\"number\">1</span>:</span><br><span class=\"line\">            k += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"comment\"># 确定纵向最大深度</span></span><br><span class=\"line\">        common = gen[left][k][<span class=\"number\">0</span>]</span><br><span class=\"line\">        depth = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> depth <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">len</span>(gen[left][k])):</span><br><span class=\"line\">            flag = <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(k + <span class=\"number\">1</span>, kk):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> depth &gt;= <span class=\"built_in\">len</span>(gen[left][i]) <span class=\"keyword\">or</span> gen[left][i][depth] != gen[left][i - <span class=\"number\">1</span>][depth]:</span><br><span class=\"line\">                    flag = <span class=\"literal\">False</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> flag:</span><br><span class=\"line\">                common += gen[left][k][depth]</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"comment\"># 当整个gen[left][k]均为左公因式（flag始终为True）时必须将depth+=1，因为depth指的是左公因式的后一位</span></span><br><span class=\"line\">        depth += (<span class=\"number\">1</span> <span class=\"keyword\">if</span> flag <span class=\"keyword\">else</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\"># extract common part</span></span><br><span class=\"line\">        gen[next_str] = ([gen[left][k][depth:]] <span class=\"keyword\">if</span> depth &lt; <span class=\"built_in\">len</span>(gen[left][k]) <span class=\"keyword\">else</span> [<span class=\"string\">&#x27;ε&#x27;</span>])</span><br><span class=\"line\">        gen[left][k] = common + next_str</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(k + <span class=\"number\">1</span>, kk):</span><br><span class=\"line\">            gen[next_str].append((gen[left][k + <span class=\"number\">1</span>][depth:] <span class=\"keyword\">if</span> depth &lt; <span class=\"built_in\">len</span>(gen[left][k + <span class=\"number\">1</span>]) <span class=\"keyword\">else</span> [<span class=\"string\">&#x27;ε&#x27;</span>]))</span><br><span class=\"line\">            gen[left].pop(k + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 递归调用</span></span><br><span class=\"line\">        extract(gen, next_str)</span><br><span class=\"line\">        next_str += <span class=\"string\">&quot;&#x27;&quot;</span></span><br><span class=\"line\">        k = k + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"built_in\">eval</span>(<span class=\"built_in\">input</span>(<span class=\"string\">&#x27;请输入文法产生式的个数：&#x27;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;请输入文法产生式：&#x27;</span>)</span><br><span class=\"line\">gen = <span class=\"built_in\">dict</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">    g = <span class=\"built_in\">input</span>().replace(<span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> g[<span class=\"number\">1</span>:<span class=\"number\">3</span>] == <span class=\"string\">&#x27;-&gt;&#x27;</span></span><br><span class=\"line\">    gen.setdefault(g[<span class=\"number\">0</span>], [])</span><br><span class=\"line\">    start = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>, <span class=\"built_in\">len</span>(g)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> g[i] == <span class=\"string\">&#x27;|&#x27;</span> <span class=\"keyword\">or</span> i == <span class=\"built_in\">len</span>(g) - <span class=\"number\">1</span>:</span><br><span class=\"line\">            i += (<span class=\"number\">1</span> <span class=\"keyword\">if</span> i == <span class=\"built_in\">len</span>(g) - <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">assert</span> start &lt; i</span><br><span class=\"line\">            gen[g[<span class=\"number\">0</span>]].append(g[start:i])</span><br><span class=\"line\">            start = i + <span class=\"number\">1</span></span><br><span class=\"line\">    extract(gen, g[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;\\nAfter left factoring:&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> gen:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(key + <span class=\"string\">&#x27; -&gt; &#x27;</span>, end=<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(*gen[key], sep=<span class=\"string\">&#x27; | &#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"tips\">Tips</span></h2><ol>\n<li><p>数据结构与<a href=\"/post/10-NO-Left-Recursion.html\" title=\"&lt;10&gt; NO Left Recursion\">&lt;10&gt; NO Left Recursion</a>的类似，只是列表中无需分终结符开头还是非终结符开头，提取左公因子一视同仁</p>\n</li>\n<li><p>由于相同字符开头的右部可能很分散，不太好直接找，因此我们在提取之前可以对一个产生式的右部先按照字符序进行排序</p>\n</li>\n<li><p>用<code>[k,kk)</code>来表示最大广度范围，<code>depth</code>是最大深度，<code>next_str</code>是下一个新产生式左部的名称（就是每次加一个【‘】）</p>\n</li>\n<li><p>注意有时其中一个右部本身就是左公因式的特殊情况，此时提取后的新产生式右部需要加上【ε】</p>\n</li>\n</ol>\n<hr>\n<h2><span id=\"outcome\">Outcome</span></h2><img src=\"/images/编译原理/16.png\" style=\"zoom:60%;\">","text":"$\\qquad$本文实现了一个较为简单的算法——文法的左公因子提取。umm其实也称不上是算法。 $\\qquad$我们的目标非常明确，就是将文法产生式的左公因式都提出来，需要注意以下几点： 在一个产生式中需要提取范围最大的公因式，即拥有该左公因式的右部应该尽可能得多 提取左公因子之...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C ☺ D E</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Outcome</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1020」Tree Traversals","uid":"ecd0b7f9610ba01de460fb7fa358ee35","slug":"「1020」Tree-Traversals","date":"2022-07-04T03:51:27.000Z","updated":"2022-07-05T03:34:42.057Z","comments":true,"path":"api/articles/「1020」Tree-Traversals.json","keywords":null,"cover":null,"text":"➳ENTRY Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you a...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"Lexer（Ver. Hand）","uid":"e7d5cd857c1aa61505680c49d614561a","slug":"Lexer（Ver-Hand）","date":"2022-05-29T16:39:19.000Z","updated":"2022-07-17T16:52:30.380Z","comments":true,"path":"api/articles/Lexer（Ver-Hand）.json","keywords":null,"cover":[],"text":"$\\qquad$本文介绍如何手撕词法分析器，整体来说难度不大，还是文件读取麻烦。 lexer.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}