{"title":"『1163」Dijkstra Sequence","uid":"ed0b23be5de3068df8822b7f089d6673","slug":"『1163」Dijkstra-Sequence","date":"2022-12-01T16:57:57.000Z","updated":"2022-12-02T06:59:49.706Z","comments":true,"path":"api/articles/『1163」Dijkstra-Sequence.json","keywords":null,"cover":null,"content":"<p>Dijkstra’s algorithm is one of the very famous greedy algorithms.<br>It is used for solving the single source shortest path problem which gives the shortest paths from one particular source vertex to all the other vertices of the given graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.</p>\n<p>In this algorithm, a set contains vertices included in shortest path tree is maintained. During each step, we find one vertex which is not yet included and has a minimum distance from the source, and collect it into the set. Hence step by step an ordered sequence of vertices, let’s call it <strong>Dijkstra sequence</strong>, is generated by Dijkstra’s algorithm.</p>\n<p>On the other hand, for a given graph, there could be more than one Dijkstra sequence. For example, both { 5, 1, 3, 4, 2 } and { 5, 3, 1, 2, 4 } are Dijkstra sequences for the graph, where 5 is the source. Your job is to check whether a given sequence is Dijkstra sequence or not.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line contains two positive integers $N_v (≤10^3)$ and $N_e​ (≤10^5)$, which are the total numbers of vertices and edges, respectively. Hence the vertices are numbered from 1 to $N_v$​.</p>\n<p>Then Ne​ lines follow, each describes an edge by giving the indices of the vertices at the two ends, followed by a positive integer weight (≤100) of the edge. It is guaranteed that the given graph is connected.</p>\n<p>Finally the number of queries, K, is given as a positive integer no larger than 100, followed by K lines of sequences, each contains a permutationof the Nv​ vertices. It is assumed that the first vertex is the source for each sequence.</p>\n<p>All the inputs in a line are separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each of the K sequences, print in a line <code>Yes</code> if it is a Dijkstra sequence, or <code>No</code> if not.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 7</span><br><span class=\"line\">1 2 2</span><br><span class=\"line\">1 5 1</span><br><span class=\"line\">2 3 1</span><br><span class=\"line\">2 4 1</span><br><span class=\"line\">2 5 2</span><br><span class=\"line\">3 5 1</span><br><span class=\"line\">3 4 1</span><br><span class=\"line\">4</span><br><span class=\"line\">5 1 3 4 2</span><br><span class=\"line\">5 3 1 2 4</span><br><span class=\"line\">2 3 4 5 1</span><br><span class=\"line\">3 2 1 5 4</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Yes</span><br><span class=\"line\">Yes</span><br><span class=\"line\">Yes</span><br><span class=\"line\">No</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$考察对Dijkstra算法的本质理解，不难。我们知道，给定起点，Dijkstra算法会逐一把距离起点由近到远的顶点加入到一个集合中，也就是已经确定到起点最短距离的顶点们，那么将顶点的加入顺序称为<strong>Dijkstra Sequence</strong>。现在给定一个无向图和若干序列，判断它们是否为这张图的Dijkstra Sequence。注意到，由于部分顶点到起点的最短距离相同，因此一张图存在多个Dijkstra Sequence。</p>\n<p>$\\qquad$很显然，直接上Dijkstra算法，由于是检查，因此我们不用完全按流程走。按照顺序遍历给出的序列$s_i$，我们只要保证当前未加入集合中没有比$s_i$距离起点更近的顶点即可，如果有更近的顶点说明不是Dijkstra Sequence退出循环，否则更新与$s_i$关联顶点到起点的距离，并将$s_i$到起点的距离改为<code>INT32_MAX</code>（后面就无需考虑$s_i$是否已在集合中）然后重复循环。</p>\n<p>⚠️ 不要更新那些已经在集合中的顶点到起点的距离，因此还是需要标记位于集合中的顶点。 </p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v, e, a, b, d, k;</span><br><span class=\"line\">    cin &gt;&gt; v &gt;&gt; e;</span><br><span class=\"line\">    vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">edge</span>(v + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; e; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class=\"line\">        edge[a].<span class=\"built_in\">emplace_back</span>(b, d);</span><br><span class=\"line\">        edge[b].<span class=\"built_in\">emplace_back</span>(a, d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cin &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dj</span><span class=\"params\">(v)</span>, <span class=\"title\">dist</span><span class=\"params\">(v + <span class=\"number\">1</span>, INT32_MAX)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(v + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> ans = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;t: dj) cin &gt;&gt; t;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;t: edge[dj[<span class=\"number\">0</span>]])</span><br><span class=\"line\">            dist[t.first] = t.second;</span><br><span class=\"line\">        visited[dj[<span class=\"number\">0</span>]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; v; dist[dj[j]] = INT32_MAX, visited[dj[j]] = <span class=\"literal\">true</span>, ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(ans = *<span class=\"built_in\">min_element</span>(dist.<span class=\"built_in\">begin</span>(), dist.<span class=\"built_in\">end</span>()) == dist[dj[j]]))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;t: edge[dj[j]])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (visited[t.first]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                dist[t.first] = <span class=\"built_in\">min</span>(dist[dj[j]] + t.second, dist[t.first]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(ans ? <span class=\"string\">&quot;Yes\\n&quot;</span> : <span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"Dijkstra’s algorithm is one of the very famous greedy algorithms.It is used for solving the single source shortest path problem which gives ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Dijkstra","slug":"Dijkstra","count":6,"path":"api/tags/Dijkstra.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1164」Good in C","uid":"e7fe1381af6f1b05a70d02f02d73c22d","slug":"「1164」Good-in-C","date":"2022-12-02T05:51:06.000Z","updated":"2022-12-02T06:57:44.180Z","comments":true,"path":"api/articles/「1164」Good-in-C.json","keywords":null,"cover":[],"text":"When your interviewer asks you to write “Hello World” using C, can you do as the following figure shows? Input Specification:Each input file...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1162』Postfix Expression","uid":"7d33432dbf79dd8f70b2b1b9bfcc3dbc","slug":"「1162』Postfix-Expression","date":"2022-12-01T16:02:39.000Z","updated":"2022-12-01T16:10:50.838Z","comments":true,"path":"api/articles/「1162』Postfix-Expression.json","keywords":null,"cover":[],"text":"Given a syntax tree (binary), you are supposed to output the corresponding postfix expression, with parentheses reflecting the precedences o...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"traversal order","slug":"traversal-order","count":13,"path":"api/tags/traversal-order.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}