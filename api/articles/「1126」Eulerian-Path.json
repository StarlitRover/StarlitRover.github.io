{"title":"「1126」Eulerian Path","uid":"9c2a27d777225ad7770aaf3f1ce46c04","slug":"「1126」Eulerian-Path","date":"2022-11-23T07:17:49.000Z","updated":"2022-11-23T07:28:33.075Z","comments":true,"path":"api/articles/「1126」Eulerian-Path.json","keywords":null,"cover":null,"content":"<p>In graph theory, an Eulerian path is a path in a graph which visits every edge exactly once. Similarly, an Eulerian circuit is an Eulerian path which starts and ends on the same vertex. They were first discussed by Leonhard Euler while solving the famous Seven Bridges of Konigsberg problem in 1736. It has been proven that connected graphs with all vertices of even degree have an Eulerian circuit, and such graphs are called <strong>Eulerian</strong>. If there are exactly two vertices of odd degree, all Eulerian paths start at one of them and end at the other. A graph that has an Eulerian path but not an Eulerian circuit is called <strong>semi-Eulerian</strong>. (Cited from <a href=\"https://en.wikipedia.org/wiki/Eulerian_path\">https://en.wikipedia.org/wiki/Eulerian_path</a>)</p>\n<p>Given an undirected graph, you are supposed to tell if it is Eulerian, semi-Eulerian, or non-Eulerian.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. Each case starts with a line containing 2 numbers N (≤ 500), and M, which are the total number of vertices, and the number of edges, respectively. Then M lines follow, each describes an edge by giving the two ends of the edge (the vertices are numbered from 1 to N).</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, first print in a line the degrees of the vertices in ascending order of their indices. Then in the next line print your conclusion about the graph – either <code>Eulerian</code>, <code>Semi-Eulerian</code>, or <code>Non-Eulerian</code>. Note that all the numbers in the first line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.</p>\n<h3><span id=\"sample-input-1\">Sample Input 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 12</span><br><span class=\"line\">5 7</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">2 3</span><br><span class=\"line\">2 4</span><br><span class=\"line\">3 4</span><br><span class=\"line\">5 2</span><br><span class=\"line\">7 6</span><br><span class=\"line\">6 3</span><br><span class=\"line\">4 5</span><br><span class=\"line\">6 4</span><br><span class=\"line\">5 6</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-1\">Sample Output 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 4 4 4 4 4 2</span><br><span class=\"line\">Eulerian</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-input-2\">Sample Input 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 10</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">2 3</span><br><span class=\"line\">2 4</span><br><span class=\"line\">3 4</span><br><span class=\"line\">5 2</span><br><span class=\"line\">6 3</span><br><span class=\"line\">4 5</span><br><span class=\"line\">6 4</span><br><span class=\"line\">5 6</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-2\">Sample Output 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 4 4 4 3 3</span><br><span class=\"line\">Semi-Eulerian</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-input-3\">Sample Input 3:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 8</span><br><span class=\"line\">1 2</span><br><span class=\"line\">2 5</span><br><span class=\"line\">5 4</span><br><span class=\"line\">4 1</span><br><span class=\"line\">1 3</span><br><span class=\"line\">3 2</span><br><span class=\"line\">3 4</span><br><span class=\"line\">5 3</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-3\">Sample Output 3:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 3 4 3 3</span><br><span class=\"line\">Non-Eulerian</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$判断图为欧拉图（所有节点的度为偶数）、半欧拉图（除了两个节点度为奇数，其余点度均为偶数） or 非欧拉图。题目都把判断方式写出来了，剩下的就考察英语阅读理解了。</p>\n<p>$\\qquad$当然这一切成立还存在一个前提条件，也是测试点3暗藏的大坑——这个图必须是连通图。这个点其实不难想到，因为计算机中将0也视为偶数，那么如果一条边也没有，所有点度都为偶数，按照上述理论应为欧拉图（礼貌的微笑.jpg）。所以判断前别忘了来个【DFS&#x2F;BFS&#x2F;并查集】检查一下连通性。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; edge;</span><br><span class=\"line\">vector&lt;<span class=\"type\">bool</span>&gt; flag;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    flag[n] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: edge[n])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag[k]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        sum += <span class=\"built_in\">dfs</span>(k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, a, b;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    edge.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>), flag.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        edge[a].<span class=\"built_in\">push_back</span>(b), edge[b].<span class=\"built_in\">push_back</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> odd = edge[<span class=\"number\">1</span>].<span class=\"built_in\">size</span>() % <span class=\"number\">2</span>, even = <span class=\"number\">1</span> - edge[<span class=\"number\">1</span>].<span class=\"built_in\">size</span>() % <span class=\"number\">2</span>;</span><br><span class=\"line\">    cout &lt;&lt; edge[<span class=\"number\">1</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; edge[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        edge[i].<span class=\"built_in\">size</span>() % <span class=\"number\">2</span> ? ++odd : ++even;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>) &lt; n) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Non-Eulerian&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(even == n ? <span class=\"string\">&quot;Eulerian&quot;</span> : (odd == <span class=\"number\">2</span> ? <span class=\"string\">&quot;Semi-Eulerian&quot;</span> : <span class=\"string\">&quot;Non-Eulerian&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"In graph theory, an Eulerian path is a path in a graph which visits every edge exactly once. Similarly, an Eulerian circuit is an Eulerian p...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"},{"name":"DFS","slug":"DFS","count":7,"path":"api/tags/DFS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 3:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 3:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"『1127』ZigZagging on a Tree","uid":"dec46595a39d6d567d60096de34e1f5b","slug":"『1127』ZigZagging-on-a-Tree","date":"2022-11-23T08:27:59.000Z","updated":"2022-11-23T08:38:26.500Z","comments":true,"path":"api/articles/『1127』ZigZagging-on-a-Tree.json","keywords":null,"cover":[],"text":"Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postord...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"traversal order","slug":"traversal-order","count":13,"path":"api/tags/traversal-order.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1125」Chain the Ropes","uid":"e21aa88525fef8dbccd8e7f69148bf51","slug":"「1125」Chain-the-Ropes","date":"2022-11-22T16:47:47.000Z","updated":"2022-11-22T16:57:28.650Z","comments":true,"path":"api/articles/「1125」Chain-the-Ropes.json","keywords":null,"cover":[],"text":"Given some segments of rope, you are supposed to chain them into one rope. Each time you may only fold two segments into loops and chain the...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"贪心","slug":"贪心","count":1,"path":"api/tags/贪心.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}