{"title":"Bézier Curve：小试牛刀","uid":"a39f642fa5f3a366579e792c57ec2418","slug":"Bezier-Curve","date":"2022-03-08T08:47:55.000Z","updated":"2022-06-01T13:43:08.012Z","comments":true,"path":"api/articles/Bezier-Curve.json","keywords":null,"cover":[],"content":"<p>$\\qquad$贝塞尔曲线有着很多特殊的性质在图形设计和路径规划中应用都非常广泛。贝塞尔曲线完全由其控制点决定其形状，n个控制点对应着n-1阶的贝塞尔曲线，并且可以通过递归来定义。本篇文章的重点在于对<strong>Bézier Curve</strong>的理解以及用<strong>OpenGL</strong>绘制<strong>Bézier Curve</strong>。</p>\n<img src=\"/images/计算机图形学/3/1.png\" style=\"zoom:50%;\">\n\n<span id=\"more\"></span>\n\n<h2><span id=\"bézier-curve1阶\">〄 Bézier Curve·1阶</span></h2><p>$\\qquad$给定两个已知坐标的控制点$P_ 0，P_ 1$，那么1阶贝塞尔曲线可以用一个关于t的参数方程来描述：<br>$$<br>\\mathbf{B}_ 1(t)&#x3D;(1-t)\\cdot \\mathbf{P}_ {0}+t\\cdot \\mathbf{P}_ {1}\\ ,\\ t \\in[0,1]<br>$$<br>$\\qquad$很显然，这表示的即是两控制点之间的线段，而每一个$t$则表示线段上的一个点，这个关于$t$的动点我们姑且先称之为<big>贝塞尔动点</big>，贝塞尔动点遍历$t\\in[0,1]$便构成贝塞尔曲线。</p>\n<p>$\\qquad$⚠️事实上贝塞尔曲线本身跟$t$是无关的，$t$只是方便描述曲线上的点而存在的，可以认为是画出贝塞尔曲线的画笔。<br><br></p>\n<h2><span id=\"bézier-curve2阶\">〄 Bézier Curve·2阶</span></h2><p>$\\qquad$给定三个已知坐标的控制点$P_ 0，P_ 1，P_ 2$，那么这时候有两个线段，我们可以先求出这两个线段上的贝塞尔动点$P’_ 0,P’_ 1$，然后求两个贝塞尔动点线段上的贝塞尔动点（三个贝塞尔动点关联同一个$t$），第三个贝塞尔动点将构成2阶贝塞尔曲线：<br>$$<br>\\mathbf{B}_ 2(t)&#x3D;(1-t) \\mathbf{P}_ {0}’+t\\mathbf{P}_ {1}’&#x3D;(1-t)[(1-t)\\mathbf{P}_ {0}+t\\mathbf{P}_ {1}]+t[(1-t)\\mathbf{P}_ {1}+t\\mathbf{P}_ {2}]\\ ,\\ t \\in[0,1]<br>$$<br>$\\qquad$那么2阶贝塞尔曲线的参数方程即为<br>$$<br>\\mathbf{B}_ 2(t)&#x3D;(1-t)^{2} \\mathbf{P}_ {0}+2 t(1-t) \\mathbf{P}_ {1}+t^{2} \\mathbf{P}_{2}\\ ,\\ t \\in[0,1]<br>$$<br>$\\qquad$我们可以看到这是一个递归的过程。<br><br></p>\n<h2><span id=\"bézier-curve3阶\">〄 Bézier Curve·3阶</span></h2><p>$\\qquad$同理3阶贝塞尔曲线的方程为<br>$$<br>\\mathbf{B}_ 3(t)&#x3D;\\mathbf{P}_ {0}(1-t)^{3}+3 \\mathbf{P}_ {1} t(1-t)^{2}+3 \\mathbf{P}_ {2} t^{2}(1-t)+\\mathbf{P}_{3} t^{3}, t \\in[0,1]<br>$$<br>$\\qquad$下图是当$t&#x3D;0.5$时的贝塞尔动点线段以及相应的3阶贝塞尔曲线</p>\n<img src=\"/images/计算机图形学/3/2.jpeg\" style=\"zoom:40%;\">\n\n<br>\n\n<p>$\\qquad$事实上对于贝塞尔曲线参数方程中每个控制点前的系数都是一个关于$t$的函数，而这些系数函数我们可以类比杨辉三角（贝塞尔曲线的递归过程本质上就是个杨辉三角）</p>\n<img src=\"/images/计算机图形学/3/3.png\" style=\"zoom:40%;\">\n\n<p>$\\qquad$上图只是一个三阶的杨辉三角，我们可以看到每个控制点所在的叶子节点到根结点（最上面的那个点）的路径乘积乘以其所在叶子节点上的数字即为其系数函数。比如说$P_ 2$，我们随便取一条到根结点的路径（不管哪条路径，乘积都是一样的），将路径上的$t$表达式进行相乘得到$t^2(1-t)$，再乘以其叶子节点3得到$3t^2(1-t)$，对照$\\mathbf{B}_ 3(t)$即为$P_2$的系数。<br><br></p>\n<h2><span id=\"bézier-curve-n-阶\">〄 Bézier Curve· $n$ 阶</span></h2><p>$\\qquad$注意到上图中的杨辉三角其实就是$[t+(1-t)]^n$的展开式，因此我们其实可以直接写出$n$阶贝塞尔曲线$\\mathbf{B}_ n(t)$中控制点$\\mathbf{P}_ i(0\\leq i&lt; n )$的系数为<br>$$<br>b_ {i,n}(t)&#x3D;\\mathrm{C}_n^i\\cdot t^i(1-t)^{n-i}<br>$$<br>$\\qquad$上式又称为<em>n</em>阶的波恩斯坦基底多项式。</p>\n<hr>\n<p>$\\qquad$接下来就到了激动人心的绘制阶段。不过其实理论内容已经差不多了，剩余的只是C++编程，OpenGL运用。</p>\n<p>$\\qquad$代码里没有什么高深的思想，没有啥优化（概括：懒），就是实现了一个点类，然后不断递归求出新的控制点坐标。当然OpenGL不能绘制连续的曲线，因此我们需要化曲为直。这时候$t$就派上用场了，我将$t$从$[0,1]$中均匀地取100个出来分别绘制相应的点，最后将这些点连起来即可。</p>\n<br>\n\n<h3><span id=\"︎-算法说明\">⚡︎ 算法说明</span></h3><ol>\n<li><p>实现了一个点类<code>Point</code>，用于存储一个点的坐标（<code>double x,y</code>），并重载了*、+符号，使坐标可以直接与浮点数进行加乘运算</p>\n</li>\n<li><p>首先需要用户输入需要绘制的贝塞尔曲线的阶数$n$，随后输入$n+1$个控制定点的坐标，最后指定$t_0$来绘制出相应的中间迭代控制点</p>\n<img src=\"/images/计算机图形学/3/5.png\" style=\"zoom:40%;\">\n</li>\n<li><p>对每个点的坐标都$&#x2F;100$来满足实际绘图坐标的范围（绘制函数传入的坐标范围$0\\leq |x|,|y|\\leq 1$）</p>\n</li>\n<li><p><code>vector&lt;vector&lt;Point&gt;&gt; control_points</code>存储参数$t_0$所对应的每一次迭代的控制点坐标，<code>control_points[i]</code>存储的是第$i$次迭代的控制点坐标</p>\n</li>\n<li><p>若$\\mathbf{P}^i_j$表示第$i$次迭代的第$j$个控制点，那么控制点的迭代公式：</p>\n</li>\n</ol>\n<p>$$<br>\\mathbf{P}^i_ j&#x3D;(1-t)\\cdot\\mathbf{P}^{i-1}_ j+t\\cdot\\mathbf{P}^{i-1}_{j+1}<br>$$</p>\n<ol start=\"6\">\n<li>绘制贝塞尔曲线是化曲为直，首先均匀取了100个$t\\in[0,1]$，画出每个$t$所对应的位于贝塞尔曲线上的点，最后将每个点连起来</li>\n<li><code>vector&lt;vector&lt;Point&gt;&gt; middle_points</code>存储的是每个$t$迭代过程中的中间控制点坐标以及最后所要连起来的100个点</li>\n<li>绘制过程：$t_0$对应的迭代过程控制点连线→贝塞尔曲线连线→$t_0$在贝塞尔曲线上对应的点</li>\n</ol>\n<br>\n\n<p>$\\qquad$其余就看代码注释吧～</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glew.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glfw3.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重载了*，+运算符的点类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">double</span> _x, <span class=\"type\">double</span> _y) : <span class=\"built_in\">x</span>(_x), <span class=\"built_in\">y</span>(_y) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Point <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> <span class=\"type\">double</span> &amp;t) <span class=\"type\">const</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(t * <span class=\"keyword\">this</span>-&gt;x, t * <span class=\"keyword\">this</span>-&gt;y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">inline</span> Point <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> Point &amp;rhs) <span class=\"type\">const</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Point</span>(<span class=\"keyword\">this</span>-&gt;x + rhs.x, <span class=\"keyword\">this</span>-&gt;y + rhs.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Bézier Curve的阶数：&quot;</span>;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//control_points存储指定t的每一次迭代控制点，middle_points存储绘制过程中的每一次迭代控制点（t会变）</span></span><br><span class=\"line\">    vector&lt;vector&lt;Point&gt;&gt; <span class=\"built_in\">control_points</span>(n + <span class=\"number\">1</span>), <span class=\"built_in\">middle_points</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">double</span> x, y, t0;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;请输入&quot;</span> &lt;&lt; n + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot;个控制点坐标（0 ≤ |x|,|y| ≤ 100）：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">        control_points[<span class=\"number\">0</span>].<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">Point</span>(x / <span class=\"number\">100</span>, y / <span class=\"number\">100</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//输入指定t，可绘制出t0时每一次的迭代控制点</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;t0 = &quot;</span>;</span><br><span class=\"line\">    cin &gt;&gt; t0;</span><br><span class=\"line\">    <span class=\"comment\">//计算t0时每一次的迭代控制点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n + <span class=\"number\">1</span> - i; ++j)</span><br><span class=\"line\">            control_points[i].<span class=\"built_in\">emplace_back</span>(control_points[i - <span class=\"number\">1</span>][j] * (<span class=\"number\">1</span> - t0) + control_points[i - <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] * t0);</span><br><span class=\"line\">    <span class=\"comment\">//求100个t所对应的点</span></span><br><span class=\"line\">    middle_points[<span class=\"number\">0</span>] = control_points[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">101</span>; ++k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> t = k / <span class=\"number\">100.0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            middle_points[i].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n + <span class=\"number\">1</span> - i; ++j)</span><br><span class=\"line\">                middle_points[i].<span class=\"built_in\">emplace_back</span>(middle_points[i - <span class=\"number\">1</span>][j] * (<span class=\"number\">1</span> - t) + middle_points[i - <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] * t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        middle_points[n].<span class=\"built_in\">emplace_back</span>(middle_points[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>] * (<span class=\"number\">1</span> - t) + middle_points[n - <span class=\"number\">1</span>][<span class=\"number\">1</span>] * t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//开始绘制，初始化glfw库</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">glfwInit</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//创建窗口以及上下文</span></span><br><span class=\"line\">    GLFWwindow *window = <span class=\"built_in\">glfwCreateWindow</span>(<span class=\"number\">800</span>, <span class=\"number\">600</span>, <span class=\"string\">&quot;Bézier Curve&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!window)</span><br><span class=\"line\">        <span class=\"built_in\">glfwTerminate</span>();</span><br><span class=\"line\">    <span class=\"comment\">//建立当前窗口的上下文</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwMakeContextCurrent</span>(window);</span><br><span class=\"line\">    <span class=\"comment\">//循环绘制使其停留在屏幕上</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!<span class=\"built_in\">glfwWindowShouldClose</span>(window))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">glfwPollEvents</span>();</span><br><span class=\"line\">        <span class=\"comment\">//背景颜色</span></span><br><span class=\"line\">        <span class=\"built_in\">glClearColor</span>(<span class=\"number\">0.2</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//绘制t0时每次迭代的控制点连线</span></span><br><span class=\"line\">        <span class=\"built_in\">glLineWidth</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//使每次迭代的控制点连线颜色不同</span></span><br><span class=\"line\">            <span class=\"built_in\">glColor3f</span>(<span class=\"number\">1.0</span> * (n - <span class=\"number\">1</span> - i) / (n - <span class=\"number\">1</span>), <span class=\"number\">1.0</span> * i / (n - <span class=\"number\">1</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"built_in\">glBegin</span>(GL_LINE_STRIP);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;p: control_points[i])</span><br><span class=\"line\">                <span class=\"built_in\">glVertex2f</span>(p.x, p.y);</span><br><span class=\"line\">            <span class=\"built_in\">glEnd</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//绘制贝塞尔曲线</span></span><br><span class=\"line\">        <span class=\"built_in\">glColor3f</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">glBegin</span>(GL_LINE_STRIP);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;p: middle_points[n])</span><br><span class=\"line\">            <span class=\"built_in\">glVertex2f</span>(p.x, p.y);</span><br><span class=\"line\">        <span class=\"built_in\">glEnd</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//绘制出贝塞尔曲线上t0所对应的点</span></span><br><span class=\"line\">        <span class=\"built_in\">glColor3f</span>(<span class=\"number\">0</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.7</span>);</span><br><span class=\"line\">        <span class=\"built_in\">glPointSize</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">        <span class=\"built_in\">glEnable</span>(GL_POINT_SMOOTH);</span><br><span class=\"line\">        <span class=\"built_in\">glBegin</span>(GL_POINTS);</span><br><span class=\"line\">        <span class=\"built_in\">glVertex2f</span>(control_points[n][<span class=\"number\">0</span>].x, control_points[n][<span class=\"number\">0</span>].y);</span><br><span class=\"line\">        <span class=\"built_in\">glEnd</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">glfwSwapBuffers</span>(window);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">glfwTerminate</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3><span id=\"︎-5th-order-bezier-curve-t_0x3d05\">⚛︎ 5$^{th}$ order Bezier curve ($t_0&#x3D;0.5$)</span></h3><img src=\"/images/计算机图形学/3/4.jpg\" style=\"zoom:50%;\">\n","text":"$\\qquad$贝塞尔曲线有着很多特殊的性质在图形设计和路径规划中应用都非常广泛。贝塞尔曲线完全由其控制点决定其形状，n个控制点对应着n-1阶的贝塞尔曲线，并且可以通过递归来定义。本篇文章的重点在于对Bézier Curve的理解以及用OpenGL绘制Bézier Curve。 ...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"计算机图形学","slug":"计算机图形学","count":3,"path":"api/categories/计算机图形学.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">〄 Bézier Curve·1阶</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">〄 Bézier Curve·2阶</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">〄 Bézier Curve·3阶</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">〄 Bézier Curve· $n$ 阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">⚡︎ 算法说明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">⚛︎ 5$^{th}$ order Bezier curve ($t_0&#x3D;0.5$)</span></a></li></ol></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「Section 4」定点数的乘除法实现","uid":"22f37ab474c466341b4a621e124d19bc","slug":"定点数的乘除法实现","date":"2022-03-09T01:13:56.000Z","updated":"2022-06-19T02:52:05.419Z","comments":true,"path":"api/articles/定点数的乘除法实现.json","keywords":null,"cover":[],"text":"☙ 定点乘法运算Σ 原码一位乘法$\\qquad[X]_ {原}&#x3D;X_ sX_ 1X_ 2…X_ n\\ ,\\ [Y]_ {原}&#x3D;Y_ sY_ 1Y_ 2…Y_ n\\ ,\\ P&#x3D;X\\cdot Y$，其中$X_ s,Y_ s,P_s$为符号位。 符号位单独...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「Section 0」小记OpenGL","uid":"df24c0ec65d9b0432ce3e888de12a2d4","slug":"小记OpenGL","date":"2022-03-08T08:01:35.000Z","updated":"2022-03-08T08:27:20.609Z","comments":true,"path":"api/articles/小记OpenGL.json","keywords":null,"cover":[],"text":" glfwMakeContextCurrent(GLFWwindow *window)：将窗口window设为当前上下文 OpenGL可以认为是一个巨大的状态机。所谓状态机，是一个包含了许多当前属性（背景颜色、渲染模式）的集合（状态），里面的属性值直到下次修改前都不会改变。那么当...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"计算机图形学","slug":"计算机图形学","count":3,"path":"api/categories/计算机图形学.json"}],"tags":[{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}