{"title":"「Section 3」补码加减运算方法","uid":"916fffb6f0cf37494d0f7af19c9c80e4","slug":"补码加减运算方法","date":"2022-03-04T09:46:00.000Z","updated":"2022-03-14T12:23:06.655Z","comments":true,"path":"api/articles/补码加减运算方法.json","keywords":null,"cover":null,"content":"<p>$\\qquad$目前计算机中的数据普遍是用补码存储的，因为补码具有简单的加减法规则，运算简单，易于实现，而且<mark>符号位可以和数值位一起参与运算</mark>。</p>\n<p>$\\qquad\\quad$α. <a href=\"#1\">补码规则运算</a></p>\n<p>$\\qquad\\quad$β. <a href=\"#2\">溢出检测</a></p>\n<p>$\\qquad\\quad$γ. <a href=\"#3\">机器数的移位运算</a></p>\n<span id=\"more\"></span>\n\n<hr>\n<h2><span id=\"α-补码运算规则\">α <span id=\"1\">补码运算规则</span></span></h2><p>$\\qquad$补码的加减法运算公式为<br>$$<br>[x+y]_ {\\mathrm{补}}&#x3D;[x]_ {\\mathrm{补}}+[y]_{\\mathrm{补}}<br>$$</p>\n<p>$$<br>[x-y]_ {\\mathrm{补}}&#x3D;[x]_ {\\mathrm{补}}+[-y]_{\\mathrm{补}}<br>$$</p>\n<p>在<a href=\"/post/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.html\" title=\"「Section 1」数据格式\">「Section 1」数据格式</a>中我们有提过补码的减法是用加法来实现的，这里其实就是被减数的补码+减数相反数的补码，而一个正数相反数的补码显然为其各位（包括符号位）取反+1。</p>\n<p>$\\qquad$那么上述的公式又如何被证明呢？这里需要用数论中模（mod）的概念。我们知道正数的补码即为原码，而负数的补码则是各位取反+1，这两种情况是分开的，那是否有一种方式能将两者大一统呢？事实上，我们可以认为一个数的补码（算上符号位是$n$位的补码）是该数模$2^{n+1}$的结果：<br>$$<br>[X]_{\\mathrm{补}}&#x3D;X\\ (\\mathrm{mod}\\ 2^{n+1})&#x3D;(2^{n+1}+X)\\ (\\mathrm{mod}\\ 2^{n+1})<br>$$<br>$\\qquad$这里的mod是取余的意思。我们规定余数必须为正，那么一个负数$Y$模$2^{n+1}$的余数即为$2^{n+1}-|Y|&#x3D;2^{n+1}+Y\\ (Y&lt;0)$，就会发现补码的定义确实如此。</p>\n<p>$\\qquad$那么，<br>$$<br>[x]_ {\\mathrm{补}}+[y]_ {\\mathrm{补}}&#x3D;[(2^{n+1}+x)+(2^{n+1}+y)]\\ (\\mathrm{mod}\\ 2^{n+1})&#x3D;[2^{n+1}+(x+y)]\\ (\\mathrm{mod}\\ 2^{n+1})&#x3D;[x+y]_{\\mathrm{补}}<br>$$</p>\n<p>$\\qquad$根据上式，第二个等式由 $[x-y]_ {\\mathrm{补}}&#x3D;[x+(-y)]_{\\mathrm{补}}$ 则显然成立。</p>\n<hr>\n<h2><span id=\"β-溢出检测\">β <span id=\"2\">溢出检测</span></span></h2><p>$\\qquad$我们很高兴地发现了补码运算的简便，但算着算着就会发现一些神奇的情况，比如说<br>$$<br>10010+10001&#x3D;^{?}00011<br>$$<br>$\\qquad$怎么说呢，就是两个负数加起来变正了。想必，这就是物极必反吧（bushi</p>\n<p>$\\qquad$这个式子的真面目应该是<br>$$<br>10010+10001&#x3D;100011<br>$$<br>$\\qquad$然而机器数的位数是有限制的，计算机难以容忍多出的一位，因此直接将最高位扔掉了，只是他不知道最高位有着特殊含义。这种现象我们称之为溢出（一般指上溢出）。</p>\n<p>$\\qquad$溢出在所难免，因此计算机必须解决溢出的问题，需要检测并指示。</p>\n<br>\n\n<h3><span id=\"︎-单符号位判溢方法\">❄︎ 单符号位判溢方法</span></h3><p>$\\qquad$我们清楚事实上只有当绝对值变大，即同号相加、异号相减（两者本质相同）的情况才会发生溢出，我们设$V$为<mark>溢出符号位</mark>，$X_f,Y_f$为两个运算数的最高符号位，$S_f$为运算结果符号位，而$O$则表示运算符，0为+，1为-，那么有<br>$$<br>V&#x3D;\\overline{O}(\\overline{X_f} \\overline{Y_f} S_f+X_f Y_f \\overline{S_f})+O(\\overline{X_f} Y_f S_f+X_f \\overline{Y_f} \\overline{S_f})<br>$$</p>\n<h3><span id=\"︎-进位判溢方法\">❄︎ 进位判溢方法</span></h3><p>$\\qquad$设$C_f$为两数符号位相加的<strong>进位</strong>信号，$C_d$则是两数最高有效位的<strong>进位</strong>信号。由于补码可以将减法转换为加法，而且只有同号相加时会发生溢出，因此这里只考虑同号加法。符号位$S_f$在不受到$C_d$影响之前为0，那么考虑$C_d$后有$S_f&#x3D;C_d$。而$C_f$的值则代表了两数的符号，0正1负。我们清楚<mark>运算结果的符号位若与两数符号位不同</mark>则表明溢出，即$S_f&#x3D;C_d$与$C_f$不同。由于异号相加（不会发生溢出）时也有$C_f&#x3D;C_d$，因此可以将$V$的表达式直接写为<br>$$<br>V&#x3D;C_d\\oplus C_f<br>$$</p>\n<h3><span id=\"︎-双符号位判溢方法\">❄︎ 双符号位判溢方法</span></h3><p>$\\qquad$运算数采用双符号位补码（变形补码）进行运算，正数的符号位变为00，负数的符号位变为11，其余位不变。当运算结果的符号位的两位不同时表明发生溢出 。<br>$$<br>S_{f1}S_{f2}&#x3D;01⇒正溢出；S_{f1}S_{f2}&#x3D;10⇒负溢出<br>$$<br>$\\qquad$其实这是一种对进位判溢方法的应用，设两个运算数$X,Y$的符号位分别为$X_fX_f,Y_fY_f$，运算结果的符号位为$S_{f1}S_{f2}$，那么有<br>$$<br>S_{f1}&#x3D;X_f+Y_f+C_f\\ (\\mathrm{mod}\\ 2),\\ S_{f2}&#x3D;X_f+Y_f+C_d\\ (\\mathrm{mod}\\ 2)<br>$$<br>当$C_f$与$C_d$不同时$S_{f1}$与$S_{f2}$也不同。而同号运算时显然$S_{f1}&#x3D;C_f,S_{f2}&#x3D;C_d$，那么$S_{f1}S_{f2}&#x3D;01$时说明两正数相加结果为负，为正溢出；$S_{f1}S_{f2}&#x3D;10$时说明两负数相加结果为正，为负溢出。</p>\n<p>$\\qquad$⚠️第一位是正确的符号位，第二位是保留溢出位。</p>\n<hr>\n<h2><span id=\"γ-机器数的移位运算\">γ <span id=\"3\">机器数的移位运算</span></span></h2><ol>\n<li><strong>逻辑移位</strong>：直接左右补0。将移位的数据视为无符号数据，各数据位在位置上发生了变化，导致无符号数据的数值（无正负）放大或缩小。(x86:SHL,SHR;RISC-V:sll,srl)</li>\n<li><strong>算术移位</strong>：将移位的数据视为带符号机器数。算术移位的结果，在数值的绝对值上进行放大或缩小，同时，符号位必须要保持不变。(x86:SAL,SAR;RISC-V:sll,sra)<ul>\n<li><strong>补码的算数右移</strong>：高位补符号位</li>\n<li><strong>补码的算术左移</strong>：数据最高有效位必须与符号位相同才能保证不会溢出，此时可以直接将最高有效位移入符号位并在左边补0</li>\n</ul>\n</li>\n<li><strong>循环移位</strong>：所有的数据位在自身范围内进行左移或者右移，左移时最高位移入最低位，右移时最低位移入最高位。(x86:ROL,ROR,RCL,RCR)</li>\n</ol>\n","text":"$\\qquad$目前计算机中的数据普遍是用补码存储的，因为补码具有简单的加减法规则，运算简单，易于实现，而且符号位可以和数值位一起参与运算。 $\\qquad\\quad$α. 补码规则运算 $\\qquad\\quad$β. 溢出检测 $\\qquad\\quad$γ. 机器数的移位运算 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">α 补码运算规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">β 溢出检测</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">❄︎ 单符号位判溢方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">❄︎ 进位判溢方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">❄︎ 双符号位判溢方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">γ 机器数的移位运算</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「Section 1」数据库系统概论","uid":"cf7c04c438de034cff5412cfe4f52f34","slug":"数据库系统概论","date":"2022-03-06T05:11:11.000Z","updated":"2022-03-06T05:19:16.128Z","comments":true,"path":"api/articles/数据库系统概论.json","keywords":null,"cover":[],"text":" 数据库（DataBase）：存储在计算机系统内的有结构的数据结构。不仅包含数据，同时还有数据的含义、数据结构、约束的完整性定义 文件系统的缺点 数据冗余较大：数据文件无法共享 数据和程序缺乏独立性：改变数据的逻辑结构就必须修改程序 数据库管理系统（Database Manage...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"数据库原理","slug":"数据库原理","count":3,"path":"api/categories/数据库原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"OpenGL落脚CLion","uid":"481cf8b49191f67983b97c3d9fc63cfa","slug":"OpenGL落脚CLion","date":"2022-03-03T11:45:51.000Z","updated":"2022-03-19T02:30:12.010Z","comments":true,"path":"api/articles/OpenGL落脚CLion.json","keywords":null,"cover":[],"text":"$\\qquad$本篇文章将阐述在Mac os Monterey(12.2.1)的CLion(2021.3.3)上配置OpenGL的整体过程。虽然网上已有相关的文章，但有很多操作存在问题，可能是Mac系统变迁的原因，故作此文。 $\\qquad$原参考文章：Mac Clion Ope...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"血泪史","slug":"血泪史","count":2,"path":"api/categories/血泪史.json"}],"tags":[{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}