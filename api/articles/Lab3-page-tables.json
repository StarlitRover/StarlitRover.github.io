{"title":"Lab3: page tables","uid":"65d0a1b9a75654efd6950a77e52b0ae4","slug":"Lab3-page-tables","date":"2022-11-17T16:34:38.000Z","updated":"2022-11-19T10:11:48.601Z","comments":true,"path":"api/articles/Lab3-page-tables.json","keywords":null,"cover":[],"content":"<p>$\\qquad$兄弟们，我XV6又回来啦，这个栏目的灰都能把人埋了，鸽子王实锤（当然不是因为懒(⁎⁍̴̛ᴗ⁍̴̛⁎)）。不过虽迟但到！主要有时候看完文档和课程后又去搞其他飞机了，回来时，发现一切回到原点。这周发现再不搞真搞不完了，Lab3是关于页表的，文档<a href=\"https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html\">戳这</a>。 </p>\n<img src=\"/images/操作系统/5.png\" title alt data-align=\"center\">\n\n<span id=\"more\"></span>\n\n<br>\n\n<h2><span id=\"coding\">❖ Coding</span></h2><hr>\n<h4><span id=\"︎-speed-up-system-calls-easy\">☑︎ Speed up system calls (easy)</span></h4><p>$\\qquad$由于用户在使用系统调用时需要从用户空间跳转到内核空间，存在一定的时间开销。我们可以通过建立一段用户（只读）和内核共享的内存空间来避免空间跳转的时间，从而加速系统调用。这是一些操作系统的常见优化方法，本实验就是希望你以此来优化getpid系统调用。</p>\n<p>$\\qquad$我们知道每个用户进程都拥有自己的虚拟空间，通过页表查找到物理地址后再进行相应的操作。因此这段共享空间的起始地址也需要记录在进程的页表上。实验文档指出，每个进程在创建时都需要新建一个只读页（shared memory），并将其物理地址映射到虚拟地址USYSCALL（一个已经存在的宏定义），然后在这一页的开头存储一个<code>struct usyscall</code>（memlayout.h），并把进程pid存入这个结构体中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">76</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">usyscall</span> &#123;</span>                       </span><br><span class=\"line\"><span class=\"number\">77</span>   <span class=\"type\">int</span> pid;  <span class=\"comment\">// Process ID</span></span><br><span class=\"line\"><span class=\"number\">78</span> &#125;;     </span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$接着我们再来瞅瞅user&#x2F;ulib.c中ugetpid的具体实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">144</span>   │ <span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB_PGTBL</span></span><br><span class=\"line\"><span class=\"number\">145</span>   │ <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"number\">146</span>   │ ugetpid(<span class=\"type\">void</span>)</span><br><span class=\"line\"><span class=\"number\">147</span>   │ &#123;</span><br><span class=\"line\"><span class=\"number\">148</span>   │   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">usyscall</span> *<span class=\"title\">u</span> =</span> (<span class=\"keyword\">struct</span> usyscall *)USYSCALL;</span><br><span class=\"line\"><span class=\"number\">149</span>   │   <span class=\"keyword\">return</span> u-&gt;pid;</span><br><span class=\"line\"><span class=\"number\">150</span>   │ &#125;</span><br><span class=\"line\"><span class=\"number\">151</span>   │ <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>这个函数直接访问USYSCALL地址，通过我们设置好的页表就可以直接到相应的usyscall结构体取得pid，从而可以替代原先需要进入内核空间的getpid函数。</p>\n<p>$\\qquad$页表相关操作基本都在kernel&#x2F;proc.c文件中，我们先找到实现主要地址映射的proc_pagetable函数，可以看到这个函数通过mappages函数完成了<strong>Trampoline</strong>（系统调用返回地址，也是用户虚拟空间中的最高地址）和<strong>Trapframe</strong>（当中断来临时存储当前寄存器值的地址，就位于Trampoline的下方）的映射。显然，我们也需要用mappages来实现USYSCALL虚拟地址的映射，但问题是我们需要知道相应的物理地址。</p>\n<p>$\\qquad$由于这个只读页是在进程创建时产生的，那么我们来到创建进程的allocproc函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span>   │ <span class=\"comment\">// Look in the process table for an UNUSED proc.</span></span><br><span class=\"line\"><span class=\"number\">101</span>   │ <span class=\"comment\">// If found, initialize state required to run in the kernel,</span></span><br><span class=\"line\"><span class=\"number\">102</span>   │ <span class=\"comment\">// and return with p-&gt;lock held.</span></span><br><span class=\"line\"><span class=\"number\">103</span>   │ <span class=\"comment\">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class=\"line\"><span class=\"number\">104</span>   │ <span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span>*</span></span><br><span class=\"line\"><span class=\"class\">105   │ <span class=\"title\">allocproc</span>(<span class=\"title\">void</span>)</span></span><br><span class=\"line\"><span class=\"class\">106   │ &#123;</span></span><br><span class=\"line\"><span class=\"number\">107</span>   │   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\"><span class=\"number\">108</span>   │ </span><br><span class=\"line\"><span class=\"number\">109</span>   │   <span class=\"keyword\">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class=\"line\"><span class=\"number\">110</span>   │     acquire(&amp;p-&gt;lock);</span><br><span class=\"line\"><span class=\"number\">111</span>   │     <span class=\"keyword\">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class=\"line\"><span class=\"number\">112</span>   │       <span class=\"keyword\">goto</span> found;</span><br><span class=\"line\"><span class=\"number\">113</span>   │     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"number\">114</span>   │       release(&amp;p-&gt;lock);</span><br><span class=\"line\"><span class=\"number\">115</span>   │     &#125;</span><br><span class=\"line\"><span class=\"number\">116</span>   │   &#125;</span><br><span class=\"line\"><span class=\"number\">117</span>   │   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">118</span>   │ </span><br><span class=\"line\"><span class=\"number\">119</span>   │ found:</span><br><span class=\"line\"><span class=\"number\">120</span>   │     ......</span><br></pre></td></tr></table></figure>\n\n<p>allocproc函数从进程表中找到一个未使用的进程块然后为它分配相应的页表空间（kalloc：分配一块页大小512B的空间），那么我们就在此仿照trapframe的做法新建只读页，并存入pid：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">130</span> + │  <span class=\"comment\">// ADD</span></span><br><span class=\"line\"><span class=\"number\">131</span> + │  <span class=\"keyword\">if</span>((p-&gt;usys = (<span class=\"keyword\">struct</span> usyscall *)kalloc())==<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">132</span> + │  &#123;</span><br><span class=\"line\"><span class=\"number\">133</span> + │     <span class=\"comment\">// kfree((void*)p-&gt;trapframe);</span></span><br><span class=\"line\"><span class=\"number\">134</span> + │     freeproc(p);</span><br><span class=\"line\"><span class=\"number\">135</span> + │     release(&amp;p-&gt;lock);</span><br><span class=\"line\"><span class=\"number\">136</span> + │     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">137</span> + │  &#125;</span><br><span class=\"line\"><span class=\"number\">138</span> + │   p-&gt;usys-&gt;pid=p-&gt;pid;</span><br><span class=\"line\"><span class=\"number\">139</span> + │ </span><br><span class=\"line\"><span class=\"number\">140</span>   │   <span class=\"comment\">// An empty user page table.</span></span><br><span class=\"line\"><span class=\"number\">141</span>   │   p-&gt;pagetable = proc_pagetable(p);</span><br><span class=\"line\"><span class=\"number\">142</span>   │   ......</span><br></pre></td></tr></table></figure>\n\n<p>由于只读页的物理地址还要在proc_pagetable中使用，因此我们需要在proc结构体（kernel&#x2F;proc.h）中加入<code>struct usyscall *usys</code>。</p>\n<p>$\\qquad$⚠️ 新建只读页必须在调用proc_pagetable（141）之前，因为需要用物理地址做映射。</p>\n<p>$\\qquad$然后我们就可以在proc_pagetable里建立映射了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">210</span> + │   <span class=\"comment\">// ADD</span></span><br><span class=\"line\"><span class=\"number\">211</span> + │   <span class=\"keyword\">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usys), PTE_R | PTE_U) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">212</span> + │   &#123;</span><br><span class=\"line\"><span class=\"number\">213</span> + │     uvmunmap(pagetable, TRAMPOLINE, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"number\">214</span> + │     uvmunmap(pagetable, TRAPFRAME, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"number\">215</span> + │     uvmfree(pagetable, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"number\">216</span> + │     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">217</span> + │   &#125;</span><br><span class=\"line\"><span class=\"number\">218</span> + │</span><br><span class=\"line\"><span class=\"number\">219</span>   │   <span class=\"keyword\">return</span> pagetable;</span><br><span class=\"line\"><span class=\"number\">220</span>   │ &#125;</span><br></pre></td></tr></table></figure>\n\n<p>⚠️权限是只读（PTE_R），同时在用户空间内运行（PTE_U）。如果map失败就需要解除前面TRAMPOLINE和TRAPFRAME的映射。</p>\n<p>$\\qquad$最后不要忘记在freeproc中释放分配来的物理空间：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">168</span> + │   <span class=\"keyword\">if</span>(p-&gt;usys)</span><br><span class=\"line\"><span class=\"number\">169</span> + │     kfree((<span class=\"type\">void</span>*)p-&gt;usys);</span><br><span class=\"line\"><span class=\"number\">170</span> + │   p-&gt;usys = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$还有很重要的一点是解除映射，否则会panic——“freewalk: leaf”：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">224</span>   │ <span class=\"type\">void</span> <span class=\"title function_\">proc_freepagetable</span><span class=\"params\">(<span class=\"type\">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class=\"line\"><span class=\"number\">225</span>   │   uvmunmap(pagetable, TRAMPOLINE, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"number\">226</span>   │   uvmunmap(pagetable, TRAPFRAME, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"number\">227</span> + │   uvmunmap(pagetable, USYSCALL, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"number\">228</span>   │   uvmfree(pagetable, sz);</span><br><span class=\"line\"><span class=\"number\">229</span>   │ &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在释放页表空间后会调用freewalk函数来检查该页表中的所有<strong>叶子pte</strong>（三级映射最后的物理地址）是否有效（PTE_V是否为1），如果存在物理地址有效就会panic。</p>\n<br>\n\n<h4><span id=\"︎-print-a-page-tableeasy\">☑︎ Print a page table（easy）</span></h4><p>$\\qquad$实现函数vmprint打印出页表树。页表是三级查找结构，把所有PTE条目看作一个节点，物理地址所对应的PTE条目为其子节点，那么从宏观上来看每个L2 page directory的物理地址都对应一个深度不超过3的树。</p>\n<p>$\\qquad$只要知道了如何判断PTE（page table entry）和PT就能写出递归函数了。我们可以参考freewalk函数（kernel&#x2F;vm.c），对就是上面刚刚出现的那位老哥，它就是通过递归遍历整棵树来检查物理地址是否还有效的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">266</span>   │ <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"number\">267</span>   │ freewalk(<span class=\"type\">pagetable_t</span> pagetable)</span><br><span class=\"line\"><span class=\"number\">268</span>   │ &#123;</span><br><span class=\"line\"><span class=\"number\">269</span>   │   <span class=\"comment\">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class=\"line\"><span class=\"number\">270</span>   │   <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; i++)&#123;</span><br><span class=\"line\"><span class=\"number\">271</span>   │     <span class=\"type\">pte_t</span> pte = pagetable[i];</span><br><span class=\"line\"><span class=\"number\">272</span>   │     <span class=\"keyword\">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\"><span class=\"number\">273</span>   │       <span class=\"comment\">// this PTE points to a lower-level page table.</span></span><br><span class=\"line\"><span class=\"number\">274</span>   │       uint64 child = PTE2PA(pte);</span><br><span class=\"line\"><span class=\"number\">275</span>   │       freewalk((<span class=\"type\">pagetable_t</span>)child);</span><br><span class=\"line\"><span class=\"number\">276</span>   │       pagetable[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">277</span>   │     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pte &amp; PTE_V)&#123;</span><br><span class=\"line\"><span class=\"number\">278</span>   │       panic(<span class=\"string\">&quot;freewalk: leaf&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">279</span>   │     &#125;</span><br><span class=\"line\"><span class=\"number\">280</span>   │   &#125;</span><br><span class=\"line\"><span class=\"number\">281</span>   │   kfree((<span class=\"type\">void</span>*)pagetable);</span><br><span class=\"line\"><span class=\"number\">282</span>   │ &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见如果PTE_V是有效的，没有任何权限则说明这是一个PTE，需要继续递归，反之则说明是叶子节点，即虚拟地址对应的真实物理地址。</p>\n<p>$\\qquad$由于我们需要用【 ..】的个数来表示深度，因此在vmprint中设置一个<code>static int depth</code>，递归进入子函数前+1，退出时-1。</p>\n<p>$\\qquad$首先在kernel&#x2F;exec.c的exec函数中加入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">143</span> + │     <span class=\"keyword\">if</span>(p-&gt;pid==<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">144</span> + │     vmprint(p-&gt;pagetable);</span><br><span class=\"line\"><span class=\"number\">145</span> + │ </span><br><span class=\"line\"><span class=\"number\">146</span>   │     <span class=\"keyword\">return</span> argc; <span class=\"comment\">// this ends up in a0, the first argument to main(argc, argv)</span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$对于vmprint的实现，我是直接在exec函数前插入的，实验文档推荐在kernel&#x2F;vm.c里实现，那就别忘了在kernel&#x2F;defs.h里声明。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">12</span> + │ <span class=\"type\">void</span> <span class=\"title function_\">vmprint</span><span class=\"params\">(<span class=\"type\">pagetable_t</span> pg)</span></span><br><span class=\"line\">13 + │ &#123;</span><br><span class=\"line\"><span class=\"number\">14</span> + │     <span class=\"type\">static</span> <span class=\"type\">int</span> depth = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">15</span> + │     <span class=\"keyword\">if</span> (depth == <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">16</span> + │         <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;page table %p\\n&quot;</span>, *pg);</span><br><span class=\"line\"><span class=\"number\">17</span> + │     <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; ++i)</span><br><span class=\"line\"><span class=\"number\">18</span> + │     &#123;</span><br><span class=\"line\"><span class=\"number\">19</span> + │         <span class=\"type\">pte_t</span> pte = pg[i];</span><br><span class=\"line\"><span class=\"number\">20</span> + │         <span class=\"keyword\">if</span> (pte &amp; PTE_V)</span><br><span class=\"line\"><span class=\"number\">21</span> + │         &#123;</span><br><span class=\"line\"><span class=\"number\">22</span> + │             uint64 child = PTE2PA(pte);</span><br><span class=\"line\"><span class=\"number\">23</span> + │             <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; depth; ++j)</span><br><span class=\"line\"><span class=\"number\">24</span> + │                 <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; ..&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">25</span> + │             <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: pte %p pa %p\\n&quot;</span>, i, pte, child);</span><br><span class=\"line\"><span class=\"number\">26</span> + │             <span class=\"keyword\">if</span> ((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"number\">27</span> + │             &#123;</span><br><span class=\"line\"><span class=\"number\">28</span> + │                 depth += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">29</span> + │                 vmprint((<span class=\"type\">pagetable_t</span>) child);</span><br><span class=\"line\"><span class=\"number\">30</span> + │             &#125;</span><br><span class=\"line\"><span class=\"number\">31</span> + │         &#125;</span><br><span class=\"line\"><span class=\"number\">32</span> + │     &#125;</span><br><span class=\"line\"><span class=\"number\">33</span> + │     depth -= <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">34</span> + │ &#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$然后启动qemu后就会输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hart 2 starting</span><br><span class=\"line\">hart 1 starting</span><br><span class=\"line\">page table 0x0000000021fda801</span><br><span class=\"line\"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class=\"line\"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class=\"line\"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class=\"line\"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class=\"line\"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class=\"line\"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class=\"line\"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class=\"line\"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class=\"line\"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class=\"line\"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h4><span id=\"︎-detecting-which-pages-have-been-accessed-hard\">☑︎ Detecting which pages have been accessed (hard)</span></h4><p>$\\qquad$这里我们需要实现一个系统调用pgaccess，来检查给定物理页们是否被访问过（accessed：read or write），用one bit来表示一个物理页的结果，并将结果拷贝至用户空间。</p>\n<p>$\\qquad$pgaccess会接受三个参数——第一个是起始页的虚拟地址，第二个是需要往后检查的页数，最后一个是需要将结果拷贝到用户空间的物理地址。文档中说最后用户空间会用一个bitmask的数据结构存储结果，其中a bit代表1页且第一页位于最低有效位，另外可以自行设置一个页数上限。在内核中运行时，我们可以用一个uint64来存储结果，那么页数上限即为64。另外我们需要自己在kernel&#x2F;risv.h中定义PTE_A，至于这一位在物理地址中的哪一位则需要查询<a href=\"https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf\">riscv手册</a>（P70）：</p>\n<img title src=\"/images/操作系统/6.png\" alt data-align=\"center\" width=\"582\">\n\n<p>$\\qquad$你可能会问PTE_A不是我们自行定义的吗。事实上，pgaccess只是实现一个检查的功能，真正置位的是riscv硬件。文档中指出“The RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB miss”，当CPU需要那一物理页时，发现Translation Look-aside Buffer未命中（cache中没有），就会去access这一页，然后将其PTE_A置1，因此PTE_A的位置是由硬件规定的。</p>\n<p>$\\qquad$根据上图可知PTE_A位于倒数第6位，那么就在kernel&#x2F;riscv.h中加入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">346</span> + │ <span class=\"meta\">#<span class=\"keyword\">define</span> PTE_A (1L &lt;&lt; 6) <span class=\"comment\">// access bit</span></span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$准确地来讲，页表中存储的并不是物理地址，而是0(10 bits)+PPN(44 bits)+flags(10 bits)&#x3D;PTE(64 bits)，因此我们可以看到kernel&#x2F;riscv.h中很多转换宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">348</span>   │ <span class=\"comment\">// shift a physical address to the right place for a PTE.</span></span><br><span class=\"line\"><span class=\"number\">349</span>   │ <span class=\"meta\">#<span class=\"keyword\">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class=\"line\"><span class=\"number\">350</span>   │ </span><br><span class=\"line\"><span class=\"number\">351</span>   │ <span class=\"meta\">#<span class=\"keyword\">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class=\"line\"><span class=\"number\">352</span>   │ </span><br><span class=\"line\"><span class=\"number\">353</span>   │ <span class=\"meta\">#<span class=\"keyword\">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$想要获取PTE_A只需要<code>(PTE&amp;PTE_A)&gt;&gt;6</code>  即可。另外由于参数是从用户空间传入，因此我们需要将这些参数通过argaddr（64 bits）和argint（32 bits）拷贝过来。由于传入的是虚拟地址，因此我们需要用walk函数找到实际的物理地址。</p>\n<p>$\\qquad$kernel&#x2F;sysproc.c中已经指明了函数的实现位置，直接撸就完事：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"number\">79</span>   │<span class=\"meta\">#<span class=\"keyword\">ifdef</span> LAB_PGTBL</span></span><br><span class=\"line\"> <span class=\"number\">80</span>   │<span class=\"type\">int</span></span><br><span class=\"line\"> <span class=\"number\">81</span>   │sys_pgaccess(<span class=\"type\">void</span>)</span><br><span class=\"line\"> <span class=\"number\">82</span>   │&#123;</span><br><span class=\"line\"> <span class=\"number\">83</span>   │    <span class=\"comment\">// lab pgtbl: your code here.</span></span><br><span class=\"line\"> <span class=\"number\">84</span> + │    uint64 sa, ua, buf = <span class=\"number\">0</span>;</span><br><span class=\"line\"> <span class=\"number\">85</span> + │    <span class=\"type\">int</span> n;</span><br><span class=\"line\"> <span class=\"number\">86</span> + │    <span class=\"keyword\">if</span> (argaddr(<span class=\"number\">0</span>, &amp;sa) &lt; <span class=\"number\">0</span> || argint(<span class=\"number\">1</span>, &amp;n) &lt; <span class=\"number\">0</span> || argaddr(<span class=\"number\">2</span>, &amp;ua) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"> <span class=\"number\">87</span> + │        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"> <span class=\"number\">88</span> + │</span><br><span class=\"line\"> <span class=\"number\">89</span> + │    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">64</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"> <span class=\"number\">90</span> + │</span><br><span class=\"line\"> <span class=\"number\">91</span> + │    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\"> <span class=\"number\">92</span> + │    uint64 pg = sa;</span><br><span class=\"line\"> <span class=\"number\">93</span> + │    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\"> <span class=\"number\">94</span> + │    &#123;</span><br><span class=\"line\"> <span class=\"number\">95</span> + │        <span class=\"type\">pte_t</span> *pte = walk(p-&gt;pagetable, pg, <span class=\"number\">0</span>);</span><br><span class=\"line\"> <span class=\"number\">96</span> + │        buf += ((*pte &amp; PTE_A) &gt; <span class=\"number\">0</span>) &lt;&lt; i;</span><br><span class=\"line\"> <span class=\"number\">97</span> + │        (*pte) &amp;= (~PTE_A);</span><br><span class=\"line\"> <span class=\"number\">98</span> + │        pg += PGSIZE;</span><br><span class=\"line\"> <span class=\"number\">99</span> + │    &#125;</span><br><span class=\"line\"><span class=\"number\">100</span> + │</span><br><span class=\"line\"><span class=\"number\">101</span> + │    <span class=\"keyword\">return</span> copyout(p-&gt;pagetable, ua, (<span class=\"type\">char</span> *) &amp;buf, <span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\"><span class=\"number\">102</span>   │&#125;</span><br><span class=\"line\"><span class=\"number\">103</span>   │<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$文档中指出我们检查完后还需要将PTE_A置0，因为硬件只顾着在访问时置1，如果不复位那么PTE_A就永远是1了。因此别忘记<code>(*pte) &amp;= (~PTE_A)</code>，另外别写出<code>(*pte &amp; PTE_A &gt; 0)</code>，【&amp;】的优先级比【&gt;】低。</p>\n<br>\n\n<h2><span id=\"references\">❖ References</span></h2><hr>\n<ul>\n<li><p>[1] <a href=\"https://zhuanlan.zhihu.com/p/429304672\">MIT 6.S081 2021: Lab page tables</a></p>\n</li>\n<li><p>[2] <a href=\"https://www.cnblogs.com/duile/p/16087757.html\">MIT6.S081-Lab3 Pgtbl [2021Fall]</a></p>\n</li>\n</ul>\n","text":"$\\qquad$兄弟们，我XV6又回来啦，这个栏目的灰都能把人埋了，鸽子王实锤（当然不是因为懒(⁎⁍̴̛ᴗ⁍̴̛⁎)）。不过虽迟但到！主要有时候看完文档和课程后又去搞其他飞机了，回来时，发现一切回到原点。这周发现再不搞真搞不完了，Lab3是关于页表的，文档戳这。 ❖ Coding ☑︎ S...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":3,"path":"api/categories/操作系统.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"xv6","slug":"xv6","count":3,"path":"api/tags/xv6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">❖ Coding</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">☑︎ Speed up system calls (easy)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">☑︎ Print a page table（easy）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">☑︎ Detecting which pages have been accessed (hard)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">❖ References</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1115」Counting Nodes in a Binary Search Tree","uid":"4fd53e230858db5e382512fd3cfbd1a2","slug":"「1115」Counting-Nodes-in-a-Binary-Search-Tree","date":"2022-11-20T11:34:27.000Z","updated":"2022-11-20T11:43:17.664Z","comments":true,"path":"api/articles/「1115」Counting-Nodes-in-a-Binary-Search-Tree.json","keywords":null,"cover":null,"text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains o...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"binary search","slug":"binary-search","count":7,"path":"api/tags/binary-search.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1114」Family Property","uid":"7239e6ffaff5533d5d38121f0a34ad8b","slug":"「1114」Family-Property","date":"2022-11-16T02:09:36.000Z","updated":"2022-11-16T02:19:44.538Z","comments":true,"path":"api/articles/「1114」Family-Property.json","keywords":null,"cover":null,"text":"This time, you are supposed to help us collect the data for family-owned property. Given each person’s family members, and the estate（房产）inf...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"},{"name":"BFS","slug":"BFS","count":10,"path":"api/tags/BFS.json"},{"name":"tuple","slug":"tuple","count":9,"path":"api/tags/tuple.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}