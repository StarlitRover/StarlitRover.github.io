{"title":"遗传算法","uid":"5e05676005a67b187c728a6e49c065fb","slug":"遗传算法","date":"2022-08-19T16:37:41.000Z","updated":"2022-08-20T10:04:49.322Z","comments":true,"path":"api/articles/遗传算法.json","keywords":null,"cover":[],"content":"<p>$\\qquad$“物竞天择，适者生存“，进化界的名言没想到也能用在算法里，不得不承认每个算法工程师也是天马行空的魔法师。由于经常参加数学煎馍美食烹饪大赛，因此时不时需要和启发式算法打交道，这些智能算法的思想充满着活力和开拓性，coding的时候甚至感觉自己像上帝一样为自己的世界制定着规则，不禁连连感叹。</p>\n<p>$\\qquad$今天开启智能算法篇章，首先上场的是遗传大法。</p>\n<p><img src=\"/images/%E6%95%B0%E5%AD%A6%E7%85%8E%E9%A6%8D/0.jpg\"></p>\n<span id=\"more\"></span>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$启发式算法的目的往往是寻求一个优化模型的最优解，但由于模型的过于庞大或是复杂，想要把精确的最优解揪出来需要花费大量的时间和算力。那么我们退而求其次，争取尽可能逼近最优解，接受一定范围的误差，从而有了各种启发式算法八仙过海。</p>\n<p>$\\qquad$遗传算法，顾名思义，我们将每一个可行解看作为一个个体，让这些个体生存繁衍，我们作为上帝制定出如何计算个体对于环境适应值（目标函数）的规则。接下来就交给大自然去选择，经过一代一代的淘汰进化，最终出现在我们面前就是适应度最高的个体们。</p>\n<p>$\\qquad$那么繁衍淘汰这么复杂的生理过程如何在计算机内表达呢，我们知道繁衍的本质就是基因的交换重组，而基因的本质是对遗传信息的编码，计算机最擅长的莫过于此。因此我们首先需要将每个个体（可行解）进行编码为基因串，为了贴合计算机并方便起见一般都是转换为二进制编码，那么繁衍的过程很显然就是对基因进行切片重组。问题是大自然如果只靠单纯的基因重组繁衍后代，那么物种的多样性将被限制，之所以物种能够进化一方面是自然选择，另外一个重要的机制是变异，变异使得原本的基因片段得以改变，从而物种朝着不同的方向发展（搜索），大大增加了算法的鲁棒性。</p>\n<p>$\\qquad$下面是一个数模比赛中遇到的简化版案例。</p>\n<hr>\n<h2><span id=\"ƺ\">ƺ</span></h2><p>$\\qquad$简单地说，有一些交易订单，首先根据每个订单的$f(\\alpha,\\beta)$计算结果对所有订单进行降序排序，其中$(\\alpha,\\beta)$两个与订单无关的待定权重，然后排序结果会送入一个贪心算法中，最终输出一个结果。那么很显然不同的$(\\alpha,\\beta)$会影响订单的排序结果，从而影响到最终的输出结果。此时我希望得到最大结果，但对于权重的取值无从下手。那么就让大自然的遗传大法来筛选吧。</p>\n<h3><span id=\"编码解码\">⚤ 编码解码</span></h3><p>$\\qquad$在此我们需要先确定$(\\alpha,\\beta)$的取值范围，从而才能对有限的基因进行编码解码。根据初步的估计可以得出两者最优解的分布范围</p>\n<p>$$<br>\\alpha&#x3D;\\overline{0.abcd}\\ ,\\ \\beta&#x3D;\\overline{0.00efg}\\quad( a,b,c,d,e,f,g\\in\\{0,1,2,\\cdots,9\\})<br>$$</p>\n<p>$\\qquad$那么一组可行解即为7位十进制数，根据$2^{23}&lt;10^7&lt;2^{24}$可知需要24位{0,1}二进制串来编码</p>\n<p>$$<br>abcdefg\\sim b_1b_2\\cdots b_{24}\\ ,\\ b_i\\in\\{0,1\\}<br>$$</p>\n<p>$\\qquad$前16位为α，后8位为β，那么可以写出解码函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decode</span>(<span class=\"params\">gene</span>):</span><br><span class=\"line\">    alpha = <span class=\"built_in\">eval</span>(gene[<span class=\"number\">0</span>:<span class=\"number\">16</span>]) * <span class=\"number\">0.0001</span></span><br><span class=\"line\">    beta = <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;0b&#x27;</span> + gene[<span class=\"number\">16</span>:]) * <span class=\"number\">0.00001</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [alpha, beta]</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"初始化种群\">⚤ 初始化种群</span></h3><p>$\\qquad$个体不能无中生有，我们必然需要先随机生成一个祖先种群，即第一代个体，这些个体没有什么特别要求，只要满足约束条件即可（可行解）。在我们这个问题中对$\\alpha,\\beta$没有约束，只要在上述范围内即可。</p>\n<p>$\\qquad$注意这里由于二进制表示范围大于我们的上述范围，因此还是先分别生成十进制数然后转化为二进制，最后拼接在一起的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random <span class=\"keyword\">as</span> rd</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>(<span class=\"params\">num</span>):</span><br><span class=\"line\">    pop = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(num):</span><br><span class=\"line\">        b1 = <span class=\"built_in\">bin</span>(rd.randint(<span class=\"number\">0</span>, <span class=\"number\">10000</span>))</span><br><span class=\"line\">        b2 = <span class=\"built_in\">bin</span>(rd.randint(<span class=\"number\">0</span>, <span class=\"number\">1000</span>))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(b1) &lt; <span class=\"number\">16</span>:</span><br><span class=\"line\">            b1 = <span class=\"built_in\">list</span>(b1)</span><br><span class=\"line\">            b1.insert(<span class=\"number\">2</span>, <span class=\"string\">&#x27;0&#x27;</span> * (<span class=\"number\">16</span> - <span class=\"built_in\">len</span>(b1)))</span><br><span class=\"line\">            b1 = <span class=\"string\">&#x27;&#x27;</span>.join(b1)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(b2) &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">            b2 = <span class=\"built_in\">list</span>(b2)</span><br><span class=\"line\">            b2.insert(<span class=\"number\">2</span>, <span class=\"string\">&#x27;0&#x27;</span> * (<span class=\"number\">12</span> - <span class=\"built_in\">len</span>(b2)))</span><br><span class=\"line\">            b2 = <span class=\"string\">&#x27;&#x27;</span>.join(b2)</span><br><span class=\"line\">        pop.append(b1 + b2[<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pop</span><br></pre></td></tr></table></figure>\n\n<h2><span id=\"适应性评价\">⚤ 适应性评价</span></h2><p>$\\qquad$在开启大自然的选拔机制前，我们需要定义每个个体的适应度，本质上来说就是有多合我们的心意，在运行过程中代表着存活率。如果目标函数是最大化，那么往往是直接将目标函数作为适应性函数；若是最小化，则可以进行取负平移或是取倒数等操作。</p>\n<p>$\\qquad$另外适应性计算<big>不需要</big>是一个函数，在本例中就是一个贪心算法来计算个体适应性的。</p>\n<p>$\\qquad$对于个体$i$假设其适应性为$\\kappa_i$，那么其生存率为</p>\n<p>$$<br>s_i&#x3D;\\frac{\\kappa_i}{\\sum\\limits_{j&#x3D;1}^N \\kappa_j}<br>$$</p>\n<h2><span id=\"轮盘赌选择\">⚤ 轮盘赌选择</span></h2><p>$\\qquad$这是一个比较经典常用的优胜劣汰方式，根据淘汰率$\\mu$生成$[(1-\\mu)\\cdot N]$个随机数$r_i\\in[0,1]$，每个随机数选择满足下列条件的第$k$个个体，未被选择的个体将被淘汰</p>\n<p>$$<br>\\sum_{j&#x3D;1}^k s_j\\geq r_i\\ ,\\ \\sum_{j&#x3D;1}^{k-1} s_j&lt;r_i<br>$$</p>\n<p>$\\qquad$有点像上帝掷骰子。这里不直接选择生存率最高的个体也是在模拟现实世界中的意外，给算法加入了更大的随机性，毕竟未必优良个体繁衍的后代就一定还是优良的，相反劣势个体也是一样。这样的处理方式大大增加了算法的灵活性。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdg = np.array(<span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(adpt, pop)))</span><br><span class=\"line\">out_num = <span class=\"built_in\">int</span>(out_rate * <span class=\"built_in\">len</span>(pop))</span><br><span class=\"line\">next_pop = []</span><br><span class=\"line\">in_num = <span class=\"built_in\">len</span>(pop) - out_num</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(in_num):</span><br><span class=\"line\">    dice = rd.random() * jdg.<span class=\"built_in\">sum</span>()</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(pop)):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> += jdg[j]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">sum</span> &gt; dice:</span><br><span class=\"line\">            next_pop.append(pop[j])</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<h2><span id=\"交叉重组\">⚤ 交叉重组</span></h2><p>$\\qquad$对上一步中幸存下来的个体，随机选取两者进行交叉重组。首先随机生成一个交叉位点，然后将两个个体的基因在交叉位点处拆分重组后形成的两个新个体加入当前的种群中。我在这里的处理方式是不断繁衍至种群个体数量恢复如初，如果按指数方式增加种群数量的话，迭代次数稍微一大就会很慢。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">round</span>(out_num / <span class=\"number\">2</span>)):</span><br><span class=\"line\">       x = rd.randint(<span class=\"number\">0</span>, in_num - <span class=\"number\">1</span>)</span><br><span class=\"line\">       y = rd.randint(<span class=\"number\">0</span>, in_num - <span class=\"number\">1</span>)</span><br><span class=\"line\">       node = rd.randint(<span class=\"number\">3</span>, <span class=\"number\">25</span>)</span><br><span class=\"line\">       next_pop.append(next_pop[x][<span class=\"number\">0</span>:node] + next_pop[y][node:])</span><br><span class=\"line\">       next_pop.append(next_pop[y][<span class=\"number\">0</span>:node] + next_pop[x][node:])</span><br></pre></td></tr></table></figure>\n\n<h2><span id=\"个体变异\">⚤ 个体变异</span></h2><p>$\\qquad$对新一代种群中的每个个体生成一个随机数$r\\in (0,1)$，若$r&lt;p_m$（$p_m$是变异概率，一般较小）则随意生成一个变异位点，将该位点处的编码进行二进制反转（0→1,1→0）。$p_m$过大会导致进化收敛到最后的优良种群基因不稳定，即使迭代次数较大也难以收敛。</p>\n<p>$\\qquad$🧟‍♀️丧尸就是变异过猛的结果🧟‍♂️</p>\n<p>$\\qquad$BUT，如果说搜索范围非常大的话，我们将$p_m$适当调大可能会有着意想不到的结果，但前提是每次迭代后都要更新当前最优个体基因和适应性，这样就相当于一种变相的随机搜索。当然可以两者相结合，那你将面向$p_m$搜索。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(next_pop)):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> rd.random() &lt; pm:</span><br><span class=\"line\">        node = rd.randint(<span class=\"number\">2</span>, <span class=\"number\">25</span>)</span><br><span class=\"line\">        next_pop[i] = next_pop[i][<span class=\"number\">0</span>:node] + (<span class=\"string\">&#x27;1&#x27;</span> <span class=\"keyword\">if</span> next_pop[i][node] == <span class=\"string\">&#x27;0&#x27;</span> <span class=\"keyword\">else</span> <span class=\"string\">&#x27;0&#x27;</span>) + next_pop[i][node + <span class=\"number\">1</span>:]</span><br></pre></td></tr></table></figure>\n\n<h2><span id=\"重复迭代\">⚤ 重复迭代</span></h2><p>$\\qquad$一般设置300-500轮迭代，更重要的是观察适应性是否逐渐收敛。</p>\n<hr>\n<br>\n\n<center><big>那么上帝是不是也在运行着高阶的遗传算法呢？</big></center>\n","text":"$\\qquad$“物竞天择，适者生存“，进化界的名言没想到也能用在算法里，不得不承认每个算法工程师也是天马行空的魔法师。由于经常参加数学煎馍美食烹饪大赛，因此时不时需要和启发式算法打交道，这些智能算法的思想充满着活力和开拓性，coding的时候甚至感觉自己像上帝一样为自己的世界制...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"智能算法","slug":"智能算法","count":4,"path":"api/categories/智能算法.json"}],"tags":[{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"},{"name":"数学煎馍","slug":"数学煎馍","count":4,"path":"api/tags/数学煎馍.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">ƺ</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 编码解码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 初始化种群</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 适应性评价</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 轮盘赌选择</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 交叉重组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 个体变异</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚤ 重复迭代</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1039」Course List for Student","uid":"925a25c8e70f189f82f27070d123048d","slug":"「1039」Course-List-for-Student","date":"2022-08-20T13:47:05.000Z","updated":"2022-08-20T14:22:58.811Z","comments":true,"path":"api/articles/「1039」Course-List-for-Student.json","keywords":null,"cover":null,"text":"Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to o...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1038」Recover the Smallest Number","uid":"f0575046ba6429b64e77d36d9af8e107","slug":"「1038」Recover-the-Smallest-Number","date":"2022-08-19T04:22:22.000Z","updated":"2022-08-19T07:56:15.793Z","comments":true,"path":"api/articles/「1038」Recover-the-Smallest-Number.json","keywords":null,"cover":null,"text":"Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given { 32, 321, 3214, 0229, ...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"binary search","slug":"binary-search","count":7,"path":"api/tags/binary-search.json"},{"name":"sort","slug":"sort","count":24,"path":"api/tags/sort.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}