{"title":"「1018」Public Bike Management","uid":"f49316d46cb145f81e643476c18ee695","slug":"1018-Public-Bike-Management","date":"2022-04-13T00:42:21.000Z","updated":"2022-07-04T03:55:46.505Z","comments":true,"path":"api/articles/1018-Public-Bike-Management.json","keywords":null,"cover":[],"content":"<p>$\\qquad$There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.</p>\n<p>$\\qquad$The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in <strong>perfect</strong> condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.</p>\n<span id=\"more\"></span>\n\n<p>$\\qquad$When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.</p>\n<p><img src=\"https://images.ptausercontent.com/213\" alt=\"img\"></p>\n<p>$\\qquad$The above figure illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex $S$ is the current number of bikes stored at $S$. Given that the maximum capacity of each station is 10. To solve the problem at $S_3$, we have 2 different shortest paths:</p>\n<ol>\n<li>PBMC -&gt; $S_1$ -&gt; $S_3$. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from $S_1$ and then take 5 bikes to $S_3$, so that both stations will be in perfect conditions.</li>\n<li>PBMC -&gt; $S_2$ -&gt; $S_3$. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.</li>\n</ol>\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>$\\qquad$Each input file contains one test case. For each case, the first line contains 4 numbers: $C_\\max (≤100)$, always an even number, is the maximum capacity of each station; $N(≤500)$, the total number of stations; $S_p$, the index of the problem station (the stations are numbered from 1 to $N$, and PBMC is represented by the vertex 0); and $M$, the number of roads. The second line contains $N$ non-negative numbers $C_i (i&#x3D;1,⋯,N)$ where each $C_i$ is the current number of bikes at $S_i$ respectively. Then $M$ lines follow, each contains 3 numbers: $S_i$, $S_j$, and $T_{ij}$ which describe the time $T_{ij}$ taken to move betwen stations $S_i$ and $S_j$. All the numbers in a line are separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>$\\qquad$For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0−&gt;$S_1$−&gt;⋯−&gt;$S_p$. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of $S_p$ is adjusted to perfect.</p>\n<p>$\\qquad$Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 3 3 5</span><br><span class=\"line\">6 7 0</span><br><span class=\"line\">0 1 1</span><br><span class=\"line\">0 2 1</span><br><span class=\"line\">0 3 3</span><br><span class=\"line\">1 3 1</span><br><span class=\"line\">2 3 1</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 0-&gt;2-&gt;3 0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$极繁翻译：PBMC是杭州公共自行车管理部门，负责管理平衡各个自行车租凭点的自行车数量。当一个租凭点的自行车数量刚好是最大数量的一半时，我们认为是恰好的。当一个站点上报至PBMC需要调整其自行车数量时，PBMC会选择一条耗时最短的路前往，同时将沿途站点的自行车数量也调整至恰好的状态。在前往的途中，途经站点多出来的自行车可以填补到后面需要的站点，这样带回PBMC的自行车就会少一些。注意，返回途中不调整任何站点。如果有多条耗时相同的路径则选择带上自行车数量最少的路，如果还是有相同的，则选择带回自行车最少的路。现给出站点的最大容量、站点数量、上报的站点编号、各条路径的耗时情况，需要输出最优路线以及需要带上和带回的自行车数。题目保证最优路径唯一。</p>\n<p>$\\qquad$这题目，有毒。深刻理解什么叫，有坑的地方就有我。</p>\n<p>$\\qquad$理解错题意，重构了几次代码，废了好多时间。做完再仔细阅读题目，感觉还是没get到那几个坑：</p>\n<ol>\n<li>回去的路上不能调整各站点自行车，只能在来的路上用前面站点多出来的自行车填补后面的站点，也就是说后面站点多出来不能填补前面的站点，只能带回去。这是什么人工智障？PBMC早就知道各个站点的自行车数量，为什么不能做到全局规划呢（格局小了，锻炼编程能力而已，以后还要面对各种甲方爸爸呢</li>\n<li>输出要求里说，如果路径不唯一，则输出带回数量最少的路径。当时我也纳闷，因为前面举的那个例子里面选择的是带上数量最少的路。结果其实是先选择带上最少的，再选择带回最少的。。（请打开麦克风好好交流</li>\n</ol>\n<p>$\\qquad$总之，不懂。</p>\n<br>\n\n<p>$\\qquad$显然，这不是一道单纯的Dijkstra算法题，Dijkstra的基本思想本质上是广度优先搜索BFS，但只能找到一条最短路，而我们需要找到所有最短路，因此需要加以改进。</p>\n<p>$\\qquad$Dijkstra算法中，当一个新点被纳入起点所在的集合中时，我们会更新与该点相连的点到起点的距离，如果更新的距离≥ 原距离的话就不需要更新。那么在这个问题中，如果更新的距离&#x3D;&#x3D;原距离，我们依然需要记录，从而保留所有长度相同的路径信息。</p>\n<p>$\\qquad$首先我们需要一个<code>vector</code>来记录所有站点到PBMC（编号为0）的最短距离（这里的距离是时间），并初始化所有距离为最大值<code>INF</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n + <span class=\"number\">1</span>, INF)</span></span>; <span class=\"comment\">// #define INF INT32_MAX</span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$然后初始化的时候需要将所有与PBMC相连的站点<code>dist</code>修改为他们之间的距离。</p>\n<p>$\\qquad$另外还需要标记各个站点是否已被纳入集合$S$，其中$S$表示所有已经求出最短距离的站点编号，初始情况下只含0。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">isVisited</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">isVisited[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$最重要的我们还需要存储路径，由于最后是根据带上和带回的自行车数进行最优选择，因此也一并存了，因此诞生了一个究极复杂的类型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vector&lt;vector&lt;pair&lt;pair&lt;send num,take back num&gt;,path points&gt;&gt;&gt;</span></span><br><span class=\"line\">vector&lt;vector&lt;pair&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, vector&lt;<span class=\"type\">int</span>&gt;&gt;&gt;&gt; <span class=\"built_in\">track</span>(n + <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$简单地说，就是所有站点都拥有一个<code>vector</code>，里面存储了PBMC到该站点所有最短路径的信息，每个最短路径信息是一个<code>pair&lt;pair&lt;int,int&gt;,vector&lt;int&gt;&gt;</code>，后面的<code>vector&lt;int&gt;</code>就是这条路径上依次的站点编号，前面<code>pair&lt;int,int&gt;</code>则是这条路径到当前站点所必须带上和带回的自行车数量。</p>\n<p>$\\qquad$接下来每次循环都从<code>dist</code>中找到距离最小的站点<code>min_idx</code>，将该站点编号纳入集合$S$。在更新与该点相连的站点<code>dist[i]</code>时，如果更短了，那么更新<code>dist[i]</code>并将其<code>track[i]</code>清空，然后进行“如果是相等的”的操作；如果是相等的，说明又找到了一条最短路径，那么将<code>track[min_idx]</code>中的每一条记录更新之后推入<code>track[i]</code>。也就是说，<code>track[i]</code>中存储的路径长度均为<code>dist[i]</code>，因此修改<code>dist[i]</code>时必须清空<code>track[i]</code>。</p>\n<p>$\\qquad$另外<code>num_to_perfect[i]</code>存储站点$i$需要多少辆自行车才能到达恰好的状态，为负则表示多出来的自行车数量：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num_to_perfect[i] = max_cap / <span class=\"number\">2</span> - num_to_perfect[i];</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INF INT32_MAX</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; info;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;info, vector&lt;<span class=\"type\">int</span>&gt;&gt; path;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(path &amp;a, path &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"keyword\">return</span> a.first.first &lt; b.first.first || a.first.first == b.first.first &amp;&amp; a.first.second &lt; b.first.second;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max_cap, n, sp, m, s1, s2, t;</span><br><span class=\"line\">    cin &gt;&gt; max_cap &gt;&gt; n &gt;&gt; sp &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">num_to_perfect</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span>, <span class=\"title\">dist</span><span class=\"params\">(n + <span class=\"number\">1</span>, INF)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; num_to_perfect[i];</span><br><span class=\"line\">        num_to_perfect[i] = max_cap / <span class=\"number\">2</span> - num_to_perfect[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; road;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; t;</span><br><span class=\"line\">        road[s1].<span class=\"built_in\">emplace_back</span>(s2, t);</span><br><span class=\"line\">        road[s2].<span class=\"built_in\">emplace_back</span>(s1, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;path&gt;&gt; <span class=\"built_in\">track</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">isVisited</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    isVisited[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> min_dist = INF, min_idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//initialization</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s: road[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dist[s.first] = s.second;</span><br><span class=\"line\">        info tmp = <span class=\"built_in\">move</span>(num_to_perfect[s.first] &lt; <span class=\"number\">0</span> ? info&#123;<span class=\"number\">0</span>, -num_to_perfect[s.first]&#125; : info&#123;num_to_perfect[s.first], <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        track[s.first].<span class=\"built_in\">emplace_back</span>(tmp, vector&lt;<span class=\"type\">int</span>&gt;&#123;s.first&#125;);</span><br><span class=\"line\">        min_dist = s.second &lt; min_dist ? (min_idx = s.first, s.second) : min_dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    isVisited[min_idx] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isVisited[sp])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// update dist[i] for i in neighbor of min_idx</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;d: road[min_idx])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isVisited[d.first] || dist[min_idx] + d.second &gt; dist[d.first])</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dist[min_idx] + d.second &lt; dist[d.first])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                track[d.first].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">                dist[d.first] = dist[min_idx] + d.second;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 将min_idx的路径信息延续到d.first</span></span><br><span class=\"line\">            <span class=\"comment\">// k不能是引用，会直接修改track[min_idx]</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> k: track[min_idx])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                k.second.<span class=\"built_in\">push_back</span>(d.first);</span><br><span class=\"line\">              <span class=\"comment\">// 包括了num_to_perfect[d.first]&lt;0的情况</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (num_to_perfect[d.first] &lt;= k.first.second)</span><br><span class=\"line\">                    k.first.second -= num_to_perfect[d.first];</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    k.first.first += (num_to_perfect[d.first] - k.first.second);</span><br><span class=\"line\">                    k.first.second = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                track[d.first].<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 更新完后min_idx的路径信息可以清空以减少空间消耗</span></span><br><span class=\"line\">        track[min_idx].<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        min_dist = INF, min_idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">            min_dist = (!isVisited[i] &amp;&amp; dist[i] &lt; min_dist) ? (min_idx = i, dist[i]) : min_dist;</span><br><span class=\"line\">        isVisited[min_idx] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(track[sp].<span class=\"built_in\">begin</span>(), track[sp].<span class=\"built_in\">end</span>(), cmp);</span><br><span class=\"line\">    cout &lt;&lt; track[sp][<span class=\"number\">0</span>].first.first &lt;&lt; <span class=\"string\">&quot; 0&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s: track[sp][<span class=\"number\">0</span>].second)</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;-&gt;&quot;</span> &lt;&lt; s;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; track[sp][<span class=\"number\">0</span>].first.second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"$\\qquad$There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may re...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"sort","slug":"sort","count":24,"path":"api/tags/sort.json"},{"name":"pair","slug":"pair","count":6,"path":"api/tags/pair.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"},{"name":"Dijkstra","slug":"Dijkstra","count":6,"path":"api/tags/Dijkstra.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"Bison^Flex=语法分析生成中","uid":"1ebcc2044e1859de323771c4cf459a30","slug":"Bison-Flex-语法分析生成中","date":"2022-05-05T14:23:51.000Z","updated":"2022-05-22T11:37:41.903Z","comments":true,"path":"api/articles/Bison-Flex-语法分析生成中.json","keywords":null,"cover":[],"text":"$\\qquad$上古时代的时候（前一段时间参加了些些小竞赛，状态有点迷糊，五一又浪里个浪，所以…虽迟但到！），我们有讲解过借助Flex实现SysY词法分析。词法分析是编译的第一阶段，仅仅只是将代码进行切块归类，得到的只是些零散的tokens。现在我们进入第二阶段，对这些token...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1017」Queueing at Bank","uid":"f28bb9815d595dfd2f2742951bf93359","slug":"1017-Queueing-at-Bank","date":"2022-04-08T05:03:29.000Z","updated":"2022-07-04T03:49:11.938Z","comments":true,"path":"api/articles/1017-Queueing-at-Bank.json","keywords":null,"cover":null,"text":"➳ENTRY $\\qquad$Suppose a bank has K windows open for service. There is a yellow line in front of the windows which devides the waiting area ...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"sort","slug":"sort","count":24,"path":"api/tags/sort.json"},{"name":"pair","slug":"pair","count":6,"path":"api/tags/pair.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}