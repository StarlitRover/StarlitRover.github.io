{"title":"「1123」Is It a Complete AVL Tree","uid":"84f574e4cfc0fc23647f1cff6dfd2d15","slug":"「1123」Is-It-a-Complete-AVL-Tree","date":"2022-11-22T15:46:11.000Z","updated":"2022-11-22T16:07:22.231Z","comments":true,"path":"api/articles/「1123」Is-It-a-Complete-AVL-Tree.json","keywords":null,"cover":[],"content":"<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"https://images.ptausercontent.com/fb337acb-93b0-4af2-9838-deff5ce98058.jpg\" alt=\"F1.jpg\"></th>\n<th><img src=\"https://images.ptausercontent.com/d1635de7-3e3f-4aaa-889b-ba29f35890db.jpg\" alt=\"F2.jpg\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://images.ptausercontent.com/e868e4b9-9fea-4f70-b7a7-1f5d8a3be4ef.jpg\" alt=\"F3.jpg\"></td>\n<td><img src=\"https://images.ptausercontent.com/98aa1782-cea5-4792-8736-999436cf43a9.jpg\" alt=\"F4.jpg\"></td>\n</tr>\n</tbody></table>\n<p>Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print <code>YES</code> if the tree is complete, or <code>NO</code> if not.</p>\n<h3><span id=\"sample-input-1\">Sample Input 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">88 70 61 63 65</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-1\">Sample Output 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">70 63 88 61 65</span><br><span class=\"line\">YES</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-input-2\">Sample Input 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br><span class=\"line\">88 70 61 96 120 90 65 68</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-2\">Sample Output 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">88 65 96 61 70 90 120 68</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$又见AVL！第二次看它比第一次亲切多了，但还是花了不少时间，而且是看着之前的博客码的。关于AVL旋转的详细介绍请见<a href=\"/post/%E3%80%8C1066%E3%80%8DRoot-of-AVL-Tree.html\" title=\"「1066」Root of AVL Tree\">「1066」Root of AVL Tree</a>。</p>\n<p>$\\qquad$这次需要我们输出AVL的层次遍历，同时判断是否为完全二叉树（编号与满二叉树相同）。As before，用pair对存储左右子节点，同时存储每个节点作为根节点的子树高度，都通过map进行索引。</p>\n<p>$\\qquad$对每一个新节点的插入，先通过递归找到插入位置，然后在递归回退的过程中找到第一个左右子树高度差&gt;1的节点，进行AVL旋转调整同时更新相应的高度。最后BFS出层次遍历，顺便记录每个节点编号（&#x3D;父节点编号*2【左子节点】&#x2F;父节点编号*2+1【右子节点】），看最后一个节点编号是否&#x3D;N，不等于说明不是完全二叉树。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> diff(root) (depth[sons[root].first]-depth[sons[root].second])</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> depth(root) (max(depth[sons[root].first],depth[sons[root].second])+1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; sons;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; depth;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;root, <span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        root = num, depth[num] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root &gt; num) <span class=\"built_in\">insert</span>(sons[root].first, num);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">insert</span>(sons[root].second, num);</span><br><span class=\"line\">    depth[root] = <span class=\"built_in\">depth</span>(root);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">diff</span>(root)) &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">bool</span> isLeft = <span class=\"built_in\">diff</span>(root) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> &amp;so = isLeft ? sons[root].first : sons[root].second,</span><br><span class=\"line\">        &amp;si = isLeft ? sons[root].second : sons[root].first,</span><br><span class=\"line\">        &amp;sso = isLeft ? sons[so].first : sons[so].second,</span><br><span class=\"line\">        &amp;ssi = isLeft ? sons[so].second : sons[so].first,</span><br><span class=\"line\">        tmp = so;</span><br><span class=\"line\">    <span class=\"comment\">// 判断插入节点是否位于子树的同侧</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"built_in\">diff</span>(root) ^ <span class=\"built_in\">diff</span>(so)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        so = ssi, ssi = root, root = tmp;</span><br><span class=\"line\">        depth[ssi] = <span class=\"built_in\">depth</span>(ssi);</span><br><span class=\"line\">        depth[root] = <span class=\"built_in\">depth</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> &amp;ssso = isLeft ? sons[ssi].first : sons[ssi].second,</span><br><span class=\"line\">            &amp;sssi = isLeft ? sons[ssi].second : sons[ssi].first,</span><br><span class=\"line\">            t1 = ssso, t2 = sssi;</span><br><span class=\"line\">        ssso = so, sssi = root, so = t2, root = ssi, ssi = t1;</span><br><span class=\"line\">        <span class=\"comment\">// 注意高度更新顺序自下往上</span></span><br><span class=\"line\">        depth[ssso] = <span class=\"built_in\">depth</span>(ssso);</span><br><span class=\"line\">        depth[sssi] = <span class=\"built_in\">depth</span>(sssi);</span><br><span class=\"line\">        depth[root] = <span class=\"built_in\">depth</span>(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, r;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; m;</span><br><span class=\"line\">        <span class=\"built_in\">insert</span>(r, m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">bool</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; crt&#123;&#123;r, <span class=\"number\">1</span>&#125;&#125;, nxt;</span><br><span class=\"line\">    <span class=\"type\">int</span> end = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!crt.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: crt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, flag ? <span class=\"string\">&quot; &quot;</span> : (flag = <span class=\"literal\">true</span>, <span class=\"string\">&quot;&quot;</span>), k.first);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sons[k.first].first)</span><br><span class=\"line\">                nxt.<span class=\"built_in\">emplace_back</span>(sons[k.first].first, <span class=\"number\">2</span> * k.second);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sons[k.first].second)</span><br><span class=\"line\">                nxt.<span class=\"built_in\">emplace_back</span>(sons[k.first].second, <span class=\"number\">2</span> * k.second + <span class=\"number\">1</span>);</span><br><span class=\"line\">            end = k.second;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        crt = std::<span class=\"built_in\">move</span>(nxt);</span><br><span class=\"line\">        nxt = vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(end == n ? <span class=\"string\">&quot;\\nYES&quot;</span> : <span class=\"string\">&quot;\\nNO&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","text":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one;...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"BFS","slug":"BFS","count":10,"path":"api/tags/BFS.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"},{"name":"AVL","slug":"AVL","count":2,"path":"api/tags/AVL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 2:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1124」Raffle for Weibo Followers","uid":"0e44f9fb7cc06322096d65164057b9ec","slug":"「1124」Raffle-for-Weibo-Followers","date":"2022-11-22T16:27:16.000Z","updated":"2022-11-22T16:35:23.813Z","comments":true,"path":"api/articles/「1124」Raffle-for-Weibo-Followers.json","keywords":null,"cover":null,"text":"John got a full mark on PAT. He was so happy that he decided to hold a raffle（抽奖） for his followers on Weibo – that is, he would select winn...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1122」Hamiltonian Cycle","uid":"033ed2c7a1bcdb67e313290ff8557d56","slug":"「1122」Hamiltonian-Cycle","date":"2022-11-22T07:14:15.000Z","updated":"2022-11-22T07:29:47.317Z","comments":true,"path":"api/articles/「1122」Hamiltonian-Cycle.json","keywords":null,"cover":null,"text":"The “Hamilton cycle problem” is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a “Hamiltonian cycle”. ...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}