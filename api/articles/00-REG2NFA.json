{"title":"<00> REG2NFA","uid":"6fcdc9dd323137269ea9dcabb8b1efc8","slug":"00-REG2NFA","date":"2022-05-09T15:49:12.000Z","updated":"2022-05-17T07:57:50.980Z","comments":true,"path":"api/articles/00-REG2NFA.json","keywords":null,"cover":[],"content":"<p>$\\qquad$本文借助<a href=\"https://github.com/pytransitions/transitions\">transitions库</a>基于<strong>逆波兰表示法</strong>（<strong>Reverse Polish Notation，RPN</strong>）实现了正则表达式转NFA，并画出相关的状态转移图。</p>\n<img src=\"/images/编译原理/4.png\" style=\"zoom:60%;\">\n\n<span id=\"more\"></span>\n\n<br>\n\n<hr>\n<h2><span id=\"transitions库介绍\">∅ Transitions库介绍</span></h2><p>$\\qquad$引用官网中的一句话“They say a good example is worth 100 pages of API documentation, a million directives, or a thousand words.”</p>\n<p>$\\qquad$Here is an example:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from transitions.extensions import GraphMachine</span><br><span class=\"line\"></span><br><span class=\"line\"># The states</span><br><span class=\"line\">states = [&#x27;solid&#x27;, &#x27;liquid&#x27;, &#x27;gas&#x27;, &#x27;plasma&#x27;]</span><br><span class=\"line\"></span><br><span class=\"line\"># The transitions</span><br><span class=\"line\">transitions = [</span><br><span class=\"line\">                &#123;&#x27;trigger&#x27;: &#x27;melt&#x27;, &#x27;source&#x27;: &#x27;solid&#x27;, &#x27;dest&#x27;: &#x27;liquid&#x27;&#125;,</span><br><span class=\"line\">                [&#x27;evaporate&#x27;, &#x27;liquid&#x27;, &#x27;gas&#x27;],</span><br><span class=\"line\">                [&#x27;sublimate&#x27;, &#x27;solid&#x27;, &#x27;gas&#x27;]</span><br><span class=\"line\">              ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Initialize</span><br><span class=\"line\">machine = GraphMachine(states=states, transitions=transitions, initial=&#x27;liquid&#x27;, title=&#x27;my STD&#x27;)</span><br><span class=\"line\">machine.add_transition(&#x27;ionize&#x27;, &#x27;gas&#x27;, &#x27;plasma&#x27;)</span><br><span class=\"line\">machine.get_graph().draw(&#x27;my_state_diagram.png&#x27;, prog=&#x27;dot&#x27;)</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$Here is the output:</p>\n<img src=\"/images/编译原理/5.png\" style=\"zoom:80%;\">\n\n<p>$\\qquad$上面的栗子基本包含了本文所用到的所有操作，另外说明几点：</p>\n<ol>\n<li><code>transitions</code>列表中既可以是字典，也可以是列表，甚至是两者的结合，但都需要按照<code>[trigger , source , destination]</code>的顺序写</li>\n<li><code>add_transition()</code>函数增加转移函数，输入参数也需要按照上述顺序</li>\n<li><code>GraphMachine</code>函数中的<code>initial</code>参数指定初始状态，并标注为不同的颜色，然而我们在画状态转移图时标注的往往不是初始状态而是接收状态，因此我一般将<code>initial</code>参数赋为接收状态</li>\n<li>更多使用方式请参见<a href=\"https://github.com/pytransitions/transitions\">transitions&#x2F;README.md</a></li>\n</ol>\n<hr>\n<h2><span id=\"逆波兰表示法rpn\">∇ 逆波兰表示法RPN</span></h2><p>$\\qquad$逆波兰表示法，是一种是由波兰数学家扬·武卡谢维奇于1920年引入的数学表达式形式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为<strong>后缀表示法</strong>。逆波兰记法不需要括号来标识操作符的优先级。$^{[1]}$</p>\n<p>$\\qquad$比如说</p>\n<p>$$5\\ +\\ ((1\\ +\\ 2)\\ <em>\\ 4)\\ -\\ 3\\  &#x3D;&#x3D;\\mathbf{RPN}&#x3D;⇒\\ 5\\ 1\\ 2\\ +\\ 4\\ </em>\\ +\\ 3\\ -$$</p>\n<p>$\\qquad$首先阐述一下逆波兰表达式是如何得到的，我们采取如下算法：</p>\n<ol>\n<li><p>需要两个栈，一个存数，一个存符号，下面分别称之为<strong>数栈</strong>和<strong>符号栈</strong></p>\n</li>\n<li><p>顺序读入中缀表达式（正常的运算式）</p>\n</li>\n<li><p>遇到数（完整的数，不是逐位）时压入数栈</p>\n</li>\n<li><p>遇到运算符时，首先从符号栈栈顶开始检查，如果栈顶符号优先级&gt;(&#x3D;)读入运算符，则将栈顶符号弹出压入数栈中，然后检查符号栈下一个符号，循环往复，直到符号栈栈顶符号优先级&lt;读入运算符时，将读入运算符压入符号栈</p>\n<p>⚠️由于运算符基本是左结合的，因此我们可以认为左边（符号栈内）的运算符优先级&gt;右边（读入）的同级运算符</p>\n</li>\n<li><p>当读入【(】时，直接压入符号栈，且只有读入【)】时才可以弹出</p>\n</li>\n<li><p>当读入【)】时，将符号栈内的符号依次弹出压入数栈，直到遇到第一个【(】，注意【(】直接弹出不压入数栈</p>\n</li>\n<li><p>读完运算式后，依次弹出符号栈并压入数栈，那么数栈【栈底→栈顶】即为逆波兰表达式</p>\n</li>\n</ol>\n<p>$\\qquad$那么逆波兰表达式有什么优点呢，既然是关于运算式的那必然涉及到计算。对于逆波兰表达式，我们只需顺序读入，遇到数字压入栈中，遇到运算符则弹出栈顶的两个数字直接计算再压入栈中，最终的栈里只会剩余一个数，即为运算结果。</p>\n<p>$$\\$\\ 5\\ 1\\ 2\\ +\\ 4\\ <em>\\ +\\ 3\\ -→ \\ 5\\ 3\\ \\$\\ 4\\ </em>\\ +\\ 3\\ -→ \\ 5\\ \\ 12\\ \\$+\\ 3\\ -→ \\ 17\\ \\$3\\ -→ 14\\$ $$</p>\n<hr>\n<h2><span id=\"א-regular-expression-2-nfa\">ℵ Regular Expression 2 NFA</span></h2><p>$\\qquad$这里的正则表达式我们认为仅有三种符号：Kleene闭包【*】，连接运算符【·】（一般省略），或运算符【｜】（<strong>三者的优先级依次降低</strong>）。那么正则表达式转为NFA的规则基本可以由下图概括，</p>\n<img src=\"/images/编译原理/6.jpg\" style=\"zoom:50%;\">\n\n<br>\n\n<p>$\\qquad$基本思想是先将正则表达式转为逆波兰表达式，然后用开始节点和最终节点的编号对<code>[start node num , end node num]</code>来表示正则表达式的运算结果，在用逆波兰表达式计算的同时生成列表<code>transitions</code>，最后绘制相应的状态转移图。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> transitions.extensions <span class=\"keyword\">import</span> GraphMachine</span><br><span class=\"line\"></span><br><span class=\"line\">rpn = []</span><br><span class=\"line\">priority = &#123;<span class=\"string\">&#x27;|&#x27;</span>: <span class=\"number\">0</span>, <span class=\"string\">&#x27;*&#x27;</span>: <span class=\"number\">2</span>, <span class=\"string\">&#x27;.&#x27;</span>: <span class=\"number\">1</span>, <span class=\"string\">&#x27;(&#x27;</span>: -<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 补全正则表达式的连接运算符</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dotREG</span>(<span class=\"params\">s</span>):</span><br><span class=\"line\">    i = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(s):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s[i].islower() <span class=\"keyword\">or</span> s[i] == <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s[i - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span> <span class=\"keyword\">or</span> s[i - <span class=\"number\">1</span>].islower() <span class=\"keyword\">or</span> s[i - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">                s = s[:i] + <span class=\"string\">&#x27;.&#x27;</span> + s[i:]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算正则表达式的逆波兰表达式rpn</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">REG2RPN</span>(<span class=\"params\">r</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> rpn</span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    ops = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(r):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r[i].islower():</span><br><span class=\"line\">            rpn.append(r[i])</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> r[i] <span class=\"keyword\">in</span> [<span class=\"string\">&#x27;.&#x27;</span>, <span class=\"string\">&#x27;|&#x27;</span>, <span class=\"string\">&#x27;*&#x27;</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ops:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> priority[ops[-<span class=\"number\">1</span>]] &gt;= priority[r[i]]:</span><br><span class=\"line\">                    rpn.append(ops.pop())</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">            ops.append(r[i])</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> r[i] == <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">            ops.append(<span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> r[i] == <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ops[-<span class=\"number\">1</span>] != <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">                rpn.append(ops.pop())</span><br><span class=\"line\">            ops.pop()</span><br><span class=\"line\">        i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ops:</span><br><span class=\"line\">        rpn.append(ops.pop())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">r = <span class=\"built_in\">input</span>(<span class=\"string\">&quot;Input regular expression: &quot;</span>)</span><br><span class=\"line\">r = dotREG(r)</span><br><span class=\"line\">REG2RPN(r)</span><br><span class=\"line\">status = <span class=\"number\">0</span></span><br><span class=\"line\">crt_stt = []</span><br><span class=\"line\">transitions = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(rpn)):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> rpn[i].islower():</span><br><span class=\"line\">        crt_stt.append([status, status + <span class=\"number\">1</span>])</span><br><span class=\"line\">        transitions.append([rpn[i], <span class=\"built_in\">str</span>(status), <span class=\"built_in\">str</span>(status + <span class=\"number\">1</span>)])</span><br><span class=\"line\">        status += <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> rpn[i] == <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(crt_stt[-<span class=\"number\">1</span>][<span class=\"number\">0</span>]), <span class=\"built_in\">str</span>(crt_stt[-<span class=\"number\">1</span>][<span class=\"number\">1</span>])])</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(crt_stt[-<span class=\"number\">1</span>][<span class=\"number\">1</span>]), <span class=\"built_in\">str</span>(crt_stt[-<span class=\"number\">1</span>][<span class=\"number\">0</span>])])</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> rpn[i] == <span class=\"string\">&#x27;.&#x27;</span>:</span><br><span class=\"line\">        stt1 = crt_stt.pop()</span><br><span class=\"line\">        stt2 = crt_stt.pop()</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(stt2[<span class=\"number\">1</span>]), <span class=\"built_in\">str</span>(stt1[<span class=\"number\">0</span>])])</span><br><span class=\"line\">        crt_stt.append([stt2[<span class=\"number\">0</span>], stt1[<span class=\"number\">1</span>]])</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> rpn[i] == <span class=\"string\">&#x27;|&#x27;</span>:</span><br><span class=\"line\">        stt1 = crt_stt.pop()</span><br><span class=\"line\">        stt2 = crt_stt.pop()</span><br><span class=\"line\">        crt_stt.append([status, status + <span class=\"number\">1</span>])</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(status), <span class=\"built_in\">str</span>(stt1[<span class=\"number\">0</span>])])</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(status), <span class=\"built_in\">str</span>(stt2[<span class=\"number\">0</span>])])</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(stt1[<span class=\"number\">1</span>]), <span class=\"built_in\">str</span>(status + <span class=\"number\">1</span>)])</span><br><span class=\"line\">        transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"built_in\">str</span>(stt2[<span class=\"number\">1</span>]), <span class=\"built_in\">str</span>(status + <span class=\"number\">1</span>)])</span><br><span class=\"line\">        status += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">transitions.append([<span class=\"string\">&#x27;ε&#x27;</span>, <span class=\"string\">&#x27;start&#x27;</span>, <span class=\"built_in\">str</span>(crt_stt[<span class=\"number\">0</span>][<span class=\"number\">0</span>])])</span><br><span class=\"line\">states = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">str</span>, <span class=\"built_in\">range</span>(status))).append(<span class=\"string\">&#x27;start&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">NFA = GraphMachine(states=states,</span><br><span class=\"line\">                   transitions=transitions,</span><br><span class=\"line\">                   initial=<span class=\"built_in\">str</span>(crt_stt[<span class=\"number\">0</span>][<span class=\"number\">1</span>]), title=<span class=\"string\">&#x27;REG2NFA&#x27;</span>)</span><br><span class=\"line\">NFA.get_graph().draw(<span class=\"string\">&#x27;REG2NFA.png&#x27;</span>, prog=<span class=\"string\">&#x27;dot&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"few-tips\">⊈ Few Tips</span></h3><ol>\n<li>虽然【(】的优先级最高，但由于【(】在遇到【)】之前不能弹出，因此我们将其优先级置为最低 </li>\n<li>python的list自带<code>pop()</code>函数，不仅弹出最后一个元素，同时返回其值，这与C++的&lt;stack&gt;不同</li>\n<li>NFA起点是’start’，接收状态为序号最大的状态，颜色与其他状态不同</li>\n<li><code>rpn</code>为数栈，<code>ops</code>为符号栈</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(aa|b)*a(a|bb)*</span><br></pre></td></tr></table></figure>\n\n<img src=\"/images/编译原理/7.png\" style=\"zoom:70%;\">\n\n<br>\n\n<hr>\n<h3><span id=\"reference\">「Reference」</span></h3><ul>\n<li><a href=\"https://zh.wikipedia.org/w/index.php?title=%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&oldid=67874513\">逆波兰表示法</a>. (2021, September 24). Retrieved from 维基百科, 自由的百科全书</li>\n</ul>\n","text":"$\\qquad$本文借助transitions库基于逆波兰表示法（Reverse Polish Notation，RPN）实现了正则表达式转NFA，并画出相关的状态转移图。 ∅ Transitions库介绍$\\qquad$引用官网中的一句话“They say a good exa...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">∅ Transitions库介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">∇ 逆波兰表示法RPN</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">ℵ Regular Expression 2 NFA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">⊈ Few Tips</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">「Reference」</span></a></li></ol></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"<01> NFA2DFA","uid":"876685c2961fc61a4c5638eee32e520e","slug":"01-NFA2DFA","date":"2022-05-11T03:07:43.000Z","updated":"2022-05-17T07:57:35.663Z","comments":true,"path":"api/articles/01-NFA2DFA.json","keywords":null,"cover":[],"text":"$\\qquad$本文借助Graphviz库实现了NFA转DFA，并输出DFA的状态转移图。 ∅ Graphviz库介绍$\\qquad$你一定很疑惑我昨天刚介绍完Transitions库今天怎么就就换了一个绘制库。ummm…Transitions库其实更注重于状态机本身的实现，当你...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"YOLOv5说明书","uid":"4eb946cc0edf20ceda9a686ce0927f5a","slug":"Yolov5说明书","date":"2022-05-07T03:54:21.000Z","updated":"2022-06-06T16:32:40.579Z","comments":true,"path":"api/articles/Yolov5说明书.json","keywords":null,"cover":[],"text":"$\\qquad$YOLO 的全称是 You Only Look Once，指只需要浏览一次就可以识别出图中的物体的类别和位置。YOLOv5 是由 Ultralytics LLC 公司于 2020 年 5 月所提出，其图像推理速度最快达 0.007 s，即每秒可处理 140 帧，满...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Machine Learning","slug":"Machine-Learning","count":3,"path":"api/categories/Machine-Learning.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"python","slug":"python","count":11,"path":"api/tags/python.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}