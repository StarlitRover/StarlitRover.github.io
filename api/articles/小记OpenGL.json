{"title":"「Section 0」小记OpenGL","uid":"df24c0ec65d9b0432ce3e888de12a2d4","slug":"小记OpenGL","date":"2022-03-08T08:01:35.000Z","updated":"2022-03-08T08:27:20.609Z","comments":true,"path":"api/articles/小记OpenGL.json","keywords":null,"cover":[],"content":"<ol>\n<li><p><code>glfwMakeContextCurrent(GLFWwindow *window)</code>：将窗口<code>window</code>设为当前上下文</p>\n<ul>\n<li>OpenGL可以认为是一个巨大的状态机。所谓状态机，是一个包含了许多当前属性（背景颜色、渲染模式）的集合（状态），里面的属性值直到下次修改前都不会改变。那么当内部属性发生改变时状态也随之而变，类似编译原理里面的自动机。</li>\n<li>上下文可以认为是OpenGL当前的状态，即当前执行操作的窗口，可以认为选择<code>window</code>作为当前画布。</li>\n</ul>\n<span id=\"more\"></span>\n</li>\n<li><p><code>glViewport(GLint x,GLint y,GLsizei width,GLsizei height)</code>：在窗口上设置绘制区域</p>\n<ul>\n<li>x，y以像素为单位，指定了视口的左下角位置</li>\n<li>width，height 表示这个视口矩形的宽度和高度，根据窗口的实时变化重绘窗口</li>\n<li>在默认情况下，视口被设置为占据打开窗口的整个像素矩形，视口大小与窗口大小相同</li>\n<li>需要置于<code>glfwMakeContextCurrent(GLFWwindow *window)</code>函数后才会生效</li>\n<li>一个程序内可以使用多次在不同区域内进行绘制</li>\n<li>注册回调函数，即每次调整窗口时调用这个函数来调整视口</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow* window, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>OpenGL中的函数名</strong>：<code>glColor3f</code>,<code>glVertex2f</code>,<code>glVertex3d</code>, …</p>\n<ul>\n<li>开头gl表示OpenGL中的函数</li>\n<li>数字前的单词表示该函数的作用</li>\n<li>数字表示有几个参数，在<code>glVertex</code>中2表示二维坐标，3则表示三维坐标</li>\n<li>数字后面的字母表示参数类型<ul>\n<li>s：16位整型</li>\n<li>i：32位整型</li>\n<li>f：32位符点数</li>\n<li>d：64位符点数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>3D坐标</strong>：<code>glVertex3f(x,y,z)</code></p>\n<ul>\n<li>$x,y,z\\in[-1.0f,1.0f]$</li>\n<li>$x,y$是二维平面的坐标，$[0f,0f]$是窗口的中心，$x$轴向右为正方向，$y$轴向上为正方向</li>\n<li>$z$为深度，可以认为是到屏幕的垂直距离</li>\n</ul>\n</li>\n<li><p><strong>绘制代码</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glBegin</span>(TYPE);</span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"built_in\">glEnd</span>()</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>TYPE</code>为绘图类型，常见的类型有：</p>\n<ul>\n<li><p><code>GL_POINTS</code>：离散的点（⚠️<strong>画圆点</strong>：在<code>glBegin</code>前加<code>glEnable(GL_POINT_SMOOTH);</code>）</p>\n</li>\n<li><p><code>GL_LINES</code>：线</p>\n</li>\n<li><p><code>GL_LINE_STRIP</code>：折线图（多个点的连线）</p>\n</li>\n<li><p><code>GL_LINE_LOOP</code>：首尾相连的闭合线</p>\n</li>\n<li><p><code>GL_TRIANGLES</code>：三角形</p>\n</li>\n<li><p><code>GL_TRIANGLE_STRIP</code>：绘制同方向的三角形</p>\n<img src=\"/images/计算机图形学/2/1.webp\" style=\"zoom:100%;\"></li>\n</ul>\n</li>\n<li><p><strong>调节粗细大小</strong>：置于<code>glBegin(TYPE)</code>前</p>\n<ul>\n<li><strong>线的粗细</strong>：<code>void glLineWidth(GLfloat width)</code>，$0\\leq width\\leq 10$</li>\n<li><strong>点的大小</strong>：<code>void glPointSize(GLfloat size)</code> ，<code>size</code>的单位是像素（默认为正方形）</li>\n</ul>\n<img src=\"/images/计算机图形学/2/2.jpeg\" style=\"zoom:70%;\"></li>\n</ol>\n","text":" glfwMakeContextCurrent(GLFWwindow *window)：将窗口window设为当前上下文 OpenGL可以认为是一个巨大的状态机。所谓状态机，是一个包含了许多当前属性（背景颜色、渲染模式）的集合（状态），里面的属性值直到下次修改前都不会改变。那么当...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"计算机图形学","slug":"计算机图形学","count":3,"path":"api/categories/计算机图形学.json"}],"tags":[{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"}],"toc":"","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"Bézier Curve：小试牛刀","uid":"a39f642fa5f3a366579e792c57ec2418","slug":"Bezier-Curve","date":"2022-03-08T08:47:55.000Z","updated":"2022-06-01T13:43:08.012Z","comments":true,"path":"api/articles/Bezier-Curve.json","keywords":null,"cover":[],"text":"$\\qquad$贝塞尔曲线有着很多特殊的性质在图形设计和路径规划中应用都非常广泛。贝塞尔曲线完全由其控制点决定其形状，n个控制点对应着n-1阶的贝塞尔曲线，并且可以通过递归来定义。本篇文章的重点在于对Bézier Curve的理解以及用OpenGL绘制Bézier Curve。 ...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"计算机图形学","slug":"计算机图形学","count":3,"path":"api/categories/计算机图形学.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"OpenGL","slug":"OpenGL","count":4,"path":"api/tags/OpenGL.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「Section 2」建立数据模型","uid":"6e65b890459bfc2665ec0e0a14ed8ee7","slug":"建立数据模型","date":"2022-03-06T06:27:50.000Z","updated":"2022-06-12T04:04:53.662Z","comments":true,"path":"api/articles/建立数据模型.json","keywords":null,"cover":[],"text":" 概念模型的基本概念 实体：客观事物的映射，可以是实际存在的对象，也可以是某种概念 属性：实体的特征，描述实体，使实体更为具体 域：一个属性的取值范围 实体集：所有具有相同属性的实体所构成的集合 实体型：实体名称以及所有属性名构成的集合 码：实体集中可以根据一个属性或多个属性唯一...","link":"","photos":[],"count_time":{"symbolsCount":675,"symbolsTime":"1 mins."},"categories":[{"name":"数据库原理","slug":"数据库原理","count":3,"path":"api/categories/数据库原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}