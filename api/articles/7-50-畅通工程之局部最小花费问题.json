{"title":"7-50 畅通工程之局部最小花费问题","uid":"e48195bb952699bdcd7eaab2b29014de","slug":"7-50-畅通工程之局部最小花费问题","date":"2022-02-09T14:37:31.000Z","updated":"2022-10-14T09:58:36.134Z","comments":true,"path":"api/articles/7-50-畅通工程之局部最小花费问题.json","keywords":null,"cover":[],"content":"<p><a href=\"https://pintia.cn/problem-sets/15/problems/897\">➳ENTRY</a><br>$\\qquad$某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全地区畅通需要的最低成本。</p>\n<h2><span id=\"输入格式\">输入格式:</span></h2><p>$\\qquad$输入的第一行给出村庄数目N (1≤N≤100)；随后的$\\frac{N(N-1)}{2}$行对应村庄间道路的成本及修建状态：每行给出4个正整数，分别是两个村庄的编号（从1编号到N），此两村庄间道路的成本，以及修建状态-1表示已建，0表示未建。</p>\n<span id=\"more\"></span>\n\n<h2><span id=\"输出格式\">输出格式:</span></h2><p>$\\qquad$输出全省畅通需要的最低成本。</p>\n<h2><span id=\"输入样例\">输入样例:</span></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">1 2 1 1</span><br><span class=\"line\">1 3 4 0</span><br><span class=\"line\">1 4 1 1</span><br><span class=\"line\">2 3 3 0</span><br><span class=\"line\">2 4 2 1</span><br><span class=\"line\">3 4 5 0</span><br></pre></td></tr></table></figure>\n\n<h2><span id=\"输出样例\">输出样例:</span></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$初看这题的分数时，我虎躯一震…竟然有35分。回想自己以往被虐的难题最多也只有30分，莫非是什么绝世难题。</p>\n<img src=\"/images/PTA-数据结构与算法题目集/7-50/huqu.jpeg\" width=\"250\" height=\"250\" alt=\"虎躯一震\" align=\"center\">\n\n<p>$\\qquad$不过…看这题目长度并没有难题的气势。</p>\n<p>$\\qquad$读完题目，常规之中透着一丝不羁。第一感觉是一道求最小生成树的题目，不过又有所不同，因为部分边已经选定了，我们需要在题目选定部分边的情况下选取成本（权值之和）最小并能使所有点连通的边。<br>$\\qquad$既然如此，那就把已经连通的点们看作一个大点，然后求大点们的最小生成树就完事了。参照处理最小生成树的Alg.Kruskal思想，我们可以每次选取一条两个顶点不在同一个连通集内且权值最小的边，直至所有点均连通。</p>\n<p>$\\qquad$对于连通集的处理，那就不得不说一说<big><strong>并查集</strong></big>。下面简单介绍一下并查集。</p>\n<p>$\\qquad$<em><strong>Wikipedia</strong></em>：”并查集是一种用于处理一些不交集的合并及查询问题的数据结构。” 我们需要对一些元素进行划分，这里可以认为元素中有若干个帮派，帮派里的元素也有等级制度（诸如<em><strong>头头，大哥，小弟，etc</strong></em>）。那么事实上我们只要让每个元素记住自己上一级是谁即可，即父节点，而等级最高元素的父节点是他自己，把这种层次形象化后其实就是个树的数据结构。那么对任意一个小弟，通过不断访问父节点的父节点就能找到最大的头头。其最大的特点就是每个元素只存自己的父节点。对于两个帮派交汇，若想要元素较少的帮派归附于另一帮派，只要让该帮派头头的父节点指向（<em><strong>这里的指向并不是说父节点是指针，也可以是数组</strong></em>）另一帮派的头头即可。以上所说的这种呢是毫无优化最基础的并查集，因为很显然在特殊情况下可能会退化成链表。我们当然也可以直接让所有帮派成员的父节点都指向最大元素，有兴趣进一步了解可以移步至<a href=\"https://zhuanlan.zhihu.com/p/93647900\">算法学习笔记(1) : 并查集</a>。</p>\n<p>$\\qquad$那么本题中的村庄很显然就是我们要划分的元素，因此我们可以先定义一个存储各村庄父节点的<code>vector</code>，一开始均初始化为自己:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">belong</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">iota</span>(belong.<span class=\"built_in\">begin</span>(), belong.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//belong-&gt;[0,1,2,...,n-1]</span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$同时我们需要一个<code>size</code>向量来存储每个帮派现有的元素个数，好在帮派交汇时决定谁并入谁，这是一种优化策略：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">size</span><span class=\"params\">(n, <span class=\"number\">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$对于已经建成的公路，公路两端的村庄是连通的，需要将这两个帮派合并，那么就根据少数并入多数的策略进行合并：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> max_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[x] : belong[y],</span><br><span class=\"line\">    min_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[y] : belong[x];</span><br><span class=\"line\">belong[min_idx] = max_idx;</span><br><span class=\"line\">size[max_idx] += size[min_idx];</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$由于我想要知道初始情况下连通集的个数，因此我必须让所有成员均指向其帮派头目，才能得知有几个帮派头目。但是上述代码会发生一个帮派头头的父节点指向了另一个帮派头头，但其手下成员的父节点并未更新，因此结束上述操作后还需找到每个元素真正的头头：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v: belong)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (v != belong[v])</span><br><span class=\"line\">        v = belong[v];</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$此时<code>belong</code>中都是头头的编号了，我们只需将其放入<code>set</code>容器中即可得知连通集的个数。显然，每次找一条边只能使连通集个数-1，那么我们需要找的边数即是连通集的个数-1。</p>\n<hr>\n<p>$\\qquad$话说回来，每条公路的成本该怎么存呢？其实初看题目的时候我就纳闷已经修通的公路为啥还要告诉我成本。如果不给的话，数据倒是不规整了…估计是程序员那该死的强迫症作祟吧。<br>$\\qquad$也就是说，其实需要的数据也不是很多…本来最大也就$100\\times 100$的成本矩阵，现在没这个念头了。本来想用<code>map</code>和<code>pair</code>结合的，不过由于后面需要对成本进行排序…<code>sort</code>和<code>map</code>天性不搭，全剧终。<br>$\\qquad$那就找<code>map</code>他爸<code>pair</code>:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;pair&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, <span class=\"type\">int</span>&gt; cost;</span><br><span class=\"line\">/*pair&lt;pair&lt;village1,village2&gt;,cost&gt;*/</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$最后，只要将<code>cost</code>按从小到大的顺序进行<code>sort</code>，然后按顺序判断每个公路的两个村庄是否位于两个连通集，若是则计入其成本直至有（连通集的个数-1）条符合条件的公路为止。另外这个过程需要动态更新连通集的关系，因为连通集的个数一直在变少。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;, <span class=\"type\">int</span>&gt; info;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, x, y, c;</span><br><span class=\"line\">    <span class=\"type\">bool</span> flag;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">belong</span><span class=\"params\">(n)</span>, <span class=\"title\">size</span><span class=\"params\">(n, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    vector&lt;info&gt; cost;</span><br><span class=\"line\">    <span class=\"built_in\">iota</span>(belong.<span class=\"built_in\">begin</span>(), belong.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n * (n - <span class=\"number\">1</span>) / <span class=\"number\">2</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c &gt;&gt; flag;</span><br><span class=\"line\">        x -= <span class=\"number\">1</span>; y -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!flag)</span><br><span class=\"line\">            cost.<span class=\"built_in\">push_back</span>(&#123; &#123;x, y&#125;, c&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> max_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[x] : belong[y],</span><br><span class=\"line\">                min_idx = (size[belong[x]] &gt; size[belong[y]]) ? belong[y] : belong[x];</span><br><span class=\"line\">            belong[min_idx] = max_idx;</span><br><span class=\"line\">            size[max_idx] += size[min_idx];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v: belong)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (v != belong[v])</span><br><span class=\"line\">            v = belong[v];</span><br><span class=\"line\">    <span class=\"function\">set&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">div</span><span class=\"params\">(belong.begin(), belong.end())</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> all_cost = <span class=\"number\">0</span>, idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(cost.<span class=\"built_in\">begin</span>(), cost.<span class=\"built_in\">end</span>(), [](info &amp;a, info &amp;b) &#123; <span class=\"keyword\">return</span> a.second &lt; b.second; &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; div.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v1, v2;</span><br><span class=\"line\">        <span class=\"comment\">// 优化版</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            v1 = cost[idx].first.first, v2 = cost[idx].first.second;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (belong[v1] != belong[belong[v1]])</span><br><span class=\"line\">                belong[v1] = belong[belong[v1]];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (belong[v2] != belong[belong[v2]])</span><br><span class=\"line\">                belong[v2] = belong[belong[v2]];</span><br><span class=\"line\">            ++idx;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (belong[v1] == belong[v2]);</span><br><span class=\"line\">        <span class=\"type\">int</span> max_idx = (size[belong[v1]] &gt; size[belong[v2]]) ? belong[v1] : belong[v2],</span><br><span class=\"line\">            min_idx = (size[belong[v1]] &gt; size[belong[v2]]) ? belong[v2] : belong[v1];</span><br><span class=\"line\">        belong[min_idx] = max_idx;</span><br><span class=\"line\">        size[max_idx] += size[min_idx];</span><br><span class=\"line\">        <span class=\"comment\">/* 简化版</span></span><br><span class=\"line\"><span class=\"comment\">        do</span></span><br><span class=\"line\"><span class=\"comment\">        &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            v1 = cost[idx].first.first, v2 = cost[idx].first.second;</span></span><br><span class=\"line\"><span class=\"comment\">            ++idx;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125; while (belong[v1] == belong[v2]);</span></span><br><span class=\"line\"><span class=\"comment\">        belong[belong[v1]] = belong[v2];</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        all_cost += cost[idx - <span class=\"number\">1</span>].second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; all_cost;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2><span id=\"σ-几点说明\">Σ 几点说明</span></h2><ol>\n<li><p><code>map</code>的本质是<code>pair</code>，但<code>pair</code>的两部分是平等的，不能通过其一访问另一个</p>\n</li>\n<li><p><code>iota</code>函数在指定初值后可以使<code>vector</code>按增序排列：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"> <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(num)</span></span>; <span class=\"comment\">//需要先确定向量大小</span></span><br><span class=\"line\"> <span class=\"built_in\">iota</span>(v.<span class=\"built_in\">begin</span>(),v.<span class=\"built_in\">end</span>(),start_num);</span><br><span class=\"line\"><span class=\"comment\">//v=[start_num , start_num+1 , … , start_num+num-1]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>经过几次实验，读入<code>bool</code>变量，只能输入0和1.若输入其他数字可能不会影响<code>bool</code>变量的读入，但会影响后面变量的读入.</p>\n</li>\n<li><p>优化版代码在查找符合条件的公路时顺便更新父节点，并依旧按照小并大原则进行合并，这在数据较大时较有优势；而简化版则简短精炼，合并时不管三七二十一均将<code>v1</code>并入<code>v2</code>，也不更新父节点. 以下是两者的时间比较：<br><img src=\"/images/PTA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86/7-50/otc.png\"></p>\n<center>☜优化版$\\qquad$简化版☞</center>\n<center>❣</center>\n<center>❣</center>\n<center>❣</center>\n<center>❣</center>\n<center>❣</center>\n<center>❣</center></li>\n</ol>\n<hr>\n<h2><span id=\"δ-彩蛋\">δ 彩蛋</span></h2><p>$\\qquad$然鹅简化版真的是对的吗？哈哈哈哈，虽然简化版确实通过了所有测试点，但我一直觉的简化版不够严谨，因此尝试着枚举一个反例出来。随便构造了一个：</p>\n<img src=\"/images/PTA-数据结构与算法题目集/7-50/huaixiao.jpeg\" width=\"200\" height=\"200\" alt=\"坏笑\" align=\"center\">\n\n<p>$\\qquad$简化版真的是对的吗？哈哈哈哈，虽然简化版确实通过了所有测试点，但我一直觉的简化版不够严谨，因此尝试着枚举一个反例出来。随便构造了一个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 2 2 0</span><br><span class=\"line\">1 3 10 1</span><br><span class=\"line\">1 4 10 0</span><br><span class=\"line\">1 5 3 0</span><br><span class=\"line\">2 3 1 0</span><br><span class=\"line\">2 4 10 1</span><br><span class=\"line\">2 5 10 0</span><br><span class=\"line\">3 4 10 0</span><br><span class=\"line\">3 5 10 0</span><br><span class=\"line\">4 5 10 0</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$这个测试用例优化版的结果是4，而简化版的结果是3。显然，简化版中枪了，我构造的思路就是着眼于简化版不动态更新各个元素的父节点，不更新也就算了，在检查的时候还不访问元素父节点的父节点，这样在一定的条件下就必然会导致选中的一条公路，其端点两个村庄的父节点不同，然而在之前的选取过程中这两个父节点已经合并了，也就是说，选取了一条处于一个连通集中的公路，花了没必要的造路成本。</p>\n<p>$\\qquad$哈哈哈哈哈哈，说的简化版不是我写的一样，其实简化版是我在提交完优化版后乱删而成的。当时就想着能不能简化代码，但自己改改太累了，不妨先试着删亿点然后提交看看，如果通过了那就再思考思考为什么可以删掉，于是乎，有了这个彩蛋！<br>$\\qquad$我已经将这个问题以邮件的形式发给PTA了，但我没留名字，或许以后能在这道题下面看到<br><em><strong><center>感谢一位不知名的同学补充数据！</center></strong></em><br>$\\qquad$那么怎么改正简化版呢，其实不改<code>do-while</code>部分就好了：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    v1 = cost[idx].first.first, v2 = cost[idx].first.second;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (belong[v1] != belong[belong[v1]])</span><br><span class=\"line\">        belong[v1] = belong[belong[v1]];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (belong[v2] != belong[belong[v2]])</span><br><span class=\"line\">        belong[v2] = belong[belong[v2]];</span><br><span class=\"line\">    ++idx;</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (belong[v1] == belong[v2]);</span><br><span class=\"line\">belong[belong[v1]] = belong[v2];</span><br></pre></td></tr></table></figure>\n","text":"➳ENTRY$\\qquad$某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"PTA-数据结构与算法题目集","slug":"PTA-数据结构与算法题目集","count":7,"path":"api/categories/PTA-数据结构与算法题目集.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"},{"name":"pair","slug":"pair","count":6,"path":"api/tags/pair.json"},{"name":"并查集","slug":"并查集","count":4,"path":"api/tags/并查集.json"},{"name":"numeric","slug":"numeric","count":4,"path":"api/tags/numeric.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输入格式:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输出格式:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输入样例:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输出样例:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Σ 几点说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">δ 彩蛋</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"博客着火事件","uid":"f036210e20161e9bc9972b673206da20","slug":"博客着火事件","date":"2022-02-11T02:55:42.000Z","updated":"2022-02-11T05:23:35.581Z","comments":true,"path":"api/articles/博客着火事件.json","keywords":null,"cover":[],"text":" $\\qquad$浑浑，噩噩。 $\\qquad$首先，我只想对在座的各位说： 一定要记得备份！！！ $\\qquad$鬼知道我昨天晚上经历了什么… $\\qquad$我的博客是托管在Github上的，但Github也只是静态托管，上面只有已经生成的网页代码，而真正的源代码以及每篇文章...","link":"","photos":[],"count_time":{"symbolsCount":749,"symbolsTime":"1 mins."},"categories":[{"name":"Daily","slug":"Daily","count":2,"path":"api/categories/Daily.json"}],"tags":[{"name":"blog","slug":"blog","count":2,"path":"api/tags/blog.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"7-48 银行排队问题之单窗口“夹塞”版","uid":"b06eec1520de8e94623ad87c71416a11","slug":"7-48-银行排队问题之单窗口“夹塞”版","date":"2022-02-08T14:22:42.000Z","updated":"2022-02-10T14:27:48.086Z","comments":true,"path":"api/articles/7-48-银行排队问题之单窗口“夹塞”版.json","keywords":null,"cover":null,"text":"➳ENTRY$\\qquad$排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第i位顾客与排在后面的第j位顾客是好朋友，并且愿...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"PTA-数据结构与算法题目集","slug":"PTA-数据结构与算法题目集","count":7,"path":"api/categories/PTA-数据结构与算法题目集.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}