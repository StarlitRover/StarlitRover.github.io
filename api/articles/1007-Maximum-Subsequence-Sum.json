{"title":"「1007」 Maximum Subsequence Sum","uid":"ac5b1c5b9bdf438ff9cc932e6cd1efaf","slug":"1007-Maximum-Subsequence-Sum","date":"2022-02-27T06:48:38.000Z","updated":"2022-03-01T02:39:37.308Z","comments":true,"path":"api/articles/1007-Maximum-Subsequence-Sum.json","keywords":null,"cover":null,"content":"<p><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168\">➳ENTRY</a></p>\n<p>$\\qquad$Given a sequence of <em>K</em> integers $[N_1, N_2,\\cdots, N_K]$. A continuous subsequence is defined to be $[N_i, N_{i+1},\\cdots, N_j]$ where $1≤i≤j≤K$. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence $[-2, 11, -4, 13, -5, -2]$, its maximum subsequence is $[11, -4, 13]$ with the largest sum being 20.</p>\n<p>$\\qquad$Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>\n<span id=\"more\"></span>\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>$\\qquad$Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>$\\qquad$For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 1 4</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$最大子序和，顾名思义，求出和最大的连续子序列。</p>\n<p>$\\qquad$这是一道非常经典的动态规划问题，据说也是很多大厂的面试题，不过现在应该已经被做烂了，因为之前我就已经碰到过三四回了。对，不是这一类题目，是这一道题目。但我初看题目的时候还是有点懵，估计是之前没想透吧，那么今天就让它永久住在我的博客里，以加深印象。</p>\n<p>$\\qquad$说实话一开始的思路必然是有的，第一个想法必然是枚举所有的子序和，野蛮又暴力。作为一个受过高等教育的科班大学生，我们要文明一点。当然不是说枚举不好，有时候枚举也会有意想不到的奇效，but not now.</p>\n<p>$\\qquad$仔细分析一下<strong>最大子序列</strong>，我们不妨设最大子序列为$S$，那么为什么$S$能成为最大子序列呢？首先<br>$$<br>\\forall S_k\\in S\\Rightarrow \\mathrm{sum}(S_k)&lt;\\mathrm{sum}(S)<br>$$<br>即$S$的任意连续子序列和必然小于$S$之和。另外$S$的两端要么没有数要么就是负数，不然$S$向两边扩张还可以变大，这与其定义“最大”矛盾。</p>\n<p>$\\qquad$由此我们其实可以得到一个非常重要的推论——$S$前n个数之和必然是$\\geq 0$的，否则丢弃前n个数得到新的子序列之和将会大于$S$之和。那么我们便可以设置一个<code>sum=0</code>变量，依次读入每一个数并计入<code>sum</code>中，若<code>sum&lt;0</code>了根据之前的推论说明前面计入<code>sum</code>的序列不可能成为最大子序列的前置部分，因此直接令<code>sum=0</code>丢弃前面读入的序列和，直到再次读入一个正数后再开始计数。只要<code>sum&gt;0</code>就与最大值进行比较，记录下最大的<code>sum</code>。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, sum = <span class=\"number\">0</span>, max_sum = <span class=\"number\">-1</span>, former = <span class=\"number\">0</span>, latter, former_tmp = <span class=\"number\">0</span>; </span><br><span class=\"line\">  <span class=\"comment\">//former,latter记录最大子序列的首位index，</span></span><br><span class=\"line\">  <span class=\"comment\">//max_sum=-1考虑0的存在，former_tmp必须赋初值(考虑第一个数是0的情况)</span></span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    latter = n - <span class=\"number\">1</span>; <span class=\"comment\">//全为负数时输出序列的首位两个数</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">seq</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;seq[i]);</span><br><span class=\"line\">        sum += seq[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            former_tmp = i + <span class=\"number\">1</span>; <span class=\"comment\">//former_tmp定位可能的最大子序列头index</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; max_sum)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            max_sum = sum;</span><br><span class=\"line\">            former = former_tmp;</span><br><span class=\"line\">            latter = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    max_sum = (max_sum &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : max_sum);<span class=\"comment\">//考虑全为负数的情况</span></span><br><span class=\"line\">    cout &lt;&lt; max_sum &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; seq[former] &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; seq[latter];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3><span id=\"appendix无需输出最大子序列头尾版本\">Appendix（无需输出最大子序列头尾版本）</span></h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, sum = <span class=\"number\">0</span>, max_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; m;</span><br><span class=\"line\">        sum = ((sum += m) &gt; <span class=\"number\">0</span> ? sum : <span class=\"number\">0</span>);</span><br><span class=\"line\">        max_sum = (sum &gt; max_sum ? sum : max_sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; max_sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","text":"➳ENTRY $\\qquad$Given a sequence of K integers $[N_1, N_2,\\cdots, N_K]$. A continuous subsequence is defined to be $[N_i, N_{i+1},\\cdots, N_j...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"动态规划","slug":"动态规划","count":5,"path":"api/tags/动态规划.json"},{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Appendix（无需输出最大子序列头尾版本）</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1009」Product of Polynomials","uid":"0891150107830e3ac5d4a54442d1eabc","slug":"1009-Product-of-Polynomials","date":"2022-02-27T11:45:51.000Z","updated":"2022-03-03T13:31:11.255Z","comments":true,"path":"api/articles/1009-Product-of-Polynomials.json","keywords":null,"cover":null,"text":"➳ENTRY $\\qquad$This time, you are supposed to find $A\\times B$ where A and B are two polynomials. Input Specification:$\\qquad$Each input fil...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「Section 1」数据格式","uid":"b84d0f0ccbd1fa272bb501c55b437830","slug":"数据格式","date":"2022-02-24T09:03:45.000Z","updated":"2022-03-21T14:27:22.166Z","comments":true,"path":"api/articles/数据格式.json","keywords":null,"cover":[],"text":" 机器数：数值数据在计算机中的表现形式称为机器数。 表示范围受计算机字长的限制 机器数的符号位必须被数值化为0和1 机器数的小数点是用规定的隐含方式来表达的 ⚠️ 计算机硬件无法区分有符号（signed ）与无符号（unsigned ）数，只能由程序指令加以区分 小数点的表示方法 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}