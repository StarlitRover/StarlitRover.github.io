{"title":"「1014」Waiting in Line","uid":"be23bf1b6bcf5e89051d9bbdaa72f245","slug":"1014-Waiting-in-Line","date":"2022-03-15T03:27:08.000Z","updated":"2022-03-15T10:01:02.285Z","comments":true,"path":"api/articles/1014-Waiting-in-Line.json","keywords":null,"cover":null,"content":"<p>➳<a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936\">ENTRY</a></p>\n<p>$\\qquad$Suppose a bank has $N$ windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are:</p>\n<ul>\n<li>The space inside the yellow line in front of each window is enough to contain a line with $M$ customers. Hence when all the $N$ lines are full, all the customers after (and including) the $(NM+1)^{st}$ one will have to wait in a line behind the yellow line.</li>\n<li>Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number.</li>\n<li>$Customer_i$ will take $T_i$ minutes to have his&#x2F;her transaction processed.</li>\n<li>The first $N$ customers are assumed to be served at 8:00 am.</li>\n</ul>\n<span id=\"more\"></span>\n\n<p>$\\qquad$Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his&#x2F;her business done.</p>\n<p>$\\qquad$For example, suppose that a bank has 2 windows and each window may have 2 customers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, $Customer_1$ is served at $window_1$ while $Customer_2$ is served at $window_2$. $Customer_3$ will wait in front of $window_1$ and $Customer_4$ will wait in front of $window_2$. $Customer_5$ will wait behind the yellow line.</p>\n<p>$\\qquad$At 08:01, $Customer_1$ is done and $Customer_5$ enters the line in front of $window_1$ since that line seems shorter now. $Customer_2$ will leave at 08:02, $Customer_4$ at 08:06, $Customer_3$ at 08:07, and finally $Customer_5$ at 08:10.</p>\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>$\\qquad$Each input file contains one test case. Each case starts with a line containing 4 positive integers: $N$ (≤20, number of windows), $M$ (≤10, the maximum capacity of each line inside the yellow line), <em>K</em> (≤1000, number of customers), and <em>Q</em> (≤1000, number of customer queries).</p>\n<p>$\\qquad$The next line contains <em>K</em> positive integers, which are the processing time of the <em>K</em> customers.</p>\n<p>$\\qquad$The last line contains <em>Q</em> positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to <em>K</em>.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>$\\qquad$For each of the <em>Q</em> customers, print in one line the time at which his&#x2F;her transaction is finished, in the format <code>HH:MM</code> where <code>HH</code> is in [08, 17] and <code>MM</code> is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output <code>Sorry</code> instead.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 2 7 5</span><br><span class=\"line\">1 2 6 4 3 534 2</span><br><span class=\"line\">3 4 5 6 7</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:07</span><br><span class=\"line\">08:06</span><br><span class=\"line\">08:10</span><br><span class=\"line\">17:00</span><br><span class=\"line\">Sorry</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$极简翻译：银行有$n$个窗口，每个窗口前最多排$m$个人，共有$k$个顾客，每个顾客的事务处理时间都是知道的，其中$q$个顾客来查询自己的结束时间。当窗口未排满的时候，顾客会前往人数最少的窗口，若有多个人数最少的窗口则去编号最小的；当所有窗口都排满时，后面的顾客需等在黄线后直到有顾客完成离开窗口。</p>\n<br>\n\n<p>$\\qquad$很显然，本题考查的是队列<code>queue</code>，然后考虑的东西有一点多：</p>\n<ol>\n<li>前$mn$位顾客按窗口编号从小到大依次排列，不考虑处理时间</li>\n<li>$mn+1$后的顾客则看哪个窗口的第一个（⚠️不是最后一个）顾客最先完成事务就去哪个</li>\n<li>顾客数量并不一定会完全填充满窗口</li>\n<li>同一时刻如果有多个窗口空出来黄线外的第一位顾客前往编号最小的窗口</li>\n<li>若顾客<u>开始</u>处理事务的时间（⚠️不是处理完成时间）≥17:00，那么不受理该顾客的事务</li>\n</ol>\n<p>$\\qquad$因此我们需要用队列存储每个窗口排队的客户编号来获知每个时刻窗口第一个顾客是谁，另外当我们把一个顾客分配至一个窗口时该顾客的结束时间便已经确定。对于黄线外第一位顾客的窗口选择问题，我们只需要比较当前每个窗口的第一位顾客结束时间，然后分配至结束时间最早的窗口即可。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, k, q, t, c;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;</span><br><span class=\"line\">  <span class=\"comment\">//proc_time：每个顾客的事务所需时间，end_time：每个顾客的事务完成时间</span></span><br><span class=\"line\">  <span class=\"comment\">//line_time：每个窗口最后一位顾客的结束时间，fill_time：每个窗口当前第一位顾客的结束时间</span></span><br><span class=\"line\">  <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">proc_time</span><span class=\"params\">(k)</span>, <span class=\"title\">end_time</span><span class=\"params\">(k)</span>, <span class=\"title\">line_time</span><span class=\"params\">(n, <span class=\"number\">480</span>)</span>, <span class=\"title\">fill_time</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; t;</span><br><span class=\"line\">        proc_time[i] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//黄线内的实际顾客数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> inline_num = <span class=\"built_in\">min</span>(n * m, k);</span><br><span class=\"line\">  <span class=\"comment\">//每个窗口的排队队列</span></span><br><span class=\"line\">    vector&lt;queue&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">line</span>(n);</span><br><span class=\"line\">  <span class=\"comment\">//黄线内顾客的窗口分配</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; inline_num; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line[i % n].<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        end_time[i] = line_time[i % n] += proc_time[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//如果每个窗口都满了（k≥mn）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inline_num &lt; k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//初始化每个窗口第一位顾客的结束时间</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fill_time[i] += proc_time[line[i].<span class=\"built_in\">front</span>()];</span><br><span class=\"line\">            line[i].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">//分配黄线外的顾客</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = inline_num; i &lt; k; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">//求最早空出位置的窗口编号</span></span><br><span class=\"line\">            <span class=\"type\">int</span> win = <span class=\"built_in\">int</span>(<span class=\"built_in\">min_element</span>(fill_time.<span class=\"built_in\">begin</span>(), fill_time.<span class=\"built_in\">end</span>()) - fill_time.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">            end_time[i] = line_time[win] += proc_time[i];</span><br><span class=\"line\">            fill_time[win] += proc_time[line[win].<span class=\"built_in\">front</span>()];</span><br><span class=\"line\">            line[win].<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            line[win].<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; q; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; c;</span><br><span class=\"line\">      <span class=\"comment\">//考虑每个顾客开始处理的时间=结束时间-处理时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (end_time[c - <span class=\"number\">1</span>] - proc_time[c - <span class=\"number\">1</span>] &gt;= <span class=\"number\">1020</span>)</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;Sorry&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%02d:%02d\\n&quot;</span>, end_time[c - <span class=\"number\">1</span>] / <span class=\"number\">60</span>, end_time[c - <span class=\"number\">1</span>] % <span class=\"number\">60</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"︎-算法说明\">⚡︎ 算法说明</span></h2><ol>\n<li>所有时间都先按分钟计算，最后转为时间</li>\n<li>给黄线外的第一个顾客分配完窗口后，需要更新该窗口第一个顾客的结束时间</li>\n<li><code>min_element(fill_time.begin(), fill_time.end())</code>找到的是最左边最小值的迭代器，因此符合当有多个最小人数窗口时选择编号最小的要求</li>\n</ol>\n","text":"➳ENTRY $\\qquad$Suppose a bank has $N$ windows open for service. There is a yellow line in front of the windows which devides the waiting are...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"queue","slug":"queue","count":1,"path":"api/tags/queue.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚡︎ 算法说明</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1015」Reversible Primes","uid":"b75f95681a59c62b9564ea4a8f3a4ec9","slug":"1015-Reversible-Primes","date":"2022-03-15T08:02:21.000Z","updated":"2022-12-02T10:22:48.845Z","comments":true,"path":"api/articles/1015-Reversible-Primes.json","keywords":null,"cover":null,"text":"➳ENTRY $\\qquad$A reversible prime in any number system is a prime whose “reverse” in that number system is also a prime. For example in the ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"prime","slug":"prime","count":6,"path":"api/tags/prime.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「Section 5」定点运算器（&浮点加减）","uid":"d89b7bb9a5cb29131093afe1032ded19","slug":"定点运算器","date":"2022-03-14T03:08:02.000Z","updated":"2022-03-27T08:26:05.465Z","comments":true,"path":"api/articles/定点运算器.json","keywords":null,"cover":[],"text":"$\\qquad$由前几节的内容我们知道计算机中的各类算术运算都可以由最基本的定点加法与移位运算迭代实现，那么我们只要将逻辑运算、移位运算、各种算术运算的数字逻辑电路实现集成在一起就可以构成CPU中的运算器。运算器具体可以分为定点运算部件和浮点运算部件，本节主要介绍又称为算术逻辑运...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}