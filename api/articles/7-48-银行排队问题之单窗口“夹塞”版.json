{"title":"7-48 银行排队问题之单窗口“夹塞”版","uid":"b06eec1520de8e94623ad87c71416a11","slug":"7-48-银行排队问题之单窗口“夹塞”版","date":"2022-02-08T14:22:42.000Z","updated":"2022-02-10T14:27:48.086Z","comments":true,"path":"api/articles/7-48-银行排队问题之单窗口“夹塞”版.json","keywords":null,"cover":null,"content":"<p><a href=\"https://pintia.cn/problem-sets/15/problems/895\">➳ENTRY</a><br>$\\qquad$排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第i位顾客与排在后面的第j位顾客是好朋友，并且愿意替朋友办理事务的话，那么第i位顾客的事务处理时间就是自己的事务加朋友的事务所耗时间的总和。在这种情况下，顾客的等待时间就可能被影响。假设所有人到达银行时，若没有空窗口，都会请求排在最前面的朋友帮忙（包括正在窗口接受服务的朋友）；当有不止一位朋友请求某位顾客帮忙时，该顾客会根据自己朋友请求的顺序来依次处理事务。试编写程序模拟这种现象，并计算顾客的平均等待时间。</p>\n<span id=\"more\"></span>\n<h2><span id=\"输入格式\">输入格式:</span></h2><p>$\\qquad$输入的第一行是两个整数：1≤N≤10000，为顾客总数；0≤M≤100，为彼此不相交的朋友圈子个数。若M非0，则此后M行，每行先给出正整数2≤L≤100，代表该圈子里朋友的总数，随后给出该朋友圈里的L位朋友的名字。名字由3个大写英文字母组成，名字间用1个空格分隔。最后N行给出N位顾客的姓名、到达时间T和事务处理时间P（以分钟为单位），之间用1个空格分隔。简单起见，这里假设顾客信息是按照到达时间先后顺序给出的（有并列时间的按照给出顺序排队），并且假设每个事务最多占用窗口服务60分钟（如果超过则按60分钟计算）。</p>\n<h2><span id=\"输出格式\">输出格式:</span></h2><p>$\\qquad$按顾客接受服务的顺序输出顾客名字，每个名字占1行。最后一行输出所有顾客的平均等待时间，保留到小数点后1位。</p>\n<h2><span id=\"输入样例\">输入样例:</span></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6 2</span><br><span class=\"line\">3 ANN BOB JOE</span><br><span class=\"line\">2 JIM ZOE</span><br><span class=\"line\">JIM 0 20</span><br><span class=\"line\">BOB 0 15</span><br><span class=\"line\">ANN 0 30</span><br><span class=\"line\">AMY 0 2</span><br><span class=\"line\">ZOE 1 61</span><br><span class=\"line\">JOE 3 10</span><br></pre></td></tr></table></figure>\n<h2><span id=\"输出样例\">输出样例:</span></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JIM</span><br><span class=\"line\">ZOE</span><br><span class=\"line\">BOB</span><br><span class=\"line\">ANN</span><br><span class=\"line\">JOE</span><br><span class=\"line\">AMY</span><br><span class=\"line\">75.2</span><br></pre></td></tr></table></figure>\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$终于不再是一道处理字符串的题目了，这道题较前面几题都略难一些，也更有意思一点。<br>$\\qquad$初看这道题的时候没有什么特别好的思路，愣了半天，不知道这跟什么数据结构有关，那就依感觉写吧。</p>\n<p>$\\qquad$第一个问题是如何存储他们之间的朋友关系，最先想到的是无向图，建立一个关系矩阵，最大的情况是$10^4\\times 10^4$，很可能会是个稀疏矩阵，感觉这道题没有必要用图。或者只要每个顾客存一下自己所在朋友圈的编号也是可以直接判断两人是否为朋友。<br>$\\qquad$观察这道题的要求，其实每个人只会找前一个离自己最近的朋友帮忙，因此我们只要知道每个顾客后面最近的朋友位置即可。由此可以建一个client类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">client</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"type\">int</span> T, P, nxt = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//T-&gt;Arrival Time,P-&gt;Processing Time</span></span><br><span class=\"line\">    <span class=\"comment\">//nxt-&gt;number in line of next friend,-1 means no friend in line behind himself</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>$\\qquad$那么当每位顾客都办完事后都看看队伍后面有没有自己的朋友，有的话帮他也办了，以此类推。注意如果办完事朋友还没到则不能帮忙。<br>$\\qquad$整条队伍的顺序可以用一个<code>vector</code>存储。对于帮忙办完事的朋友，可以选择从队伍中删除，也可以设置一个<code>isProcessed</code>的布尔变量来标记，若已处理则<code>continue</code>。前者可能会导致循环出现问题，因此这里我选择的是后者。<br>$\\qquad$由于还需要计算平均等待时间(⚠️<strong>等待时间不包括自己事情处理的时间</strong>)，因此要设置一个time变量来记录当前的时间，<code>time</code>减去当前顾客到达时间即为其等待时间。</p>\n<p>$\\qquad$当我以为可能会有测试点超时的时候，竟然一次性全部通过了。真是很难体会到这种feeling了，且行且珍惜吧。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">client</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"type\">bool</span> isProcessed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> T, P, nxt = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">client</span>(string _name, <span class=\"type\">int</span> t, <span class=\"type\">int</span> p):</span><br><span class=\"line\">    <span class=\"built_in\">name</span>(<span class=\"built_in\">move</span>(_name)), <span class=\"built_in\">T</span>(t), <span class=\"built_in\">P</span>(p) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    map&lt;string, <span class=\"type\">int</span>&gt; circle;</span><br><span class=\"line\">    <span class=\"comment\">//pre_loc[i]表示朋友圈i此时最后一个读入的顾客在队伍中的序号</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">pre_loc</span><span class=\"params\">(m, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; k;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; k; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cin &gt;&gt; name;</span><br><span class=\"line\">            circle[name] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//对没有朋友圈的name，circle[name]会初始化为0，因此+1使有朋友圈的name不会为0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;client&gt; queue;</span><br><span class=\"line\">    <span class=\"type\">int</span> t, p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; name &gt;&gt; t &gt;&gt; p;</span><br><span class=\"line\">        queue.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">client</span>(name, t, p &gt; <span class=\"number\">60</span> ? <span class=\"number\">60</span> : p));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (circle[name])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre_loc[circle[name] - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>)</span><br><span class=\"line\">                queue[pre_loc[circle[name] - <span class=\"number\">1</span>]].nxt = i;</span><br><span class=\"line\">            pre_loc[circle[name] - <span class=\"number\">1</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> time = <span class=\"number\">0</span>, all_waiting_time = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vector&lt;string&gt; final_list;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[i].isProcessed)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//考虑窗口存在闲置的时间</span></span><br><span class=\"line\">        time = time &lt; queue[i].T ? queue[i].T : time;</span><br><span class=\"line\">        <span class=\"type\">int</span> clt = i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (clt != <span class=\"number\">-1</span> &amp;&amp; time &gt;= queue[clt].T)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            all_waiting_time += (time - queue[clt].T);</span><br><span class=\"line\">            time += queue[clt].P;</span><br><span class=\"line\">            final_list.<span class=\"built_in\">push_back</span>(queue[clt].name);</span><br><span class=\"line\">            queue[clt].isProcessed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            clt = queue[clt].nxt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;s: final_list)</span><br><span class=\"line\">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; fixed &lt;&lt; <span class=\"built_in\">setprecision</span>(<span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">1.0</span> * all_waiting_time / n &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"➳ENTRY$\\qquad$排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第i位顾客与排在后面的第j位顾客是好朋友，并且愿...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"PTA-数据结构与算法题目集","slug":"PTA-数据结构与算法题目集","count":7,"path":"api/categories/PTA-数据结构与算法题目集.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输入格式:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输出格式:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输入样例:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">输出样例:</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"7-50 畅通工程之局部最小花费问题","uid":"e48195bb952699bdcd7eaab2b29014de","slug":"7-50-畅通工程之局部最小花费问题","date":"2022-02-09T14:37:31.000Z","updated":"2022-10-14T09:58:36.134Z","comments":true,"path":"api/articles/7-50-畅通工程之局部最小花费问题.json","keywords":null,"cover":[],"text":"➳ENTRY$\\qquad$某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"PTA-数据结构与算法题目集","slug":"PTA-数据结构与算法题目集","count":7,"path":"api/categories/PTA-数据结构与算法题目集.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"},{"name":"pair","slug":"pair","count":6,"path":"api/tags/pair.json"},{"name":"并查集","slug":"并查集","count":4,"path":"api/tags/并查集.json"},{"name":"numeric","slug":"numeric","count":4,"path":"api/tags/numeric.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"7-47 打印选课学生名单","uid":"0c577028a09af77ed6d5c0870f900894","slug":"7-47-打印选课学生名单","date":"2022-02-06T14:08:04.000Z","updated":"2022-09-11T08:51:16.855Z","comments":true,"path":"api/articles/7-47-打印选课学生名单.json","keywords":null,"cover":[],"text":"➳ENTRY$\\qquad$假设全校有最多40000名学生和最多2500门课程。现给出每个学生的选课清单，要求输出每门课的选课学生名单。 输入格式:$\\qquad$输入的第一行是两个正整数：N（≤40000），为全校学生总数；K（≤2500），为总课程数。此后N行，每行包括一个学...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"PTA-数据结构与算法题目集","slug":"PTA-数据结构与算法题目集","count":7,"path":"api/categories/PTA-数据结构与算法题目集.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}