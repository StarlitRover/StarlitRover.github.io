{"title":"「1098」Insertion or Heap Sort","uid":"1055437ed759d1b58da767b6a5e1ca44","slug":"「1098」Insertion-or-Heap-Sort","date":"2022-10-27T05:01:24.000Z","updated":"2022-11-28T02:40:07.028Z","comments":true,"path":"api/articles/「1098」Insertion-or-Heap-Sort.json","keywords":null,"cover":null,"content":"<p>According to Wikipedia:</p>\n<p><strong>Insertion sort</strong> iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>\n<p><strong>Heap sort</strong> divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.</p>\n<p>Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>\n<h3><span id=\"sample-input-1\">Sample Input 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">3 1 2 8 7 5 9 4 6 0</span><br><span class=\"line\">1 2 3 7 8 5 9 4 6 0</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-1\">Sample Output 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Insertion Sort</span><br><span class=\"line\">1 2 3 5 7 8 9 4 6 0</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-input-2\">Sample Input 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">3 1 2 8 7 5 9 4 6 0</span><br><span class=\"line\">6 4 5 1 0 3 2 7 8 9</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-2\">Sample Output 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Heap Sort</span><br><span class=\"line\">5 4 3 1 0 2 6 7 8 9</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id>🐎</span></h2><p>$\\qquad$好坏啊，知道有sort函数，就专搞部分排序。给出部分排序序列，判断是插入排序还是堆排序，并输出下一步后的排序结果。每次都有插入排序的友情参演，每次都是陪衬其他排序算法，好惨。</p>\n<p>$\\qquad$判断方式、插入排序的处理和一个<strong>弥天大坑</strong>参照<a href=\"/post/%E3%80%8C1089%E3%80%8DInsert-or-Merge.html\" title=\"「1089」Insert or Merge\">「1089」Insert or Merge</a> ，第一次写堆排序，脑子跟盘古开天辟地一样。堆排序的底层数据结构是二叉树，根据根节点和子节点的大小关系可以分为大顶堆（father&gt;sons）和小顶堆（father&lt;sons）。以大顶堆为例，每次都把二叉树分为只有两层（只有父亲和最多两个儿子）的小子堆，然后从最后一个小堆开始，把小堆中最大的节点与根节点进行互换，从后往前做完后整棵二叉树的根节点就是最大的元素。然后把这个最大的元素放到最后一个位置上（与最后一个元素互换），并将二叉树的节点个数-1，即最后的位置不参与接下来的排序。最后二叉树的层次遍历结果就是升序排列。</p>\n<p>$\\qquad$⚠️在互换小堆的父子节点时，如果这个子节点是另一个小堆的父节点，那么应该递归向下调整，直到没有子节点或者无需交换为止。</p>\n<p>$\\qquad$事实上，我们可以注意到，在第一次调整完毕后，接下来的每次调整都无需从后往前依次调整，因为我们只交换了根节点与最后一个节点，而不满足大&#x2F;小顶堆的只可能是根节点，因此只需从根节点向下递归调整即可。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">heap_down</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;heap, <span class=\"type\">int</span> r, <span class=\"type\">int</span> end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> max_r = (end - <span class=\"number\">1</span>) / <span class=\"number\">2</span>, j;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &lt;= max_r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"number\">2</span> * r + <span class=\"number\">2</span> &lt;= end)</span><br><span class=\"line\">            j = (heap[<span class=\"number\">2</span> * r + <span class=\"number\">2</span>] &gt; heap[<span class=\"number\">2</span> * r + <span class=\"number\">1</span>] ? <span class=\"number\">2</span> * r + <span class=\"number\">2</span> : <span class=\"number\">2</span> * r + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">2</span> * r + <span class=\"number\">1</span> &lt;= end)</span><br><span class=\"line\">            j = <span class=\"number\">2</span> * r + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heap[j] &gt; heap[r])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(heap[j], heap[r]);</span><br><span class=\"line\">            r = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">org</span><span class=\"params\">(n)</span>, <span class=\"title\">crt</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: org)</span><br><span class=\"line\">        cin &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: crt)</span><br><span class=\"line\">        cin &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"type\">int</span> t = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t &gt;= <span class=\"number\">0</span> &amp;&amp; crt[t] == org[t]) --t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (t &lt; n &amp;&amp; crt[t] &lt;= crt[t + <span class=\"number\">1</span>]) ++t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">copy</span><span class=\"params\">(org)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(copy.<span class=\"built_in\">begin</span>(), copy.<span class=\"built_in\">begin</span>() + t + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">bool</span> isHeap = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n &amp;&amp; (copy[i] == crt[i] || (isHeap = <span class=\"literal\">true</span>, <span class=\"literal\">false</span>)); ++i);</span><br><span class=\"line\">    cout &lt;&lt; (isHeap ? <span class=\"string\">&quot;Heap&quot;</span> : <span class=\"string\">&quot;Insertion&quot;</span>) &lt;&lt; <span class=\"string\">&quot; Sort\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isHeap)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> end = n - <span class=\"number\">1</span>, max_r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = max_r; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">            <span class=\"built_in\">heap_down</span>(org, i, end);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (--end, copy != crt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            copy = org;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(org[<span class=\"number\">0</span>], org[end + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"built_in\">heap_down</span>(org, <span class=\"number\">0</span>, end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(org.<span class=\"built_in\">begin</span>(), org.<span class=\"built_in\">begin</span>() + t + <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">        cout &lt;&lt; (i == <span class=\"number\">0</span> ? <span class=\"string\">&quot;&quot;</span> : <span class=\"string\">&quot; &quot;</span>) &lt;&lt; org[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$<code>max_r</code>是拥有儿子的最大节点编号，&gt;<code>max_r</code>的节点就无需调整。</p>\n","text":"According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iterati...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"sort","slug":"sort","count":24,"path":"api/tags/sort.json"},{"name":"heap","slug":"heap","count":3,"path":"api/tags/heap.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 2:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1099」Build A Binary Search Tree","uid":"e3cd66a2f1f386d336b0cf25b87033ab","slug":"「1099」Build-A-Binary-Search-Tree","date":"2022-10-27T12:04:57.000Z","updated":"2022-10-27T12:20:48.347Z","comments":true,"path":"api/articles/「1099」Build-A-Binary-Search-Tree.json","keywords":null,"cover":[],"text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains o...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"binary search","slug":"binary-search","count":7,"path":"api/tags/binary-search.json"},{"name":"BFS","slug":"BFS","count":10,"path":"api/tags/BFS.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1097」Deduplication on a Linked List","uid":"ffc78994f12cf87b4b6e2fe952701b6e","slug":"「1097」Deduplication-on-a-Linked-List","date":"2022-10-26T15:57:17.000Z","updated":"2022-10-26T16:06:21.941Z","comments":true,"path":"api/articles/「1097」Deduplication-on-a-Linked-List.json","keywords":null,"cover":null,"text":"Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, f...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"string","slug":"string","count":18,"path":"api/tags/string.json"},{"name":"list","slug":"list","count":5,"path":"api/tags/list.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}