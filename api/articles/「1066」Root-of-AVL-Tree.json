{"title":"「1066」Root of AVL Tree","uid":"42640cc884e7d3b61d24e0f58f7990cd","slug":"「1066」Root-of-AVL-Tree","date":"2022-09-24T16:14:37.000Z","updated":"2022-10-19T10:54:11.913Z","comments":true,"path":"api/articles/「1066」Root-of-AVL-Tree.json","keywords":null,"cover":[],"content":"<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://images.ptausercontent.com/8e3c8cca-d5ab-490b-be8b-c7101ffb94a4.jpg\" alt=\"F1.jpg\"> <img src=\"https://images.ptausercontent.com/bcdb39fb-08b6-41d8-8a3d-96708e4ad97c.jpg\" alt=\"F2.jpg\"></p>\n<p><img src=\"https://images.ptausercontent.com/33\"> <img src=\"https://images.ptausercontent.com/34\"></p>\n<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, print the root of the resulting AVL tree in one line.</p>\n<h3><span id=\"sample-input-1\">Sample Input 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">88 70 61 96 120</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-1\">Sample Output 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">70</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-input-2\">Sample Input 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7</span><br><span class=\"line\">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-2\">Sample Output 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">88</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$AVL，平衡二叉搜索树，不仅拥有BST的性质，同时每个顶点左右两棵子树的高度差不超过1，从而使树的高度尽可能维持在一个较低水平，提高搜索效率。给出一组数据，输出最终AVL的根节点，注意每个元素插入后都应及时调整为AVL。</p>\n<p>$\\qquad$当初看树这一块的时候，AVL的旋转调整让我头疼不已，现在亦是如此。苦苦思索，原来这是第一次撞上AVL的题目，于是我又回去重温了一遍《数据结构与算法分析》里的相关内容。</p>\n<p>$\\qquad$每次插入一个数后我们都从该树开始向根节点回溯，找到第一个左右子树高度差&gt;1的节点X，只要将这棵子树恢复至插入前的高度即可重新满足AVL。</p>\n<p>$\\qquad$接下来我们将插入后不满足平衡性的情形分为两种（每种都包含两个镜像对称的情况）：</p>\n<ol>\n<li><p>向X节点的左（右）子节点的左（右）子树插入后不满足</p>\n<img title src=\"/images/PAT(Advanced%20level)%20Practice/1066/1.png\" alt data-align=\"center\" width=\"457\">\n</li>\n<li><p>向X节点的左（右）子节点的右（左）子树插入后不满足</p>\n<img title src=\"/images/PAT(Advanced%20level)%20Practice/1066/2.png\" alt data-align=\"center\" width=\"455\"></li>\n</ol>\n<p>$\\qquad$我们用$T_i$来表示子树$i$，$H_i$来表示子树$i$的高度，首先显然</p>\n<p>$$<br>H_1+1&#x3D;H_3+2\\Rightarrow H_1&#x3D;H_3+1<br>$$</p>\n<p>$\\qquad$那么$T_1$不可能是空树，因为$H_1≥1$。因此我们还可以将$T_1$进行拆分：</p>\n<img title src=\"/images/PAT(Advanced%20level)%20Practice/1066/3.png\" alt data-align=\"center\" width=\"369\">\n\n<p>$\\qquad$其次$H_2\\neq H_1$，否则在插入之前就已经不满足平衡性，另外由于节点X是第一个不满足平衡性的节点，因此$H_2 &#x3D;H_1-1$。</p>\n<p>$\\qquad$综上所述，$H_2&#x3D;H_3&#x3D;\\max\\{H_4,H_5\\}&#x3D;H_1-1$，且$|H_4-H_5|\\leq 1$。</p>\n<br>\n\n<p>$\\qquad$接下来，我们通过两种不同的旋转方法在不破环BST的前提下使其重新符合平衡性（序号与上述情形相对应，只考虑镜像对称中的一种情况）：</p>\n<ol>\n<li><p>拎住绿点向上提，$T_2$成为节点X的左子树</p>\n<img title src=\"/images/PAT(Advanced%20level)%20Practice/1066/4.png\" alt data-align=\"center\" width=\"450\">\n\n<p>显然满足平衡性，且BST的有序性也未被破坏</p>\n</li>\n<li><p>拎住节点R向上提成为根节点，想象每条边的端点都是有磁性的，在上提的过程中脱落自动吸附到其他节点上，绿节点和节点X成为其左右子树，而$T_4$成为绿节点的右子树，$T_5$成为X节点的左子树 </p>\n<img title src=\"/images/PAT(Advanced%20level)%20Practice/1066/5.png\" alt data-align=\"center\" width=\"450\">\n\n<p> $T_4$和$T_5$的高度关系无法确定，但注意到 $?\\in \\{0,-1,1\\}$，因此依然可以肯定是符合平衡性要求的。</p>\n</li>\n</ol>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> diff(x) height[child[x].first]-height[child[x].second]</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; child;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; height;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;node, <span class=\"type\">int</span> &amp;num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        node = num;</span><br><span class=\"line\">        height[num] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        child[num] = <span class=\"built_in\">pair</span>(<span class=\"number\">-1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (num &gt; node)</span><br><span class=\"line\">        child[node].second = <span class=\"built_in\">insert</span>(child[node].second, num);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        child[node].first = <span class=\"built_in\">insert</span>(child[node].first, num);</span><br><span class=\"line\">    height[node] = <span class=\"built_in\">max</span>(height[child[node].first], height[child[node].second]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> head = node;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(<span class=\"built_in\">diff</span>(node)) &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> isLeft = <span class=\"built_in\">diff</span>(node) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> &amp;inSon = isLeft ? child[node].second : child[node].first,</span><br><span class=\"line\">            &amp;outSon = isLeft ? child[node].first : child[node].second,</span><br><span class=\"line\">            &amp;inGson = isLeft ? child[outSon].second : child[outSon].first,</span><br><span class=\"line\">            &amp;outGson = isLeft ? child[outSon].first : child[outSon].second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"built_in\">diff</span>(node) ^ <span class=\"built_in\">diff</span>(outSon)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            height[node] = <span class=\"built_in\">max</span>(height[inSon], height[inGson]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            height[outSon] = <span class=\"built_in\">max</span>(height[node], height[outGson]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            head = outSon;</span><br><span class=\"line\">            outSon = inGson;</span><br><span class=\"line\">            inGson = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> &amp;inGGson = isLeft ? child[inGson].second : child[inGson].first,</span><br><span class=\"line\">                &amp;outGGson = isLeft ? child[inGson].first : child[inGson].second;</span><br><span class=\"line\">            height[outSon] = <span class=\"built_in\">max</span>(height[outGson], height[outGGson]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            height[node] = <span class=\"built_in\">max</span>(height[inSon], height[inGGson]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            height[inGson] = <span class=\"built_in\">max</span>(height[node], height[outSon]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            head = inGson;</span><br><span class=\"line\">            inGson = outGGson;</span><br><span class=\"line\">            outGGson = outSon;</span><br><span class=\"line\">            outSon = inGGson;</span><br><span class=\"line\">            inGGson = node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, head, m;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; head;</span><br><span class=\"line\">    child[head] = <span class=\"built_in\">pair</span>(<span class=\"number\">-1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    height[head] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; m;</span><br><span class=\"line\">        head = <span class=\"built_in\">insert</span>(head, m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"tips\">Tips</span></h3><ol>\n<li><p>用几个引用来替代内&#x2F;外侧的儿子、孙子、曾孙节点，从而无需考虑镜像对称的情况</p>\n</li>\n<li><p>用一个map来存储每个节点子树的高度，在进行旋转调整时需要对改变的节点高度进行维护</p>\n</li>\n<li><p>insert函数完成插入操作，并对回溯过程中第一个不满足平衡性的节点子树进行旋转调整，结束后返回新子树的根节点</p>\n</li>\n<li><p>注意节点关系的赋值次序，否则可能出现将赋值后的变量当作老变量使用</p>\n</li>\n</ol>\n","text":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one;...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"},{"name":"AVL","slug":"AVL","count":2,"path":"api/tags/AVL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 2:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"Lab2: system calls","uid":"1b4d009413a4a1733c93e882f288fd9a","slug":"Lab2-system-calls","date":"2022-09-25T03:57:05.000Z","updated":"2022-09-25T07:49:21.925Z","comments":true,"path":"api/articles/Lab2-system-calls.json","keywords":null,"cover":[],"text":"$\\qquad$上周打了一场数模国赛，打前元气超人，打完葛优躺平。Lab2只有两个小实验，聚焦于如何创建系统调用命令，也并不是那么简单，实验文档戳这。 ❖ Coding ☑︎ System call tracing (moderate)$\\qquad$我们需要创建一个trace系统...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":3,"path":"api/categories/操作系统.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"xv6","slug":"xv6","count":3,"path":"api/tags/xv6.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1065」A+B and C (64bit)","uid":"42e41f54cdd74aae9e65b00439b07d2c","slug":"「1065」A-B-and-C-64bit","date":"2022-09-24T03:10:52.000Z","updated":"2022-09-24T03:25:09.213Z","comments":true,"path":"api/articles/「1065」A-B-and-C-64bit.json","keywords":null,"cover":null,"text":"Given three integers A, B and C in $(−2^{63},2^{63})$, you are supposed to tell whether A+B&gt;C. Input Specification:The first line of the ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}