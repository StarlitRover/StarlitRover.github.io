{"title":"「1053」Path of Equal Weight","uid":"f1b87526b0a747be6a4f224868f65aa7","slug":"「1053」Path-of-Equal-Weight","date":"2022-09-04T04:51:05.000Z","updated":"2022-10-19T10:53:49.440Z","comments":true,"path":"api/articles/「1053」Path-of-Equal-Weight.json","keywords":null,"cover":[],"content":"<p>Given a non-empty tree with root R, and with weight Wi​ assigned to each tree node Ti​. The <strong>weight of a path from R to L</strong> is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</p>\n<p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in the following figure: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in the figure.</p>\n<p><img src=\"https://images.ptausercontent.com/212\"></p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. Each case starts with a line containing $0&lt;N≤100$, the number of nodes in a tree, $M (&lt;N)$, the number of non-leaf nodes, and $0&lt;S&lt;2^{30}$, the given weight number. The next line contains N positive numbers where $W_i​ (&lt;1000)$ corresponds to the tree node $T_i​$. Then M lines follow, each in the format:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ID K ID[1] ID[2] ... ID[K]</span><br></pre></td></tr></table></figure>\n\n<p>where <code>ID</code> is a two-digit number representing a given non-leaf node, <code>K</code> is the number of its children, followed by a sequence of two-digit <code>ID</code>‘s of its children. For the sake of simplicity, let us fix the root ID to be <code>00</code>.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, print all the paths with weight S in <strong>non-increasing</strong> order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p>\n<p>Note: sequence$\\{A_1,A_2,⋯,A_n\\}$ is said to be <strong>greater than</strong> sequence$ \\{B_1,B_2,⋯,B_m\\}$ if there exists $1≤k&lt;min\\{n,m\\}$ such that $A_i&#x3D;B_i$ for $i&#x3D;1,⋯,k$, and $A_{k+1}&gt;B_{k+1}$.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20 9 24</span><br><span class=\"line\">10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2</span><br><span class=\"line\">00 4 01 02 03 04</span><br><span class=\"line\">02 1 05</span><br><span class=\"line\">04 2 06 07</span><br><span class=\"line\">03 3 11 12 13</span><br><span class=\"line\">06 1 09</span><br><span class=\"line\">07 2 08 10</span><br><span class=\"line\">16 1 15</span><br><span class=\"line\">13 3 14 16 17</span><br><span class=\"line\">17 2 18 19</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10 5 2 7</span><br><span class=\"line\">10 4 10</span><br><span class=\"line\">10 3 3 6 2</span><br><span class=\"line\">10 3 3 6 2</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h2><span id=\"ω\">Ω</span></h2><hr>\n<p>$\\qquad$输出所有从根节点到叶子结点权重和为给定值的权重路径。</p>\n<p>$\\qquad$其实上面这个真的小儿科，不管是DFS还是BFS都三下五除二，这个输出顺序是真的麻烦，害得我重构了两次。</p>\n<p>$\\qquad$讲讲我的心路历程吧。一开始想的比较粗糙，觉得输出顺序应该和BFS是一致的，所以上来就BFS找到权重和符合要求的所有叶子结点，根据父节点进行回溯然后依次输出。然后就发现最先输出的只能说明路径上的节点数是最少的，中间节点的权重也可以较小。</p>\n<p>$\\qquad$转念一想，输出顺序的思想是每次先找权重较大的节点进行遍历，事实上与DFS是一致的，我们只需要将便利的顺序先对权重排序一遍即可。于是乎简单地重构了下代码，还是很快的，春风拂面，小手一点。唯有最后一个测试点是绿的，百思不得其解，夜深了，看了些网上的题解，豁然开朗，问题就在于对权重相同节点的便利顺序是不确定的，最典型的栗子如下图所示，由于第二层权重相等，因此可能会先往左边遍历。</p>\n<img title src=\"file:///Users/starlitrover/Desktop/MyBlog/blog/source/images/PAT(Advanced%20level)%20Practice/1053/1.png\" alt data-align=\"center\" width=\"393\">\n\n<p>$\\qquad$当然实在不行我们就先一股脑儿找到所有节点最后再一起排个序，但没什么意思。我想借助并查集的思想，将属于同一个父节点而且权重相同的子节点进行合并，即一个节点不会存在权重一样的子节点，如此一来就可以把这些<strong>同权异父同爷</strong>（这些父节点的父节点相同）的子节点放在一起sort了。</p>\n<p>$\\qquad$大致流程如下：</p>\n<ol>\n<li><p>设置一个$real$向量，用来表示节点$k$将自己所有子节点托付给<strong>同权同父</strong>的$real[k]$节点</p>\n<p>⚠️我们需要将叶节点的属性也一并托付，让DFS知道这个节点也能作为叶子节点：</p>\n<p>$$<br>\\mathbf{isLeaf}[real[k]]&#x3D;\\mathbf{isLeaf}[real[k]]\\ ||\\ \\mathbf{isLeaf}[k]<br>$$</p>\n</li>\n<li><p>每读入非叶子节点的子节点时，建立一个权重到节点编号的map映射，$map[w]&#x3D;p$表示当前节点已存在权重为$w$的子节点$p$，之后对所有权重为$w$的子节点$q$，都采取$real[q]&#x3D;p$；若不存在该权重映射则$map[w]&#x3D;q$</p>\n</li>\n<li><p>对所有节点更新父节点：$\\mathbf{dad}[node]&#x3D;\\mathrm{real}[\\mathbf{dad}[node]]$，然后将该节点压入真正父节点的孩子向量中：$\\mathbf{children[dad}[node]]$.push_back($node$)</p>\n</li>\n<li><p>对所有节点的子节点根据权重进行降序排序</p>\n</li>\n<li><p>从根节点开始DFS，最后依次回溯输出权重路径</p>\n</li>\n</ol>\n<br>\n\n<h2><span id>🐎🧬</span></h2><hr>\n<h4><span id=\"bfs\">BFS</span></h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, s, id, k, child;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">weight</span><span class=\"params\">(n)</span>, <span class=\"title\">dad</span><span class=\"params\">(n, <span class=\"number\">-1</span>)</span>, ans, nxt, crt, <span class=\"title\">sum</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;w: weight)</span><br><span class=\"line\">        cin &gt;&gt; w;</span><br><span class=\"line\">    sum[<span class=\"number\">0</span>] = weight[<span class=\"number\">0</span>];</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">children</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; id &gt;&gt; k;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; k; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cin &gt;&gt; child;</span><br><span class=\"line\">            dad[child] = id;</span><br><span class=\"line\">            children[id].<span class=\"built_in\">push_back</span>(child);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    crt = children[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!crt.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;c: crt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum[c] += sum[dad[c]] + weight[c];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum[c] == s &amp;&amp; children[c].<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(c);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum[c] &lt; s)</span><br><span class=\"line\">                nxt.<span class=\"built_in\">insert</span>(nxt.<span class=\"built_in\">end</span>(), children[c].<span class=\"built_in\">begin</span>(), children[c].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        crt = std::<span class=\"built_in\">move</span>(nxt);</span><br><span class=\"line\">        nxt = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c: ans)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        path.<span class=\"built_in\">push_back</span>(weight[c]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (dad[c] != <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c = dad[c];</span><br><span class=\"line\">            path.<span class=\"built_in\">push_back</span>(weight[c]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> item = path.<span class=\"built_in\">rbegin</span>(); item &lt; path.<span class=\"built_in\">rend</span>(); ++item)</span><br><span class=\"line\">            cout &lt;&lt; (item == path.<span class=\"built_in\">rbegin</span>() ? <span class=\"string\">&quot;&quot;</span> : <span class=\"string\">&quot; &quot;</span>) &lt;&lt; *item;</span><br><span class=\"line\">        cout &lt;&lt; endl;</span><br><span class=\"line\">        path.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h4><span id=\"dfs\">DFS</span></h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; weight, ans, sum;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; children;</span><br><span class=\"line\">vector&lt;<span class=\"type\">bool</span>&gt; isLeaf;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">int</span> papa, <span class=\"type\">int</span> &amp;s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sum[papa] == s &amp;&amp; isLeaf[papa])</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(papa);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> k: children[papa])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum[k] = weight[k] + sum[papa];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum[k] &lt;= s)</span><br><span class=\"line\">            <span class=\"built_in\">search</span>(k, s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, s, id, k, child;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dad</span><span class=\"params\">(n, <span class=\"number\">-1</span>)</span>, real</span>;</span><br><span class=\"line\">    weight.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    sum.<span class=\"built_in\">resize</span>(n, <span class=\"number\">0</span>);</span><br><span class=\"line\">    isLeaf.<span class=\"built_in\">resize</span>(n, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    real.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    <span class=\"built_in\">iota</span>(real.<span class=\"built_in\">begin</span>(), real.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;w: weight)</span><br><span class=\"line\">        cin &gt;&gt; w;</span><br><span class=\"line\">    sum[<span class=\"number\">0</span>] = weight[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; id &gt;&gt; k;</span><br><span class=\"line\">        isLeaf[id] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; idx;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; k; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            cin &gt;&gt; child;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (idx.<span class=\"built_in\">find</span>(weight[child]) == idx.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">                idx[weight[child]] = child;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                real[child] = idx[weight[child]];</span><br><span class=\"line\">                isLeaf[real[child]] = isLeaf[real[child]] || isLeaf[child];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dad[child] = real[id];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    children.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dad[i] = real[dad[i]];</span><br><span class=\"line\">        children[dad[i]].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;v: children)</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(v.<span class=\"built_in\">begin</span>(), v.<span class=\"built_in\">end</span>(), [](<span class=\"type\">int</span> &amp;a, <span class=\"type\">int</span> &amp;b) &#123; <span class=\"keyword\">return</span> weight[a] &gt; weight[b]; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">search</span>(<span class=\"number\">0</span>, s);</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c: ans)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        path.<span class=\"built_in\">push_back</span>(weight[c]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (dad[c] != <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            c = dad[c];</span><br><span class=\"line\">            path.<span class=\"built_in\">push_back</span>(weight[c]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> item = path.<span class=\"built_in\">rbegin</span>(); item &lt; path.<span class=\"built_in\">rend</span>(); ++item)</span><br><span class=\"line\">            cout &lt;&lt; (item == path.<span class=\"built_in\">rbegin</span>() ? <span class=\"string\">&quot;&quot;</span> : <span class=\"string\">&quot; &quot;</span>) &lt;&lt; *item;</span><br><span class=\"line\">        cout &lt;&lt; endl;</span><br><span class=\"line\">        path.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h3><span id=\"tips\">Tips</span></h3><hr>\n<ol>\n<li><p>给一个vector增序赋值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\">       ……</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(num)</span></span>; <span class=\"comment\">//需要先确定向量大小</span></span><br><span class=\"line\"><span class=\"built_in\">iota</span>(v.<span class=\"built_in\">begin</span>(),v.<span class=\"built_in\">end</span>(),start);</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$最终就会得到$v&#x3D;[start , start+1 , … , start+num-1]$</p>\n</li>\n<li><p>将vector v1插入到v2的最后：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v2.<span class=\"built_in\">insert</span>(v2.<span class=\"built_in\">end</span>(), v1.<span class=\"built_in\">begin</span>(), v1.<span class=\"built_in\">end</span>());</span><br></pre></td></tr></table></figure></li>\n</ol>\n","text":"Given a non-empty tree with root R, and with weight Wi​ assigned to each tree node Ti​. The weight of a path from R to L is defined to be th...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"并查集","slug":"并查集","count":4,"path":"api/tags/并查集.json"},{"name":"numeric","slug":"numeric","count":4,"path":"api/tags/numeric.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎🧬</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">BFS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">DFS</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1055」The World's Richest","uid":"a7cca520edea6b39e829c30cbac4d862","slug":"「1055」The-World-s-Richest","date":"2022-09-06T12:17:47.000Z","updated":"2022-10-17T04:10:04.772Z","comments":true,"path":"api/articles/「1055」The-World-s-Richest.json","keywords":null,"cover":null,"text":"Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supp...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"sort","slug":"sort","count":24,"path":"api/tags/sort.json"},{"name":"tuple","slug":"tuple","count":9,"path":"api/tags/tuple.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1052」Linked List Sorting","uid":"3f7468577cc2a85a47786082d8825b1f","slug":"「1052」Linked-List-Sorting","date":"2022-09-02T01:38:56.000Z","updated":"2022-09-03T14:16:28.092Z","comments":true,"path":"api/articles/「1052」Linked-List-Sorting.json","keywords":null,"cover":null,"text":"A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an in...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"list","slug":"list","count":5,"path":"api/tags/list.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}