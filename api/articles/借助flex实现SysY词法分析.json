{"title":"借助Flex实现SysY词法分析","uid":"bba1ccc43c803be00dfdf449eaee8924","slug":"借助flex实现SysY词法分析","date":"2022-03-22T10:49:25.000Z","updated":"2022-06-10T11:59:42.342Z","comments":true,"path":"api/articles/借助flex实现SysY词法分析.json","keywords":null,"cover":[],"content":"<p>$\\qquad$词法分析（<strong>lexical analysis</strong>）是编译器的第一阶段，主要是将代码的字符序列转换为<strong>token</strong>的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说<code>int asd=897;</code>，其词法分析的结果即为</p>\n<ul>\n<li><p><code>int</code>    ：&lt; TYPE , ‘int’ &gt;</p>\n</li>\n<li><p><code>asd</code>    ：&lt; ID , ‘ast’ &gt;</p>\n</li>\n<li><p><code>=</code>        ：&lt; OPERATOR , ‘&#x3D;’ &gt;</p>\n</li>\n<li><p><code>897</code>    ：&lt; DEC_CONST , 897 &gt;</p>\n</li>\n<li><p><code>;</code>        ：&lt; SEMICN , ‘;’ &gt;</p>\n<span id=\"more\"></span></li>\n</ul>\n<p>$\\qquad$token的一般形式为&lt;type , literal&gt;，其中type为该词所属类型，literal则为其表值。词法分析的理论部分主要是自动机的构造以及转换，并不是太难，这里不做赘述。本篇文章主要讲述如何借助<strong>Flex</strong>工具来生成<strong>SysY语言</strong>（C语言的一个子集，具体语言定义<a href=\"/files/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf\">见这</a>）的词法分析。</p>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$\\qquad$Flex的前身是Lex。Lex是1975年由Mike Lesk和当时还在AT&amp;T做暑期实习的Eric Schmidt，共同完成的一款基 于Unix环境的词法分析程序生成工具。虽然Lex很出名并被广泛 使用，但它的低效和诸多问题也使其颇受诟病。后 来伯克利实验室的Vern Paxson使用C语言 重写Lex，并将这个新的程序命名为Flex(意为Fast Lexical Analyzer Generator)。无论在效率上还是在稳定性上，Flex都远远好于它的前辈Lex。我们在Linux下使用的是Flex在GNU License下的版本，称作GNU Flex。</p></blockquote>\n<p>$\\qquad$Flex是一个帮助生成词法分析代码的工具，你只需告诉它目标语言中各个词法的正则表达式，Flex就会帮你生成一个lex.yy.c的C代码文件。那么首先你需要提交给Flex一个<code>.l</code>文件来告诉它词法规则，该文件的格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%option xxx</span><br><span class=\"line\">%&#123;</span><br><span class=\"line\">    Declarations</span><br><span class=\"line\">%&#125;</span><br><span class=\"line\">    Definitions</span><br><span class=\"line\">%%</span><br><span class=\"line\">    Rules</span><br><span class=\"line\">%%</span><br><span class=\"line\">    User Subroutines</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$第一行的option是来开启Flex自带的一些辅助功能。比如说Flex提供行号记录变量<code>yylineno</code>，我们可以直接通过该变量读取当前行号而且无需维护，但在默认状态下该变量不开放给用户，如需使用就要在开头加入<code>%option yylineno</code>。</p>\n<p>$\\qquad$第二部分<strong>%{…%}<strong>中的</strong>Declarations</strong>呢，是会直接加入生成代码的靠前部分，一般是引用头文件或者是定义初始变量。</p>\n<p>$\\qquad$第三部分<strong>%}…%%</strong>中的<strong>Definitions</strong>则是定义段，这里一般会为比较长的正则表达式命名以方便下一模块的描述，类似于C语言中的宏定义。正则表达式具体的语法可以参考<a href=\"https://zhuanlan.zhihu.com/p/120819122\">Flex 核心规范</a>。</p>\n<p>$\\qquad$第四部分<strong>%%…%%</strong>的<strong>Rules</strong>则是该文件的核心部分——规则段。规则段就是定义需要被识别出来的词法类型（可以用第三部分中的定义来组合），以及识别到该类型时需要进行的操作。每一次Flex都会使用尽可能长的字符串进行匹配，即选择最长字符串可以匹配到的类型。但当同一个长度的字符串匹配了多个类型时，默认选择第一个匹配到的类型，因此Rules的排列也有讲究。</p>\n<p>$\\qquad$第五部分<strong>User Subroutines</strong>则是用户自己的代码，会直接复制到生成代码的最后。前面词法识别规则会直接被Flex翻译为一个<code>yylex()</code>函数，该函数即为匹配词法类型的函数。那么如果用户需要做一些错误处理（比如识别到该语言中不存在的字符）以及部分类型识别到后需要单独处理时，就可以将处理代码写在这。</p>\n<p>$\\qquad$另外，Flex还提供了两个全局变量 <code>yytext</code> 和 <code>yyleng</code>，分别表示刚刚匹配到类型的字符串与该字符串的长度。</p>\n<hr>\n<h2><span id=\"sysyl\">❦ SysY.l</span></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%option yylineno</span><br><span class=\"line\"></span><br><span class=\"line\">%&#123;</span><br><span class=\"line\">    #include &quot;translator.h&quot;</span><br><span class=\"line\">%&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TYPE                int|void</span><br><span class=\"line\">KEYWORD             if|else|while|break|continue|return</span><br><span class=\"line\">OPERATOR            &quot;+&quot;|&quot;-&quot;|&quot;!&quot;|&quot;*&quot;|&quot;%&quot;|&quot;/&quot;|&quot;=&quot;</span><br><span class=\"line\">COMPARISON          &quot;==&quot;|&quot;!=&quot;|&quot;&gt;&quot;|&quot;&lt;&quot;|&quot;&gt;=&quot;|&quot;&lt;=&quot;</span><br><span class=\"line\">NONZERO             [1-9]</span><br><span class=\"line\">DIGIT               [0-9]</span><br><span class=\"line\">LETTER              [A-Za-z]</span><br><span class=\"line\">OCTAL_DIGIT         [0-7]</span><br><span class=\"line\">OCTAL_CONST         0&#123;OCTAL_DIGIT&#125;*</span><br><span class=\"line\">ILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z](&#123;LETTER&#125;|&#123;DIGIT&#125;)*</span><br><span class=\"line\">HEX_PREFIX          0x|0X</span><br><span class=\"line\">HEX_DIGIT           [0-9a-fA-F]</span><br><span class=\"line\">HEX_CONST           &#123;HEX_PREFIX&#125;&#123;HEX_DIGIT&#125;+</span><br><span class=\"line\">ILLEGAL_HEX_CONST   &#123;HEX_PREFIX&#125;(&#123;LETTER&#125;|&#123;DIGIT&#125;)*</span><br><span class=\"line\">NONDIGIT            &#123;LETTER&#125;|&quot;_&quot;</span><br><span class=\"line\">ID                  &#123;NONDIGIT&#125;(&#123;DIGIT&#125;|&#123;NONDIGIT&#125;)*</span><br><span class=\"line\">DEC_CONST           &#123;NONZERO&#125;&#123;DIGIT&#125;*  </span><br><span class=\"line\">COMMENT1            &quot;/*&quot;[^*]*&quot;*&quot;+([^*/][^*]*&quot;*&quot;+)*&quot;/&quot;</span><br><span class=\"line\">COMMENT2            &quot;//&quot;.*                                                                                </span><br><span class=\"line\"></span><br><span class=\"line\">%%</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;TYPE&#125;                  &#123; printf(&quot;\\033[1;32mTYPE\\033[0m\\t\\t%s\\n&quot;,yytext);return TYPE; &#125;</span><br><span class=\"line\">&#123;OCTAL_CONST&#125;           &#123; printf(&quot;\\033[1;32mOCTAL_CONST\\033[0m\\t&quot;);return OCTAL_CONST; &#125;</span><br><span class=\"line\">&#123;ILLEGAL_OCTAL_CONST&#125;   &#123; return ILLEGAL_OCTAL_CONST; &#125;</span><br><span class=\"line\">&#123;HEX_CONST&#125;             &#123; printf(&quot;\\033[1;32mHEX_CONST\\033[0m\\t&quot;);return HEX_CONST; &#125;</span><br><span class=\"line\">&#123;ILLEGAL_HEX_CONST&#125;     &#123; return ILLEGAL_HEX_CONST; &#125;</span><br><span class=\"line\">&#123;DEC_CONST&#125;             &#123; printf(&quot;\\033[1;32mDEC_CONST\\033[0m\\t%s\\n&quot;,yytext);return DEC_CONST; &#125;</span><br><span class=\"line\">&#123;KEYWORD&#125;               &#123; printf(&quot;\\033[1;32mKEYWORD\\033[0m\\t\\t%s\\n&quot;,yytext);return KEYWORD; &#125;</span><br><span class=\"line\">&#123;ID&#125;                    &#123; printf(&quot;\\033[1;32mID\\033[0m\\t\\t%s\\n&quot;,yytext);return ID; &#125;</span><br><span class=\"line\">&#123;OPERATOR&#125;              &#123; printf(&quot;\\033[1;32mOPERATOR\\033[0m\\t%s\\n&quot;,yytext);return OPERATOR; &#125;</span><br><span class=\"line\">&#123;COMPARISON&#125;            &#123; printf(&quot;\\033[1;32mCOMPARISON\\033[0m\\t%s\\n&quot;,yytext);return COMPARISON; &#125;</span><br><span class=\"line\">&quot;(&quot;                     &#123; printf(&quot;\\033[1;32mLPARENT\\033[0m\\t\\t%s\\n&quot;,yytext);return LPARENT; &#125;</span><br><span class=\"line\">&quot;)&quot;                     &#123; printf(&quot;\\033[1;32mRPARENT\\033[0m\\t\\t%s\\n&quot;,yytext);return RPARENT; &#125;</span><br><span class=\"line\">&quot;[&quot;                     &#123; printf(&quot;\\033[1;32mLBRACKET\\033[0m\\t%s\\n&quot;,yytext);return LBRACKET; &#125;</span><br><span class=\"line\">&quot;]&quot;                     &#123; printf(&quot;\\033[1;32mRBRACKET\\033[0m\\t%s\\n&quot;,yytext);return RBRACKET; &#125;</span><br><span class=\"line\">&quot;&#123;&quot;                     &#123; printf(&quot;\\033[1;32mLBRACE\\033[0m\\t\\t%s\\n&quot;,yytext);return LBRACE; &#125;</span><br><span class=\"line\">&quot;&#125;&quot;                     &#123; printf(&quot;\\033[1;32mRBRACE\\033[0m\\t\\t%s\\n&quot;,yytext);return RBRACE; &#125;</span><br><span class=\"line\">&quot;;&quot;                     &#123; printf(&quot;\\033[1;32mSEMICN\\033[0m\\t\\t%s\\n&quot;,yytext);return SEMICN; &#125;</span><br><span class=\"line\">&quot;,&quot;                     &#123; printf(&quot;\\033[1;32mCOMMA\\033[0m\\t\\t%s\\n&quot;,yytext);return COMMA; &#125;</span><br><span class=\"line\">&quot;&amp;&amp;&quot;                    &#123; printf(&quot;\\033[1;32mAND\\033[0m\\t\\t%s\\n&quot;,yytext);return AND; &#125;</span><br><span class=\"line\">&quot;||&quot;                    &#123; printf(&quot;\\033[1;32mOR\\033[0m\\t\\t%s\\n&quot;,yytext);return OR; &#125;</span><br><span class=\"line\">&#123;COMMENT1&#125;|&#123;COMMENT2&#125;   &#123; &#125;</span><br><span class=\"line\">[ \\t\\n]                 &#123; &#125;</span><br><span class=\"line\">.                       &#123; return UNEXPECTED; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">%%</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int token_type;</span><br><span class=\"line\">    while (token_type = yylex())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (token_type == UNEXPECTED)</span><br><span class=\"line\">            printf(&quot;\\033[1;31mError type A at Line %d: Invalid character \\&quot;%s\\&quot;\\033[0m\\n&quot;, yylineno, yytext);</span><br><span class=\"line\">        else if (token_type == OCTAL_CONST)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int sum = 0;</span><br><span class=\"line\">            for (int i = 1; i &lt; yyleng; ++i)</span><br><span class=\"line\">                sum = sum * 8 + (yytext[i] - &#x27;0&#x27;);</span><br><span class=\"line\">            printf(&quot;%d\\n&quot;, sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (token_type == HEX_CONST)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int sum = 0;</span><br><span class=\"line\">            for (int i = 2; i &lt; yyleng; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (yytext[i] &lt;= &#x27;9&#x27; &amp;&amp; yytext[i] &gt;= &#x27;0&#x27;)</span><br><span class=\"line\">                    sum = sum * 16 + (yytext[i] - &#x27;0&#x27;);</span><br><span class=\"line\">                else</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    switch (yytext[i])</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                    case &#x27;a&#x27;:</span><br><span class=\"line\">                    case &#x27;A&#x27;:</span><br><span class=\"line\">                        sum = sum * 16 + 10;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case &#x27;b&#x27;:</span><br><span class=\"line\">                    case &#x27;B&#x27;:</span><br><span class=\"line\">                        sum = sum * 16 + 11;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case &#x27;c&#x27;:</span><br><span class=\"line\">                    case &#x27;C&#x27;:</span><br><span class=\"line\">                        sum = sum * 16 + 12;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case &#x27;d&#x27;:</span><br><span class=\"line\">                    case &#x27;D&#x27;:</span><br><span class=\"line\">                        sum = sum * 16 + 13;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case &#x27;e&#x27;:</span><br><span class=\"line\">                    case &#x27;E&#x27;:</span><br><span class=\"line\">                        sum = sum * 16 + 14;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case &#x27;f&#x27;:</span><br><span class=\"line\">                    case &#x27;F&#x27;:</span><br><span class=\"line\">                        sum = sum * 16 + 15;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            printf(&quot;%d\\n&quot;, sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (token_type == ILLEGAL_OCTAL_CONST)</span><br><span class=\"line\">            printf(&quot;\\033[1;31mError type B at line %d: Illegal octal number \\&#x27;%s\\&#x27;\\033[0m\\n&quot;, yylineno, yytext);</span><br><span class=\"line\">        else if (token_type == ILLEGAL_HEX_CONST)</span><br><span class=\"line\">            printf(&quot;\\033[1;31mError type B at line %d: Illegal hex number \\&#x27;%s\\&#x27;\\033[0m\\n&quot;, yylineno, yytext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"︎-一些说明\">☕︎ 一些说明</span></h2><ol>\n<li>“translator.h”头文件内对需要识别的词法类型（<strong>TYPE</strong>，<strong>OCTAL_CONST</strong>，…）进行了enum枚举，本质上就是整数</li>\n<li>第四部分中引用第三部分定义的名字时需要注意在引用名字外面加上<big>{大括号}</big>，否则会变成识别一段字符串</li>\n<li><code>printf</code>中的【\\033[1;32m…\\033[0m】是将中间文字上色🎨</li>\n<li>正则表达式中对于注释的识别是一个比较棘手的问题。<ul>\n<li>对于单行注释，我们知道开头是“&#x2F;&#x2F;”，后面需要将该行剩余所有字符都匹配掉，注意到点可以匹配非换行符的任意字符（<code>.==[^\\n]</code>），那么点的Kleene闭包<code>.*</code>即可匹配该行剩余所有字符了</li>\n<li>对于多行注释，我们知道开头是“&#x2F;*”，中间部分只要不出现“*&#x2F;”即可。那么我们可以考虑将中间部分（包括结尾“*&#x2F;”中的“*”）分为多段以“**···*”（$|*|\\geq1$）结尾的字符串，每一段的结尾前面都不能出现“*”。那么每一小段都可以先写为<code>[^*]*&quot;*&quot;+</code>（⚠️“*”仅表示字符，*表示前面部分的Kleene闭包）。但是每一段连起来的时候不能出现“*&#x2F;”，因此每一小段的开头都不能是“&#x2F;”，这时则可以写为<code>[^/*][^*]*&quot;*&quot;+</code>。然而第一小段以“&#x2F;”开头却是没关系的（<code>/*/</code>不是一个完整的注释），因此第一小段单独写为<code>[^*]*&quot;*&quot;+</code>。最终多行注释的正则表达式即为<code>&quot;/*&quot;[^*]*&quot;*&quot;+([^/*][^*]*&quot;*&quot;+)*&quot;/&quot;</code>。</li>\n</ul>\n</li>\n<li>第五部分主要实现了八进制与十六进制的转换，以及一些错误处理，包括识别非法八进制、十六进制字符和非法字符的报错</li>\n<li>八进制与十六进制的非法字符识别是另外定义了两个类型<strong>ILLEGAL_OCTAL_CONST</strong>与<strong>ILLEGAL_HEX_CONST</strong>，分别置于第四部分中<strong>OCTAL_CONST</strong>和<strong>HEX_CONST</strong>的后面。这样一来如果更长的字符串匹配到了<strong>ILLEGAL</strong>类型就会返回<strong>ILLEGAL</strong>，而正确的格式只会匹配前者。</li>\n<li><code>yylex()</code>函数每次匹配一段字符串，若匹配成功则执行该类型后面的操作，操作中如无<code>return</code>语句则继续识别，如有<code>return</code>语句则返回<code>main</code>函数</li>\n</ol>\n<hr>\n<h3><span id=\"testc\">Test.c</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int abc = 0123, bb = 0x12d23p, c = 0987, di = 0x45Fc1;</span><br><span class=\"line\">    if (abc &gt;= bb) // hello</span><br><span class=\"line\">        while (di == 1)</span><br><span class=\"line\">            return 8;</span><br><span class=\"line\">    /*This is a test</span><br><span class=\"line\">      This is a test</span><br><span class=\"line\">    */</span><br><span class=\"line\">    $</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"cast-magic\">Cast Magic 🪄</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flex SysY.l                    </span><br><span class=\"line\">clang lex.yy.c -ly -ll</span><br><span class=\"line\">cat test.c|./a.out</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"output\">Output</span></h3><img src=\"/images/编译原理/1.png\" style=\"zoom:55%;\">\n\n<br>\n\n<hr>\n<h2><span id=\"一个小坑\">∂ 一个小坑</span></h2><p>$\\qquad$第四部分中我一开始将<code>&#123;KEYWORD&#125;</code>放在<code>&#123;ID&#125;</code>的后面，执行Flex的时候一直报错</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SysY.l:36: warning, rule cannot be matched</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$很迷，当时改来改去这个warning就一直跟着<code>&#123;KEYWORD&#125;</code>跑，只有行号在变化。</p>\n<p>$\\qquad$这条warning的意思应该是无法匹配<code>&#123;KEYWORD&#125;</code>这条规则。</p>\n<p>$\\qquad$仔细想想，<code>&#123;KEYWORD&#125;</code>匹配的都是关键字，那么为什么关键字会成为关键字呢？因为在一开始的时候就被<code>&#123;KEYWORD&#125;</code>匹配到了，从而用户不能用关键字来定义变量名。这时候一看<code>&#123;ID&#125;</code>果然放在<code>&#123;KEYWORD&#125;</code>前面，显然<code>&#123;KEYWORD&#125;</code>是<code>&#123;ID&#125;</code>的一个子集，因此<code>&#123;ID&#125;</code>匹配完后<code>&#123;KEYWORD&#125;</code>就是光杆司令一个了。</p>\n","text":"$\\qquad$词法分析（lexical analysis）是编译器的第一阶段，主要是将代码的字符序列转换为token的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说int asd=897;，其词法分析的结果即为 int ：&lt; TY...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">❦ SysY.l</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">☕︎ 一些说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Test.c</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Cast Magic 🪄</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">∂ 一个小坑</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「Section 7」寻址方式","uid":"d8805cb4c52676259ff97b6383bdfab8","slug":"寻址方式","date":"2022-03-23T01:04:09.000Z","updated":"2022-03-29T12:58:20.381Z","comments":true,"path":"api/articles/寻址方式.json","keywords":null,"cover":[],"text":" 寻址方式：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法 指令寻址：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址 顺序寻址：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址 跳跃寻址：当前指令将目标指令的地址置入PC中从而实...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"Build Qt in arm64","uid":"fbbac3b5688cf257c824005fed6d10e6","slug":"Build-Qt-in-arm64","date":"2022-03-19T02:32:08.000Z","updated":"2022-09-26T17:02:27.338Z","comments":true,"path":"api/articles/Build-Qt-in-arm64.json","keywords":null,"cover":[],"text":"♿︎ 引言$\\qquad$自从电脑换成Mac后就需要面对芯片架构不同带来的众多问题，市场上还是有很多软件只适配x86而不支持arm。当然这段时间我体验下来，arm架构采用的是精简指令集，在续航方面全面吊打x86，一般来说不插电工作一天绰绰有余。当然缺点也很明显，就是软件市场依然不是...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"血泪史","slug":"血泪史","count":2,"path":"api/categories/血泪史.json"}],"tags":[{"name":"arm64","slug":"arm64","count":1,"path":"api/tags/arm64.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}