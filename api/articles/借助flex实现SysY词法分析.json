{"title":"借助Flex实现SysY词法分析","uid":"bba1ccc43c803be00dfdf449eaee8924","slug":"借助flex实现SysY词法分析","date":"2022-03-22T10:49:25.000Z","updated":"2022-06-10T11:59:42.342Z","comments":true,"path":"api/articles/借助flex实现SysY词法分析.json","keywords":null,"cover":[],"content":"<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>词法分析（<strong>lexical analysis</strong>）是编译器的第一阶段，主要是将代码的字符序列转换为<strong>token</strong>的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说<code>int asd=897;</code>，其词法分析的结果即为</p>\n<ul>\n<li><p><code>int</code>    ：&lt; TYPE , ‘int’ &gt;</p>\n</li>\n<li><p><code>asd</code>    ：&lt; ID , ‘ast’ &gt;</p>\n</li>\n<li><p><code>=</code>        ：&lt; OPERATOR , ‘=’ &gt;</p>\n</li>\n<li><p><code>897</code>    ：&lt; DEC_CONST , 897 &gt;</p>\n</li>\n<li><p><code>;</code>        ：&lt; SEMICN , ‘;’ &gt;</p>\n<span id=\"more\"></span></li>\n</ul>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>token的一般形式为&lt;type , literal&gt;，其中type为该词所属类型，literal则为其表值。词法分析的理论部分主要是自动机的构造以及转换，并不是太难，这里不做赘述。本篇文章主要讲述如何借助<strong>Flex</strong>工具来生成<strong>SysY语言</strong>（C语言的一个子集，具体语言定义<a href=\"/files/SysY%E8%AF%AD%E8%A8%80%E5%AE%9A%E4%B9%89.pdf\">见这</a>）的词法分析。</p>\n<hr>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>Flex的前身是Lex。Lex是1975年由Mike Lesk和当时还在AT&amp;T做暑期实习的Eric Schmidt，共同完成的一款基 于Unix环境的词法分析程序生成工具。虽然Lex很出名并被广泛 使用，但它的低效和诸多问题也使其颇受诟病。后 来伯克利实验室的Vern Paxson使用C语言 重写Lex，并将这个新的程序命名为Flex(意为Fast Lexical Analyzer Generator)。无论在效率上还是在稳定性上，Flex都远远好于它的前辈Lex。我们在Linux下使用的是Flex在GNU License下的版本，称作GNU Flex。</p></blockquote>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>Flex是一个帮助生成词法分析代码的工具，你只需告诉它目标语言中各个词法的正则表达式，Flex就会帮你生成一个lex.yy.c的C代码文件。那么首先你需要提交给Flex一个<code>.l</code>文件来告诉它词法规则，该文件的格式如下：</p>\n<pre class=\"line-numbers language-flex\" data-language=\"flex\"><code class=\"language-flex\">%option xxx\n%{\n    Declarations\n%}\n    Definitions\n%%\n    Rules\n%%\n    User Subroutines<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>第一行的option是来开启Flex自带的一些辅助功能。比如说Flex提供行号记录变量<code>yylineno</code>，我们可以直接通过该变量读取当前行号而且无需维护，但在默认状态下该变量不开放给用户，如需使用就要在开头加入<code>%option yylineno</code>。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>第二部分<strong>%{…%}<strong>中的</strong>Declarations</strong>呢，是会直接加入生成代码的靠前部分，一般是引用头文件或者是定义初始变量。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>第三部分<strong>%}…%%</strong>中的<strong>Definitions</strong>则是定义段，这里一般会为比较长的正则表达式命名以方便下一模块的描述，类似于C语言中的宏定义。正则表达式具体的语法可以参考<a href=\"https://zhuanlan.zhihu.com/p/120819122\">Flex 核心规范</a>。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>第四部分<strong>%%…%%</strong>的<strong>Rules</strong>则是该文件的核心部分——规则段。规则段就是定义需要被识别出来的词法类型（可以用第三部分中的定义来组合），以及识别到该类型时需要进行的操作。每一次Flex都会使用尽可能长的字符串进行匹配，即选择最长字符串可以匹配到的类型。但当同一个长度的字符串匹配了多个类型时，默认选择第一个匹配到的类型，因此Rules的排列也有讲究。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>第五部分<strong>User Subroutines</strong>则是用户自己的代码，会直接复制到生成代码的最后。前面词法识别规则会直接被Flex翻译为一个<code>yylex()</code>函数，该函数即为匹配词法类型的函数。那么如果用户需要做一些错误处理（比如识别到该语言中不存在的字符）以及部分类型识别到后需要单独处理时，就可以将处理代码写在这。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>另外，Flex还提供了两个全局变量 <code>yytext</code> 和 <code>yyleng</code>，分别表示刚刚匹配到类型的字符串与该字符串的长度。</p>\n<hr>\n<h2><span id=\"sysyl\">❦ SysY.l</span></h2><pre class=\"line-numbers language-flex\" data-language=\"flex\"><code class=\"language-flex\">%option yylineno\n\n%{\n    #include \"translator.h\"\n%}\n\nTYPE                int|void\nKEYWORD             if|else|while|break|continue|return\nOPERATOR            \"+\"|\"-\"|\"!\"|\"*\"|\"%\"|\"/\"|\"=\"\nCOMPARISON          \"==\"|\"!=\"|\"&gt;\"|\"&lt;\"|\"&gt;=\"|\"&lt;=\"\nNONZERO             [1-9]\nDIGIT               [0-9]\nLETTER              [A-Za-z]\nOCTAL_DIGIT         [0-7]\nOCTAL_CONST         0{OCTAL_DIGIT}*\nILLEGAL_OCTAL_CONST 0[0-9a-wy-zA-WY-Z]({LETTER}|{DIGIT})*\nHEX_PREFIX          0x|0X\nHEX_DIGIT           [0-9a-fA-F]\nHEX_CONST           {HEX_PREFIX}{HEX_DIGIT}+\nILLEGAL_HEX_CONST   {HEX_PREFIX}({LETTER}|{DIGIT})*\nNONDIGIT            {LETTER}|\"_\"\nID                  {NONDIGIT}({DIGIT}|{NONDIGIT})*\nDEC_CONST           {NONZERO}{DIGIT}*  \nCOMMENT1            \"/*\"[^*]*\"*\"+([^*/][^*]*\"*\"+)*\"/\"\nCOMMENT2            \"//\".*                                                                                \n\n%%\n\n{TYPE}                  { printf(\"\\033[1;32mTYPE\\033[0m\\t\\t%s\\n\",yytext);return TYPE; }\n{OCTAL_CONST}           { printf(\"\\033[1;32mOCTAL_CONST\\033[0m\\t\");return OCTAL_CONST; }\n{ILLEGAL_OCTAL_CONST}   { return ILLEGAL_OCTAL_CONST; }\n{HEX_CONST}             { printf(\"\\033[1;32mHEX_CONST\\033[0m\\t\");return HEX_CONST; }\n{ILLEGAL_HEX_CONST}     { return ILLEGAL_HEX_CONST; }\n{DEC_CONST}             { printf(\"\\033[1;32mDEC_CONST\\033[0m\\t%s\\n\",yytext);return DEC_CONST; }\n{KEYWORD}               { printf(\"\\033[1;32mKEYWORD\\033[0m\\t\\t%s\\n\",yytext);return KEYWORD; }\n{ID}                    { printf(\"\\033[1;32mID\\033[0m\\t\\t%s\\n\",yytext);return ID; }\n{OPERATOR}              { printf(\"\\033[1;32mOPERATOR\\033[0m\\t%s\\n\",yytext);return OPERATOR; }\n{COMPARISON}            { printf(\"\\033[1;32mCOMPARISON\\033[0m\\t%s\\n\",yytext);return COMPARISON; }\n\"(\"                     { printf(\"\\033[1;32mLPARENT\\033[0m\\t\\t%s\\n\",yytext);return LPARENT; }\n\")\"                     { printf(\"\\033[1;32mRPARENT\\033[0m\\t\\t%s\\n\",yytext);return RPARENT; }\n\"[\"                     { printf(\"\\033[1;32mLBRACKET\\033[0m\\t%s\\n\",yytext);return LBRACKET; }\n\"]\"                     { printf(\"\\033[1;32mRBRACKET\\033[0m\\t%s\\n\",yytext);return RBRACKET; }\n\"{\"                     { printf(\"\\033[1;32mLBRACE\\033[0m\\t\\t%s\\n\",yytext);return LBRACE; }\n\"}\"                     { printf(\"\\033[1;32mRBRACE\\033[0m\\t\\t%s\\n\",yytext);return RBRACE; }\n\";\"                     { printf(\"\\033[1;32mSEMICN\\033[0m\\t\\t%s\\n\",yytext);return SEMICN; }\n\",\"                     { printf(\"\\033[1;32mCOMMA\\033[0m\\t\\t%s\\n\",yytext);return COMMA; }\n\"&amp;&amp;\"                    { printf(\"\\033[1;32mAND\\033[0m\\t\\t%s\\n\",yytext);return AND; }\n\"||\"                    { printf(\"\\033[1;32mOR\\033[0m\\t\\t%s\\n\",yytext);return OR; }\n{COMMENT1}|{COMMENT2}   { }\n[ \\t\\n]                 { }\n.                       { return UNEXPECTED; }\n\n%%\n\nint main()\n{\n    int token_type;\n    while (token_type = yylex())\n    {\n        if (token_type == UNEXPECTED)\n            printf(\"\\033[1;31mError type A at Line %d: Invalid character \\\"%s\\\"\\033[0m\\n\", yylineno, yytext);\n        else if (token_type == OCTAL_CONST)\n        {\n            int sum = 0;\n            for (int i = 1; i &lt; yyleng; ++i)\n                sum = sum * 8 + (yytext[i] - '0');\n            printf(\"%d\\n\", sum);\n        }\n        else if (token_type == HEX_CONST)\n        {\n            int sum = 0;\n            for (int i = 2; i &lt; yyleng; ++i)\n            {\n                if (yytext[i] &lt;= '9' &amp;&amp; yytext[i] &gt;= '0')\n                    sum = sum * 16 + (yytext[i] - '0');\n                else\n                {\n                    switch (yytext[i])\n                    {\n                    case 'a':\n                    case 'A':\n                        sum = sum * 16 + 10;\n                        break;\n                    case 'b':\n                    case 'B':\n                        sum = sum * 16 + 11;\n                        break;\n                    case 'c':\n                    case 'C':\n                        sum = sum * 16 + 12;\n                        break;\n                    case 'd':\n                    case 'D':\n                        sum = sum * 16 + 13;\n                        break;\n                    case 'e':\n                    case 'E':\n                        sum = sum * 16 + 14;\n                        break;\n                    case 'f':\n                    case 'F':\n                        sum = sum * 16 + 15;\n                        break;\n                    }\n                }\n            }\n            printf(\"%d\\n\", sum);\n        }\n        else if (token_type == ILLEGAL_OCTAL_CONST)\n            printf(\"\\033[1;31mError type B at line %d: Illegal octal number \\'%s\\'\\033[0m\\n\", yylineno, yytext);\n        else if (token_type == ILLEGAL_HEX_CONST)\n            printf(\"\\033[1;31mError type B at line %d: Illegal hex number \\'%s\\'\\033[0m\\n\", yylineno, yytext);\n    }\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2><span id=\"︎-一些说明\">☕︎ 一些说明</span></h2><ol>\n<li>“translator.h”头文件内对需要识别的词法类型（<strong>TYPE</strong>，<strong>OCTAL_CONST</strong>，…）进行了enum枚举，本质上就是整数</li>\n<li>第四部分中引用第三部分定义的名字时需要注意在引用名字外面加上<big>{大括号}</big>，否则会变成识别一段字符串</li>\n<li><code>printf</code>中的【\\033[1;32m…\\033[0m】是将中间文字上色🎨</li>\n<li>正则表达式中对于注释的识别是一个比较棘手的问题。<ul>\n<li>对于单行注释，我们知道开头是“//”，后面需要将该行剩余所有字符都匹配掉，注意到点可以匹配非换行符的任意字符（<code>.==[^\\n]</code>），那么点的Kleene闭包<code>.*</code>即可匹配该行剩余所有字符了</li>\n<li>对于多行注释，我们知道开头是“/*”，中间部分只要不出现“*/”即可。那么我们可以考虑将中间部分（包括结尾“*/”中的“*”）分为多段以“**···*”（<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.564ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.543ex\" height=\"2.26ex\" role=\"img\" focusable=\"false\" viewbox=\"0 -749.5 3334 999\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7C\" d=\"M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(500.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(1222.4,0) translate(0 -0.5)\"><path data-c=\"7C\" d=\"M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z\"/></g><g data-mml-node=\"mo\" transform=\"translate(1778.2,0)\"><path data-c=\"2265\" d=\"M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"/></g><g data-mml-node=\"mn\" transform=\"translate(2834,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"/></g></g></g></svg></mjx-container>）结尾的字符串，每一段的结尾前面都不能出现“*”。那么每一小段都可以先写为<code>[^*]*\"*\"+</code>（⚠️“*”仅表示字符，*表示前面部分的Kleene闭包）。但是每一段连起来的时候不能出现“*/”，因此每一小段的开头都不能是“/”，这时则可以写为<code>[^/*][^*]*\"*\"+</code>。然而第一小段以“/”开头却是没关系的（<code>/*/</code>不是一个完整的注释），因此第一小段单独写为<code>[^*]*\"*\"+</code>。最终多行注释的正则表达式即为<code>\"/*\"[^*]*\"*\"+([^/*][^*]*\"*\"+)*\"/\"</code>。</li>\n</ul>\n</li>\n<li>第五部分主要实现了八进制与十六进制的转换，以及一些错误处理，包括识别非法八进制、十六进制字符和非法字符的报错</li>\n<li>八进制与十六进制的非法字符识别是另外定义了两个类型<strong>ILLEGAL_OCTAL_CONST</strong>与<strong>ILLEGAL_HEX_CONST</strong>，分别置于第四部分中<strong>OCTAL_CONST</strong>和<strong>HEX_CONST</strong>的后面。这样一来如果更长的字符串匹配到了<strong>ILLEGAL</strong>类型就会返回<strong>ILLEGAL</strong>，而正确的格式只会匹配前者。</li>\n<li><code>yylex()</code>函数每次匹配一段字符串，若匹配成功则执行该类型后面的操作，操作中如无<code>return</code>语句则继续识别，如有<code>return</code>语句则返回<code>main</code>函数</li>\n</ol>\n<hr>\n<h3><span id=\"testc\">Test.c</span></h3><pre class=\"line-numbers language-SysY\" data-language=\"SysY\"><code class=\"language-SysY\">int main()\n{\n    int abc = 0123, bb = 0x12d23p, c = 0987, di = 0x45Fc1;\n    if (abc &gt;= bb) // hello\n        while (di == 1)\n            return 8;\n    /*This is a test\n      This is a test\n    */\n    $\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3><span id=\"cast-magic\">Cast Magic 🪄</span></h3><pre class=\"line-numbers language-zsh\" data-language=\"zsh\"><code class=\"language-zsh\">flex SysY.l                    \nclang lex.yy.c -ly -ll\ncat test.c|./a.out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3><span id=\"output\">Output</span></h3><img src=\"/images/编译原理/1.png\" style=\"zoom:55%;\">\n\n<br>\n\n<hr>\n<h2><span id=\"一个小坑\">∂ 一个小坑</span></h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>第四部分中我一开始将<code>{KEYWORD}</code>放在<code>{ID}</code>的后面，执行Flex的时候一直报错</p>\n<pre class=\"line-numbers language-zsh\" data-language=\"zsh\"><code class=\"language-zsh\">SysY.l:36: warning, rule cannot be matched<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>很迷，当时改来改去这个warning就一直跟着<code>{KEYWORD}</code>跑，只有行号在变化。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>这条warning的意思应该是无法匹配<code>{KEYWORD}</code>这条规则。</p>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"0.036ex\" role=\"img\" focusable=\"false\" viewbox=\"0 0 2000 16\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mstyle\"><g data-mml-node=\"mspace\"/></g></g></g></svg></mjx-container>仔细想想，<code>{KEYWORD}</code>匹配的都是关键字，那么为什么关键字会成为关键字呢？因为在一开始的时候就被<code>{KEYWORD}</code>匹配到了，从而用户不能用关键字来定义变量名。这时候一看<code>{ID}</code>果然放在<code>{KEYWORD}</code>前面，显然<code>{KEYWORD}</code>是<code>{ID}</code>的一个子集，因此<code>{ID}</code>匹配完后<code>{KEYWORD}</code>就是光杆司令一个了。</p>\n","text":"词法分析（lexical analysis）是编译器的第一阶段，主要是将代码的字符序列转换为token的过程。简单地来说，就是对代码进行切块的一个过程，并将每一块添加上其所属的类别标签。比如说int asd=897;，其词法分析的结果即为 int ：&lt; TYPE , ‘in...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"编译原理","slug":"编译原理","count":7,"path":"api/categories/编译原理.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">❦ SysY.l</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">☕︎ 一些说明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Test.c</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Cast Magic 🪄</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">∂ 一个小坑</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「Section 7」寻址方式","uid":"d8805cb4c52676259ff97b6383bdfab8","slug":"寻址方式","date":"2022-03-23T01:04:09.000Z","updated":"2022-03-29T12:58:20.381Z","comments":true,"path":"api/articles/寻址方式.json","keywords":null,"cover":[],"text":" 寻址方式：（由硬件）确定本条指令的操作数地址，以及下一条指令地址的方法 指令寻址：指令在主存中是按顺序存放的，我们确定下一条指令在主存中的地址 顺序寻址：PC永远指向下一条指令的地址，取完指令后自动自增指向下一条待执行指令地址 跳跃寻址：当前指令将目标指令的地址置入PC中从而实...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":14,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"Build Qt in arm64","uid":"fbbac3b5688cf257c824005fed6d10e6","slug":"Build-Qt-in-arm64","date":"2022-03-19T02:32:08.000Z","updated":"2022-09-26T17:02:27.338Z","comments":true,"path":"api/articles/Build-Qt-in-arm64.json","keywords":null,"cover":[],"text":"♿︎ 引言自从电脑换成Mac后就需要面对芯片架构不同带来的众多问题，市场上还是有很多软件只适配x86而不支持arm。当然这段时间我体验下来，arm架构采用的是精简指令集，在续航方面全面吊打x86，一般来说不插电工作一天绰绰有余。当然缺点也很明显，就是软件市场依然不是很友好，比如说V...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"血泪史","slug":"血泪史","count":2,"path":"api/categories/血泪史.json"}],"tags":[{"name":"arm64","slug":"arm64","count":1,"path":"api/tags/arm64.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"数着头发过日子","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}