{"title":"「1097」Deduplication on a Linked List","uid":"ffc78994f12cf87b4b6e2fe952701b6e","slug":"「1097」Deduplication-on-a-Linked-List","date":"2022-10-26T15:57:17.000Z","updated":"2022-10-26T16:06:21.941Z","comments":true,"path":"api/articles/「1097」Deduplication-on-a-Linked-List.json","keywords":null,"cover":null,"content":"<p>Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive $N (≤10^5)$ which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p>\n<p>Then N lines follow, each describes a node in the format:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Address Key Next</span><br></pre></td></tr></table></figure>\n\n<p>where <code>Address</code> is the position of the node, <code>Key</code> is an integer of which absolute value is no more than 104, and <code>Next</code> is the position of the next node.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00100 5</span><br><span class=\"line\">99999 -7 87654</span><br><span class=\"line\">23854 -15 00000</span><br><span class=\"line\">87654 15 -1</span><br><span class=\"line\">00000 -15 99999</span><br><span class=\"line\">00100 21 23854</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00100 21 23854</span><br><span class=\"line\">23854 -15 99999</span><br><span class=\"line\">99999 -7 -1</span><br><span class=\"line\">00000 -15 87654</span><br><span class=\"line\">87654 15 -1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$对一个链表进行绝对值去重，即将绝对值与前面节点重复的节点单独取出组成一个新的链表，最后输出两个链表。</p>\n<p>$\\qquad$首先读入所有节点，然后用一个<code>map&lt;int,bool&gt;</code>记录出现过的节点key，再用两个<code>vector&lt;string,int&gt;</code>来模拟链表，最后直接按顺序输出即可。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\">    string head, crt, nxt;</span><br><span class=\"line\">    cin &gt;&gt; head &gt;&gt; n;</span><br><span class=\"line\">    map&lt;string, pair&lt;<span class=\"type\">int</span>, string&gt;&gt; node;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; crt &gt;&gt; m &gt;&gt; nxt;</span><br><span class=\"line\">        node[crt] = <span class=\"built_in\">make_pair</span>(m, nxt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>, <span class=\"type\">bool</span>&gt; flag;</span><br><span class=\"line\">    crt = head;</span><br><span class=\"line\">    vector&lt;pair&lt;string, <span class=\"type\">int</span>&gt;&gt; stay, rmv;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (crt != <span class=\"string\">&quot;-1&quot;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag[<span class=\"built_in\">abs</span>(node[crt].first)])</span><br><span class=\"line\">            rmv.<span class=\"built_in\">emplace_back</span>(crt, node[crt].first);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            stay.<span class=\"built_in\">emplace_back</span>(crt, node[crt].first);</span><br><span class=\"line\">            flag[<span class=\"built_in\">abs</span>(node[crt].first)] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        crt = node[crt].second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stay.<span class=\"built_in\">emplace_back</span>(<span class=\"string\">&quot;-1&quot;</span>, <span class=\"number\">0</span>), rmv.<span class=\"built_in\">emplace_back</span>(<span class=\"string\">&quot;-1&quot;</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; stay.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s %d %s\\n&quot;</span>, stay[i].first.<span class=\"built_in\">c_str</span>(), stay[i].second, stay[i + <span class=\"number\">1</span>].first.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; rmv.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s %d %s\\n&quot;</span>, rmv[i].first.<span class=\"built_in\">c_str</span>(), rmv[i].second, rmv[i + <span class=\"number\">1</span>].first.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, f...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"string","slug":"string","count":18,"path":"api/tags/string.json"},{"name":"list","slug":"list","count":5,"path":"api/tags/list.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1098」Insertion or Heap Sort","uid":"1055437ed759d1b58da767b6a5e1ca44","slug":"「1098」Insertion-or-Heap-Sort","date":"2022-10-27T05:01:24.000Z","updated":"2022-11-28T02:40:07.028Z","comments":true,"path":"api/articles/「1098」Insertion-or-Heap-Sort.json","keywords":null,"cover":null,"text":"According to Wikipedia: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iterati...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"sort","slug":"sort","count":24,"path":"api/tags/sort.json"},{"name":"heap","slug":"heap","count":3,"path":"api/tags/heap.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1096」Consecutive Factors","uid":"4284065e5cb88855913cdeb3766387e3","slug":"「1096」Consecutive-Factors","date":"2022-10-25T07:31:44.000Z","updated":"2022-10-25T07:49:32.057Z","comments":true,"path":"api/articles/「1096」Consecutive-Factors.json","keywords":null,"cover":null,"text":"Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3×5×6×7, whe...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}