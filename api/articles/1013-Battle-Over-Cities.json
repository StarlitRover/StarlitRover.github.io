{"title":"「1013」Battle Over Cities","uid":"74debfb0a3b8fd019ca9b40b7b9af159","slug":"1013-Battle-Over-Cities","date":"2022-03-12T11:09:43.000Z","updated":"2022-09-25T09:27:50.952Z","comments":true,"path":"api/articles/1013-Battle-Over-Cities.json","keywords":null,"cover":null,"content":"<p>➳<a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840\">ENTRY</a></p>\n<p>$\\qquad$It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from&#x2F;toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p>\n<p>$\\qquad$For example, if we have 3 cities and 2 highways connecting $city_1-city_2$ and $city_1-city_3$. Then if $city_1$ is occupied by the enemy, we must have 1 highway repaired, that is the highway $city_2-city_3$.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>$\\qquad$Each input file contains one test case. Each case starts with a line containing 3 numbers <em>N</em> (&lt;1000), <em>M</em> and <em>K</em>, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then <em>M</em> lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to <em>N</em>. Finally there is a line containing <em>K</em> numbers, which represent the cities we concern.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>$\\qquad$For each of the <em>K</em> cities, output in a line the number of highways need to be repaired if that city is lost.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3 2 3</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">1 2 3</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$首先极简翻译一波。简单的说就是，有一些城市，部分城市之间连有高速公路。当一个城市被敌人占领后，与其相连的高速公路都无法通行，但要求其余城市必须是连通的，试问最少需要搭几条高速公路。</p>\n<p>$\\qquad$乍看题目有点迷，其实只需要求剩余城市的连通分图数即可。若剩余城市含$n$个连通分图，那么显然最少只需$n-1$条边即可将所有剩余城市相连。</p>\n<p>$\\qquad$我采取的是<strong>Alg. BFS</strong>（广度优先搜索）的思想，按顺序遍历每一座城市，然后将与这座城市相连的城市进行标记，接着再将与这些城市相连的城市进行标记，逐层递归，直至相连的城市数量为0。当然对于被敌人占领的那一座城市我们需要在一开始对其就进行标记，从而后面递归的时候就无法从这座城市经过。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m, k, a, b;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class=\"line\">  <span class=\"comment\">//记录高速公路</span></span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;&gt; connect;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        connect[a].<span class=\"built_in\">push_back</span>(b);</span><br><span class=\"line\">        connect[b].<span class=\"built_in\">push_back</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">//标记变量</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">mark</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> city, num;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; city;</span><br><span class=\"line\">        num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">fill</span>(mark.<span class=\"built_in\">begin</span>(), mark.<span class=\"built_in\">end</span>(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        mark[city] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mark[j])</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          <span class=\"comment\">//mark[j]=false说明是一个新的连通分图</span></span><br><span class=\"line\">            num += <span class=\"number\">1</span>;</span><br><span class=\"line\">          <span class=\"comment\">//cup存储与next中城市相连的城市</span></span><br><span class=\"line\">            set&lt;<span class=\"type\">int</span>&gt; next&#123;j&#125;, cup;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!next.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;c: next)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mark[c])</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        mark[c] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        cup.<span class=\"built_in\">insert</span>(connect[c].<span class=\"built_in\">begin</span>(), connect[c].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                next = cup;</span><br><span class=\"line\">                cup.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; num - <span class=\"number\">1</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"︎-算法说明\">⚡︎ 算法说明</span></h2><ol>\n<li>使用<code>map</code>可以直接通过城市序号访问与其相连的城市<code>vector</code></li>\n<li><code>fill(mark.begin(), mark.end(), false);</code>将<code>mark</code>迭代器中的值全部填充为<code>false</code></li>\n<li>用<code>set</code>记录与当前城市相连的城市可以避免重复</li>\n<li><code>cup.insert(connect[c].begin(), connect[c].end());</code>将<code>vector&lt;int&gt; connect[c]</code>中的值插入到<code>set&lt;int&gt; cup</code>的尾部</li>\n<li>本题也可以采用<strong>Alg. DFS</strong>（深度优先搜索），详情可见<a href=\"https://www.liuchuo.net/archives/2346\">柳婼 の blog</a></li>\n</ol>\n","text":"➳ENTRY $\\qquad$It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the hi...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"},{"name":"BFS","slug":"BFS","count":10,"path":"api/tags/BFS.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">⚡︎ 算法说明</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「Section 5」定点运算器（&浮点加减）","uid":"d89b7bb9a5cb29131093afe1032ded19","slug":"定点运算器","date":"2022-03-14T03:08:02.000Z","updated":"2022-03-27T08:26:05.465Z","comments":true,"path":"api/articles/定点运算器.json","keywords":null,"cover":[],"text":"$\\qquad$由前几节的内容我们知道计算机中的各类算术运算都可以由最基本的定点加法与移位运算迭代实现，那么我们只要将逻辑运算、移位运算、各种算术运算的数字逻辑电路实现集成在一起就可以构成CPU中的运算器。运算器具体可以分为定点运算部件和浮点运算部件，本节主要介绍又称为算术逻辑运...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","count":8,"path":"api/categories/计算机组成原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「Section 3」关系模型","uid":"4b69eccade1977efb8c2be2f48efdb06","slug":"关系模型","date":"2022-03-09T13:28:00.000Z","updated":"2022-03-10T09:24:41.096Z","comments":true,"path":"api/articles/关系模型.json","keywords":null,"cover":[],"text":" 关系模型的主要术语 关系（表）：一个关系可用一个表来表示，每个关系都有唯一的名称。 属性：表（关系）中的每一列即为一个属性，一个表内的属性名都是唯一的，且都显示在行首。 域：可以认为是属性的定义域。 元组：表中的一行数据称为一个元组，即一个实体所有属性值的总称。同样的，一个表中...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"数据库原理","slug":"数据库原理","count":3,"path":"api/categories/数据库原理.json"}],"tags":[{"name":"notes","slug":"notes","count":13,"path":"api/tags/notes.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}