{"title":"「1021」Deepest Root","uid":"984c45eac2cbd15ed424e46306609be5","slug":"「1021」Deepest-Root","date":"2022-07-05T03:27:49.000Z","updated":"2022-07-17T15:23:59.994Z","comments":true,"path":"api/articles/「1021」Deepest-Root.json","keywords":null,"cover":null,"content":"<p><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856\">➳ENTRY</a></p>\n<p>A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called <strong>the deepest root</strong>.</p>\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each case, the first line contains a positive integer $N (≤10^4)$ which is the number of nodes, and hence the nodes are numbered from 1 to $N$. Then $N−1$ lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print <code>Error: K components</code> where <code>K</code> is the number of connected components in the graph.</p>\n<h3><span id=\"sample-input-1\">Sample Input 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 3</span><br><span class=\"line\">1 4</span><br><span class=\"line\">2 5</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-1\">Sample Output 1:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-input-2\">Sample Input 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 3</span><br><span class=\"line\">1 4</span><br><span class=\"line\">2 5</span><br><span class=\"line\">3 4</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output-2\">Sample Output 2:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: 2 components</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$给出节点个数$N$和$N-1$条边，首先判断该无向图是否构成树，然后按升序输出作为根节点时能使树高度最高的节点编号。</p>\n<p>$\\qquad$首先边的个数已经满足树的要求，因此如果不是树的话就一定不是连通的。所以首先需要求取连通分图数，这里用DFS和BFS皆可。然后如果连通分图数为1，再寻找作为根节点可以使高度最高的节点。</p>\n<p>$\\qquad$虽说找的是高度最高，但本质上是在树中找一条最长且节点不重复的路径，最终输出的则是所有最长路径的左右两个节点编号。我们可以将其中一条最长路径拉成直线，其他不属于该路径的边可以视作该直线的分支，那么显然在该直线上的所有节点都属于至少一条最长路径（即直线本身），而且所有最长路径必然会经过直线上的至少一个节点，另外直线上每个节点对最长路径的长度划分都是固定的（否则必然会产生更长的）。不管从哪个节点开始BFS都迟早会达到直线上的某个节点$P$，不失一般性，我们假设节点$P$将最长路径划分后的<big>左端&gt;右端</big>，首先可以肯定最终必然会到达直线最左端节点，另外必然可以到达经过$P$左边节点们的最长路径的一端（因为直线上每个节点对最长路径长度划分都是一致的，因此到达的其他端点到距其最近的直线上节点$Q$的距离&#x3D;$Q$到直线最左端节点的距离）。然而$P$右侧的端点被忽略了，因此我们还需要从第一次BFS得到的端点中选一个重新开始BFS（注意直线上分支的最大长度必然≤最长路径&#x2F;2，因此距离第一次BFS得到的任意端点最近的直线节点将最长距离划分的结果会是 右端&gt;左端，从而可以互补），最后取并集得到所有端点。</p>\n<p>$\\qquad$这些证明只是为了说明该算法的合理性，在代码中并不体现。</p>\n<hr>\n<h2><span id=\"cde\">C☺DE</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>, set&lt;<span class=\"type\">int</span>&gt;&gt; path;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">        path[x].<span class=\"built_in\">insert</span>(y);</span><br><span class=\"line\">        path[y].<span class=\"built_in\">insert</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">flag</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt;= n; ++k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag[k]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        set&lt;<span class=\"type\">int</span>&gt; next&#123;k&#125;, tmp;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!next.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i: next)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                flag[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                tmp.<span class=\"built_in\">insert</span>(path[i].<span class=\"built_in\">begin</span>(), path[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next = tmp;</span><br><span class=\"line\">            tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cnt += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt; deepestA, deepestB, tmp&#123;<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Error: %d components&quot;</span>, cnt);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        flag.<span class=\"built_in\">assign</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!tmp.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            deepestA = tmp;</span><br><span class=\"line\">            tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i: deepestA)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: path[i])</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!flag[k]) tmp.<span class=\"built_in\">insert</span>(k);</span><br><span class=\"line\">                flag[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmp.<span class=\"built_in\">insert</span>(*deepestA.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">        flag.<span class=\"built_in\">assign</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!tmp.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            deepestB = tmp;</span><br><span class=\"line\">            tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i: deepestB)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: path[i])</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!flag[k]) tmp.<span class=\"built_in\">insert</span>(k);</span><br><span class=\"line\">                flag[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    deepestA.<span class=\"built_in\">insert</span>(deepestB.<span class=\"built_in\">begin</span>(), deepestB.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;k: deepestA)</span><br><span class=\"line\">        cout &lt;&lt; k &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"tips\">Tips</span></h3><ol>\n<li><p>先用BFS计算连通分图个数</p>\n</li>\n<li><p>在BFS求最大深度时勿将父节点加入下一轮遍历节点中</p>\n</li>\n</ol>\n","text":"➳ENTRY A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are sup...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"},{"name":"BFS","slug":"BFS","count":10,"path":"api/tags/BFS.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 1:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output 2:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">C☺DE</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Tips</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1022」Digital Library","uid":"8e6bb31e56ec41155c96a89b29398eaf","slug":"「1022」Digital-Library","date":"2022-07-06T10:55:03.000Z","updated":"2022-07-06T11:10:27.508Z","comments":true,"path":"api/articles/「1022」Digital-Library.json","keywords":null,"cover":null,"text":"➳ENTRY A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, an...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1020」Tree Traversals","uid":"ecd0b7f9610ba01de460fb7fa358ee35","slug":"「1020」Tree-Traversals","date":"2022-07-04T03:51:27.000Z","updated":"2022-07-05T03:34:42.057Z","comments":true,"path":"api/articles/「1020」Tree-Traversals.json","keywords":null,"cover":null,"text":"➳ENTRY Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you a...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"map","slug":"map","count":25,"path":"api/tags/map.json"},{"name":"vector","slug":"vector","count":17,"path":"api/tags/vector.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}