{"title":"『1167」Cartesian Tree","uid":"fec11be8fe74efb46e38390fb6e3547a","slug":"『1167」Cartesian-Tree","date":"2022-12-02T06:37:46.000Z","updated":"2022-12-04T07:29:58.752Z","comments":true,"path":"api/articles/『1167」Cartesian-Tree.json","keywords":null,"cover":[],"content":"<p>A <strong>Cartesian tree</strong> is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal returns the original sequence. For example, given the sequence { 8, 15, 3, 4, 1, 5, 12, 10, 18, 6 }, the min-heap Cartesian tree is shown by the figure.</p>\n<p><img src=\"https://images.ptausercontent.com/6a99f68a-6578-46e0-9232-fbf0adf3691f.jpg\" alt=\"CTree.jpg\"></p>\n<p>Your job is to output the level-order traversal sequence of the min-heap Cartesian tree.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. Each case starts from giving a positive integer N (≤30), and then N distinct numbers in the next line, separated by a space. All the numbers are in the range of <strong>int</strong>.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each test case, print in a line the level-order traversal sequence of the min-heap Cartesian tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the beginning or the end of the line.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">8 15 3 4 1 5 12 10 18 6</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 3 5 8 4 6 15 10 12 18</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$笛卡尔树是通过一串序列进行构造的，它满足最小堆的特征（父节点&lt;子节点），同时它的中序遍历结果就是构造序列。</p>\n<p>$\\qquad$由于构造序列与中序遍历是一致的，那么在逐一插入节点的过程中，我们只能将新节点插入到现有节点的右边（原有节点是新节点的左子树&#x2F;新节点是原有节点的右子树），才能保证中序遍历中新节点在现有节点的后面。然后最小堆的特征约束了小节点必须在大节点的上方，可以认为一个约束了左右，另一个约束了上下，那么就可以制定如下插入方案：</p>\n<ol>\n<li><p>新节点&gt;当前节点：向右子树插入</p>\n</li>\n<li><p>新节点&lt;当前节点：将当前节点作为新节点的左子树</p>\n</li>\n</ol>\n<p>$\\qquad$每次都从根节点开始插入，递归插入函数返回插入后子树的根节点。另外由于节点键值是整型范围，因此还需要一个bool数组标记各个节点的子节点是否存在。</p>\n<center><big>完结撒花，祝我明天考试顺利～</big></center>\n\n<br>\n\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; sons;</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>, pair&lt;<span class=\"type\">bool</span>, <span class=\"type\">bool</span>&gt;&gt; has;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> r, <span class=\"type\">int</span> k)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r &lt; k &amp;&amp; has[r].second)</span><br><span class=\"line\">        sons[r].second = <span class=\"built_in\">insert</span>(sons[r].second, k);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r &lt; k)</span><br><span class=\"line\">        sons[r].second = k, has[r].second = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r &gt; k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sons[k].first = r, has[k].first = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, r, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">        cin &gt;&gt; k, r = <span class=\"built_in\">insert</span>(r, k);</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; crt&#123;r&#125;, nxt;</span><br><span class=\"line\">    <span class=\"type\">bool</span> space = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!crt.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;t: crt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, space ? <span class=\"string\">&quot; &quot;</span> : (space = <span class=\"literal\">true</span>, <span class=\"string\">&quot;&quot;</span>), t);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (has[t].first) nxt.<span class=\"built_in\">push_back</span>(sons[t].first);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (has[t].second) nxt.<span class=\"built_in\">push_back</span>(sons[t].second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        crt = std::<span class=\"built_in\">move</span>(nxt), nxt = <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"A Cartesian tree is a binary tree constructed from a sequence of distinct numbers. The tree is heap-ordered, and an inorder traversal return...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"「1166』Summit","uid":"198f2c49e9910efe18930d8f84735116","slug":"「1166』Summit","date":"2022-12-02T06:16:17.000Z","updated":"2022-12-02T06:37:24.567Z","comments":true,"path":"api/articles/「1166』Summit.json","keywords":null,"cover":null,"text":"A summit (峰会) is a meeting of heads of state or government. Arranging the rest areas for the summit is not a simple job. The ideal arrangeme...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"},{"name":"bitset","slug":"bitset","count":4,"path":"api/tags/bitset.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}