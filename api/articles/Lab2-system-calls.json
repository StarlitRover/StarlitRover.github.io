{"title":"Lab2: system calls","uid":"1b4d009413a4a1733c93e882f288fd9a","slug":"Lab2-system-calls","date":"2022-09-25T03:57:05.000Z","updated":"2022-09-25T07:49:21.925Z","comments":true,"path":"api/articles/Lab2-system-calls.json","keywords":null,"cover":[],"content":"<p>$\\qquad$上周打了一场数模国赛，打前元气超人，打完葛优躺平。Lab2只有两个小实验，聚焦于如何创建系统调用命令，也并不是那么简单，实验文档<a href=\"https://pdos.csail.mit.edu/6.828/2021/labs/syscall.html\">戳这</a>。</p>\n<img src=\"/images/操作系统/2.png\" title alt data-align=\"center\">\n\n<span id=\"more\"></span>\n\n<br>\n\n<h2><span id=\"coding\">❖ Coding</span></h2><hr>\n<h4><span id=\"︎-system-call-tracing-moderate\">☑︎ System call tracing (moderate)</span></h4><p>$\\qquad$我们需要创建一个trace系统调用来追踪一个命令中指定的系统调用，并打印出相应的返回值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ trace 2147483647 grep hello README</span><br><span class=\"line\">4: syscall trace -&gt; 0</span><br><span class=\"line\">4: syscall exec -&gt; 3</span><br><span class=\"line\">4: syscall open -&gt; 3</span><br><span class=\"line\">4: syscall read -&gt; 1023</span><br><span class=\"line\">4: syscall read -&gt; 966</span><br><span class=\"line\">4: syscall read -&gt; 70</span><br><span class=\"line\">4: syscall read -&gt; 0</span><br><span class=\"line\">4: syscall close -&gt; 0</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$指令格式：<code>trace mask cmd</code>。mask用来指定需要追踪的系统调用，在操作系统中每个系统调用都会有自己唯一的编号SYS_syscall（在kernel&#x2F;syscall.h中的宏定义），比如说fork的编号就是SYS_fork，如果<code>mask&amp;(1&lt;&lt;SYS_syscall)!=0</code>就说明需要追踪该syscall，需要打印出其返回值，本质上如果假设$mask[i]$代表其二进制低$i$位数字的话，那么$mask[i]&#x3D;1$就代表需要追踪SYS_syscall&#x3D;$i$的系统调用。</p>\n<p>$\\qquad$那么我们就需要在进程结构体proc中加入<code>int mask</code>，注意到一个进程中执行不同系统调用是通过fork来实现的，本质上又创建了一个proc实体，因此在fork的实现（kernel&#x2F;proc.c）中我们需要实现mask的传递：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    np-&gt;mask = p-&gt;mask;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$那么接下来就可以打印信息<code>pid: syscall name -&gt; return_value</code>。我们可以在每个系统调用都必经的函数syscall（kernel&#x2F;syscall.c）里面实现，首先观察syscall函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">syscall</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> num;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\"></span><br><span class=\"line\">  num = p-&gt;trapframe-&gt;a7;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %s: unknown sys call %d\\n&quot;</span>,p-&gt;pid, p-&gt;name, num);</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a0 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$可以看出p里面存储了我们需要的pid，但p-&gt;name并不是我们想要的系统调用名称，注意到fork实现中（kernel&#x2F;proc.c：304）是直接拷贝原proc的name，即name里存储的其实是进程名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">safestrcpy(np-&gt;name, p-&gt;name, <span class=\"keyword\">sizeof</span>(p-&gt;name)）;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$这里需要注意进程与线程之间的差别。虽然fork完后也是一个proc结构体，但事实上只是p-&gt;name进程下的一个线程而已。进程是对运行程序的封装，是系统进行<strong>资源调度和分配</strong>的基本单位，各进程之间相互隔离不共享数据，实现了操作系统的并发性；而线程则是一个进程中的子任务，是<strong>CPU调度</strong>的最小单位，一个进程中的所有线程共享该进程的数据资源。那么每个命令就是一个进程，里面会执行多个系统调用，每个系统调用都是一个线程。</p>\n<p>$\\qquad$虽然p里面没有线程名称的直接信息，但肯定有其他相关信息。注意到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br></pre></td></tr></table></figure>\n\n<p>这里调用了<code>syscalls[num]</code>，然后将返回值传递给了a0寄存器（RISC-V的C规范是把返回值放在a0中）。syscalls是一个无符号整型指针数组，即函数指针。那么可以肯定这个num将是一个重要的突破口，我们只要按照syscalls中系统调用的顺序定义一个字符串数组sysname，<code>sysname[num]</code>就是系统调用的名称了。同时<code>p-&gt;trapframe-&gt;a0</code>就是函数返回值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">107</span> + │ <span class=\"keyword\">extern</span> uint64 <span class=\"title function_\">sys_trace</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">132</span> + │ [SYS_trace]   sys_trace, <span class=\"comment\">//static uint64 (*syscalls[])(void)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">136</span> + │ <span class=\"type\">char</span> *sysname[] = &#123;</span><br><span class=\"line\"><span class=\"number\">137</span> + │ [SYS_fork]    <span class=\"string\">&quot;fork&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">138</span> + │ [SYS_exit]    <span class=\"string\">&quot;exit&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">139</span> + │ [SYS_wait]    <span class=\"string\">&quot;wait&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">140</span> + │ [SYS_pipe]    <span class=\"string\">&quot;pipe&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">141</span> + │ [SYS_read]    <span class=\"string\">&quot;read&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">142</span> + │ [SYS_kill]    <span class=\"string\">&quot;kill&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">143</span> + │ [SYS_exec]    <span class=\"string\">&quot;exec&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">144</span> + │ [SYS_fstat]   <span class=\"string\">&quot;stat&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">145</span> + │ [SYS_chdir]   <span class=\"string\">&quot;chdir&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">146</span> + │ [SYS_dup]     <span class=\"string\">&quot;dup&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">147</span> + │ [SYS_getpid]  <span class=\"string\">&quot;getpid&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">148</span> + │ [SYS_sbrk]    <span class=\"string\">&quot;sbrk&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">149</span> + │ [SYS_sleep]   <span class=\"string\">&quot;sleep&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">150</span> + │ [SYS_uptime]  <span class=\"string\">&quot;uptime&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">151</span> + │ [SYS_open]    <span class=\"string\">&quot;open&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">152</span> + │ [SYS_write]   <span class=\"string\">&quot;write&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">153</span> + │ [SYS_mknod]   <span class=\"string\">&quot;mknod&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">154</span> + │ [SYS_unlink]  <span class=\"string\">&quot;unlink&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">155</span> + │ [SYS_link]    <span class=\"string\">&quot;link&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">156</span> + │ [SYS_mkdir]   <span class=\"string\">&quot;mkdir&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">157</span> + │ [SYS_close]   <span class=\"string\">&quot;close&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">158</span> + │ [SYS_trace]   <span class=\"string\">&quot;trace&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">159</span>   │ &#125;;</span><br><span class=\"line\"><span class=\"number\">160</span>   │ </span><br><span class=\"line\"><span class=\"number\">161</span>   │ <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"number\">162</span>   │ syscall(<span class=\"type\">void</span>)</span><br><span class=\"line\"><span class=\"number\">163</span>   │ &#123;</span><br><span class=\"line\"><span class=\"number\">164</span>   │   <span class=\"type\">int</span> num;</span><br><span class=\"line\"><span class=\"number\">165</span>   │   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\"><span class=\"number\">166</span>   │ </span><br><span class=\"line\"><span class=\"number\">167</span>   │   num = p-&gt;trapframe-&gt;a7;</span><br><span class=\"line\"><span class=\"number\">168</span>   │   <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class=\"line\"><span class=\"number\">169</span>   │     p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class=\"line\"><span class=\"number\">170</span> + │     <span class=\"keyword\">if</span>(<span class=\"number\">1</span>&lt;&lt;num &amp; p-&gt;mask)</span><br><span class=\"line\"><span class=\"number\">171</span> + │         <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: syscall %s -&gt; %d\\n&quot;</span>,p-&gt;pid,sysname[num],p-&gt;trapframe-&gt;a0);</span><br><span class=\"line\"><span class=\"number\">172</span>   │   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"number\">173</span>   │     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %s: unknown sys call %d\\n&quot;</span>,</span><br><span class=\"line\"><span class=\"number\">174</span>   │             p-&gt;pid, p-&gt;name, num);</span><br><span class=\"line\"><span class=\"number\">175</span>   │     p-&gt;trapframe-&gt;a0 = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"number\">176</span>   │   &#125;</span><br><span class=\"line\"><span class=\"number\">177</span>   │ &#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$o对，我们甚至还没实现trace函数💦。你可能会觉得上面的做法已经间接实现了trace，但事实上trace是在用户模式（user mode）调用的，因此传入的参数还在用户空间，而系统调用都是在内核空间内执行的，为了操作系统不受进程影响两者是分隔的。</p>\n<img title src=\"/images/操作系统/3.png\" alt data-align=\"center\" width=\"420\">\n\n<p>$\\qquad$用户态的trace函数已经帮我们实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/param.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/stat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i;</span><br><span class=\"line\">  <span class=\"type\">char</span> *nargv[MAXARG];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(argc &lt; <span class=\"number\">3</span> || (argv[<span class=\"number\">1</span>][<span class=\"number\">0</span>] &lt; <span class=\"string\">&#x27;0&#x27;</span> || argv[<span class=\"number\">1</span>][<span class=\"number\">0</span>] &gt; <span class=\"string\">&#x27;9&#x27;</span>))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;Usage: %s mask command\\n&quot;</span>, argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">trace</span>(<span class=\"built_in\">atoi</span>(argv[<span class=\"number\">1</span>])) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"number\">2</span>, <span class=\"string\">&quot;%s: trace failed\\n&quot;</span>, argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;</span><br><span class=\"line\">    nargv[i<span class=\"number\">-2</span>] = argv[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">exec</span>(nargv[<span class=\"number\">0</span>], nargv);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$不难看出关键函数是<code>int trace(int)</code>，那我们需要先在user&#x2F;user.h中声明该系统调用，同时在user&#x2F;usys.pl（生成汇编文件user&#x2F;usys.S）中加入<code>entry(&quot;trace&quot;)</code>使trace函数可以进入内核模式，并在<code>kernel/syscall.h</code>中添加一个系统调用号，整个系统调用过程如下所示$^{[2]}$：</p>\n<ol>\n<li><p>user&#x2F;user.h：用户态程序调用跳板函数 trace()</p>\n</li>\n<li><p>user&#x2F;usys.S：跳板函数 trace 使用 CPU 提供的 ecall 指令，进入内核模式</p>\n</li>\n<li><p>kernel&#x2F;syscall.c：到达内核模式统一执行系统调用处理函数syscall，所有系统调用都会跳到这里来处理</p>\n</li>\n<li><p>kernel&#x2F;syscall.c：syscall根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用</p>\n</li>\n<li><p>kernel&#x2F;sysproc.c：到达 sys_trace 函数，执行具体内核操作</p>\n</li>\n</ol>\n<p>$\\qquad$接下来只需在kernel&#x2F;sysproc.c中实现sys_trace，该函数只要把用户空间的mask拿进来就行，cmd在执行时事实上可以认为是trace的多个子线程，因此mask会一直传递下去。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint64</span><br><span class=\"line\"><span class=\"title function_\">sys_trace</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> mask;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(argint(<span class=\"number\">0</span>, &amp;mask) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">   myproc()-&gt;mask=mask;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h4><span id=\"︎-sysinfo-moderate\">☑︎ Sysinfo (moderate)</span></h4><p>$\\qquad$实现一个系统调用sysinfo，它接受一个指向struct sysinfo的指针，然后向这个结构体写入剩余空间的字节数和状态非”UNUSED”的进程数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">───────┬─────────────────────────────────────────────────────────</span><br><span class=\"line\">       │ File: kernel/sysinfo.h</span><br><span class=\"line\">───────┼─────────────────────────────────────────────────────────</span><br><span class=\"line\">   <span class=\"number\">1</span>   │ <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sysinfo</span> &#123;</span></span><br><span class=\"line\">   <span class=\"number\">2</span>   │   uint64 freemem;   <span class=\"comment\">// amount of free memory (bytes)</span></span><br><span class=\"line\">   <span class=\"number\">3</span>   │   uint64 nproc;     <span class=\"comment\">// number of process</span></span><br><span class=\"line\">   <span class=\"number\">4</span>   │ &#125;;</span><br><span class=\"line\">───────┴─────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$首先我们需要实现统计剩余空间字节数和已使用进程数的函数。关于空间分配的实现在kernel&#x2F;kalloc.c，注意到kmem中有一项freelist链表，然后看kfree函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">46</span>   │ <span class=\"type\">void</span></span><br><span class=\"line\"><span class=\"number\">47</span>   │ kfree(<span class=\"type\">void</span> *pa)</span><br><span class=\"line\"><span class=\"number\">48</span>   │ &#123;</span><br><span class=\"line\"><span class=\"number\">49</span>   │   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"><span class=\"number\">50</span>   │ </span><br><span class=\"line\"><span class=\"number\">51</span>   │   <span class=\"keyword\">if</span>(((uint64)pa % PGSIZE) != <span class=\"number\">0</span> || (<span class=\"type\">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class=\"line\"><span class=\"number\">52</span>   │     panic(<span class=\"string\">&quot;kfree&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">53</span>   │ </span><br><span class=\"line\"><span class=\"number\">54</span>   │   <span class=\"comment\">// Fill with junk to catch dangling refs.</span></span><br><span class=\"line\"><span class=\"number\">55</span>   │   <span class=\"built_in\">memset</span>(pa, <span class=\"number\">1</span>, PGSIZE);</span><br><span class=\"line\"><span class=\"number\">56</span>   │ </span><br><span class=\"line\"><span class=\"number\">57</span>   │   r = (<span class=\"keyword\">struct</span> run*)pa;</span><br><span class=\"line\"><span class=\"number\">58</span>   │ </span><br><span class=\"line\"><span class=\"number\">59</span>   │   acquire(&amp;kmem.lock);</span><br><span class=\"line\"><span class=\"number\">60</span>   │   r-&gt;next = kmem.freelist;</span><br><span class=\"line\"><span class=\"number\">61</span>   │   kmem.freelist = r;</span><br><span class=\"line\"><span class=\"number\">62</span>   │   release(&amp;kmem.lock);</span><br><span class=\"line\"><span class=\"number\">63</span>   │ &#125;</span><br></pre></td></tr></table></figure>\n\n<p>kfree函数将pa地址开始PGSIZE大小的空间都初始化为1，然后将pa挂到freelist的头上，再将freelist指向pa，而kalloc函数则是每次都使用freelist的第一块PGSIZE空间。说明freelist是可用空间的链表，而且每次分配的最小单元是PGSIZE字节，那么我们只要数一下freelist的元素个数然后乘个PGSIZE即可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint64</span><br><span class=\"line\"><span class=\"title function_\">count_freemem</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  acquire(&amp;kmem.lock);</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span> =</span> kmem.freelist;</span><br><span class=\"line\">  uint64 cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (r)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ++cnt;</span><br><span class=\"line\">    r = r-&gt;next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  release(&amp;kmem.lock);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cnt * PGSIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$为防止竞态条件产生，在统计时需要先给kmem上锁。</p>\n<br>\n\n<p>$\\qquad$对于统计状态为非”UNUSED”的进程数也不难，注意到kernel&#x2F;proc.c中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span>   │ <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> <span class=\"title\">proc</span>[<span class=\"title\">NPROC</span>];</span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$可知最大进程数即为NPROC，那么我们只要遍历proc，然后依次检查状态即可。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint64</span><br><span class=\"line\"><span class=\"title function_\">count_process</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  uint64 cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NPROC; ++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (proc[i].state != UNUSED)</span><br><span class=\"line\">      ++cnt;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$最后我们只要将这个sysinfo结构体拷贝至用户空间即可。首先通过argaddr函数获取用户态<code>int sysinfo(struct sysinfo *)</code>传入的sysinfo虚地址，然后结合该进程的页表pagetable可以得到该地址对应的物理地址，最后将内核中的sysinfo结构体拷贝过去。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint64</span><br><span class=\"line\"><span class=\"title function_\">sys_sysinfo</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sysinfo</span> <span class=\"title\">sf</span>;</span></span><br><span class=\"line\">  uint64 addr;</span><br><span class=\"line\">  sf.freemem = count_freemem();</span><br><span class=\"line\">  sf.nproc = count_process();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (argaddr(<span class=\"number\">0</span>, &amp;addr) &lt; <span class=\"number\">0</span> || copyout(p-&gt;pagetable, addr, (<span class=\"type\">char</span> *)&amp;sf, <span class=\"keyword\">sizeof</span>(sf)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$argaddr第一个参数0是指从a0寄存器获取，我特地回去翻了一下计组PPT</p>\n<img title src=\"/images/操作系统/4.png\" alt data-align=\"center\" width=\"650\">\n\n<p>$\\qquad$果然，a0、a1存储函数参数，as I guess。</p>\n<p>$\\qquad$其余声明之类的与上面的trace类似。另外别忘了在kernel&#x2F;sysproc.c中加入</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">9</span> + │ <span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;kernel/sysinfo.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>$\\qquad$如果一切正常，在xv6启动后输入sysinfotest会输出OK。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sysinfotest</span><br><span class=\"line\">sysinfotest: start</span><br><span class=\"line\">sysinfotest: OK</span><br></pre></td></tr></table></figure>\n\n<br>\n\n<h2><span id=\"reference\">❖ Reference</span></h2><hr>\n<p>$\\qquad$<strong>[1]</strong>$\\quad$<a href=\"https://zhuanlan.zhihu.com/p/332243456\">MIT 6.S081 2020 Lab2 system calls讲解</a></p>\n<p>$\\qquad$<strong>[2]</strong>$\\quad$<a href=\"https://blog.miigon.net/posts/s081-lab2-system-calls/\">[mit6.s081] 笔记 Lab2: System calls | 系统调用</a></p>\n","text":"$\\qquad$上周打了一场数模国赛，打前元气超人，打完葛优躺平。Lab2只有两个小实验，聚焦于如何创建系统调用命令，也并不是那么简单，实验文档戳这。 ❖ Coding ☑︎ System call tracing (moderate)$\\qquad$我们需要创建一个trace系统...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"操作系统","slug":"操作系统","count":3,"path":"api/categories/操作系统.json"}],"tags":[{"name":"走码观花","slug":"走码观花","count":15,"path":"api/tags/走码观花.json"},{"name":"xv6","slug":"xv6","count":3,"path":"api/tags/xv6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">❖ Coding</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">☑︎ System call tracing (moderate)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">☑︎ Sysinfo (moderate)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">❖ Reference</span></a></li></ol>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"「1067」Sort with Swap(0, i)","uid":"f66bf5b8d2fc86417cb09b027c83ec14","slug":"「1067」Sort-with-Swap-0-i","date":"2022-09-25T09:25:33.000Z","updated":"2022-09-25T10:12:35.709Z","comments":true,"path":"api/articles/「1067」Sort-with-Swap-0-i.json","keywords":null,"cover":null,"text":"Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY opera...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Graph","slug":"Graph","count":16,"path":"api/tags/Graph.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1066」Root of AVL Tree","uid":"42640cc884e7d3b61d24e0f58f7990cd","slug":"「1066」Root-of-AVL-Tree","date":"2022-09-24T16:14:37.000Z","updated":"2022-10-19T10:54:11.913Z","comments":true,"path":"api/articles/「1066」Root-of-AVL-Tree.json","keywords":null,"cover":[],"text":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one;...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"},{"name":"AVL","slug":"AVL","count":2,"path":"api/tags/AVL.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}