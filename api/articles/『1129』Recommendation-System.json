{"title":"『1129』Recommendation System","uid":"f1ff96299aac15c031753a8c21bad439","slug":"『1129』Recommendation-System","date":"2022-11-23T16:22:12.000Z","updated":"2022-11-23T16:50:43.210Z","comments":true,"path":"api/articles/『1129』Recommendation-System.json","keywords":null,"cover":null,"content":"<p>Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation system that rates the user’s preference by the number of times that an item has been accessed by this user.</p>\n<span id=\"more\"></span>\n\n<h3><span id=\"input-specification\">Input Specification:</span></h3><p>Each input file contains one test case. For each test case, the first line contains two positive integers: N (≤ 50,000), the total number of queries, and K (≤ 10), the maximum number of recommendations the system must show to the user. Then given in the second line are the indices of items that the user is accessing – for the sake of simplicity, all the items are indexed from 1 to N. All the numbers in a line are separated by a space.</p>\n<h3><span id=\"output-specification\">Output Specification:</span></h3><p>For each case, process the queries one by one. Output the recommendations for each query in a line in the format:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">query: rec[1] rec[2] ... rec[K]</span><br></pre></td></tr></table></figure>\n\n<p>where <code>query</code> is the item that the user is accessing, and <code>rec[i]</code> (<code>i</code>&#x3D;1, … K) is the <code>i</code>-th item that the system recommends to the user. The first K items that have been accessed most frequently are supposed to be recommended in non-increasing order of their frequencies. If there is a tie, the items will be ordered by their indices in increasing order.</p>\n<p>Note: there is no output for the first item since it is impossible to give any recommendation at the time. It is guaranteed to have the output for at least one query.</p>\n<h3><span id=\"sample-input\">Sample Input:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12 3</span><br><span class=\"line\">3 5 7 5 5 3 2 1 8 3 8 12</span><br></pre></td></tr></table></figure>\n\n<h3><span id=\"sample-output\">Sample Output:</span></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5: 3</span><br><span class=\"line\">7: 3 5</span><br><span class=\"line\">5: 3 5 7</span><br><span class=\"line\">5: 5 3 7</span><br><span class=\"line\">3: 5 3 7</span><br><span class=\"line\">2: 5 3 7</span><br><span class=\"line\">1: 5 3 2</span><br><span class=\"line\">8: 5 3 1</span><br><span class=\"line\">3: 5 3 1</span><br><span class=\"line\">8: 3 5 1</span><br><span class=\"line\">12: 3 5 8</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2><span id=\"ω\">Ω</span></h2><p>$\\qquad$写一个推荐系统，假设访问对象的编号从1-N，给出用户按时间顺序访问的对象序列，以及每次最多推荐的对象个数，在每次用户访问对象前（除第一次）给出推荐序列，按照先前访问次数降序排列，如果访问次数一致，按照序号升序排列。</p>\n<p>$\\qquad$这勾八题目我读了半天，谁来救救我的英蓝瓜哥。没有想太多，只知道每次都需要选出访问次数最高的$k$个对象，每次排序估计时间开销太大。于是乎我打算用set和vector设计一个桶<code>vector&lt;set&lt;int&gt;&gt; item(n+1)</code>，那么<code>item[i]</code>就表示访问次数为$i$的对象集合，set会自动按照序号升序排列。接着再用一个<code>vector&lt;int&gt; cnt(n+1,0)</code>存储每个物体的访问次数。那么每当一个对象的访问次数增加时，我们都需要将原先桶中（$item[cnt[i]]$）的对象erase，在新桶中（$item[cnt[i]+1]$）插入。然后再用一个most变量记录当前的最高访问次数，那么每次选择推荐对象时都从$item[most]$开始找$k$个即可。</p>\n<p>$\\qquad$⚠️如果访问过的对象不足$k$个就不需要推荐这么多，有多少就推荐多少。</p>\n<p>$\\qquad$听上去虽然有点麻烦，但实现起来还是很快的。然鹅一开始最后一个测试点一直SF，我一脸茫然，两眼懵逼。最后发现前面的访问对象可能都是同一个，那么预测对象只需要输出一个即可，而不能取决于访问次数！！！</p>\n<p>$\\qquad$还有一种做法，感觉相对easy点，就是全部装在一个set中，然后给出set的compare函数，那么每次都直接从前$k$个选择，感觉实操性更强一点。</p>\n<p>$\\qquad$o还无意中发现，multiset中如果erase函数的参数给的是特定值的话就会把所有特定值都删掉，如果想只删其中一个，就搭配find给出迭代器：<code>multiset.erase(multiset.find(value))</code>。估计内部实现就是<code>set&lt;pair&lt;...,int&gt;&gt;</code>。</p>\n<hr>\n<h2><span id>🐎</span></h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, k, m, most = <span class=\"number\">1</span>, j, p, distinct = <span class=\"number\">1</span>;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class=\"line\">    vector&lt;set&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">item</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    item[<span class=\"number\">1</span>].<span class=\"built_in\">insert</span>(m), cnt[m] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cin &gt;&gt; m;</span><br><span class=\"line\">        j = <span class=\"built_in\">min</span>(distinct, k), p = most;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d:&quot;</span>, m);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;t: item[p--])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; %d&quot;</span>, t);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (--j &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt[m] &gt; <span class=\"number\">1</span>) item[cnt[m] - <span class=\"number\">1</span>].<span class=\"built_in\">erase</span>(m);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> ++distinct;</span><br><span class=\"line\">        item[cnt[m]].<span class=\"built_in\">insert</span>(m);</span><br><span class=\"line\">        most = <span class=\"built_in\">max</span>(most, cnt[m]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","text":"Recommendation system predicts the preference that a user would give to an item. Now you are asked to program a very simple recommendation s...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"set","slug":"set","count":16,"path":"api/tags/set.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Input Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Output Specification:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Input:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Sample Output:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Ω</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">🐎</span></a>","author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}},"mapped":true,"prev_post":{"title":"『1130」Infix Expression","uid":"0def5409a91f0fbcec7f6cf9896df886","slug":"『1130」Infix-Expression","date":"2022-11-23T17:27:42.000Z","updated":"2022-11-25T06:58:03.937Z","comments":true,"path":"api/articles/『1130」Infix-Expression.json","keywords":null,"cover":[],"text":"Given a syntax tree (binary), you are supposed to output the corresponding infix expression, with parentheses reflecting the precedences of ...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"},{"name":"traversal order","slug":"traversal-order","count":13,"path":"api/tags/traversal-order.json"},{"name":"Tree","slug":"Tree","count":23,"path":"api/tags/Tree.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}},"next_post":{"title":"「1128」N Queens Puzzle","uid":"988044046878bff1b1dd82dbd324dde7","slug":"「1128」N-Queens-Puzzle","date":"2022-11-23T09:22:37.000Z","updated":"2022-11-23T17:47:43.830Z","comments":true,"path":"api/articles/「1128」N-Queens-Puzzle.json","keywords":null,"cover":[],"text":"The “eight queens puzzle” is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other. Thus,...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"PAT（Advanced Level）Practice","slug":"PAT（Advanced-Level）Practice","count":153,"path":"api/categories/PAT（Advanced-Level）Practice.json"}],"tags":[{"name":"C＋＋","slug":"C＋＋","count":160,"path":"api/tags/C＋＋.json"}],"author":{"name":"Starlit Rover","slug":"blog-author","avatar":"https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcQWu4nWh5NV26rlAS5lR23iaundn5IVlV3EpYGNAdtnMObooQnk","link":"/","description":"Stroll in the starlit firmament~","socials":{"github":"https://github.com/StarlitRover","twitter":"https://twitter.com/Starlit_Rover","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"steam":{"icon":"/images/aurora/steam.svg","link":"https://steamcommunity.com/id/starlitrover/"}}}}}}